(function () {
// Copyright (c) 2009-2012 Turbulenz Limited
/*global Float32Array: false*/
/*global TurbulenzEngine: false*/

//
// Vector math library
//
var VMathArrayConstructor = [].constructor;

// Ensure there is a slice function available for Float32Arrays

if ((typeof Float32Array !== "undefined") &&
    (Float32Array.prototype !== undefined) &&
    (Float32Array.prototype.slice === undefined))
{
    Float32Array.prototype.slice = function Float32ArraySlice(s, e)
    {
        var length = this.length;
        if (s === undefined)
        {
            s = 0;
        }
        else if (s < 0)
        {
            s += length;
        }
        if (e === undefined)
        {
            e = length;
        }
        else if (e < 0)
        {
            e += length;
        }

        length = (e - s);
        if (0 < length)
        {
            var dst = new Float32Array(length);
            var n = 0;
            do
            {
                dst[n] = this[s];
                n += 1;
                s += 1;
            }
            while (s < e);
            return dst;
        }
        else
        {
            return new Float32Array();
        }
    };
}

var VMath =
{
    version : 1,

    // Default precision for equality comparations
    precision : 1e-6,

    FLOAT_MAX : Number.MAX_VALUE,

    select : function selectFn(m, a, b)
    {
        if (m)
        {
            return a;
        }
        else
        {
            return b;
        }
    },

    reciprocal : function reciprocalFn(a)
    {
        if (a !== 0.0)
        {
            return (1.0 / a);
        }
        else
        {
            throw "Division by zero";
        }
    },

    /*jshint bitwise: false*/
    truncate : function truncateFn(value)
    {
        return (value | 0);
    },
    /*jshint bitwise: true*/

    //
    // Vector2
    //
    v2BuildZero : function v2BuildZeroFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        return dst;
    },

    v2BuildOne : function v2BuildOneFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        return dst;
    },

    v2BuildXAxis : function v2BuildXAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        return dst;
    },

    v2BuildYAxis : function v2BuildYAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 0.0;
        dst[1] = 1.0;
        return dst;
    },

    v2Build : function v2Fn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a;
        dst[1] = b;
        return dst;
    },

    v2Copy : function v2CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        return dst;
    },

    v2Set : function v2SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
    },

    v2Neg : function v2NegFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = -a[0];
        dst[1] = -a[1];
        return dst;
    },

    v2Add : function v2AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0];
        dst[1] = a[1] + b[1];
        return dst;
    },

    v2Add3 : function v2Add3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0] + c[0];
        dst[1] = a[1] + b[1] + c[1];
        return dst;
    },

    v2Add4 : function v2Add4Fn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0] + c[0] + d[0];
        dst[1] = a[1] + b[1] + c[1] + d[1];
        return dst;
    },

    v2Sub : function v2SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        return dst;
    },

    v2Mul : function v2MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        return dst;
    },

    v2MulAdd : function v2MulAddFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] * b[0]) + c[0];
        dst[1] = (a[1] * b[1]) + c[1];
        return dst;
    },

    v2Dot : function v2DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]));
    },

    v2PerpDot : function v2PerpDot(a, b)
    {
        return ((a[0] * b[1]) - (a[1] * b[0]));
    },

    v2LengthSq : function v2LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        return ((a0 * a0) + (a1 * a1));
    },

    v2Length : function v2LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        return Math.sqrt((a0 * a0) + (a1 * a1));
    },

    v2Reciprocal : function v2ReciprocalFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        var rcp = VMath.reciprocal;
        dst[0] = rcp(a[0]);
        dst[1] = rcp(a[1]);
        return dst;
    },

    v2Normalize : function v2NormalizeFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var a0 = a[0];
        var a1 = a[1];
        var lsq = ((a0 * a0) + (a1 * a1));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            dst[0] = (a0 * lr);
            dst[1] = (a1 * lr);
        }
        else
        {
            dst[0] = 0;
            dst[1] = 0;
        }
        return dst;
    },

    v2Abs : function v2AbsFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var abs = Math.abs;
        dst[0] = abs(a[0]);
        dst[1] = abs(a[1]);
        return dst;
    },

    v2Max : function v2MaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var max = Math.max;
        dst[0] = max(a[0], b[0]);
        dst[1] = max(a[1], b[1]);
        return dst;
    },

    v2Min : function v2MinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var min = Math.min;
        dst[0] = min(a[0], b[0]);
        dst[1] = min(a[1], b[1]);
        return dst;
    },

    v2Equal : function v2EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision);
    },

    // Vector2 'masks'
    v2MaskEqual : function v2MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision)];
    },

    v2MaskLess : function v2MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1])];
    },

    v2MaskGreater : function v2MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1])];
    },

    v2MaskGreaterEq : function v2MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1])];
    },

    v2MaskNot : function v2MaskNotFn(a)
    {
        return [!a[0],
                !a[1]];
    },

    v2MaskOr : function v2MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1])];
    },

    v2MaskAnd : function v2MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1])];
    },

    v2Select : function v2SelectFn(m, a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = m[0] ? a[0] : b[0];
        dst[1] = m[1] ? a[1] : b[1];
        return dst;
    },

    // Vector2 operations with scalar
    v2ScalarBuild : function v2ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        dst[0] = a;
        dst[1] = a;

        return dst;
    },

    v2ScalarMax : function v2ScalarMaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        var max = Math.max;
        dst[0] = max(a[0], b);
        dst[1] = max(a[1], b);

        return dst;
    },

    v2ScalarMin : function v2ScalarMinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        var min = Math.min;
        dst[0] = min(a[0], b);
        dst[1] = min(a[1], b);

        return dst;
    },

    v2ScalarAdd : function v2ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);

        return dst;
    },

    v2ScalarSub : function v2ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);

        return dst;
    },

    v2ScalarMul : function v2ScalarMulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        if (b === 0)
        {
            dst[0] = 0;
            dst[1] = 0;
        }
        else
        {
            dst[0] = a[0] * b;
            dst[1] = a[1] * b;
        }
        return dst;
    },

    v2AddScalarMul : function v2AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        return dst;
    },

    // Vector2 'masks' with scalars
    v2EqualScalarMask : function v2EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision)];
    },

    v2LessScalarMask : function v2LessScalarMaskFn(a, b)
    {
        return [(a[0] < b),
                (a[1] < b)];
    },

    v2GreaterScalarMask : function v2GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b)];
    },

    v2GreaterEqScalarMask : function v2GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b)];
    },

    v2Lerp : function v2LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] + ((b[0] - a[0]) * t));
        dst[1] = (a[1] + ((b[1] - a[1]) * t));
        return dst;
    },

    //
    // Vector3
    //
    v3BuildZero : function v3BuildZeroFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildOne  : function v3BuildOneFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        dst[2] = 1.0;
        return dst;
    },

    v3BuildXAxis : function v3BuildXAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildYAxis : function v3BuildYAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 1.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildZAxis : function v3BuildZAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 1.0;
        return dst;
    },

    v3Build : function v3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = a;
        dst[1] = b;
        dst[2] = c;
        return dst;
    },

    v3Copy : function v3CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        return dst;
    },

    v3Set : function v3SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
        v[2] = a[2];
    },

    v3Neg : function v3NegFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = -a[0];
        dst[1] = -a[1];
        dst[2] = -a[2];
        return dst;
    },

    v3Add : function v3AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] + b[0]);
        dst[1] = (a[1] + b[1]);
        dst[2] = (a[2] + b[2]);
        return dst;
    },

    v3Add3 : function v3Add3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = a[0] + b[0] + c[0];
        dst[1] = a[1] + b[1] + c[1];
        dst[2] = a[2] + b[2] + c[2];
        return dst;
    },

    v3Add4 : function v3Add4Fn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = a[0] + b[0] + c[0] + d[0];
        dst[1] = a[1] + b[1] + c[1] + d[1];
        dst[2] = a[2] + b[2] + c[2] + d[2];
        return dst;
    },

    v3Sub : function v3SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        dst[2] = (a[2] - b[2]);
        return dst;
    },

    v3Mul : function v3MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        dst[2] = (a[2] * b[2]);
        return dst;
    },

    v3MulAdd : function v3MulAddFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] * b[0]) + c[0];
        dst[1] = (a[1] * b[1]) + c[1];
        dst[2] = (a[2] * b[2]) + c[2];
        return dst;
    },

    v3Dot : function v3DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]));
    },

    v3Cross : function v3CrossFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        dst[0] = ((a1 * b2) - (a2 * b1));
        dst[1] = ((a2 * b0) - (a0 * b2));
        dst[2] = ((a0 * b1) - (a1 * b0));
        return dst;
    },

    v3LengthSq : function v3LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        return ((a0 * a0) + (a1 * a1) + (a2 * a2));
    },

    v3Length : function v3LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        return Math.sqrt((a0 * a0) + (a1 * a1) + (a2 * a2));
    },

    v3Reciprocal : function v3ReciprocalFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var rcp = VMath.reciprocal;
        dst[0] = rcp(a[0]);
        dst[1] = rcp(a[1]);
        dst[2] = rcp(a[2]);
        return dst;
    },

    v3Normalize : function v3NormalizeFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var lsq = ((a0 * a0) + (a1 * a1) + (a2 * a2));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            dst[0] = (a0 * lr);
            dst[1] = (a1 * lr);
            dst[2] = (a2 * lr);
        }
        else
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
        }
        return dst;
    },

    v3Abs : function v3AbsFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var abs = Math.abs;
        dst[0] = abs(a[0]);
        dst[1] = abs(a[1]);
        dst[2] = abs(a[2]);
        return dst;
    },

    v3Max : function v3MaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var max = Math.max;
        dst[0] = max(a[0], b[0]);
        dst[1] = max(a[1], b[1]);
        dst[2] = max(a[2], b[2]);
        return dst;
    },

    v3Min : function v3MinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var min = Math.min;
        dst[0] = min(a[0], b[0]);
        dst[1] = min(a[1], b[1]);
        dst[2] = min(a[2], b[2]);
        return dst;
    },

    v3Equal : function v3EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision);
    },

    // Vector3 'masks'
    v3MaskEqual : function v3MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision),
                (abs(a[2] - b[2]) <= precision)];
    },

    v3MaskLess : function v3MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1]),
                (a[2] < b[2])];
    },

    v3MaskGreater : function v3MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1]),
                (a[2] > b[2])];
    },

    v3MaskGreaterEq : function v3MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1]),
                (a[2] >= b[2])];
    },

    v3MaskNot : function v3MaskNotFn(a)
    {
        return [!a[0],
                !a[1],
                !a[2]];
    },

    v3MaskOr : function v3MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1]),
                (a[2] || b[2])];
    },

    v3MaskAnd : function v3MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1]),
                (a[2] && b[2])];
    },

    v3Select : function v3SelectFn(m, a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[0] ? a[0] : b[0];
        dst[1] = m[1] ? a[1] : b[1];
        dst[2] = m[2] ? a[2] : b[2];
        return dst;
    },

    // Vector3 operations with scalar
    v3ScalarBuild : function v3ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = a;
        dst[1] = a;
        dst[2] = a;

        return dst;
    },

    v3ScalarMax : function v3ScalarMaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var max = Math.max;
        dst[0] = max(a[0], b);
        dst[1] = max(a[1], b);
        dst[2] = max(a[2], b);

        return dst;
    },

    v3ScalarMin : function v3ScalarMinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var min = Math.min;
        dst[0] = min(a[0], b);
        dst[1] = min(a[1], b);
        dst[2] = min(a[2], b);

        return dst;
    },

    v3ScalarAdd : function v3ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);
        dst[2] = (a[2] + b);

        return dst;
    },

    v3ScalarSub : function v3ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);
        dst[2] = (a[2] - b);

        return dst;
    },

    v3ScalarMul : function v3ScalarMulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        if (b === 0)
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
        }
        else
        {
            dst[0] = (a[0] * b);
            dst[1] = (a[1] * b);
            dst[2] = (a[2] * b);
        }
        return dst;
    },

    v3AddScalarMul : function v3AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        dst[2] = a[2] + b[2] * c;

        return dst;
    },

    // Vector3 'masks' with scalars
    v3EqualScalarMask : function v3EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision),
                (abs(a[2] - b) <= precision)];
    },

    v3LessScalarMask : function v3LessScalarMaskFn(a, b)
    {
        return [(a[0] < b),
                (a[1] < b),
                (a[2] < b)];
    },

    v3GreaterScalarMask : function v3GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b),
                (a[2] > b)];
    },

    v3GreaterEqScalarMask : function v3GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b),
                (a[2] >= b)];
    },

    v3Lerp : function v3LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] =  (a[0] + ((b[0] - a[0]) * t));
        dst[1] =  (a[1] + ((b[1] - a[1]) * t));
        dst[2] =  (a[2] + ((b[2] - a[2]) * t));

        return dst;
    },

    //
    // Vector4
    //
    v4BuildZero : function v4BuildZeroFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        return dst;
    },

    v4BuildOne  : function v4BuildOneFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        dst[2] = 1.0;
        dst[3] = 1.0;
        return dst;
    },

    v4Build : function v4BuildFn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = a;
        dst[1] = b;
        dst[2] = c;
        dst[3] = d;
        return dst;
    },

    v4Copy : function v4CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        return dst;
    },

    v4Set : function v4SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
        v[2] = a[2];
        v[3] = a[3];
    },

    v4Neg : function v4NegFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = -a[0];
        dst[1] = -a[1];
        dst[2] = -a[2];
        dst[3] = -a[3];

        return dst;
    },

    v4Add : function v4AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] + b[0]);
        dst[1] = (a[1] + b[1]);
        dst[2] = (a[2] + b[2]);
        dst[3] = (a[3] + b[3]);
        return dst;
    },

    v4Add3 : function v4Add3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a[0] + b[0] + c[0];
        dst[1] = a[1] + b[1] + c[1];
        dst[2] = a[2] + b[2] + c[2];
        dst[3] = a[3] + b[3] + c[3];

        return dst;
    },

    v4Add4 : function v4Add4Fn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a[0] + b[0] + c[0] + d[0];
        dst[1] = a[1] + b[1] + c[1] + d[1];
        dst[2] = a[2] + b[2] + c[2] + d[2];
        dst[3] = a[3] + b[3] + c[3] + d[3];

        return dst;
    },

    v4Sub : function v4SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        dst[2] = (a[2] - b[2]);
        dst[3] = (a[3] - b[3]);
        return dst;
    },

    v4Mul : function v4MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        dst[2] = (a[2] * b[2]);
        dst[3] = (a[3] * b[3]);
        return dst;
    },

    v4MulAdd : function v4MulAddFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] * b[0]) + c[0];
        dst[1] = (a[1] * b[1]) + c[1];
        dst[2] = (a[2] * b[2]) + c[2];
        dst[3] = (a[3] * b[3]) + c[3];

        return dst;
    },

    v4Dot : function v4DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]));
    },

    v4LengthSq : function v4LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        return ((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
    },

    v4Length : function v4LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        return Math.sqrt((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
    },

    v4Reciprocal : function v4ReciprocalFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var rcp = VMath.reciprocal;
        dst[0] = rcp(a[0]);
        dst[1] = rcp(a[1]);
        dst[2] = rcp(a[2]);
        dst[3] = rcp(a[3]);

        return dst;
    },

    v4Normalize : function v4NormalizeFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];

        var lsq = ((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            dst[0] = a0 * lr;
            dst[1] = a1 * lr;
            dst[2] = a2 * lr;
            dst[3] = a3 * lr;
        }
        else
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
            dst[3] = 0;
        }
        return dst;
    },

    v4Abs : function v4AbsFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var abs = Math.abs;
        dst[0] = abs(a[0]);
        dst[1] = abs(a[1]);
        dst[2] = abs(a[2]);
        dst[3] = abs(a[3]);

        return dst;
    },

    v4Max : function v4MaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var max = Math.max;
        dst[0] = max(a[0], b[0]);
        dst[1] = max(a[1], b[1]);
        dst[2] = max(a[2], b[2]);
        dst[3] = max(a[3], b[3]);

        return dst;
    },

    v4Min : function v4MinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var min = Math.min;
        dst[0] = min(a[0], b[0]);
        dst[1] = min(a[1], b[1]);
        dst[2] = min(a[2], b[2]);
        dst[3] = min(a[3], b[3]);

        return dst;
    },

    v4Equal : function v4EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision &&
                abs(a[3] - b[3]) <= precision);
    },

    // Vector3 'masks'
    v4MaskEqual : function v4MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision),
                (abs(a[2] - b[2]) <= precision),
                (abs(a[3] - b[3]) <= precision)];
    },

    v4MaskLess : function v4MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1]),
                (a[2] < b[2]),
                (a[3] < b[3])];
    },

    v4MaskGreater : function v4MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1]),
                (a[2] > b[2]),
                (a[3] > b[3])];
    },

    v4MaskGreaterEq : function v4MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1]),
                (a[2] >= b[2]),
                (a[3] >= b[3])];
    },

    v4MaskNot : function v4MaskNotFn(a)
    {
        return [!a[0],
                !a[1],
                !a[2],
                !a[3]];
    },

    v4MaskOr : function v4MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1]),
                (a[2] || b[2]),
                (a[3] || b[3])];
    },

    v4MaskAnd : function v4MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1]),
                (a[2] && b[2]),
                (a[3] && b[3])];
    },

    v4Many : function v4ManyFn(m)
    {
        return (m[0] || m[1] || m[2] || m[3]);
    },

    v4MaskAll : function v4MaskAllFn(m)
    {
        return (m[0] && m[1] && m[2] && m[3]);
    },

    v4Select : function v4SelectFn(m, a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = m[0] ? a[0] : b[0];
        dst[1] = m[1] ? a[1] : b[1];
        dst[2] = m[2] ? a[2] : b[2];
        dst[3] = m[3] ? a[3] : b[3];

        return dst;
    },

    // Vector4 operations with scalar
    v4ScalarBuild : function v4ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a;
        dst[1] = a;
        dst[2] = a;
        dst[3] = a;

        return dst;
    },

    v4ScalarMax : function v4ScalarMaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var max = Math.max;
        dst[0] = max(a[0], b);
        dst[1] = max(a[1], b);
        dst[2] = max(a[2], b);
        dst[3] = max(a[3], b);

        return dst;
    },

    v4ScalarMin : function v4ScalarMinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var min = Math.min;
        dst[0] = min(a[0], b);
        dst[1] = min(a[1], b);
        dst[2] = min(a[2], b);
        dst[3] = min(a[3], b);

        return dst;
    },

    v4ScalarAdd : function v4ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);
        dst[2] = (a[2] + b);
        dst[3] = (a[3] + b);

        return dst;
    },

    v4ScalarSub : function v4ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);
        dst[2] = (a[2] - b);
        dst[3] = (a[3] - b);

        return dst;
    },

    v4ScalarMul : function v4ScalarMulFn(a, b, dst)
    {
        if (b === 0)
        {
            return VMath.v4BuildZero(dst);
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(4);
            }

            dst[0] = (a[0] * b);
            dst[1] = (a[1] * b);
            dst[2] = (a[2] * b);
            dst[3] = (a[3] * b);

            return dst;
        }
    },

    v4AddScalarMul : function v4AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        dst[2] = a[2] + b[2] * c;
        dst[3] = a[3] + b[3] * c;

        return dst;
    },

    v4ScalarEqual : function v4ScalarEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return (abs(a[0] - b) <= precision &&
                abs(a[1] - b) <= precision &&
                abs(a[2] - b) <= precision &&
                abs(a[3] - b) <= precision);
    },

    // Vector3 'masks' with scalars
    v4EqualScalarMask : function v4EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision),
                (abs(a[2] - b) <= precision),
                (abs(a[3] - b) <= precision)];
    },

    v4LessScalarMask : function v4LessScalarMaskFn(a, b)
    {
        return [(a[0] < b),
                (a[1] < b),
                (a[2] < b),
                (a[3] < b)];
    },

    v4GreaterScalarMask : function v4GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b),
                (a[2] > b),
                (a[3] > b)];
    },

    v4GreaterEqScalarMask : function v4GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b),
                (a[2] >= b),
                (a[3] >= b)];
    },

    v4Lerp : function v4LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] + ((b[0] - a[0]) * t));
        dst[1] = (a[1] + ((b[1] - a[1]) * t));
        dst[2] = (a[2] + ((b[2] - a[2]) * t));
        dst[3] = (a[3] + ((b[3] - a[3]) * t));
        return dst;
    },

    //
    // AABB
    //

    aabbBuild : function aabbBuildFn(a0, a1, a2, a3, a4, a5, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = a0;
        dst[1] = a1;
        dst[2] = a2;
        dst[3] = a3;
        dst[4] = a4;
        dst[5] = a5;

        return dst;
    },

    aabbBuildEmpty : function aabbBuildEmptyFn(dst)
    {
        var float_max = this.FLOAT_MAX;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = float_max;
        dst[1] = float_max;
        dst[2] = float_max;
        dst[3] = -float_max;
        dst[4] = -float_max;
        dst[5] = -float_max;

        return dst;
    },

    aabbCopy : function aabbCopyFn(aabb, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = aabb[0];
        dst[1] = aabb[1];
        dst[2] = aabb[2];
        dst[3] = aabb[3];
        dst[4] = aabb[4];
        dst[5] = aabb[5];

        return dst;
    },

    aabbSet : function aabbSet(dst, src)
    {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        dst[4] = src[4];
        dst[5] = src[5];
    },

    aabbIsEmpty : function aabbIsEmptyFn(aabb)
    {
        return aabb[0] > aabb[3];
    },

    aabbMin : function aabbMinFn(aabb, dst)
    {
        if (dst === undefined)
        {
            return aabb.slice(0, 3);
        }
        dst[0] = aabb[0];
        dst[1] = aabb[1];
        dst[2] = aabb[2];
        return dst;
    },

    aabbMax : function aabbMaxFn(aabb, dst)
    {
        if (dst === undefined)
        {
            return aabb.slice(3, 6);
        }
        dst[0] = aabb[3];
        dst[1] = aabb[4];
        dst[2] = aabb[5];
        return dst;
    },

    aabbGetCenterAndHalf : function aabbGetCenterAndHalfFn(aabb, center, half)
    {
        var cX = (aabb[0] + aabb[3]) * 0.5;
        var cY = (aabb[1] + aabb[4]) * 0.5;
        var cZ = (aabb[2] + aabb[5]) * 0.5;

        center[0] = cX;
        center[1] = cY;
        center[2] = cZ;

        half[0] = aabb[3] - cX;
        half[1] = aabb[4] - cY;
        half[2] = aabb[5] - cZ;
    },

    aabbIsInsidePlanes : function aabbIsInsidePlanesFn(aabb, planes)
    {
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? aabb[0] : aabb[3]) + d1 * (d1 < 0 ? aabb[1] : aabb[4]) + d2 * (d2 < 0 ? aabb[2] : aabb[5])) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    aabbIsFullyInsidePlanes : function aabbIsFullyInsidePlanesFn(aabb, planes)
    {
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? aabb[0] : aabb[3]) + d1 * (d1 > 0 ? aabb[1] : aabb[4]) + d2 * (d2 > 0 ? aabb[2] : aabb[5])) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    aabbUnion : function aabbUnionFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = a[0] < b[0] ? a[0] : b[0];
        dst[1] = a[1] < b[1] ? a[1] : b[1];
        dst[2] = a[2] < b[2] ? a[2] : b[2];
        dst[3] = a[3] > b[3] ? a[3] : b[3];
        dst[4] = a[4] > b[4] ? a[4] : b[4];
        dst[5] = a[5] > b[5] ? a[5] : b[5];

        return dst;
    },

    aabbUnionArray : function aabbUnionArrayFn(aabbArray, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }
        VMath.aabbCopy(aabbArray[0], dst);

        var numAABBs = aabbArray.length;
        for (var i = 0; i < numAABBs; i += 1)
        {
            var aabb = aabbArray[i];
            dst[0] = (dst[0] < aabb[0] ? dst[0] : aabb[0]);
            dst[1] = (dst[1] < aabb[1] ? dst[1] : aabb[1]);
            dst[2] = (dst[2] < aabb[2] ? dst[2] : aabb[2]);
            dst[3] = (dst[3] > aabb[3] ? dst[3] : aabb[3]);
            dst[4] = (dst[4] > aabb[4] ? dst[4] : aabb[4]);
            dst[5] = (dst[5] > aabb[5] ? dst[5] : aabb[5]);
        }

        return dst;
    },

    aabbAddPoints : function aabbAddPointFn(aabb, ps)
    {
        var i;
        var numPoints = ps.length;

        var r0 = aabb[0];
        var r1 = aabb[1];
        var r2 = aabb[2];
        var r3 = aabb[3];
        var r4 = aabb[4];
        var r5 = aabb[5];

        var p0, p1, p2;

        for (i = 0; i < numPoints; i += 1)
        {
            p0 = ps[i][0];
            p1 = ps[i][1];
            p2 = ps[i][2];

            r0 = (r0 < p0 ? r0 : p0);
            r1 = (r1 < p1 ? r1 : p1);
            r2 = (r2 < p2 ? r2 : p2);
            r3 = (r3 > p0 ? r3 : p0);
            r4 = (r4 > p1 ? r4 : p1);
            r5 = (r5 > p2 ? r5 : p2);
        }

        aabb[0] = r0;
        aabb[1] = r1;
        aabb[2] = r2;
        aabb[3] = r3;
        aabb[4] = r4;
        aabb[5] = r5;

    },

    aabbTransform : function aabbTransformFn(aabb, matrix, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        var cX = (aabb[0] + aabb[3]) * 0.5;
        var cY = (aabb[1] + aabb[4]) * 0.5;
        var cZ = (aabb[2] + aabb[5]) * 0.5;

        var hX = aabb[3] - cX;
        var hY = aabb[4] - cY;
        var hZ = aabb[5] - cZ;

        var m0 = matrix[0];
        var m1 = matrix[1];
        var m2 = matrix[2];
        var m3 = matrix[3];
        var m4 = matrix[4];
        var m5 = matrix[5];
        var m6 = matrix[6];
        var m7 = matrix[7];
        var m8 = matrix[8];

        var ctX = matrix[9] +  (m0 * cX + m3 * cY + m6 * cZ);
        var ctY = matrix[10] + (m1 * cX + m4 * cY + m7 * cZ);
        var ctZ = matrix[11] + (m2 * cX + m5 * cY + m8 * cZ);

        var abs = Math.abs;

        var htX = (abs(m0) * hX + abs(m3) * hY + abs(m6) * hZ);
        var htY = (abs(m1) * hX + abs(m4) * hY + abs(m7) * hZ);
        var htZ = (abs(m2) * hX + abs(m5) * hY + abs(m8) * hZ);

        dst[0] = ctX - htX;
        dst[1] = ctY - htY;
        dst[2] = ctZ - htZ;
        dst[3] = ctX + htX;
        dst[4] = ctY + htY;
        dst[5] = ctZ + htZ;

        return dst;
    },

    aabbIntercept : function aabbInterceptFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = a[0] > b[0] ? a[0] : b[0];
        dst[1] = a[1] > b[1] ? a[1] : b[1];
        dst[2] = a[2] > b[2] ? a[2] : b[2];
        dst[3] = a[3] < b[3] ? a[3] : b[3];
        dst[4] = a[4] < b[4] ? a[4] : b[4];
        dst[5] = a[5] < b[5] ? a[5] : b[5];

        return dst;
    },

    aabbOverlaps : function aabbOverlapsFn(a, b)
    {
        return ((a[0] <= b[3]) &&
                (a[1] <= b[4]) &&
                (a[2] <= b[5]) &&
                (a[3] >= b[0]) &&
                (a[4] >= b[1]) &&
                (a[5] >= b[2]));
    },

    aabbSphereOverlaps : function aabbSphereOverlapsFn(aabb, center, radius)
    {
        var centerX = center[0];
        var centerY = center[1];
        var centerZ = center[2];
        var radiusSquared = radius * radius;

        var minX = aabb[0];
        var minY = aabb[1];
        var minZ = aabb[2];
        var maxX = aabb[3];
        var maxY = aabb[4];
        var maxZ = aabb[5];
        var totalDistance = 0, sideDistance;

        if (centerX < minX)
        {
            sideDistance = (minX - centerX);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerX > maxX)
        {
            sideDistance = (centerX - maxX);
            totalDistance += (sideDistance * sideDistance);
        }
        if (centerY < minY)
        {
            sideDistance = (minY - centerY);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerY > maxY)
        {
            sideDistance = (centerY - maxY);
            totalDistance += (sideDistance * sideDistance);
        }
        if (centerZ < minZ)
        {
            sideDistance = (minZ - centerZ);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerZ > maxZ)
        {
            sideDistance = (centerZ - maxZ);
            totalDistance += (sideDistance * sideDistance);
        }
        return (totalDistance <= radiusSquared);
    },

    aabbIsInside : function aabbIsInsideFn(a, b)
    {
        return ((a[0] >= b[0]) &&
                (a[1] >= b[1]) &&
                (a[2] >= b[2]) &&
                (a[3] <= b[3]) &&
                (a[4] <= b[4]) &&
                (a[5] <= b[5]));
    },

    aabbTestInside : function aabbTestInsideFn(a, b)
    {
        if ((a[0] <= b[3]) &&
            (a[1] <= b[4]) &&
            (a[2] <= b[5]) &&
            (a[3] >= b[0]) &&
            (a[4] >= b[1]) &&
            (a[5] >= b[2]))
        {

            if ((a[0] >= b[0]) &&
                (a[1] >= b[1]) &&
                (a[2] >= b[2]) &&
                (a[3] <= b[3]) &&
                (a[4] <= b[4]) &&
                (a[5] <= b[5]))
            {
                return 2;
            }
            return 1;
        }

        return 0;
    },

    //
    // Matrix
    //
    m33BuildIdentity : function m33BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        dst[4] = 1.0;
        dst[5] = 0.0;
        dst[6] = 0.0;
        dst[7] = 0.0;
        dst[8] = 1.0;

        return dst;
    },

    // Matrix33
    m33Build : function m33BuildFn(r, u, a, dst)
    {
        var length = arguments.length;
        if (length >= 9)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 9)
            {
                res = arguments[9];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(9);
                }
            }
            else
            {
                res = new VMathArrayConstructor(9);
            }

            res[0] = arguments[0];
            res[1] = arguments[1];
            res[2] = arguments[2];
            res[3] = arguments[3];
            res[4] = arguments[4];
            res[5] = arguments[5];
            res[6] = arguments[6];
            res[7] = arguments[7];
            res[8] = arguments[8];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(9);
            }

            dst[0] = r[0];
            dst[1] = r[1];
            dst[2] = r[2];
            dst[3] = u[0];
            dst[4] = u[1];
            dst[5] = u[2];
            dst[6] = a[0];
            dst[7] = a[1];
            dst[8] = a[2];

            return dst;
        }
    },

    m33Copy : function m33CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];

        return dst;
    },

    m33FromAxisRotation : function m33FromAxisRotationFn(axis, angle, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;

        dst[0] = tx * axisX + c;
        dst[1] = tx * axisY - sz;
        dst[2] = tx * axisZ + sy;
        dst[3] = ty * axisX + sz;
        dst[4] = ty * axisY + c;
        dst[5] = ty * axisZ - sx;
        dst[6] = tz * axisX - sy;
        dst[7] = tz * axisY + sx;
        dst[8] = tz * axisZ + c;

        return dst;
    },

    m33FromQuat: function m33FromQuatFn(q, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var qx = q[0];
        var qy = q[1];
        var qz = q[2];
        var qw = q[3];

        var xx = 2.0 * qx * qx;
        var yy = 2.0 * qy * qy;
        var zz = 2.0 * qz * qz;
        var xy = 2.0 * qx * qy;
        var zw = 2.0 * qz * qw;
        var xz = 2.0 * qx * qz;
        var yw = 2.0 * qy * qw;
        var yz = 2.0 * qy * qz;
        var xw = 2.0 * qx * qw;

        dst[0] = 1.0 - yy - zz;
        dst[1] = xy - zw;
        dst[2] = xz + yw;
        dst[3] = xy + zw;
        dst[4] = 1.0 - xx - zz;
        dst[5] = yz - xw;
        dst[6] = xz - yw;
        dst[7] = yz + xw;
        dst[8] = 1.0 - xx - yy;

        return dst;
    },

    m33Right : function m33RightFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        return dst;
    },

    m33Up : function m33UpFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[3];
        dst[1] = m[4];
        dst[2] = m[5];
        return dst;
    },

    m33At : function m33AtFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[6];
        dst[1] = m[7];
        dst[2] = m[8];
        return dst;
    },

    m33SetRight : function m33SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
    },

    m33SetUp : function m33SetUpFn(m, v)
    {
        m[3] = v[0];
        m[4] = v[1];
        m[5] = v[2];
    },

    m33SetAt : function m33SetAtFn(m, v)
    {
        m[6] = v[0];
        m[7] = v[1];
        m[8] = v[2];
    },

    m33Transpose : function m33TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        dst[0] = m0;
        dst[1] = m3;
        dst[2] = m6;
        dst[3] = m1;
        dst[4] = m4;
        dst[5] = m7;
        dst[6] = m2;
        dst[7] = m5;
        dst[8] = m8;
        return dst;
    },

    m33Determinant : function m33DeterminantFn(m)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        return (m0 * (m4 * m8 - m5 * m7) +
                m1 * (m5 * m6 - m3 * m8) +
                m2 * (m3 * m7 - m4 * m6));
    },

    m33Inverse : function m33InverseFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var det = VMath.m33Determinant(m);
        if (det === 0.0)
        {
            dst[0] = dst[1] = dst[2] = 0.0;
            dst[3] = dst[4] = dst[5] = 0.0;
            dst[6] = dst[7] = dst[8] = 0.0;
            return dst;
        }
        else
        {
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];

            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[1] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[2] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[3] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[5] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[6] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[7] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            return dst;
        }
    },

    m33InverseTranspose : function m33InverseTransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var det = (m0 * (m4 * m8 - m5 * m7) +
                   m1 * (m5 * m6 - m3 * m8) +
                   m2 * (m3 * m7 - m4 * m6));
        if (det === 0.0)
        {
            dst[0] = dst[1] = dst[2] = 0.0;
            dst[3] = dst[4] = dst[5] = 0.0;
            dst[6] = dst[7] = dst[8] = 0.0;
            return dst;
        }
        else
        {
            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[3] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[6] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[1] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[7] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[2] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[5] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            return dst;
        }
    },

    m33Mul : function m33MulFn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] = (b1 * a0 + b4 * a1 + b7 * a2);
        dst[2] = (b2 * a0 + b5 * a1 + b8 * a2);

        dst[3] = (b0 * a3 + b3 * a4 + b6 * a5);
        dst[4] = (b1 * a3 + b4 * a4 + b7 * a5);
        dst[5] = (b2 * a3 + b5 * a4 + b8 * a5);

        dst[6] = (b0 * a6 + b3 * a7 + b6 * a8);
        dst[7] = (b1 * a6 + b4 * a7 + b7 * a8);
        dst[8] = (b2 * a6 + b5 * a7 + b8 * a8);

        return dst;
    },

    m33Transform : function m33TransformFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2);
        return dst;
    },

    m33Equal : function m33EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision &&
                abs(a[3] - b[3]) <= precision &&
                abs(a[4] - b[4]) <= precision &&
                abs(a[5] - b[5]) <= precision &&
                abs(a[6] - b[6]) <= precision &&
                abs(a[7] - b[7]) <= precision &&
                abs(a[8] - b[8]) <= precision);
    },

    m33MulM43 : function m33MulM43Fn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];

        dst[0] = b0 * a0 + b3 * a1 + b6 * a2;
        dst[1] = b1 * a0 + b4 * a1 + b7 * a2;
        dst[2] = b2 * a0 + b5 * a1 + b8 * a2;

        dst[3] = b0 * a3 + b3 * a4 + b6 * a5;
        dst[4] = b1 * a3 + b4 * a4 + b7 * a5;
        dst[5] = b2 * a3 + b5 * a4 + b8 * a5;

        dst[6] = b0 * a6 + b3 * a7 + b6 * a8;
        dst[7] = b1 * a6 + b4 * a7 + b7 * a8;
        dst[8] = b2 * a6 + b5 * a7 + b8 * a8;

        dst[9] = b[9];
        dst[10] = b[10];
        dst[11] = b[11];

        return dst;
    },

    m33MulM44 : function m33MulM44Fn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];
        var b9  = b[9];
        var b10 = b[10];
        var b11 = b[11];


        dst[0] = b0 * a0 + b4 * a1 + b8  * a2;
        dst[1] = b1 * a0 + b5 * a1 + b9  * a2;
        dst[2] = b2 * a0 + b6 * a1 + b10 * a2;
        dst[3] = b3 * a0 + b7 * a1 + b11 * a2;

        dst[4] = b0 * a3 + b4 * a4 + b8  * a5;
        dst[5] = b1 * a3 + b5 * a4 + b9  * a5;
        dst[6] = b2 * a3 + b6 * a4 + b10 * a5;
        dst[7] = b3 * a3 + b7 * a4 + b11 * a5;

        dst[8] = b0 * a6 + b4 * a7 + b8  * a8;
        dst[9] = b1 * a6 + b5 * a7 + b9  * a8;
        dst[10] = b2 * a6 + b6 * a7 + b10 * a8;
        dst[11] = b3 * a6 + b7 * a7 + b11 * a8;

        dst[12] = b[12];
        dst[13] = b[13];
        dst[14] = b[14];
        dst[15] = b[15];

        return dst;
    },

    // Matrix3 operations with scalar
    m33ScalarAdd : function m33ScalarAddFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }
        for (var n = 0; n < 9; n += 1)
        {
            dst[n] = (m[n] + s);
        }
        return dst;
    },

    m33ScalarSub : function m33ScalarSubFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }
        for (var n = 0; n < 9; n += 1)
        {
            dst[n] = (m[n] - s);
        }
        return dst;
    },

    m33ScalarMul : function m33ScalarMulFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        for (var n = 0; n < 9; n += 1)
        {
            dst[n] = (m[n] * s);
        }

        return dst;
    },

    // Matrix34
    m34BuildIdentity : function m34BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        dst[0] = 1.0;
        dst[5] = 1.0;
        dst[10] = 1.0;
        return dst;
    },

    m34Pos : function m34PosFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[3];
        dst[1] = m[7];
        dst[2] = m[11];
        return dst;
    },

    m34Scale : function m34ScaleFn(m, scale, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        dst[0] = m[0] * sx;
        dst[1] = m[1] * sx;
        dst[2] = m[2] * sx;
        dst[3] = m[3];

        dst[4] = m[4] * sy;
        dst[5] = m[5] * sy;
        dst[6] = m[6] * sy;
        dst[7] = m[7];

        dst[8] = m[8] * sz;
        dst[9] = m[9] * sz;
        dst[10] = m[10] * sz;
        dst[11] = m[11];

        return dst;
    },

    // Matrix43
    m43BuildIdentity : function m43BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        dst[4] = 1.0;
        dst[5] = 0.0;
        dst[6] = 0.0;
        dst[7] = 0.0;
        dst[8] = 1.0;
        dst[9] = 0.0;
        dst[10] = 0.0;
        dst[11] = 0.0;
        return dst;
    },

    m43Build : function m43BuildFn(r, u, a, p, dst)
    {
        var length = arguments.length;
        if (length >= 12)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 12)
            {
                res = arguments[12];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(12);
                }
            }
            else
            {
                res = new VMathArrayConstructor(12);
            }

            res[0] = arguments[0];
            res[1] = arguments[1];
            res[2] = arguments[2];
            res[3] = arguments[3];
            res[4] = arguments[4];
            res[5] = arguments[5];
            res[6] = arguments[6];
            res[7] = arguments[7];
            res[8] = arguments[8];
            res[9] = arguments[9];
            res[10] = arguments[10];
            res[11] = arguments[11];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(12);
            }

            dst[0] = r[0];
            dst[1] = r[1];
            dst[2] = r[2];
            dst[3] = u[0];
            dst[4] = u[1];
            dst[5] = u[2];
            dst[6] = a[0];
            dst[7] = a[1];
            dst[8] = a[2];
            dst[9] = p[0];
            dst[10] = p[1];
            dst[11] = p[2];

            return dst;
        }
    },

    m43BuildTranslation : function m43BuildTranslationFn(p, dst)
    {
        // Can NOT use p or dst because it will overwrite the input value...
        var res, a;

        var length = arguments.length;
        if (length >= 3)
        {
            a = arguments;
            if (length === 4)
            {
                res = arguments[3];
            }
        }
        else
        {
            a = p;
            res = dst;
        }

        if (res === undefined)
        {
            res = new VMathArrayConstructor(12);
        }

        res[0] = 1;
        res[1] = 0;
        res[2] = 0;
        res[3] = 0;
        res[4] = 1;
        res[5] = 0;
        res[6] = 0;
        res[7] = 0;
        res[8] = 1;
        res[9] = a[0];
        res[10] = a[1];
        res[11] = a[2];

        return res;
    },

    m43Copy : function m43CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];
        dst[9] = m[9];
        dst[10] = m[10];
        dst[11] = m[11];

        return dst;
    },

    m43FromM33V3: function m43FromM33V3Fn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];
        dst[9] = v[0];
        dst[10] = v[1];
        dst[11] = v[2];

        return dst;
    },

    m43FromAxisRotation : function m43FromAxisRotationFn(axis, angle, dst)
    {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = tx * axisX + c;
        dst[1] = tx * axisY - sz;
        dst[2] = tx * axisZ + sy;

        dst[3] = ty * axisX + sz;
        dst[4] = ty * axisY + c;
        dst[5] = ty * axisZ - sx;

        dst[6] = tz * axisX - sy;
        dst[7] = tz * axisY + sx;
        dst[8] = tz * axisZ + c;

        dst[9] = 0.0;
        dst[10] = 0.0;
        dst[11] = 0.0;

        return dst;
    },

    m43FromQuatPos : function m43FromQuatPosFn(qp, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var qx = qp[0];
        var qy = qp[1];
        var qz = qp[2];
        var qw = qp[3];
        var px = qp[4];
        var py = qp[5];
        var pz = qp[6];

        var xx = 2.0 * qx * qx;
        var yy = 2.0 * qy * qy;
        var zz = 2.0 * qz * qz;
        var xy = 2.0 * qx * qy;
        var zw = 2.0 * qz * qw;
        var xz = 2.0 * qx * qz;
        var yw = 2.0 * qy * qw;
        var yz = 2.0 * qy * qz;
        var xw = 2.0 * qx * qw;

        dst[0] = 1.0 - yy - zz;
        dst[1] = xy - zw;
        dst[2] = xz + yw;

        dst[3] = xy + zw;
        dst[4] = 1.0 - xx - zz;
        dst[5] = yz - xw;

        dst[6] = xz - yw;
        dst[7] = yz + xw;
        dst[8] = 1.0 - xx - yy;

        dst[9] = px;
        dst[10] = py;
        dst[11] = pz;

        return dst;
    },

    m43FromRTS : function m43FromRTSFn(quat, pos, scale, dst)
    {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];

        var xx = (2.0 * qx * qx);
        var yy = (2.0 * qy * qy);
        var zz = (2.0 * qz * qz);
        var xy = (2.0 * qx * qy);
        var zw = (2.0 * qz * qw);
        var xz = (2.0 * qx * qz);
        var yw = (2.0 * qy * qw);
        var yz = (2.0 * qy * qz);
        var xw = (2.0 * qx * qw);

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = sx * (1.0 - yy - zz);
        dst[1] = sx * (xy - zw);
        dst[2] = sx * (xz + yw);
        dst[3] = sy * (xy + zw);
        dst[4] = sy * (1.0 - xx - zz);
        dst[5] = sy * (yz - xw);
        dst[6] = sz * (xz - yw);
        dst[7] = sz * (yz + xw);
        dst[8] = sz * (1.0 - xx - yy);
        dst[9]  = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43FromRT : function m43FromRTFn(quat, pos, dst)
    {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];

        var xx = (2.0 * qx * qx);
        var yy = (2.0 * qy * qy);
        var zz = (2.0 * qz * qz);
        var xy = (2.0 * qx * qy);
        var zw = (2.0 * qz * qw);
        var xz = (2.0 * qx * qz);
        var yw = (2.0 * qy * qw);
        var yz = (2.0 * qy * qz);
        var xw = (2.0 * qx * qw);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  1.0 - yy - zz;
        dst[1] =  xy - zw;
        dst[2] =  xz + yw;
        dst[3] =  xy + zw;
        dst[4] =  1.0 - xx - zz;
        dst[5] =  yz - xw;
        dst[6] =  xz - yw;
        dst[7] =  yz + xw;
        dst[8] =  1.0 - xx - yy;
        dst[9]  = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43Right : function m43RightFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        return dst;
    },

    m43Up : function m43UpFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[3];
        dst[1] = m[4];
        dst[2] = m[5];
        return dst;
    },

    m43At : function m43AtFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[6];
        dst[1] = m[7];
        dst[2] = m[8];
        return dst;
    },

    m43Pos : function m43PosFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[9];
        dst[1] = m[10];
        dst[2] = m[11];
        return dst;
    },

    m43SetRight : function m43SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
    },

    m43SetUp : function m43SetUpFn(m, v)
    {
        m[3] = v[0];
        m[4] = v[1];
        m[5] = v[2];
    },

    m43SetAt : function m43SetAtFn(m, v)
    {
        m[6] = v[0];
        m[7] = v[1];
        m[8] = v[2];
    },

    m43SetPos : function m43SetPosFn(m, v)
    {
        m[9] = v[0];
        m[10] = v[1];
        m[11] = v[2];
    },

    m43SetAxisRotation : function m43SetAxisRotationFn(m, axis, angle)
    {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;
        m[0] = tx * axisX + c;
        m[1] = tx * axisY - sz;
        m[2] = tx * axisZ + sy;
        m[3] = ty * axisX + sz;
        m[4] = ty * axisY + c;
        m[5] = ty * axisZ - sx;
        m[6] = tz * axisX - sy;
        m[7] = tz * axisY + sx;
        m[8] = tz * axisZ + c;
    },

    m43InverseOrthonormal : function m43InverseOrthonormalFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var px = m[9];
        var py = m[10];
        var pz = m[11];
        dst[0] = m0;
        dst[1] = m3;
        dst[2] = m6;
        dst[3] = m1;
        dst[4] = m4;
        dst[5] = m7;
        dst[6] = m2;
        dst[7] = m5;
        dst[8] = m8;
        dst[9]  = -((px * m0) + (py * m1) + (pz * m2));
        dst[10] = -((px * m3) + (py * m4) + (pz * m5));
        dst[11] = -((px * m6) + (py * m7) + (pz * m8));
        return dst;
    },

    m43Orthonormalize : function m43OrthonormalizeFn(m, dst)
    {
        var normalize = VMath.v3Normalize;
        var length    = VMath.v3Length;
        var dot       = VMath.v3Dot;
        var cross     = VMath.v3Cross;
        var abs       = Math.abs;

        var right = VMath.m43Right(m);
        var up    = VMath.m43Up(m);
        var at    = VMath.m43At(m);
        var pos   = VMath.m43Pos(m);

        var innerX = length(right);
        var innerY = length(up);
        var innerZ = length(at);

        normalize(right, right);
        normalize(up, up);
        normalize(at, at);

        var vpU, vpV, vpW;
        if (innerX > 0.0)
        {
            if (innerY > 0.0)
            {
                if (innerZ > 0.0)
                {
                    var outerX = abs(dot(up, at));
                    var outerY = abs(dot(at, right));
                    var outerZ = abs(dot(right, up));
                    if (outerX < outerY)
                    {
                        if (outerX < outerZ)
                        {
                            vpU = up;
                            vpV = at;
                            vpW = right;
                        }
                        else
                        {
                            vpU = right;
                            vpV = up;
                            vpW = at;
                        }
                    }
                    else
                    {
                        if (outerY < outerZ)
                        {
                            vpU = at;
                            vpV = right;
                            vpW = up;
                        }
                        else
                        {
                            vpU = right;
                            vpV = up;
                            vpW = at;
                        }
                    }
                }
                else
                {
                    vpU = right;
                    vpV = up;
                    vpW = at;
                }
            }
            else
            {
                vpU = at;
                vpV = right;
                vpW = up;
            }
        }
        else
        {
            vpU = up;
            vpV = at;
            vpW = right;
        }

        cross(vpU, vpV, vpW);
        normalize(vpW, vpW);

        cross(vpW, vpU, vpV);
        normalize(vpV, vpV);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = right[0];
        dst[1] = right[1];
        dst[2] = right[2];
        dst[3] = up[0];
        dst[4] = up[1];
        dst[5] = up[2];
        dst[6] = at[0];
        dst[7] = at[1];
        dst[8] = at[2];
        dst[9] = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43Determinant : function m43DeterminantFn(m)
    {
        return (m[0] * (m[4] * m[8] - m[5] * m[7]) +
                m[1] * (m[5] * m[6] - m[3] * m[8]) +
                m[2] * (m[3] * m[7] - m[4] * m[6]));
    },

    m43Inverse : function m43InverseFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var det = (m0 * (m4 * m8 - m5 * m7) +
                   m1 * (m5 * m6 - m3 * m8) +
                   m2 * (m3 * m7 - m4 * m6));
        if (det === 0.0)
        {
            return dst;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(12);
            }
            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[1] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[2] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[3] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[5] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[6] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[7] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            dst[9]  = ((m3 * (m10 * m8  - m7 * m11) + m4  * (m6 * m11 - m9 * m8) + m5  * (m9 * m7 - m6 * m10)) * detrecp);
            dst[10] = ((m6 * (m2  * m10 - m1 * m11) + m7  * (m0 * m11 - m9 * m2) + m8  * (m9 * m1 - m0 * m10)) * detrecp);
            dst[11] = ((m9 * (m2  * m4  - m1 * m5)  + m10 * (m0 * m5  - m3 * m2) + m11 * (m3 * m1 - m0 * m4))  * detrecp);
            return dst;
        }
    },

    m43Translate : function m43TranslateFn(matrix, pos)
    {
        matrix[9]  += pos[0];
        matrix[10] += pos[1];
        matrix[11] += pos[2];
    },

    m43Scale : function m43ScaleFn(m, scale, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        dst[0] = m[0] * sx;
        dst[1] = m[1] * sx;
        dst[2] = m[2] * sx;
        dst[3] = m[3] * sy;
        dst[4] = m[4] * sy;
        dst[5] = m[5] * sy;
        dst[6] = m[6] * sz;
        dst[7] = m[7] * sz;
        dst[8] = m[8] * sz;
        dst[9] = m[9];
        dst[10] = m[10];
        dst[11] = m[11];

        return dst;
    },

    m43TransformVector : function m43TransformVectorFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2);
        return dst;
    },

    m43TransformPoint : function m43TransformPointFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2 + m[9]);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2 + m[10]);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2 + m[11]);
        return dst;
    },

    m43Mul : function m43MulFn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];
        var a9  = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] =  (b1 * a0 + b4 * a1 + b7 * a2);
        dst[2] =  (b2 * a0 + b5 * a1 + b8 * a2);
        dst[3] =  (b0 * a3 + b3 * a4 + b6 * a5);
        dst[4] =  (b1 * a3 + b4 * a4 + b7 * a5);
        dst[5] =  (b2 * a3 + b5 * a4 + b8 * a5);
        dst[6] =  (b0 * a6 + b3 * a7 + b6 * a8);
        dst[7] =  (b1 * a6 + b4 * a7 + b7 * a8);
        dst[8] =  (b2 * a6 + b5 * a7 + b8 * a8);
        dst[9]  = (b0 * a9 + b3 * a10 + b6 * a11 + b[9]);
        dst[10] = (b1 * a9 + b4 * a10 + b7 * a11 + b[10]);
        dst[11] = (b2 * a9 + b5 * a10 + b8 * a11 + b[11]);

        return dst;
    },

    m43MulM44 : function m43MulM44Fn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];
        var a9  = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];
        var b9  = b[9];
        var b10 = b[10];
        var b11 = b[11];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  (b0 * a0 + b4 * a1 + b8  * a2);
        dst[1] =  (b1 * a0 + b5 * a1 + b9  * a2);
        dst[2] =  (b2 * a0 + b6 * a1 + b10 * a2);
        dst[3] =  (b3 * a0 + b7 * a1 + b11 * a2);
        dst[4] =  (b0 * a3 + b4 * a4 + b8  * a5);
        dst[5] =  (b1 * a3 + b5 * a4 + b9  * a5);
        dst[6] =  (b2 * a3 + b6 * a4 + b10 * a5);
        dst[7] =  (b3 * a3 + b7 * a4 + b11 * a5);
        dst[8] =  (b0 * a6 + b4 * a7 + b8  * a8);
        dst[9]  = (b1 * a6 + b5 * a7 + b9  * a8);
        dst[10] = (b2 * a6 + b6 * a7 + b10 * a8);
        dst[11] = (b3 * a6 + b7 * a7 + b11 * a8);
        dst[12] = (b0 * a9 + b4 * a10 + b8  * a11 + b[12]);
        dst[13] = (b1 * a9 + b5 * a10 + b9  * a11 + b[13]);
        dst[14] = (b2 * a9 + b6 * a10 + b10 * a11 + b[14]);
        dst[15] = (b3 * a9 + b7 * a10 + b11 * a11 + b[15]);

        return dst;
    },

    m43Transpose : function m43TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        dst[0] =  m0;
        dst[1] =  m3;
        dst[2] =  m6;
        dst[3] =  m9;
        dst[4] =  m1;
        dst[5] =  m4;
        dst[6] =  m7;
        dst[7] =  m10;
        dst[8] =  m2;
        dst[9]  = m5;
        dst[10] = m8;
        dst[11] = m11;

        return dst;
    },

    m43MulTranspose: function m43MulTransposeFn(a, b, dst)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];
        var a9 = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];
        var b9 = b[9];
        var b10 = b[10];
        var b11 = b[11];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] =  (b0 * a3 + b3 * a4 + b6 * a5);
        dst[2] =  (b0 * a6 + b3 * a7 + b6 * a8);
        dst[3] =  (b0 * a9 + b3 * a10 + b6 * a11 + b9);
        dst[4] =  (b1 * a0 + b4 * a1 + b7 * a2);
        dst[5] =  (b1 * a3 + b4 * a4 + b7 * a5);
        dst[6] =  (b1 * a6 + b4 * a7 + b7 * a8);
        dst[7] =  (b1 * a9 + b4 * a10 + b7 * a11 + b10);
        dst[8] =  (b2 * a0 + b5 * a1 + b8 * a2);
        dst[9]  = (b2 * a3 + b5 * a4 + b8 * a5);
        dst[10] = (b2 * a6 + b5 * a7 + b8 * a8);
        dst[11] = (b2 * a9 + b5 * a10 + b8 * a11 + b11);

        return dst;
    },

    m43Offset: function m43OffsetFn(m, o, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var o0 = o[0];
        var o1 = o[1];
        var o2 = o[2];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  m3;
        dst[4] =  m4;
        dst[5] =  m5;
        dst[6] =  m6;
        dst[7] =  m7;
        dst[8] =  m8;
        dst[9]  = (m0 * o0 + m3 * o1 + m6 * o2 + m9);
        dst[10] = (m1 * o0 + m4 * o1 + m7 * o2 + m10);
        dst[11] = (m2 * o0 + m5 * o1 + m8 * o2 + m11);

        return dst;
    },

    m43NegOffset: function m43NegOffsetFn(m, o, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var o0 = -o[0];
        var o1 = -o[1];
        var o2 = -o[2];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  m3;
        dst[4] =  m4;
        dst[5] =  m5;
        dst[6] =  m6;
        dst[7] =  m7;
        dst[8] =  m8;
        dst[9]  = (m0 * o0 + m3 * o1 + m6 * o2 + m9);
        dst[10] = (m1 * o0 + m4 * o1 + m7 * o2 + m10);
        dst[11] = (m2 * o0 + m5 * o1 + m8 * o2 + m11);

        return dst;
    },

    m43InverseTransposeProjection: function m43InverseTransposeProjectionFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var xf = (0.5 / s[0]);
        var yf = (0.5 / s[1]);
        var zf = (0.5 / s[2]);
        var m0 = (m[0] * xf);
        var m1 = (m[1] * xf);
        var m2 = (m[2] * xf);
        var m3 = (m[3] * yf);
        var m4 = (m[4] * yf);
        var m5 = (m[5] * yf);
        var m6 = (m[6] * zf);
        var m7 = (m[7] * zf);
        var m8 = (m[8] * zf);
        var px = m[9];
        var py = m[10];
        var pz = m[11];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  (0.5 - ((px * m0) + (py * m1) + (pz * m2)));
        dst[4] =  m3;
        dst[5] =  m4;
        dst[6] =  m5;
        dst[7] =  (0.5 - ((px * m3) + (py * m4) + (pz * m5)));
        dst[8] =  m6;
        dst[9]  = m7;
        dst[10] = m8;
        dst[11] = (0.5 - ((px * m6) + (py * m7) + (pz * m8)));

        return dst;
    },

    // Matrix 43 opeations with scalar
    m43ScalarAdd : function m43ScalarAddFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        for (var n = 0; n < 12; n += 1)
        {
            dst[n] = (m[n] + s);
        }
        return dst;
    },

    m43ScalarSub : function m43ScalarSubFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        for (var n = 0; n < 12; n += 1)
        {
            dst[n] = (m[n] - s);
        }
        return dst;
    },

    m43ScalarMul : function m43ScalarMulFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        for (var n = 0; n < 12; n += 1)
        {
            dst[n] = (m[n] * s);
        }
        return dst;
    },

    // Matrix44
    m44BuildIdentity : function m44BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  1.0;
        dst[1] =  0.0;
        dst[2] =  0.0;
        dst[3] =  0.0;
        dst[4] =  0.0;
        dst[5] =  1.0;
        dst[6] =  0.0;
        dst[7] =  0.0;
        dst[8] =  0.0;
        dst[9] =  0.0;
        dst[10] = 1.0;
        dst[11] = 0.0;
        dst[12] = 0.0;
        dst[13] = 0.0;
        dst[14] = 0.0;
        dst[15] = 1.0;

        return dst;
    },

    m44Build : function m44BuildFn(r, u, a, p, dst)
    {
        var length = arguments.length;
        if (length >= 16)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 16)
            {
                res = arguments[16];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(16);
                }
            }
            else
            {
                res = new VMathArrayConstructor(16);
            }

            res[0] =  arguments[0];
            res[1] =  arguments[1];
            res[2] =  arguments[2];
            res[3] =  arguments[3];
            res[4] =  arguments[4];
            res[5] =  arguments[5];
            res[6] =  arguments[6];
            res[7] =  arguments[7];
            res[8] =  arguments[8];
            res[9] =  arguments[9];
            res[10] = arguments[10];
            res[11] = arguments[11];
            res[12] = arguments[12];
            res[13] = arguments[13];
            res[14] = arguments[14];
            res[15] = arguments[15];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(16);
            }

            dst[0] =  r[0];
            dst[1] =  r[1];
            dst[2] =  r[2];
            dst[3] =  r[3];
            dst[4] =  u[0];
            dst[5] =  u[1];
            dst[6] =  u[2];
            dst[7] =  u[3];
            dst[8] =  a[0];
            dst[9] =  a[1];
            dst[10] = a[2];
            dst[11] = a[3];
            dst[12] = p[0];
            dst[13] = p[1];
            dst[14] = p[2];
            dst[15] = p[3];

            return dst;
        }
    },

    m44Copy : function m44CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  m[0];
        dst[1] =  m[1];
        dst[2] =  m[2];
        dst[3] =  m[3];
        dst[4] =  m[4];
        dst[5] =  m[5];
        dst[6] =  m[6];
        dst[7] =  m[7];
        dst[8] =  m[8];
        dst[9] =  m[9];
        dst[10] = m[10];
        dst[11] = m[11];
        dst[12] = m[12];
        dst[13] = m[13];
        dst[14] = m[14];
        dst[15] = m[15];

        return dst;
    },

    m44Right : function m44RightFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(0, 4);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        return dst;
    },

    m44Up : function m44UpFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(4, 8);
        }

        dst[0] = m[4];
        dst[1] = m[5];
        dst[2] = m[6];
        dst[3] = m[7];
        return dst;
    },

    m44At : function m44AtFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(8, 12);
        }

        dst[0] = m[8];
        dst[1] = m[9];
        dst[2] = m[10];
        dst[3] = m[11];
        return dst;
    },

    m44Pos : function m44PosFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(12);
        }

        dst[0] = m[12];
        dst[1] = m[13];
        dst[2] = m[14];
        dst[3] = m[15];
        return dst;
    },

    m44SetRight : function m44SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
        m[3] = v[3];
    },

    m44SetUp : function m44SetUpFn(m, v)
    {
        m[4] = v[0];
        m[5] = v[1];
        m[6] = v[2];
        m[7] = v[3];
    },

    m44SetAt : function m44SetAtFn(m, v)
    {
        m[8] = v[0];
        m[9] = v[1];
        m[10] = v[2];
        m[11] = v[3];
    },

    m44SetPos : function m44SetPosFn(m, v)
    {
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];
        m[15] = v[3];
    },

    m44Translate : function m44TranslateFn(m, v)
    {
        m[12] += v[0];
        m[13] += v[1];
        m[14] += v[2];
        m[15] += v[3];
    },

    m44Scale : function m44ScaleFn(m, scale, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        /*jshint white: false */
        dst[0] =  m[0]  * scale[0];
        dst[1] =  m[1]  * scale[0];
        dst[2] =  m[2]  * scale[0];
        dst[3] =  m[3];
        dst[4] =  m[4]  * scale[1];
        dst[5] =  m[5]  * scale[1];
        dst[6] =  m[6]  * scale[1];
        dst[7] =  m[7];
        dst[8] =  m[8]  * scale[2];
        dst[9] =  m[9]  * scale[2];
        dst[10] = m[10] * scale[2];
        dst[11] = m[11];
        dst[12] = m[12];
        dst[13] = m[13];
        dst[14] = m[14];
        dst[15] = m[15];
        /*jshint white: true */

        return dst;
    },

    m44Transform : function m44TransformFn(m, v, dst)
    {
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        var v3 = v[3];
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        if (v3 !== 1.0)
        {
            dst[0] = ((m[0] * v0) + (m[4] * v1) + (m[8]  * v2) + (m[12] * v3));
            dst[1] = ((m[1] * v0) + (m[5] * v1) + (m[9]  * v2) + (m[13] * v3));
            dst[2] = ((m[2] * v0) + (m[6] * v1) + (m[10] * v2) + (m[14] * v3));
            dst[3] = ((m[3] * v0) + (m[7] * v1) + (m[11] * v2) + (m[15] * v3));
        }
        else
        {
            dst[0] = ((m[0] * v0) + (m[4] * v1) + (m[8]  * v2) + m[12]);
            dst[1] = ((m[1] * v0) + (m[5] * v1) + (m[9]  * v2) + m[13]);
            dst[2] = ((m[2] * v0) + (m[6] * v1) + (m[10] * v2) + m[14]);
            dst[3] = ((m[3] * v0) + (m[7] * v1) + (m[11] * v2) + m[15]);
        }
        return dst;
    },

    m44Mul : function m44MulFn(a, b, dst)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];
        var a9 = a[9];
        var a10 = a[10];
        var a11 = a[11];
        var a12 = a[12];
        var a13 = a[13];
        var a14 = a[14];
        var a15 = a[15];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];
        var b9 = b[9];
        var b10 = b[10];
        var b11 = b[11];
        var b12 = b[12];
        var b13 = b[13];
        var b14 = b[14];
        var b15 = b[15];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] = (b0 * a0  + b4 * a1  + b8  * a2  + b12 * a3);
        dst[1] = (b1 * a0  + b5 * a1  + b9  * a2  + b13 * a3);
        dst[2] = (b2 * a0  + b6 * a1  + b10 * a2  + b14 * a3);
        dst[3] = (b3 * a0  + b7 * a1  + b11 * a2  + b15 * a3);
        dst[4] = (b0 * a4  + b4 * a5  + b8  * a6  + b12 * a7);
        dst[5] = (b1 * a4  + b5 * a5  + b9  * a6  + b13 * a7);
        dst[6] = (b2 * a4  + b6 * a5  + b10 * a6  + b14 * a7);
        dst[7] = (b3 * a4  + b7 * a5  + b11 * a6  + b15 * a7);
        dst[8] = (b0 * a8  + b4 * a9  + b8  * a10 + b12 * a11);
        dst[9] = (b1 * a8  + b5 * a9  + b9  * a10 + b13 * a11);
        dst[10] = (b2 * a8  + b6 * a9  + b10 * a10 + b14 * a11);
        dst[11] = (b3 * a8  + b7 * a9  + b11 * a10 + b15 * a11);
        dst[12] = (b0 * a12 + b4 * a13 + b8  * a14 + b12 * a15);
        dst[13] = (b1 * a12 + b5 * a13 + b9  * a14 + b13 * a15);
        dst[14] = (b2 * a12 + b6 * a13 + b10 * a14 + b14 * a15);
        dst[15] = (b3 * a12 + b7 * a13 + b11 * a14 + b15 * a15);

        return dst;
    },

    m44Inverse : function m44InverseFn(m, dst)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        /*jshint white: false */
        var A0 = (( m0 *  m5) - ( m1 *  m4));
        var A1 = (( m0 *  m6) - ( m2 *  m4));
        var A2 = (( m0 *  m7) - ( m3 *  m4));
        var A3 = (( m1 *  m6) - ( m2 *  m5));
        var A4 = (( m1 *  m7) - ( m3 *  m5));
        var A5 = (( m2 *  m7) - ( m3 *  m6));
        var B0 = (( m8 * m13) - ( m9 * m12));
        var B1 = (( m8 * m14) - (m10 * m12));
        var B2 = (( m8 * m15) - (m11 * m12));
        var B3 = (( m9 * m14) - (m10 * m13));
        var B4 = (( m9 * m15) - (m11 * m13));
        var B5 = ((m10 * m15) - (m11 * m14));
        /*jshint white: true */

        var det = ((A0 * B5) - (A1 * B4) + (A2 * B3) + (A3 * B2) - (A4 * B1) + (A5 * B0));
        if (det === 0.0)
        {
            /*jshint white: false */
            dst[ 0] = 0.0;
            dst[ 1] = 0.0;
            dst[ 2] = 0.0;
            dst[ 3] = 0.0;
            dst[ 4] = 0.0;
            dst[ 5] = 0.0;
            dst[ 6] = 0.0;
            dst[ 7] = 0.0;
            dst[ 8] = 0.0;
            dst[ 9] = 0.0;
            dst[10] = 0.0;
            dst[11] = 0.0;
            dst[12] = 0.0;
            dst[13] = 0.0;
            dst[14] = 0.0;
            dst[15] = 0.0;
            /*jshint white: true */
        }
        else
        {
            var detrecp = 1.0 / det;
            /*jshint white: false */
            dst[ 0] = (+ ( m5 * B5) - ( m6 * B4) + ( m7 * B3)) * detrecp;
            dst[ 4] = (- ( m4 * B5) + ( m6 * B2) - ( m7 * B1)) * detrecp;
            dst[ 8] = (+ ( m4 * B4) - ( m5 * B2) + ( m7 * B0)) * detrecp;
            dst[12] = (- ( m4 * B3) + ( m5 * B1) - ( m6 * B0)) * detrecp;
            dst[ 1] = (- ( m1 * B5) + ( m2 * B4) - ( m3 * B3)) * detrecp;
            dst[ 5] = (+ ( m0 * B5) - ( m2 * B2) + ( m3 * B1)) * detrecp;
            dst[ 9] = (- ( m0 * B4) + ( m1 * B2) - ( m3 * B0)) * detrecp;
            dst[13] = (+ ( m0 * B3) - ( m1 * B1) + ( m2 * B0)) * detrecp;
            dst[ 2] = (+ (m13 * A5) - (m14 * A4) + (m15 * A3)) * detrecp;
            dst[ 6] = (- (m12 * A5) + (m14 * A2) - (m15 * A1)) * detrecp;
            dst[10] = (+ (m12 * A4) - (m13 * A2) + (m15 * A0)) * detrecp;
            dst[14] = (- (m12 * A3) + (m13 * A1) - (m14 * A0)) * detrecp;
            dst[ 3] = (- ( m9 * A5) + (m10 * A4) - (m11 * A3)) * detrecp;
            dst[ 7] = (+ ( m8 * A5) - (m10 * A2) + (m11 * A1)) * detrecp;
            dst[11] = (- ( m8 * A4) + ( m9 * A2) - (m11 * A0)) * detrecp;
            dst[15] = (+ ( m8 * A3) - ( m9 * A1) + (m10 * A0)) * detrecp;
            /*jsline white: true */
        }

        return dst;
    },

    m44Transpose : function m44TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] = m[0];
        dst[1] = m[4];
        dst[2] = m[8];
        dst[3] = m[12];
        dst[4] = m[1];
        dst[5] = m[5];
        dst[6] = m[9];
        dst[7] = m[13];
        dst[8] = m[2];
        dst[9] = m[6];
        dst[10] = m[10];
        dst[11] = m[14];
        dst[12] = m[3];
        dst[13] = m[7];
        dst[14] = m[11];
        dst[15] = m[15];

        return dst;
    },

    // Matrix44 operations with scalars
    m44ScalarAdd : function m44ScalarAddFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }
        for (var n = 0; n < 16; n += 1)
        {
            dst[n] = (m[n] + s);
        }
        return dst;
    },

    m44ScalarSub : function m44ScalarSubFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }
        for (var n = 0; n < 16; n += 1)
        {
            dst[n] = (m[n] - s);
        }
        return dst;
    },

    m44ScalarMul : function m44ScalarMulFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }
        for (var n = 0; n < 16; n += 1)
        {
            dst[n] = (m[n] * s);
        }
        return dst;
    },

    // Quaternion
    quatBuild : function quatBuildFn(x, y, z, w, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = x;
        dst[1] = y;
        dst[2] = z;
        dst[3] = w;
        return dst;
    },

    quatCopy : function quatCopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        return dst;
    },

    quatIsSimilar : function quatIsSimilarFn(q1, q2, precision)
    {
        if (precision === undefined)
        {
            precision = this.precision;
        }
        // this compares for similar rotations not raw data
        var q1temp = q1;

        if (q1[3] * q2[3] < 0.0)
        {
            // quaternions in opposing hemispheres, negate one
            q1temp = VMath.v4Neg(q1);
        }

        var mag_sqrd = VMath.v4LengthSq(VMath.v4Sub(q1temp, q2));
        var epsilon_sqrd = (precision * precision);
        return mag_sqrd < epsilon_sqrd;
    },

    quatLength : function quatLengthFn(q)
    {
        return VMath.v4Length(q);
    },

    quatDot : function quatDotFn(q1, q2)
    {
        return VMath.v4Dot(q1, q2);
    },

    quatMul : function quatMulFn(q1, q2, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        // Note quaternion multiplication is the opposite way around from our matrix multiplication
        //var v1 = q1; // use full quats to avoid copy
        //var v2 = q2;

        /*
        // Calculate the imaginary part
        var quat = VMath.v3Add3(VMath.v3ScalarMul(v2, q1[3]), VMath.v3ScalarMul(v1, q2[3]), VMath.v3Cross(v1, v2));
        // And extend with the real part
        quat[3] = (q1[3] * q2[3]) - VMath.v3Dot(v1, v2);
        */

        // Inlined from above
        var q2x = q1[0];
        var q2y = q1[1];
        var q2z = q1[2];
        var q2w = q1[3];
        var q1x = q2[0];
        var q1y = q2[1];
        var q1z = q2[2];
        var q1w = q2[3];

        var cx = (q1z * q2y) - (q1y * q2z);
        var cy = (q1x * q2z) - (q1z * q2x);
        var cz = (q1y * q2x) - (q1x * q2y);

        dst[0] = (q2x * q1w) + (q1x * q2w) + cx;
        dst[1] = (q2y * q1w) + (q1y * q2w) + cy;
        dst[2] = (q2z * q1w) + (q1z * q2w) + cz;
        dst[3] = (q1w * q2w) - (q1x * q2x + q1y * q2y + q1z * q2z);

        return dst;
    },

    quatMulTranslate : function quatMulTranslateFn(qa, va, qb, vb, qr, vr)
    {
        var qax = qa[0];
        var qay = qa[1];
        var qaz = qa[2];
        var qaw = qa[3];
        var qbx = qb[0];
        var qby = qb[1];
        var qbz = qb[2];
        var qbw = qb[3];

        // Multiply together the two quaternions
        var cx = (qaz * qby) - (qay * qbz);
        var cy = (qax * qbz) - (qaz * qbx);
        var cz = (qay * qbx) - (qax * qby);

        qr[0] = (qbx * qaw) + (qax * qbw) + cx;
        qr[1] = (qby * qaw) + (qay * qbw) + cy;
        qr[2] = (qbz * qaw) + (qaz * qbw) + cz;
        qr[3] = (qaw * qbw) - (qax * qbx + qay * qby + qaz * qbz);

        // Transform the 2nd vector by the first quaternion and add in the first position
        var vax = va[0];
        var vay = va[1];
        var vaz = va[2];
        var vbx = vb[0];
        var vby = vb[1];
        var vbz = vb[2];

        var s = (qaw * qaw) - (qax * qax + qay * qay + qaz * qaz);
        var rx = vbx * s;
        var ry = vby * s;
        var rz = vbz * s;

        s = qax * vbx + qay * vby + qaz * vbz;

        var twoS = s + s;
        rx += qax * twoS;
        ry += qay * twoS;
        rz += qaz * twoS;

        cx = (qaz * vby) - (qay * vbz);
        cy = (qax * vbz) - (qaz * vbx);
        cz = (qay * vbx) - (qax * vby);
        var twoQw = qaw + qaw;
        rx += cx * twoQw;
        ry += cy * twoQw;
        rz += cz * twoQw;

        vr[0] = rx + vax;
        vr[1] = ry + vay;
        vr[2] = rz + vaz;
    },

    quatNormalize : function quatNormalizeFn(q, dst)
    {
        var norme = VMath.quatDot(q, q);
        if (norme === 0.0)
        {
            return VMath.v4BuildZero(dst);
        }
        else
        {
            var recip = 1.0 / Math.sqrt(norme);
            return VMath.v4ScalarMul(q, recip, dst);
        }
    },

    quatConjugate : function quatConjugateFn(q, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = -q[0];
        dst[1] = -q[1];
        dst[2] = -q[2];
        dst[3] =  q[3];

        return dst;
    },

    quatLerp : function quatLerpFn(q1, q2, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var q1x = q1[0];
        var q1y = q1[1];
        var q1z = q1[2];
        var q1w = q1[3];
        var q2x = q2[0];
        var q2y = q2[1];
        var q2z = q2[2];
        var q2w = q2[3];

        dst[0] = ((q2x - q1x) * t) + q1x;
        dst[1] = ((q2y - q1y) * t) + q1y;
        dst[2] = ((q2z - q1z) * t) + q1z;
        dst[3] = ((q2w - q1w) * t) + q1w;

        return dst;
    },

    cosMinSlerpAngle : Math.cos(Math.PI / 40.0), // use a lerp for angles <= 4.5 degrees

    quatSlerp : function quatSlerpFn(q1, q2, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var q1x = q1[0];
        var q1y = q1[1];
        var q1z = q1[2];
        var q1w = q1[3];
        var q2x = q2[0];
        var q2y = q2[1];
        var q2z = q2[2];
        var q2w = q2[3];
        var dotq1q2 = (q1x * q2x) + (q1y * q2y) + (q1z * q2z) + (q1w * q2w);

        var cosom = dotq1q2;
        if (cosom < 0.0)
        {
            q1x = -q1x;
            q1y = -q1y;
            q1z = -q1z;
            q1w = -q1w;
            cosom = -cosom;
        }

        if (cosom > VMath.cosMinSlerpAngle)
        {
            var delta = t;
            if (dotq1q2 <= 0.0)
            {
                delta = -t;
            }

            var qrx = ((q2x - q1x) * delta) + q1x;
            var qry = ((q2y - q1y) * delta) + q1y;
            var qrz = ((q2z - q1z) * delta) + q1z;
            var qrw = ((q2w - q1w) * delta) + q1w;

            var mag = Math.sqrt((qrx * qrx) + (qry * qry) + (qrz * qrz) + (qrw * qrw));
            var recip = 1.0 / mag;

            dst[0] =  qrx * recip;
            dst[1] =  qry * recip;
            dst[2] =  qrz * recip;
            dst[3] =  qrw * recip;

            return dst;
        }

        var sinFn = Math.sin;
        var omega = Math.acos(cosom);
        var inv_sin_omega = 1.0 / sinFn(omega);

        var scalar = sinFn((1.0 - t) * omega) * inv_sin_omega;
        q1x = q1x * scalar;
        q1y = q1y * scalar;
        q1z = q1z * scalar;
        q1w = q1w * scalar;

        scalar = sinFn(t * omega) * inv_sin_omega;
        q2x = q2x * scalar;
        q2y = q2y * scalar;
        q2z = q2z * scalar;
        q2w = q2w * scalar;

        dst[0] =  q1x + q2x;
        dst[1] =  q1y + q2y;
        dst[2] =  q1z + q2z;
        dst[3] =  q1w + q2w;

        return dst;
    },

    quatFromM43 : function quatFromM43Fn(m, dst)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];

        var x, y, z, w, s;
        var trace = m0 + m4 + m8 + 1;
        if (trace > VMath.precision)
        {
            w = Math.sqrt(trace) / 2;
            x = (m5 - m7) / (4 * w);
            y = (m6 - m2) / (4 * w);
            z = (m1 - m3) / (4 * w);
        }
        else
        {
            if ((m0 > m4) && (m0 > m8))
            {
                s = Math.sqrt(1.0 + m0 - m4 - m8) * 2; // S=4*qx
                w = (m5 - m7) / s;
                x = 0.25 * s;
                y = (m3 + m1) / s;
                z = (m6 + m2) / s;
            }
            else if (m4 > m8)
            {
                s = Math.sqrt(1.0 + m4 - m0 - m8) * 2; // S=4*qy
                w = (m6 - m2) / s;
                x = (m3 + m1) / s;
                y = 0.25 * s;
                z = (m7 + m5) / s;
            }
            else
            {
                s = Math.sqrt(1.0 + m8 - m0 - m4) * 2; // S=4*qz
                w = (m1 - m3) / s;
                x = (m6 + m2) / s;
                y = (m7 + m5) / s;
                z = 0.25 * s;
            }
        }

        var q = VMath.quatNormalize([x, y, z, w], dst);

        return VMath.quatConjugate(q, dst);
    },

    quatFromAxisRotation : function quatFromAxisRotationFn(axis, angle, dst)
    {
        var omega = 0.5 * angle;
        var s = Math.sin(omega);
        var c = Math.cos(omega);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = axis[0] * s;
        dst[1] = axis[1] * s;
        dst[2] = axis[2] * s;
        dst[3] = c;

        return VMath.quatNormalize(dst, dst);
    },

    quatToAxisRotation : function quatToAxisRotation(q, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var q3 = q[3];
        var angle = Math.acos(q3) * 2.0;
        var sin_sqrd = 1.0 - q3 * q3;

        if (sin_sqrd < VMath.precision)
        {
            // we can return any axis
            dst[0] = 1.0;
            dst[1] = 0.0;
            dst[2] = 0.0;
            dst[3] = angle;
        }
        else
        {
            var scale = 1.0 / Math.sqrt(sin_sqrd);
            dst[0] = q[0] * scale;
            dst[1] = q[1] * scale;
            dst[2] = q[2] * scale;
            dst[3] = angle;
        }
        return dst;
    },

    quatTransformVector : function quatTransformVectorFn(q, v, dst)
    {
        /*
        var qimaginary = q; // Use full quat directly to avoid copy
        var qw = q[3];

        var s = (qw * qw) - VMath.v3Dot(qimaginary, qimaginary);

        var r = VMath.v3ScalarMul(v, s);

        s = VMath.v3Dot(qimaginary, v);
        r = VMath.v3Add(r, VMath.v3ScalarMul(qimaginary, s + s));
        r = VMath.v3Add(r, VMath.v3ScalarMul(VMath.v3Cross(qimaginary, v), qw + qw));
        */

        // Inlined from above
        var qx = q[0];
        var qy = q[1];
        var qz = q[2];
        var qw = q[3];

        var vx = v[0];
        var vy = v[1];
        var vz = v[2];

        //var s = (qw * qw) - VMath.v3Dot(qimaginary, qimaginary);
        var s = (qw * qw) - (qx * qx + qy * qy + qz * qz);

        //var r = VMath.v3ScalarMul(v, s);
        var rx = vx * s;
        var ry = vy * s;
        var rz = vz * s;

        //s = VMath.v3Dot(qimaginary, v);
        s = qx * vx + qy * vy + qz * vz;

        //r = VMath.v3Add(r, VMath.v3ScalarMul(qimaginary, s + s));
        var twoS = s + s;
        rx += qx * twoS;
        ry += qy * twoS;
        rz += qz * twoS;

        //r = VMath.v3Add(r, VMath.v3ScalarMul(VMath.v3Cross(VMath.v3Neg(qimaginary), v), qw + qw));
        var cx = (qz * vy) - (qy * vz);
        var cy = (qx * vz) - (qz * vx);
        var cz = (qy * vx) - (qx * vy);
        var twoQw = qw + qw;
        rx += cx * twoQw;
        ry += cy * twoQw;
        rz += cz * twoQw;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = rx;
        dst[1] = ry;
        dst[2] = rz;

        return dst;
    },

    quatEqual : function quatEqual(q1, q2, precision)
    {
        if (precision === undefined)
        {
            precision = this.precision;
        }
        var abs = Math.abs;
        return (abs(q1[0] - q2[0]) <= precision &&
                abs(q1[1] - q2[1]) <= precision &&
                abs(q1[2] - q2[2]) <= precision &&
                abs(q1[3] - q2[3]) <= precision);
    },

    // quatPos
    quatPosBuild : function quatPosBuildFn(x, y, z, w, px, py, pz, dst)
    {
        if (arguments.length < 7)
        {
            if (z === undefined)
            {
                z = new VMathArrayConstructor(7);
            }
            z[0] = x[0];
            z[1] = x[1];
            z[2] = x[2];
            z[3] = x[3];
            z[4] = y[0];
            z[5] = y[1];
            z[6] = y[2];
            return z;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(7);
            }
            dst[0] = x;
            dst[1] = y;
            dst[2] = z;
            dst[3] = w;
            dst[4] = px;
            dst[5] = py;
            dst[6] = pz;
            return dst;
        }
    },

    quatPosTransformVector : function quatPosTransformVectorFn(qp, n, dst)
    {
        return VMath.quatTransformVector(qp, n, dst);
    },

    quatPosTransformPoint : function quatPosTransformPointFn(qp, p)
    {
        var offset = qp.slice(4, 7);

        var rotatedp = VMath.quatTransformVector(qp, p);
        return VMath.v3Add(rotatedp, offset);
    },

    quatPosMul : function quatPosMulFn(qp1, qp2)
    {
        var v2 = qp2.slice(4, 7);

        var qr = VMath.quatMul(qp1, qp2);
        var pr = VMath.quatPosTransformPoint(qp1, v2);
        qr[4] = pr[0];
        qr[5] = pr[1];
        qr[6] = pr[2];

        return qr;
    },

    //
    // Visibility queries
    //
    isVisibleBox : function isVisibleBoxFn(center, halfDimensions, vpm)
    {
        var abs = Math.abs;

        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];

        var h0 = halfDimensions[0];
        var h1 = halfDimensions[1];
        var h2 = halfDimensions[2];

        var m0  = vpm[0];
        var m1  = vpm[1];
        var m2  = vpm[2];
        var m3  = vpm[3];
        var m4  = vpm[4];
        var m5  = vpm[5];
        var m6  = vpm[6];
        var m7  = vpm[7];
        var m8  = vpm[8];
        var m9  = vpm[9];
        var m10 = vpm[10];
        var m11 = vpm[11];

        var I0 = (m0  * h0);
        var I1 = (m1  * h0);
        var I2 = (m2  * h0);
        var I3 = (m3  * h0);
        var J0 = (m4  * h1);
        var J1 = (m5  * h1);
        var J2 = (m6  * h1);
        var J3 = (m7  * h1);
        var K0 = (m8  * h2);
        var K1 = (m9  * h2);
        var K2 = (m10 * h2);
        var K3 = (m11 * h2);

        var T0 = (m0 * c0 + m4 * c1 + m8  * c2 + vpm[12]);
        var T1 = (m1 * c0 + m5 * c1 + m9  * c2 + vpm[13]);
        var T2 = (m2 * c0 + m6 * c1 + m10 * c2 + vpm[14]);
        var T3 = (m3 * c0 + m7 * c1 + m11 * c2 + vpm[15]);

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleBoxOrigin : function isVisibleBoxOriginFn(halfDimensions, vpm)
    {
        var abs = Math.abs;

        var h0 = halfDimensions[0];
        var h1 = halfDimensions[1];
        var h2 = halfDimensions[2];

        var I0 = (vpm[0]  * h0);
        var I1 = (vpm[1]  * h0);
        var I2 = (vpm[2]  * h0);
        var I3 = (vpm[3]  * h0);
        var J0 = (vpm[4]  * h1);
        var J1 = (vpm[5]  * h1);
        var J2 = (vpm[6]  * h1);
        var J3 = (vpm[7]  * h1);
        var K0 = (vpm[8]  * h2);
        var K1 = (vpm[9]  * h2);
        var K2 = (vpm[10] * h2);
        var K3 = (vpm[11] * h2);
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphere : function isVisibleSphereFn(center, radius, vpm)
    {
        var abs = Math.abs;

        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];

        var m0  = vpm[0];
        var m1  = vpm[1];
        var m2  = vpm[2];
        var m3  = vpm[3];
        var m4  = vpm[4];
        var m5  = vpm[5];
        var m6  = vpm[6];
        var m7  = vpm[7];
        var m8  = vpm[8];
        var m9  = vpm[9];
        var m10 = vpm[10];
        var m11 = vpm[11];

        var I0 = m0;
        var I1 = m1;
        var I2 = m2;
        var I3 = m3;
        var J0 = m4;
        var J1 = m5;
        var J2 = m6;
        var J3 = m7;
        var K0 = m8;
        var K1 = m9;
        var K2 = m10;
        var K3 = m11;

        var T0 = (m0 * c0 + m4 * c1 + m8  * c2 + vpm[12]);
        var T1 = (m1 * c0 + m5 * c1 + m9  * c2 + vpm[13]);
        var T2 = (m2 * c0 + m6 * c1 + m10 * c2 + vpm[14]);
        var T3 = (m3 * c0 + m7 * c1 + m11 * c2 + vpm[15]);

        var nradius = -radius;

        return !(((T0 - T3) >  radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  radius * (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphereOrigin : function isVisibleSphereOriginFn(radius, vpm)
    {
        var abs = Math.abs;

        var I0 = vpm[0];
        var I1 = vpm[1];
        var I2 = vpm[2];
        var I3 = vpm[3];
        var J0 = vpm[4];
        var J1 = vpm[5];
        var J2 = vpm[6];
        var J3 = vpm[7];
        var K0 = vpm[8];
        var K1 = vpm[9];
        var K2 = vpm[10];
        var K3 = vpm[11];
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        var nradius = -radius;

        return !(((T0 - T3) >  radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  radius * (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphereUnit : function isVisibleSphereUnitFn(vpm)
    {
        var abs = Math.abs;

        var I0 = vpm[0];
        var I1 = vpm[1];
        var I2 = vpm[2];
        var I3 = vpm[3];
        var J0 = vpm[4];
        var J1 = vpm[5];
        var J2 = vpm[6];
        var J3 = vpm[7];
        var K0 = vpm[8];
        var K1 = vpm[9];
        var K2 = vpm[10];
        var K3 = vpm[11];
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    transformBox : function transformBoxFn(center, halfExtents, matrix)
    {
        var abs = Math.abs;
        var m0  = matrix[0];
        var m1  = matrix[1];
        var m2  = matrix[2];
        var m3  = matrix[3];
        var m4  = matrix[4];
        var m5  = matrix[5];
        var m6  = matrix[6];
        var m7  = matrix[7];
        var m8  = matrix[8];
        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];
        var h0 = halfExtents[0];
        var h1 = halfExtents[1];
        var h2 = halfExtents[2];

        var out_center = new VMathArrayConstructor(3);
        out_center[0] = m0 * c0 + m3 * c1 + m6 * c2 + matrix[9];
        out_center[1] = m1 * c0 + m4 * c1 + m7 * c2 + matrix[10];
        out_center[2] = m2 * c0 + m5 * c1 + m8 * c2 + matrix[11];

        var out_halfext = new VMathArrayConstructor(3);
        out_halfext[0] = abs(m0) * h0 + abs(m3) * h1 + abs(m6) * h2;
        out_halfext[1] = abs(m1) * h0 + abs(m4) * h1 + abs(m7) * h2;
        out_halfext[2] = abs(m2) * h0 + abs(m5) * h1 + abs(m8) * h2;

        return {
            center : out_center,
            halfExtents : out_center
        };
    },

    //
    // Planes
    //
    planeNormalize : function planeNormalizeFn(plane, output)
    {
        if (output === undefined)
        {
            output = new VMathArrayConstructor(4);
        }

        var a = plane[0];
        var b = plane[1];
        var c = plane[2];
        var lsq = ((a * a) + (b * b) + (c * c));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            output[0] = (a * lr);
            output[1] = (b * lr);
            output[2] = (c * lr);
            output[3] = (plane[3] * lr);
        }
        else
        {
            output[0] = 0;
            output[1] = 0;
            output[2] = 0;
            output[3] = 0;
        }

        return output;
    },

    extractFrustumPlanes : function extractFrustumPlanesFn(m, p)
    {
        var planeNormalize = VMath.planeNormalize;
        var m0  = m[0];
        var m1  = m[1];
        var m2  = m[2];
        var m3  = m[3];
        var m4  = m[4];
        var m5  = m[5];
        var m6  = m[6];
        var m7  = m[7];
        var m8  = m[8];
        var m9  = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];
        var planes = (p || []);

        // Negate 'd' here to avoid doing it on the isVisible functions
        planes[0] = planeNormalize([(m3  + m0), (m7  + m4), (m11 + m8),
                                    -(m15 + m12)], planes[0]); // left
        planes[1] = planeNormalize([(m3  - m0), (m7  - m4), (m11 - m8),
                                    -(m15 - m12)], planes[1]); // right
        planes[2] = planeNormalize([(m3  - m1), (m7  - m5), (m11 - m9),
                                    -(m15 - m13)], planes[2]); // top
        planes[3] = planeNormalize([(m3  + m1), (m7  + m5), (m11 + m9),
                                    -(m15 + m13)], planes[3]); // bottom
        planes[4] = planeNormalize([(m3  + m2), (m7  + m6), (m11 + m10),
                                    -(m15 + m14)], planes[4]);  // near
        planes[5] = planeNormalize([(m3  - m2), (m7  - m6), (m11 - m10),
                                    -(m15 - m14)], planes[5]); // far

        return planes;
    },

    isInsidePlanesPoint : function isInsidePlanesPointFn(p, planes)
    {
        var p0 = p[0];
        var p1 = p[1];
        var p2 = p[2];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            if ((plane[0] * p0 + plane[1] * p1 + plane[2] * p2) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isInsidePlanesSphere : function isInsidePlanesSphereFn(c, r, planes)
    {
        var c0 = c[0];
        var c1 = c[1];
        var c2 = c[2];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            if ((plane[0] * c0 + plane[1] * c1 + plane[2] * c2) < (plane[3] - r))
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isInsidePlanesBox : function isInsidePlanesBoxFn(c, h, planes)
    {
        var c0 = c[0];
        var c1 = c[1];
        var c2 = c[2];
        var h0 = h[0];
        var h1 = h[1];
        var h2 = h[2];
        var p0 = (c0 + h0);
        var p1 = (c1 + h1);
        var p2 = (c2 + h2);
        var n0 = (c0 - h0);
        var n1 = (c1 - h1);
        var n2 = (c2 - h2);
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },


    extractIntersectingPlanes : function extractIntersectingPlanesFn(extents, planes)
    {
        var n0 = extents[0];
        var n1 = extents[1];
        var n2 = extents[2];
        var p0 = extents[3];
        var p1 = extents[4];
        var p2 = extents[5];
        var numPlanes = planes.length;
        var p = [];
        var np = 0;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) < plane[3])
            {
                p[np] = plane;
                np += 1;
            }
            n += 1;
        }
        while (n < numPlanes);
        return p;
    }
};

if (typeof Float32Array !== "undefined")
{
    var testVector = new Float32Array([1, 2, 3]);

    // Clamp FLOAT_MAX
    testVector[0] = VMath.FLOAT_MAX;

    VMath.FLOAT_MAX = testVector[0];
    VMathArrayConstructor = Float32Array;
}

// If the plugin has a 'getNativeMathDevice' method then VMath should
// replace the standard MathDevice.

if (TurbulenzEngine.hasOwnProperty('VMath'))
{
    TurbulenzEngine.VMath = VMath;
}




// Copyright (c) 2009-2012 Turbulenz Limited
/*global Float32Array: false*/

//
// AABBTreeNode
//
function AABBTreeNode() {}
AABBTreeNode.prototype =
{
    version : 1,

    isLeaf : function aabbtreeNodeIsLeafFn()
    {
        return !!this.externalNode;
    },

    reset : function aabbtreeNodeResetFn(minX, minY, minZ, maxX, maxY, maxZ,
                                         escapeNodeOffset,
                                         externalNode)
    {
        this.escapeNodeOffset = escapeNodeOffset;
        this.externalNode = externalNode;
        var oldExtents = this.extents;
        oldExtents[0] = minX;
        oldExtents[1] = minY;
        oldExtents[2] = minZ;
        oldExtents[3] = maxX;
        oldExtents[4] = maxY;
        oldExtents[5] = maxZ;
    },

    clear : function aabbtreeNodeClearFn()
    {
        this.escapeNodeOffset = 1;
        this.externalNode = undefined;
        var oldExtents = this.extents;
        var maxNumber = Number.MAX_VALUE;
        oldExtents[0] = maxNumber;
        oldExtents[1] = maxNumber;
        oldExtents[2] = maxNumber;
        oldExtents[3] = -maxNumber;
        oldExtents[4] = -maxNumber;
        oldExtents[5] = -maxNumber;
    }
};

// Constructor function
AABBTreeNode.create = function aabbtreeNodeCreateFn(extents, escapeNodeOffset, externalNode)
{
    var n = new AABBTreeNode();
    n.escapeNodeOffset = escapeNodeOffset;
    n.externalNode = externalNode;
    n.extents = extents;
    return n;
};


//
// AABBTree
//
function AABBTree() {}
AABBTree.prototype =
{
    version : 1,
    numNodesLeaf : 4,

    add : function addFn(externalNode, extents)
    {
        var endNode = this.endNode;
        externalNode.aabbTreeIndex = endNode;
        var copyExtents = new this.arrayConstructor(6);
        copyExtents[0] = extents[0];
        copyExtents[1] = extents[1];
        copyExtents[2] = extents[2];
        copyExtents[3] = extents[3];
        copyExtents[4] = extents[4];
        copyExtents[5] = extents[5];
        this.nodes[endNode] = AABBTreeNode.create(copyExtents, 1, externalNode);
        this.endNode = (endNode + 1);
        this.needsRebuild = true;
        this.numAdds += 1;
        this.numExternalNodes += 1;
    },

    remove : function removeFn(externalNode)
    {
        var index = externalNode.aabbTreeIndex;
        if (index !== undefined)
        {
            if (this.numExternalNodes > 1)
            {
                var nodes = this.nodes;

                nodes[index].clear();

                var endNode = this.endNode;
                if ((index + 1) >= endNode)
                {
                    while (!nodes[endNode - 1].externalNode) // No leaf
                    {
                        endNode -= 1;
                    }
                    this.endNode = endNode;
                }
                else
                {
                    this.needsRebuild = true;
                }
                this.numExternalNodes -= 1;
            }
            else
            {
                this.clear();
            }

            delete externalNode.aabbTreeIndex;
        }
    },

    findParent : function findParentFn(nodeIndex)
    {
        var nodes = this.nodes;
        var parentIndex = nodeIndex;
        var nodeDist = 0;
        var parent;
        do
        {
            parentIndex -= 1;
            nodeDist += 1;
            parent = nodes[parentIndex];
        }
        while (parent.escapeNodeOffset <= nodeDist);
        return parent;
    },

    update : function aabbTreeUpdateFn(externalNode, extents)
    {
        var index = externalNode.aabbTreeIndex;
        if (index !== undefined)
        {
            var min0 = extents[0];
            var min1 = extents[1];
            var min2 = extents[2];
            var max0 = extents[3];
            var max1 = extents[4];
            var max2 = extents[5];

            var needsRebuild = this.needsRebuild;
            var needsRebound = this.needsRebound;
            var nodes = this.nodes;
            var node = nodes[index];
            var nodeExtents = node.extents;

            var doUpdate = (needsRebuild ||
                            needsRebound ||
                            nodeExtents[0] > min0 ||
                            nodeExtents[1] > min1 ||
                            nodeExtents[2] > min2 ||
                            nodeExtents[3] < max0 ||
                            nodeExtents[4] < max1 ||
                            nodeExtents[5] < max2);

            nodeExtents[0] = min0;
            nodeExtents[1] = min1;
            nodeExtents[2] = min2;
            nodeExtents[3] = max0;
            nodeExtents[4] = max1;
            nodeExtents[5] = max2;

            if (doUpdate)
            {
                if (!needsRebuild && 1 < nodes.length)
                {
                    this.numUpdates += 1;
                    if (this.startUpdate > index)
                    {
                        this.startUpdate = index;
                    }
                    if (this.endUpdate < index)
                    {
                        this.endUpdate = index;
                    }
                    if (!needsRebound)
                    {
                        // force a rebound when things change too much
                        if ((2 * this.numUpdates) > this.numExternalNodes)
                        {
                            this.needsRebound = true;
                        }
                        else
                        {
                            var parent = this.findParent(index);
                            var parentExtents = parent.extents;
                            if (parentExtents[0] > min0 ||
                                parentExtents[1] > min1 ||
                                parentExtents[2] > min2 ||
                                parentExtents[3] < max0 ||
                                parentExtents[4] < max1 ||
                                parentExtents[5] < max2)
                            {
                                this.needsRebound = true;
                            }
                        }
                    }
                    else
                    {
                        // force a rebuild when things change too much
                        if (this.numUpdates > (3 * this.numExternalNodes))
                        {
                            this.needsRebuild = true;
                            this.numAdds = this.numUpdates;
                        }
                    }
                }
            }
        }
        else
        {
            this.add(externalNode, extents);
        }
    },

    needsFinalize : function needsFinalizeFn()
    {
        return (this.needsRebuild || this.needsRebound);
    },

    finalize : function finalizeFn()
    {
        if (this.needsRebuild)
        {
            this.rebuild();
        }
        else if (this.needsRebound)
        {
            this.rebound();
        }
    },

    rebound : function reboundFn()
    {
        var nodes = this.nodes;
        if (nodes.length > 1)
        {
            var startUpdateNodeIndex = this.startUpdate;
            var endUpdateNodeIndex   = this.endUpdate;

            var nodesStack = [];
            var numNodesStack = 0;
            var topNodeIndex = 0;
            for (;;)
            {
                var topNode = nodes[topNodeIndex];
                var currentNodeIndex = topNodeIndex;
                var currentEscapeNodeIndex = (topNodeIndex + topNode.escapeNodeOffset);
                var nodeIndex = (topNodeIndex + 1); // First child
                var node;
                do
                {
                    node = nodes[nodeIndex];
                    var escapeNodeIndex = (nodeIndex + node.escapeNodeOffset);
                    if (nodeIndex < endUpdateNodeIndex)
                    {
                        if (!node.externalNode) // No leaf
                        {
                            if (escapeNodeIndex > startUpdateNodeIndex)
                            {
                                nodesStack[numNodesStack] = topNodeIndex;
                                numNodesStack += 1;
                                topNodeIndex = nodeIndex;
                            }
                        }
                    }
                    else
                    {
                        break;
                    }
                    nodeIndex = escapeNodeIndex;
                }
                while (nodeIndex < currentEscapeNodeIndex);

                if (topNodeIndex === currentNodeIndex)
                {
                    nodeIndex = (topNodeIndex + 1); // First child
                    node = nodes[nodeIndex];

                    var extents = node.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var minZ = extents[2];
                    var maxX = extents[3];
                    var maxY = extents[4];
                    var maxZ = extents[5];

                    nodeIndex = (nodeIndex + node.escapeNodeOffset);
                    while (nodeIndex < currentEscapeNodeIndex)
                    {
                        node = nodes[nodeIndex];
                        extents = node.extents;
                        /*jshint white: false*/
                        if (minX > extents[0]) { minX = extents[0]; }
                        if (minY > extents[1]) { minY = extents[1]; }
                        if (minZ > extents[2]) { minZ = extents[2]; }
                        if (maxX < extents[3]) { maxX = extents[3]; }
                        if (maxY < extents[4]) { maxY = extents[4]; }
                        if (maxZ < extents[5]) { maxZ = extents[5]; }
                        /*jshint white: true*/
                        nodeIndex = (nodeIndex + node.escapeNodeOffset);
                    }

                    extents = topNode.extents;
                    extents[0] = minX;
                    extents[1] = minY;
                    extents[2] = minZ;
                    extents[3] = maxX;
                    extents[4] = maxY;
                    extents[5] = maxZ;

                    endUpdateNodeIndex = topNodeIndex;

                    if (0 < numNodesStack)
                    {
                        numNodesStack -= 1;
                        topNodeIndex = nodesStack[numNodesStack];
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        //this.numUpdates = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    },

    rebuild : function rebuildFn()
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;

            var buildNodes, numBuildNodes, endNodeIndex;

            if (this.numExternalNodes === nodes.length)
            {
                buildNodes = nodes;
                numBuildNodes = nodes.length;
                nodes = [];
                this.nodes = nodes;
            }
            else
            {
                buildNodes = [];
                buildNodes.length = this.numExternalNodes;
                numBuildNodes = 0;
                endNodeIndex = this.endNode;
                for (var n = 0; n < endNodeIndex; n += 1)
                {
                    var currentNode = nodes[n];
                    if (currentNode.externalNode) // Is leaf
                    {
                        nodes[n] = undefined;
                        buildNodes[numBuildNodes] = currentNode;
                        numBuildNodes += 1;
                    }
                }
                if (buildNodes.length > numBuildNodes)
                {
                    buildNodes.length = numBuildNodes;
                }
            }

            var rootNode;
            if (numBuildNodes > 1)
            {
                if (numBuildNodes > this.numNodesLeaf &&
                    this.numAdds > 0)
                {
                    if (this.highQuality)
                    {
                        this.sortNodesHighQuality(buildNodes);
                    }
                    else if (this.ignoreY)
                    {
                        this.sortNodesNoY(buildNodes);
                    }
                    else
                    {
                        this.sortNodes(buildNodes);
                    }
                }

                this.recursiveBuild(buildNodes, 0, numBuildNodes, 0);

                endNodeIndex = nodes[0].escapeNodeOffset;
                if (nodes.length > endNodeIndex)
                {
                    nodes.length = endNodeIndex;
                }
                this.endNode = endNodeIndex;

                // Check if we should take into account the Y coordinate
                rootNode = nodes[0];
                var extents = rootNode.extents;
                var deltaX = (extents[3] - extents[0]);
                var deltaY = (extents[4] - extents[1]);
                var deltaZ = (extents[5] - extents[2]);
                this.ignoreY = ((4 * deltaY) < (deltaX <= deltaZ ? deltaX : deltaZ));
            }
            else
            {
                rootNode = buildNodes[0];
                rootNode.externalNode.aabbTreeIndex = 0;
                nodes.length = 1;
                nodes[0] = rootNode;
                this.endNode = 1;
            }
            buildNodes = null;
        }

        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        this.numUpdates = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    },

    sortNodes : function sortNodesFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[3]);
        }

        function getkeyYfn(node)
        {
            var extents = node.extents;
            return (extents[1] + extents[4]);
        }

        function getkeyZfn(node)
        {
            var extents = node.extents;
            return (extents[2] + extents[5]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[3]);
        }

        function getreversekeyYfn(node)
        {
            var extents = node.extents;
            return -(extents[1] + extents[4]);
        }

        function getreversekeyZfn(node)
        {
            var extents = node.extents;
            return -(extents[2] + extents[5]);
        }

        var nthElement = this.nthElement;
        var reverse = false;
        var axis = 0;

        function sortNodesRecursive(nodes, startIndex, endIndex)
        {
            /*jshint bitwise: false*/
            var splitNodeIndex = ((startIndex + endIndex) >> 1);
            /*jshint bitwise: true*/

            if (axis === 0)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
                }
            }
            else if (axis === 2)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn);
                }
            }
            else //if (axis === 1)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
                }
            }

            if (axis === 0)
            {
                axis = 2;
            }
            else if (axis === 2)
            {
                axis = 1;
            }
            else //if (axis === 1)
            {
                axis = 0;
            }

            reverse = !reverse;

            if ((startIndex + numNodesLeaf) < splitNodeIndex)
            {
                sortNodesRecursive(nodes, startIndex, splitNodeIndex);
            }

            if ((splitNodeIndex + numNodesLeaf) < endIndex)
            {
                sortNodesRecursive(nodes, splitNodeIndex, endIndex);
            }
        }

        sortNodesRecursive(nodes, 0, numNodes);
    },

    sortNodesNoY : function sortNodesNoYFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[3]);
        }

        function getkeyZfn(node)
        {
            var extents = node.extents;
            return (extents[2] + extents[5]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[3]);
        }

        function getreversekeyZfn(node)
        {
            var extents = node.extents;
            return -(extents[2] + extents[5]);
        }

        var nthElement = this.nthElement;
        var reverse = false;
        var axis = 0;

        function sortNodesNoYRecursive(nodes, startIndex, endIndex)
        {
            /*jshint bitwise: false*/
            var splitNodeIndex = ((startIndex + endIndex) >> 1);
            /*jshint bitwise: true*/

            if (axis === 0)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
                }
            }
            else //if (axis === 2)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn);
                }
            }

            if (axis === 0)
            {
                axis = 2;
            }
            else //if (axis === 2)
            {
                axis = 0;
            }

            reverse = !reverse;

            if ((startIndex + numNodesLeaf) < splitNodeIndex)
            {
                sortNodesNoYRecursive(nodes, startIndex, splitNodeIndex);
            }

            if ((splitNodeIndex + numNodesLeaf) < endIndex)
            {
                sortNodesNoYRecursive(nodes, splitNodeIndex, endIndex);
            }
        }

        sortNodesNoYRecursive(nodes, 0, numNodes);
    },

    sortNodesHighQuality : function sortNodesHighQualityFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[3]);
        }

        function getkeyYfn(node)
        {
            var extents = node.extents;
            return (extents[1] + extents[4]);
        }

        function getkeyZfn(node)
        {
            var extents = node.extents;
            return (extents[2] + extents[5]);
        }

        function getkeyXZfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[2] + extents[3] + extents[5]);
        }

        function getkeyZXfn(node)
        {
            var extents = node.extents;
            return (extents[0] - extents[2] + extents[3] - extents[5]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[3]);
        }

        function getreversekeyYfn(node)
        {
            var extents = node.extents;
            return -(extents[1] + extents[4]);
        }

        function getreversekeyZfn(node)
        {
            var extents = node.extents;
            return -(extents[2] + extents[5]);
        }

        function getreversekeyXZfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[2] + extents[3] + extents[5]);
        }

        function getreversekeyZXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] - extents[2] + extents[3] - extents[5]);
        }

        var nthElement = this.nthElement;
        var calculateSAH = this.calculateSAH;
        var reverse = false;

        function sortNodesHighQualityRecursive(nodes, startIndex, endIndex)
        {
            /*jshint bitwise: false*/
            var splitNodeIndex = ((startIndex + endIndex) >> 1);
            /*jshint bitwise: true*/

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
            var sahX = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
            var sahY = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn);
            var sahZ = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXZfn);
            var sahXZ = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZXfn);
            var sahZX = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            if (sahX <= sahY &&
                sahX <= sahZ &&
                sahX <= sahXZ &&
                sahX <= sahZX)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
                }
            }
            else if (sahZ <= sahY &&
                     sahZ <= sahXZ &&
                     sahZ <= sahZX)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZfn);
                }
            }
            else if (sahY <= sahXZ &&
                     sahY <= sahZX)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
                }
            }
            else if (sahXZ <= sahZX)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXZfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXZfn);
                }
            }
            else //if (sahZX <= sahXZ)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyZXfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyZXfn);
                }
            }

            reverse = !reverse;

            if ((startIndex + numNodesLeaf) < splitNodeIndex)
            {
                sortNodesHighQualityRecursive(nodes, startIndex, splitNodeIndex);
            }

            if ((splitNodeIndex + numNodesLeaf) < endIndex)
            {
                sortNodesHighQualityRecursive(nodes, splitNodeIndex, endIndex);
            }
        }

        sortNodesHighQualityRecursive(nodes, 0, numNodes);
    },

    calculateSAH : function calculateSAHFn(buildNodes, startIndex, endIndex)
    {
        var buildNode, extents, minX, minY, minZ, maxX, maxY, maxZ;

        buildNode = buildNodes[startIndex];
        extents = buildNode.extents;
        minX = extents[0];
        minY = extents[1];
        minZ = extents[2];
        maxX = extents[3];
        maxY = extents[4];
        maxZ = extents[5];

        for (var n = (startIndex + 1); n < endIndex; n += 1)
        {
            buildNode = buildNodes[n];
            extents = buildNode.extents;
            /*jshint white: false*/
            if (minX > extents[0]) { minX = extents[0]; }
            if (minY > extents[1]) { minY = extents[1]; }
            if (minZ > extents[2]) { minZ = extents[2]; }
            if (maxX < extents[3]) { maxX = extents[3]; }
            if (maxY < extents[4]) { maxY = extents[4]; }
            if (maxZ < extents[5]) { maxZ = extents[5]; }
            /*jshint white: true*/
        }

        return ((maxX - minX) + (maxY - minY) + (maxZ - minZ));
    },

    nthElement : function nthElementFn(nodes, first, nth, last, getkey)
    {
        function medianFn(a, b, c)
        {
            if (a < b)
            {
                if (b < c)
                {
                    return b;
                }
                else if (a < c)
                {
                    return c;
                }
                else
                {
                    return a;
                }
            }
            else if (a < c)
            {
                return a;
            }
            else if (b < c)
            {
                return c;
            }
            return b;
        }

        function insertionSortFn(nodes, first, last, getkey)
        {
            var sorted = (first + 1);
            while (sorted !== last)
            {
                var tempNode = nodes[sorted];
                var tempKey = getkey(tempNode);

                var next = sorted;
                var current = (sorted - 1);

                while (next !== first && tempKey < getkey(nodes[current]))
                {
                    nodes[next] = nodes[current];
                    next -= 1;
                    current -= 1;
                }

                if (next !== sorted)
                {
                    nodes[next] = tempNode;
                }

                sorted += 1;
            }
        }

        while ((last - first) > 8)
        {
            /*jshint bitwise: false*/
            var midValue = medianFn(getkey(nodes[first]),
                                    getkey(nodes[first + ((last - first) >> 1)]),
                                    getkey(nodes[last - 1]));
            /*jshint bitwise: true*/

            var firstPos = first;
            var lastPos  = last;
            var midPos;
            for (; ; firstPos += 1)
            {
                while (getkey(nodes[firstPos]) < midValue)
                {
                    firstPos += 1;
                }

                do
                {
                    lastPos -= 1;
                }
                while (midValue < getkey(nodes[lastPos]));

                if (firstPos >= lastPos)
                {
                    midPos = firstPos;
                    break;
                }
                else
                {
                    var temp = nodes[firstPos];
                    nodes[firstPos] = nodes[lastPos];
                    nodes[lastPos]  = temp;
                }
            }

            if (midPos <= nth)
            {
                first = midPos;
            }
            else
            {
                last = midPos;
            }
        }

        insertionSortFn(nodes, first, last, getkey);
    },

    recursiveBuild : function recursiveBuildFn(buildNodes, startIndex, endIndex, lastNodeIndex)
    {
        var nodes = this.nodes;
        var nodeIndex = lastNodeIndex;
        lastNodeIndex += 1;

        var minX, minY, minZ, maxX, maxY, maxZ, extents;
        var buildNode, lastNode;

        if ((startIndex + this.numNodesLeaf) >= endIndex)
        {
            buildNode = buildNodes[startIndex];
            extents = buildNode.extents;
            minX = extents[0];
            minY = extents[1];
            minZ = extents[2];
            maxX = extents[3];
            maxY = extents[4];
            maxZ = extents[5];

            buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
            nodes[lastNodeIndex] = buildNode;

            for (var n = (startIndex + 1); n < endIndex; n += 1)
            {
                buildNode = buildNodes[n];
                extents = buildNode.extents;
                /*jshint white: false*/
                if (minX > extents[0]) { minX = extents[0]; }
                if (minY > extents[1]) { minY = extents[1]; }
                if (minZ > extents[2]) { minZ = extents[2]; }
                if (maxX < extents[3]) { maxX = extents[3]; }
                if (maxY < extents[4]) { maxY = extents[4]; }
                if (maxZ < extents[5]) { maxZ = extents[5]; }
                /*jshint white: true*/
                lastNodeIndex += 1;
                buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }

            lastNode = nodes[lastNodeIndex];
        }
        else
        {
            /*jshint bitwise: false*/
            var splitPosIndex = ((startIndex + endIndex) >> 1);
            /*jshint bitwise: true*/

            if ((startIndex + 1) >= splitPosIndex)
            {
                buildNode = buildNodes[startIndex];
                buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }
            else
            {
                this.recursiveBuild(buildNodes, startIndex, splitPosIndex, lastNodeIndex);
            }

            lastNode = nodes[lastNodeIndex];
            extents = lastNode.extents;
            minX = extents[0];
            minY = extents[1];
            minZ = extents[2];
            maxX = extents[3];
            maxY = extents[4];
            maxZ = extents[5];

            lastNodeIndex = (lastNodeIndex + lastNode.escapeNodeOffset);

            if ((splitPosIndex + 1) >= endIndex)
            {
                buildNode = buildNodes[splitPosIndex];
                buildNode.externalNode.aabbTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }
            else
            {
                this.recursiveBuild(buildNodes, splitPosIndex, endIndex, lastNodeIndex);
            }

            lastNode = nodes[lastNodeIndex];
            extents = lastNode.extents;
            /*jshint white: false*/
            if (minX > extents[0]) { minX = extents[0]; }
            if (minY > extents[1]) { minY = extents[1]; }
            if (minZ > extents[2]) { minZ = extents[2]; }
            if (maxX < extents[3]) { maxX = extents[3]; }
            if (maxY < extents[4]) { maxY = extents[4]; }
            if (maxZ < extents[5]) { maxZ = extents[5]; }
            /*jshint white: true*/
        }

        var node = nodes[nodeIndex];
        if (node !== undefined)
        {
            node.reset(minX, minY, minZ, maxX, maxY, maxZ,
                       (lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex));
        }
        else
        {
            var parentExtents = new this.arrayConstructor(6);
            parentExtents[0] = minX;
            parentExtents[1] = minY;
            parentExtents[2] = minZ;
            parentExtents[3] = maxX;
            parentExtents[4] = maxY;
            parentExtents[5] = maxZ;

            nodes[nodeIndex] = AABBTreeNode.create(parentExtents,
                                                   (lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex));
        }
    },

    getVisibleNodes : function getVisibleNodesFn(planes, visibleNodes)
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var numPlanes = planes.length;
            var numVisibleNodes = visibleNodes.length;
            var node, extents, endChildren;
            var n0, n1, n2, p0, p1, p2;
            var isInside, n, plane, d0, d1, d2;
            var nodeIndex = 0;

            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                n0 = extents[0];
                n1 = extents[1];
                n2 = extents[2];
                p0 = extents[3];
                p1 = extents[4];
                p2 = extents[5];
                //isInsidePlanesAABB
                isInside = true;
                n = 0;
                do
                {
                    plane = planes[n];
                    d0 = plane[0];
                    d1 = plane[1];
                    d2 = plane[2];
                    if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < plane[3])
                    {
                        isInside = false;
                        break;
                    }
                    n += 1;
                }
                while (n < numPlanes);
                if (isInside)
                {
                    if (node.externalNode) // Is leaf
                    {
                        visibleNodes[numVisibleNodes] = node.externalNode;
                        numVisibleNodes += 1;
                        nodeIndex += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                    else
                    {
                        //isFullyInsidePlanesAABB
                        isInside = true;
                        n = 0;
                        do
                        {
                            plane = planes[n];
                            d0 = plane[0];
                            d1 = plane[1];
                            d2 = plane[2];
                            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) < plane[3])
                            {
                                isInside = false;
                                break;
                            }
                            n += 1;
                        }
                        while (n < numPlanes);
                        if (isInside)
                        {
                            endChildren = (nodeIndex + node.escapeNodeOffset);
                            nodeIndex += 1;
                            do
                            {
                                node = nodes[nodeIndex];
                                if (node.externalNode) // Is leaf
                                {
                                    visibleNodes[numVisibleNodes] = node.externalNode;
                                    numVisibleNodes += 1;
                                }
                                nodeIndex += 1;
                            }
                            while (nodeIndex < endChildren);
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                        else
                        {
                            nodeIndex += 1;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
        }
    },

    getOverlappingNodes : function getOverlappingNodesFn(queryExtents, overlappingNodes, startIndex)
    {
        if (this.numExternalNodes > 0)
        {
            var queryMinX = queryExtents[0];
            var queryMinY = queryExtents[1];
            var queryMinZ = queryExtents[2];
            var queryMaxX = queryExtents[3];
            var queryMaxY = queryExtents[4];
            var queryMaxZ = queryExtents[5];
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var node, extents, endChildren;
            var numOverlappingNodes = 0;
            var storageIndex = (startIndex === undefined) ? overlappingNodes.length : startIndex;
            var nodeIndex = 0;
            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                var minX = extents[0];
                var minY = extents[1];
                var minZ = extents[2];
                var maxX = extents[3];
                var maxY = extents[4];
                var maxZ = extents[5];
                if (queryMinX <= maxX &&
                    queryMinY <= maxY &&
                    queryMinZ <= maxZ &&
                    queryMaxX >= minX &&
                    queryMaxY >= minY &&
                    queryMaxZ >= minZ)
                {
                    if (node.externalNode) // Is leaf
                    {
                        overlappingNodes[storageIndex] = node.externalNode;
                        storageIndex += 1;
                        numOverlappingNodes += 1;
                        nodeIndex += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (queryMaxX >= maxX &&
                            queryMaxY >= maxY &&
                            queryMaxZ >= maxZ &&
                            queryMinX <= minX &&
                            queryMinY <= minY &&
                            queryMinZ <= minZ)
                        {
                            endChildren = (nodeIndex + node.escapeNodeOffset);
                            nodeIndex += 1;
                            do
                            {
                                node = nodes[nodeIndex];
                                if (node.externalNode) // Is leaf
                                {
                                    overlappingNodes[storageIndex] = node.externalNode;
                                    storageIndex += 1;
                                    numOverlappingNodes += 1;
                                }
                                nodeIndex += 1;
                            }
                            while (nodeIndex < endChildren);
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                        else
                        {
                            nodeIndex += 1;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
            return numOverlappingNodes;
        }
        else
        {
            return 0;
        }
    },

    getSphereOverlappingNodes : function getSphereOverlappingNodesFn(center, radius, overlappingNodes)
    {
        if (this.numExternalNodes > 0)
        {
            var radiusSquared = (radius * radius);
            var centerX = center[0];
            var centerY = center[1];
            var centerZ = center[2];
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var node, extents;
            var numOverlappingNodes = overlappingNodes.length;
            var nodeIndex = 0;
            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                var minX = extents[0];
                var minY = extents[1];
                var minZ = extents[2];
                var maxX = extents[3];
                var maxY = extents[4];
                var maxZ = extents[5];
                var totalDistance = 0, sideDistance;
                if (centerX < minX)
                {
                    sideDistance = (minX - centerX);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerX > maxX)
                {
                    sideDistance = (centerX - maxX);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (centerY < minY)
                {
                    sideDistance = (minY - centerY);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerY > maxY)
                {
                    sideDistance = (centerY - maxY);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (centerZ < minZ)
                {
                    sideDistance = (minZ - centerZ);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerZ > maxZ)
                {
                    sideDistance = (centerZ - maxZ);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (totalDistance <= radiusSquared)
                {
                    nodeIndex += 1;
                    if (node.externalNode) // Is leaf
                    {
                        overlappingNodes[numOverlappingNodes] = node.externalNode;
                        numOverlappingNodes += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
        }
    },

    getOverlappingPairs : function getOverlappingPairsFn(overlappingPairs, startIndex)
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var currentNode, currentExternalNode, node, extents;
            var numInsertions = 0;
            var storageIndex = (startIndex === undefined) ? overlappingPairs.length : startIndex;
            var currentNodeIndex = 0, nodeIndex;
            for (;;)
            {
                currentNode = nodes[currentNodeIndex];
                while (!currentNode.externalNode) // No leaf
                {
                    currentNodeIndex += 1;
                    currentNode = nodes[currentNodeIndex];
                }

                currentNodeIndex += 1;
                if (currentNodeIndex < endNodeIndex)
                {
                    currentExternalNode = currentNode.externalNode;
                    extents = currentNode.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var minZ = extents[2];
                    var maxX = extents[3];
                    var maxY = extents[4];
                    var maxZ = extents[5];

                    nodeIndex = currentNodeIndex;
                    for (;;)
                    {
                        node = nodes[nodeIndex];
                        extents = node.extents;
                        if (minX <= extents[3] &&
                            minY <= extents[4] &&
                            minZ <= extents[5] &&
                            maxX >= extents[0] &&
                            maxY >= extents[1] &&
                            maxZ >= extents[2])
                        {
                            nodeIndex += 1;
                            if (node.externalNode) // Is leaf
                            {
                                overlappingPairs[storageIndex] = currentExternalNode;
                                overlappingPairs[storageIndex + 1] = node.externalNode;
                                storageIndex += 2;
                                numInsertions += 2;
                                if (nodeIndex >= endNodeIndex)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            nodeIndex += node.escapeNodeOffset;
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                    }
                }
                else
                {
                    break;
                }
            }
            return numInsertions;
        }
        else
        {
            return 0;
        }
    },

    getRootNode : function getRootNodeFn()
    {
        return this.nodes[0];
    },

    getNodes : function getNodesFn()
    {
        return this.nodes;
    },

    getEndNodeIndex : function getEndNodeIndexFn()
    {
        return this.endNode;
    },

    clear : function clearFn()
    {
        this.nodes = [];
        this.endNode = 0;
        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        this.numUpdates = 0;
        this.numExternalNodes = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    }
};

AABBTree.rayTest = function aabbtreeRayTestFn(trees, ray, callback)
{
    // convert ray to parametric form
    var origin = ray.origin;
    var direction = ray.direction;

    // values used throughout calculations.
    var o0 = origin[0];
    var o1 = origin[1];
    var o2 = origin[2];
    var d0 = direction[0];
    var d1 = direction[1];
    var d2 = direction[2];
    var id0 = 1 / d0;
    var id1 = 1 / d1;
    var id2 = 1 / d2;

    // evaluate distance factor to a node's extents from ray origin, along direction
    // use this to induce an ordering on which nodes to check.
    function distanceExtents(extents, upperBound)
    {
        var min0 = extents[0];
        var min1 = extents[1];
        var min2 = extents[2];
        var max0 = extents[3];
        var max1 = extents[4];
        var max2 = extents[5];

        // treat origin internal to extents as 0 distance.
        if (min0 <= o0 && o0 <= max0 &&
            min1 <= o1 && o1 <= max1 &&
            min2 <= o2 && o2 <= max2)
        {
            return 0.0;
        }

        var tmin, tmax;
        var tymin, tymax;
        var del;
        if (d0 >= 0)
        {
            // Deal with cases where d0 == 0
            del = (min0 - o0);
            tmin = ((del === 0) ? 0 : (del * id0));
            del = (max0 - o0);
            tmax = ((del === 0) ? 0 : (del * id0));
        }
        else
        {
            tmin = ((max0 - o0) * id0);
            tmax = ((min0 - o0) * id0);
        }

        if (d1 >= 0)
        {
            // Deal with cases where d1 == 0
            del = (min1 - o1);
            tymin = ((del === 0) ? 0 : (del * id1));
            del = (max1 - o1);
            tymax = ((del === 0) ? 0 : (del * id1));
        }
        else
        {
            tymin = ((max1 - o1) * id1);
            tymax = ((min1 - o1) * id1);
        }

        if ((tmin > tymax) || (tymin > tmax))
        {
            return undefined;
        }

        if (tymin > tmin)
        {
            tmin = tymin;
        }

        if (tymax < tmax)
        {
            tmax = tymax;
        }

        var tzmin, tzmax;
        if (d2 >= 0)
        {
            // Deal with cases where d2 == 0
            del = (min2 - o2);
            tzmin = ((del === 0) ? 0 : (del * id2));
            del = (max2 - o2);
            tzmax = ((del === 0) ? 0 : (del * id2));
        }
        else
        {
            tzmin = ((max2 - o2) * id2);
            tzmax = ((min2 - o2) * id2);
        }

        if ((tmin > tzmax) || (tzmin > tmax))
        {
            return undefined;
        }

        if (tzmin > tmin)
        {
            tmin = tzmin;
        }

        if (tzmax < tmax)
        {
            tmax = tzmax;
        }

        if (tmin < 0)
        {
            tmin = tmax;
        }

        return (0 <= tmin && tmin < upperBound) ? tmin : undefined;
    }

    // we traverse both trees at once
    // keeping a priority list of nodes to check next.

    // TODO: possibly implement priority list more effeciently?
    //       binary heap probably too much overhead in typical case.
    var priorityList = [];
    //current upperBound on distance to first intersection
    //and current closest object properties
    var minimumResult = null;

    //if node is a leaf, intersect ray with shape
    // otherwise insert node into priority list.
    function processNode(tree, nodeIndex, upperBound)
    {
        var nodes = tree.getNodes();
        var node = nodes[nodeIndex];
        var distance = distanceExtents(node.extents, upperBound);
        if (distance === undefined)
        {
            return upperBound;
        }

        if (node.externalNode)
        {
            var result = callback(tree, node.externalNode, ray, distance, upperBound);
            if (result)
            {
                minimumResult = result;
                upperBound = result.factor;
            }
        }
        else
        {
            // TODO: change to binary search?
            var length = priorityList.length;
            var i;
            for (i = 0; i < length; i += 1)
            {
                var curObj = priorityList[i];
                if (distance > curObj.distance)
                {
                    break;
                }
            }

            //insert node at index i
            priorityList.splice(i - 1, 0, {
                    tree: tree,
                    nodeIndex: nodeIndex,
                    distance: distance
                });
        }

        return upperBound;
    }

    var upperBound = ray.maxFactor;

    var tree;
    var i;
    for (i = 0; i < trees.length; i += 1)
    {
        tree = trees[i];
        if (tree.endNode !== 0)
        {
            upperBound = processNode(tree, 0, upperBound);
        }
    }

    while (priorityList.length !== 0)
    {
        var nodeObj = priorityList.pop();
        // A node inserted into priority list after this one may have
        // moved the upper bound.
        if (nodeObj.distance >= upperBound)
        {
            continue;
        }

        var nodeIndex = nodeObj.nodeIndex;
        tree = nodeObj.tree;
        var nodes = tree.getNodes();

        var node = nodes[nodeIndex];
        var maxIndex = nodeIndex + node.escapeNodeOffset;

        var childIndex = nodeIndex + 1;
        do
        {
            upperBound = processNode(tree, childIndex, upperBound);
            childIndex += nodes[childIndex].escapeNodeOffset;
        }
        while (childIndex < maxIndex);
    }

    return minimumResult;
};

// Constructor function
AABBTree.create = function aabbtreeCreateFn(highQuality)
{
    var t = new AABBTree();
    t.clear();
    if (highQuality)
    {
        t.highQuality = true;
    }
    return t;
};

// Detect correct typed arrays
(function () {
    AABBTree.prototype.arrayConstructor = Array;
    if (typeof Float32Array !== "undefined")
    {
        var testArray = new Float32Array(4);
        var textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            AABBTree.prototype.arrayConstructor = Float32Array;
        }
    }
}());

// Copyright (c) 2009-2011 Turbulenz Limited

//
// Camera
//
function Camera() {}
Camera.prototype =
{
    version : 1,

    viewOffsetX : 0.0,
    viewOffsetY : 0.0,

    recipViewWindowX : 1.0 / 1.0,
    recipViewWindowY : 1.0 / 1.0,

    infinite : false,
    parallel : false,

    aspectRatio : 4.0 / 3.0,

    nearPlane : 1.0,
    farPlane  : 1000.0,

    lookAt : function lookAtFn(lookAt, up, eyePosition)
    {
        var md = this.md;
        var v3Normalize = md.v3Normalize;
        var v3Cross = md.v3Cross;
        var zaxis = md.v3Sub(eyePosition, lookAt);

        v3Normalize.call(md, zaxis, zaxis);
        var xaxis = v3Cross.call(md, v3Normalize.call(md, up, up), zaxis);
        v3Normalize.call(md, xaxis, xaxis);
        var yaxis = v3Cross.call(md, zaxis, xaxis);
        this.matrix = md.m43Build(xaxis, yaxis, zaxis, eyePosition, this.matrix);
    },

    updateProjectionMatrix : function updateProjectionMatrixFn()
    {
        var rcpvwX = this.recipViewWindowX;
        var rcpvwY = this.recipViewWindowY * this.aspectRatio;
        var shearX = rcpvwX * this.viewOffsetX;
        var shearY = rcpvwY * this.viewOffsetY;
        var far    = this.farPlane;
        var near   = this.nearPlane;

        var rcpfn;
        if (far !== near)
        {
            rcpfn = (1.0 / (far - near));
        }
        else
        {
            rcpfn = 0.0;
        }

        var z0, z1, w0, w1;
        if (this.parallel)
        {
            z0 = -2.0 * rcpfn;
            w0 = (-(far + near) * rcpfn);
            z1 = 0.0;
            w1 = 1.0;
        }
        else
        {
            if (this.infinite)
            {
                z0 = -1.0;
            }
            else
            {
                z0 = (-(far + near) * rcpfn);
                //z0 = (far * rcpfn);
            }

            w0 = -(2.0 * far * near * rcpfn);
            //w0 = (-z0 * near);

            z1 = -1.0;
            w1 = 0.0;
        }

        this.projectionMatrix = this.md.m44Build(rcpvwX,  0.0,     0.0, 0.0,
                                                 0.0,     rcpvwY,  0.0, 0.0,
                                                 -shearX, -shearY,  z0,  z1,
                                                 0.0,     0.0,      w0,  w1,
                                                 this.projectionMatrix);
    },

    updateViewMatrix : function updateViewMatrixFn()
    {
        var md = this.md;
        this.viewMatrix = md.m43InverseOrthonormal(this.matrix, this.viewMatrix);
    },

    updateViewProjectionMatrix : function updateViewProjectionMatrixFn()
    {
        var md = this.md;
        this.viewProjectionMatrix = md.m43MulM44(this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);
    },

    extractFrustumPlanes : function extractFrustumPlanesFn(m, p)
    {
        var md = this.md;
        var m0  = m[0];
        var m1  = m[1];
        var m2  = m[2];
        var m3  = m[3];
        var m4  = m[4];
        var m5  = m[5];
        var m6  = m[6];
        var m7  = m[7];
        var m8  = m[8];
        var m9  = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];
        var planes = (p || []);

        // Negate 'd' here to avoid doing it on the isVisible functions
        var vec = md.v4Build((m3  + m0), (m7  + m4), (m11 + m8), -(m15 + m12));
        planes[0] = md.planeNormalize(vec, planes[0]); // left

        md.v4Build((m3  - m0), (m7  - m4), (m11 - m8), -(m15 - m12), vec);
        planes[1] = md.planeNormalize(vec, planes[1]); // right

        md.v4Build((m3  - m1), (m7  - m5), (m11 - m9),  -(m15 - m13), vec);
        planes[2] = md.planeNormalize(vec, planes[2]); // top

        md.v4Build((m3  + m1), (m7  + m5), (m11 + m9),  -(m15 + m13), vec);
        planes[3] = md.planeNormalize(vec, planes[3]); // bottom

        md.v4Build((m3  + m2), (m7  + m6), (m11 + m10), -(m15 + m14), vec);
        planes[4] = md.planeNormalize(vec, planes[4]);  // near

        md.v4Build((m3  - m2), (m7  - m6), (m11 - m10), -(m15 - m14), vec);
        planes[5] = md.planeNormalize(vec, planes[5]); // far

        return planes;
    },

    updateFrustumPlanes : function updateFrustumPlanesFn()
    {
        this.frustumPlanes = this.extractFrustumPlanes(this.viewProjectionMatrix, this.frustumPlanes);
    },

    isVisiblePoint : function isVisiblePointFn(p)
    {
        var md = this.md;
        return md.isInsidePlanesPoint(p, this.frustumPlanes);
    },

    isVisibleSphere : function isVisibleSphereFn(c, r)
    {
        var md = this.md;
        return md.isInsidePlanesSphere(c, r, this.frustumPlanes);
    },

    isVisibleBox : function isVisibleBoxFn(c, h)
    {
        var md = this.md;
        return md.isInsidePlanesBox(c, h, this.frustumPlanes);
    },

    isVisibleAABB : function isVisibleAABBFn(extents)
    {
        var md = this.md;
        return md.aabbIsInsidePlanes(extents, this.frustumPlanes);
    },

    isFullyInsideAABB : function isFullyInsideAABBFn(extents)
    {
        var md = this.md;
        return md.aabbIsFullyInsidePlanes(extents, this.frustumPlanes);
    },

    getFrustumPoints : function getFrustumPointsFn(farPlane)
    {
        var viewOffsetX = this.viewOffsetX;
        var viewOffsetY = this.viewOffsetY;

        var viewWindowX = 1.0 / this.recipViewWindowX;
        var viewWindowY = 1.0 / (this.recipViewWindowY * this.aspectRatio);

        var transform = this.matrix;

        var farClip  = farPlane || this.farPlane;
        var nearClip = this.nearPlane;

        var frustumPoints = [];

        if (!this.parallel)
        {
            var co0 = ((transform[0] * viewOffsetX) + (transform[3] * viewOffsetY));
            var co1 = ((transform[1] * viewOffsetX) + (transform[4] * viewOffsetY));
            var co2 = ((transform[2] * viewOffsetX) + (transform[5] * viewOffsetY));

            var right0 = (transform[0] * viewWindowX);
            var right1 = (transform[1] * viewWindowX);
            var right2 = (transform[2] * viewWindowX);
            var up0    = (transform[3] * viewWindowY);
            var up1    = (transform[4] * viewWindowY);
            var up2    = (transform[5] * viewWindowY);
            var at0    = (co0 - transform[6]);
            var at1    = (co1 - transform[7]);
            var at2    = (co2 - transform[8]);
            var pos0   = (transform[9]  + co0);
            var pos1   = (transform[10] + co1);
            var pos2   = (transform[11] + co2);

            var dirTR0 = (at0 + right0 + up0);
            var dirTR1 = (at1 + right1 + up1);
            var dirTR2 = (at2 + right2 + up2);
            var dirTL0 = (at0 - right0 + up0);
            var dirTL1 = (at1 - right1 + up1);
            var dirTL2 = (at2 - right2 + up2);
            var dirBL0 = (at0 - right0 - up0);
            var dirBL1 = (at1 - right1 - up1);
            var dirBL2 = (at2 - right2 - up2);
            var dirBR0 = (at0 + right0 - up0);
            var dirBR1 = (at1 + right1 - up1);
            var dirBR2 = (at2 + right2 - up2);

            frustumPoints[0] = [(pos0 + (dirTR0 * nearClip)), (pos1 + (dirTR1 * nearClip)), (pos2 + (dirTR2 * nearClip))];
            frustumPoints[4] = [(pos0 + (dirTR0 * farClip)),  (pos1 + (dirTR1 * farClip)),  (pos2 + (dirTR2 * farClip))];
            frustumPoints[1] = [(pos0 + (dirTL0 * nearClip)), (pos1 + (dirTL1 * nearClip)), (pos2 + (dirTL2 * nearClip))];
            frustumPoints[5] = [(pos0 + (dirTL0 * farClip)),  (pos1 + (dirTL1 * farClip)),  (pos2 + (dirTL2 * farClip))];
            frustumPoints[2] = [(pos0 + (dirBL0 * nearClip)), (pos1 + (dirBL1 * nearClip)), (pos2 + (dirBL2 * nearClip))];
            frustumPoints[6] = [(pos0 + (dirBL0 * farClip)),  (pos1 + (dirBL1 * farClip)),  (pos2 + (dirBL2 * farClip))];
            frustumPoints[3] = [(pos0 + (dirBR0 * nearClip)), (pos1 + (dirBR1 * nearClip)), (pos2 + (dirBR2 * nearClip))];
            frustumPoints[7] = [(pos0 + (dirBR0 * farClip)),  (pos1 + (dirBR1 * farClip)),  (pos2 + (dirBR2 * farClip))];
        }
        else
        {
            frustumPoints[0] = [];
            frustumPoints[4] = [];
            frustumPoints[1] = [];
            frustumPoints[5] = [];
            frustumPoints[2] = [];
            frustumPoints[6] = [];
            frustumPoints[3] = [];
            frustumPoints[7] = [];

            frustumPoints[0][2] = nearClip;
            frustumPoints[1][2] = nearClip;
            frustumPoints[2][2] = nearClip;
            frustumPoints[3][2] = nearClip;

            frustumPoints[4][2] = farClip;
            frustumPoints[5][2] = farClip;
            frustumPoints[6][2] = farClip;
            frustumPoints[7][2] = farClip;

            var offset = (1.0 - nearClip) * viewOffsetX;
            frustumPoints[0][0] = (viewWindowX + offset);
            frustumPoints[1][0] = (offset - viewWindowX);
            frustumPoints[2][0] = (offset - viewWindowX);
            frustumPoints[3][0] = (viewWindowX + offset);

            offset = (1.0 - farClip) * viewOffsetX;
            frustumPoints[4][0] = (viewWindowX + offset);
            frustumPoints[5][0] = (offset - viewWindowX);
            frustumPoints[6][0] = (offset - viewWindowX);
            frustumPoints[7][0] = (viewWindowX + offset);

            offset = (1.0 - nearClip) * viewOffsetY;
            frustumPoints[0][1] = (viewWindowY + offset);
            frustumPoints[1][1] = (viewWindowY + offset);
            frustumPoints[2][1] = (offset - viewWindowY);
            frustumPoints[3][1] = (offset - viewWindowY);

            offset = (1.0 - farClip) * viewOffsetY;
            frustumPoints[4][1] = (viewWindowY + offset);
            frustumPoints[5][1] = (viewWindowY + offset);
            frustumPoints[6][1] = (offset - viewWindowY);
            frustumPoints[7][1] = (offset - viewWindowY);

            var md = this.md;
            frustumPoints[0] = md.m43TransformPoint(transform, frustumPoints[0]);
            frustumPoints[1] = md.m43TransformPoint(transform, frustumPoints[1]);
            frustumPoints[2] = md.m43TransformPoint(transform, frustumPoints[2]);
            frustumPoints[3] = md.m43TransformPoint(transform, frustumPoints[3]);
            frustumPoints[4] = md.m43TransformPoint(transform, frustumPoints[4]);
            frustumPoints[5] = md.m43TransformPoint(transform, frustumPoints[5]);
            frustumPoints[6] = md.m43TransformPoint(transform, frustumPoints[6]);
            frustumPoints[7] = md.m43TransformPoint(transform, frustumPoints[7]);
        }

        return frustumPoints;
    },

    getFrustumFarPoints : function getFrustumFarPointsFn()
    {
        var viewOffsetX = this.viewOffsetX;
        var viewOffsetY = this.viewOffsetY;
        var viewWindowX = 1.0 / this.recipViewWindowX;
        var viewWindowY = 1.0 / (this.recipViewWindowY * this.aspectRatio);
        var transform   = this.matrix;
        var farClip     = this.farPlane;

        var frustumPoints;

        if (!this.parallel)
        {
            var t0  = transform[0];
            var t1  = transform[1];
            var t2  = transform[2];
            var t3  = transform[3];
            var t4  = transform[4];
            var t5  = transform[5];
            var t6  = transform[6];
            var t7  = transform[7];
            var t8  = transform[8];
            var t9  = transform[9];
            var t10 = transform[10];
            var t11 = transform[11];

            var co0 = ((t0 * viewOffsetX) + (t3 * viewOffsetY));
            var co1 = ((t1 * viewOffsetX) + (t4 * viewOffsetY));
            var co2 = ((t2 * viewOffsetX) + (t5 * viewOffsetY));

            var right0 = (t0  * viewWindowX);
            var right1 = (t1  * viewWindowX);
            var right2 = (t2  * viewWindowX);
            var up0    = (t3  * viewWindowY);
            var up1    = (t4  * viewWindowY);
            var up2    = (t5  * viewWindowY);
            var at0    = (co0 - t6);
            var at1    = (co1 - t7);
            var at2    = (co2 - t8);
            var pos0   = (t9  + co0);
            var pos1   = (t10 + co1);
            var pos2   = (t11 + co2);

            var dirTR0 = ((at0 + right0 + up0) * farClip);
            var dirTR1 = ((at1 + right1 + up1) * farClip);
            var dirTR2 = ((at2 + right2 + up2) * farClip);
            var dirTL0 = ((at0 - right0 + up0) * farClip);
            var dirTL1 = ((at1 - right1 + up1) * farClip);
            var dirTL2 = ((at2 - right2 + up2) * farClip);
            var dirBL0 = ((at0 - right0 - up0) * farClip);
            var dirBL1 = ((at1 - right1 - up1) * farClip);
            var dirBL2 = ((at2 - right2 - up2) * farClip);
            var dirBR0 = ((at0 + right0 - up0) * farClip);
            var dirBR1 = ((at1 + right1 - up1) * farClip);
            var dirBR2 = ((at2 + right2 - up2) * farClip);

            frustumPoints = [ [(pos0 + dirTR0), (pos1 + dirTR1), (pos2 + dirTR2)],
                              [(pos0 + dirTL0), (pos1 + dirTL1), (pos2 + dirTL2)],
                              [(pos0 + dirBL0), (pos1 + dirBL1), (pos2 + dirBL2)],
                              [(pos0 + dirBR0), (pos1 + dirBR1), (pos2 + dirBR2)] ];
        }
        else
        {
            var offsetX = (1.0 - farClip) * viewOffsetX;
            var offsetY = (1.0 - farClip) * viewOffsetY;
            var md = this.md;
            frustumPoints = [ md.m43TransformPoint(transform, [(viewWindowX + offsetX), (viewWindowY + offsetY), farClip]),
                              md.m43TransformPoint(transform, [(offsetX - viewWindowX), (viewWindowY + offsetY), farClip]),
                              md.m43TransformPoint(transform, [(offsetX - viewWindowX), (offsetY - viewWindowY), farClip]),
                              md.m43TransformPoint(transform, [(viewWindowX + offsetX), (offsetY - viewWindowY), farClip]) ];
        }

        return frustumPoints;
    },

    getFrustumExtents : function getFrustumExtentsFn(extents, farClip)
    {
        var frustumPoints = this.getFrustumPoints(farClip);
        var frustumPoint = frustumPoints[0];
        var min0 = frustumPoint[0];
        var min1 = frustumPoint[1];
        var min2 = frustumPoint[2];
        var max0 = min0;
        var max1 = min1;
        var max2 = min2;
        for (var i = 1; i < 8; i += 1)
        {
            frustumPoint = frustumPoints[i];
            var p0 = frustumPoint[0];
            var p1 = frustumPoint[1];
            var p2 = frustumPoint[2];
            if (min0 > p0)
            {
                min0 = p0;
            }
            else if (max0 < p0)
            {
                max0 = p0;
            }
            if (min1 > p1)
            {
                min1 = p1;
            }
            else if (max1 < p1)
            {
                max1 = p1;
            }
            if (min2 > p2)
            {
                min2 = p2;
            }
            else if (max2 < p2)
            {
                max2 = p2;
            }
        }
        extents[0] = min0;
        extents[1] = min1;
        extents[2] = min2;
        extents[3] = max0;
        extents[4] = max1;
        extents[5] = max2;
    }
};

// Constructor function
Camera.create = function cameraCreateFn(md)
{
    var c = new Camera();
    c.md = md;
    c.matrix = md.m43BuildIdentity();
    c.viewMatrix = md.m43BuildIdentity();
    c.updateProjectionMatrix();
    c.viewProjectionMatrix = c.projectionMatrix.slice();
    c.frustumPlanes = [];
    c.updateFrustumPlanes();
    return c;
};

//
// CameraController
//
function CameraController() {}
CameraController.prototype =
{
    version : 1,

    rotateSpeed       : 2.0,
    maxSpeed          : 1,
    mouseRotateFactor : 0.1,

    rotate : function rotateFn(turn, pitch)
    {
        var degreestoradians = (Math.PI / 180.0);
        var md = this.md;
        var matrix = this.camera.matrix;
        var pos = md.m43Pos(matrix);
        md.m43SetPos(matrix, md.v3BuildZero());

        var rotate;
        if (pitch !== 0.0)
        {
            pitch *= this.rotateSpeed * degreestoradians;
            pitch *= this.mouseRotateFactor;

            var right = md.v3Normalize(md.m43Right(matrix));
            md.m43SetRight(matrix, right);

            rotate = md.m43FromAxisRotation(right, pitch);

            matrix = md.m43Mul(matrix, rotate);
        }

        if (turn !== 0.0)
        {
            turn *= this.rotateSpeed * degreestoradians;
            turn *= this.mouseRotateFactor;

            rotate = md.m43FromAxisRotation(md.v3BuildYAxis(), turn);

            matrix = md.m43Mul(matrix, rotate);
        }

        md.m43SetPos(matrix, pos);

        this.camera.matrix = matrix;
    },

    translate : function translateFn(right, up, forward)
    {
        var md = this.md;
        var matrix = this.camera.matrix;
        var pos = md.m43Pos(matrix);
        var speed = this.maxSpeed;
        pos = md.v3Add4(pos,
                        md.v3ScalarMul(md.m43Right(matrix), (speed * right)),
                        md.v3ScalarMul(md.m43Up(matrix),    (speed * up)),
                        md.v3ScalarMul(md.m43At(matrix),   -(speed * forward)));
        md.m43SetPos(matrix, pos);
    },

    update : function cameraControllerUpdateFn()
    {
        var updateMatrix = false;

        if (this.turn !== 0.0 ||
            this.pitch !== 0.0)
        {
            updateMatrix = true;

            this.rotate(this.turn, this.pitch);

            this.turn = 0.0;
            this.pitch = 0.0;
        }

        if (this.step > 0)
        {
            this.forward += this.step;
        }
        else if (this.step < 0)
        {
            this.backward -= this.step;
        }

        var right = ((this.right + this.padright) - (this.left + this.padleft));
        var up = this.up - this.down;
        var forward = ((this.forward + this.padforward) - (this.backward + this.padbackward));
        if (right !== 0.0 ||
            up !== 0.0 ||
            forward !== 0.0)
        {
            updateMatrix = true;

            this.translate(right, up, forward);

            if (this.step > 0)
            {
                this.forward -= this.step;
                this.step = 0.0;
            }
            else if (this.step < 0)
            {
                this.backward += this.step;
                this.step = 0.0;
            }
        }

        if (updateMatrix)
        {
            this.camera.updateViewMatrix();
        }
    }
};

// Constructor function
CameraController.create = function cameraControllerCreateFn(gd, id, camera, log)
{
    var c = new CameraController();

    c.md = camera.md;
    c.camera = camera;
    c.turn = 0.0;
    c.pitch = 0.0;
    c.right = 0.0;
    c.left = 0.0;
    c.up = 0.0;
    c.down = 0.0;
    c.forward = 0.0;
    c.backward = 0.0;
    c.step = 0.0;
    c.padright = 0.0;
    c.padleft = 0.0;
    c.padforward = 0.0;
    c.padbackward = 0.0;
    c.looktouch = {
        id: -1,
        originX: 0,
        originY: 0
    };
    c.movetouch = {
        id: -1,
        originX: 0,
        originY: 0
    };

    var keyCodes;

    if (id)
    {
        keyCodes = id.keyCodes;
    }

    // keyboard handling
    function onkeydownFn(keynum)
    {
        switch (keynum)
        {
        case keyCodes.A:
        case keyCodes.LEFT:
        case keyCodes.NUMPAD_4:
            c.left = 1.0;
            break;

        case keyCodes.D:
        case keyCodes.RIGHT:
        case keyCodes.NUMPAD_6:
            c.right = 1.0;
            break;

        case keyCodes.W:
        case keyCodes.UP:
        case keyCodes.NUMPAD_8:
            c.forward = 1.0;
            break;

        case keyCodes.S:
        case keyCodes.DOWN:
        case keyCodes.NUMPAD_2:
            c.backward = 1.0;
            break;

        case keyCodes.E:
        case keyCodes.NUMPAD_9:
            c.up = 1.0;
            break;

        case keyCodes.Q:
        case keyCodes.NUMPAD_7:
            c.down = 1.0;
            break;
        }
    }

    function onkeyupFn(keynum)
    {
        switch (keynum)
        {
        case keyCodes.A:
        case keyCodes.LEFT:
        case keyCodes.NUMPAD_4:
            c.left = 0.0;
            break;

        case keyCodes.D:
        case keyCodes.RIGHT:
        case keyCodes.NUMPAD_6:
            c.right = 0.0;
            break;

        case keyCodes.W:
        case keyCodes.UP:
        case keyCodes.NUMPAD_8:
            c.forward = 0.0;
            break;

        case keyCodes.S:
        case keyCodes.DOWN:
        case keyCodes.NUMPAD_2:
            c.backward = 0.0;
            break;

        case keyCodes.E:
        case keyCodes.NUMPAD_9:
            c.up = 0.0;
            break;

        case keyCodes.Q:
        case keyCodes.NUMPAD_7:
            c.down = 0.0;
            break;

        case keyCodes.RETURN:
            gd.fullscreen = !gd.fullscreen;
            break;
        }
    }

    if (log)
    {
        c.onkeydown = function onkeydownLogFn(keynum)
        {
            log.innerHTML += " KeyDown:&nbsp;" + keynum;
            onkeydownFn(keynum);
        };

        c.onkeyup = function onkeyupLogFn(keynum)
        {
            if (keynum === keyCodes.BACKSPACE)
            {
                log.innerHTML = "";
            }
            else
            {
                log.innerHTML += " KeyUp:&nbsp;" + keynum;
            }
            onkeyupFn(keynum);
        };
    }
    else
    {
        c.onkeydown = onkeydownFn;
        c.onkeyup = onkeyupFn;
    }

    // Mouse handling
    c.onmouseup = function onmouseupFn(button, x, y)
    {
        if (!id.isLocked())
        {
            id.lockMouse();
        }
    };

    c.onmousewheel = function onmousewheelFn(delta)
    {
        c.step = delta * 5;
    };

    c.onmousemove = function onmousemoveFn(deltaX, deltaY)
    {
        c.turn  += deltaX;
        c.pitch += deltaY;
    };

    // Pad handling
    c.onpadmove = function onpadmoveFn(lX, lY, lZ, rX, rY, rZ, dpadState)
    {
        c.turn  += lX * 10.0;
        c.pitch += lY * 10.0;

        if (rX >= 0)
        {
            c.padright = rX;
            c.padleft  = 0;
        }
        else
        {
            c.padright = 0;
            c.padleft  = -rX;
        }

        if (rY >= 0)
        {
            c.padforward  = rY;
            c.padbackward = 0.0;
        }
        else
        {
            c.padforward  = 0.0;
            c.padbackward = -rY;
        }
    };

    c.onmouselocklost = function onmouselocklostFn()
    {
        id.unlockMouse();
    };

    c.ontouchstart = function ontouchstartFn(touchEvent)
    {
        var changedTouches = touchEvent.changedTouches;
        var numTouches = changedTouches.length;
        var t;
        var halfScreenWidth = gd.width * 0.5;
        for (t = 0; t < numTouches; t += 1)
        {
            var touchId = changedTouches[t].identifier;
            var touchX = changedTouches[t].positionX;
            var touchY = changedTouches[t].positionY;
            if (touchX < halfScreenWidth &&
                c.looktouch.id === -1)
            {
                c.looktouch.id = touchId;
                c.looktouch.originX = touchX;
                c.looktouch.originY = touchY;
            }
            else if (touchX >= halfScreenWidth &&
                     c.movetouch.id === -1)
            {
                c.movetouch.id = touchId;
                c.movetouch.originX = touchX;
                c.movetouch.originY = touchY;
            }
        }
    };

    c.ontouchend = function ontouchendFn(touchEvent)
    {
        var changedTouches = touchEvent.changedTouches;
        var numTouches = changedTouches.length;
        var t;
        for (t = 0; t < numTouches; t += 1)
        {
            var touchId = changedTouches[t].identifier;
            if (c.looktouch.id === touchId)
            {
                c.looktouch.id = -1;
                c.looktouch.originX = 0;
                c.looktouch.originY = 0;
                c.turn = 0;
                c.pitch = 0;
            }
            else if (c.movetouch.id === touchId)
            {
                c.movetouch.id = -1;
                c.movetouch.originX = 0;
                c.movetouch.originY = 0;
                c.left = 0.0;
                c.right = 0.0;
                c.forward = 0.0;
                c.backward = 0.0;
            }
        }
    };

    c.ontouchmove = function ontouchmoveFn(touchEvent)
    {
        var changedTouches = touchEvent.changedTouches;
        var numTouches = changedTouches.length;
        var deadzone = 16.0;
        var t;
        for (t = 0; t < numTouches; t += 1)
        {
            var touchId = changedTouches[t].identifier;
            var touchX = changedTouches[t].positionX;
            var touchY = changedTouches[t].positionY;
            if (c.looktouch.id === touchId)
            {
                if (touchX - c.looktouch.originX > deadzone ||
                    touchX - c.looktouch.originX < -deadzone)
                {
                    c.turn = (touchX - c.looktouch.originX) / deadzone;
                }
                else
                {
                    c.turn = 0.0;
                }
                if (touchY - c.looktouch.originY > deadzone ||
                    touchY - c.looktouch.originY < -deadzone)
                {
                    c.pitch = (touchY - c.looktouch.originY) / 16.0;
                }
                else
                {
                    c.pitch = 0.0;
                }
            }
            else if (c.movetouch.id === touchId)
            {
                if (touchX - c.movetouch.originX > deadzone)
                {
                    c.left = 0.0;
                    c.right = 1.0;
                }
                else if (touchX - c.movetouch.originX < -deadzone)
                {
                    c.left = 1.0;
                    c.right = 0.0;
                }
                else
                {
                    c.left = 0.0;
                    c.right = 0.0;
                }
                if (touchY - c.movetouch.originY > deadzone)
                {
                    c.forward = 0.0;
                    c.backward = 1.0;
                }
                else if (touchY - c.movetouch.originY < -deadzone)
                {
                    c.forward = 1.0;
                    c.backward = 0.0;
                }
                else
                {
                    c.forward = 0.0;
                    c.backward = 0.0;
                }
            }
        }
    };

    // Attach to an InputDevice
    c.attach = function attachFn(id)
    {
        id.addEventListener('keydown', c.onkeydown);
        id.addEventListener('keyup', c.onkeyup);
        id.addEventListener('mouseup', c.onmouseup);
        id.addEventListener('mousewheel', c.onmousewheel);
        id.addEventListener('mousemove', c.onmousemove);
        id.addEventListener('padmove', c.onpadmove);
        id.addEventListener('mouselocklost', c.onmouselocklost);
        id.addEventListener('touchstart', c.ontouchstart);
        id.addEventListener('touchend', c.ontouchend);
        id.addEventListener('touchmove', c.ontouchmove);
    };

    if (id)
    {
        c.attach(id);
    }

    return c;
};

// Copyright (c) 2010-2012 Turbulenz Limited

/*global TurbulenzEngine: false*/
/*global Reference: false*/

//
// Geometry
//
function Geometry() {}
Geometry.prototype =
{
    version: 1,

    //
    // destroy
    //
    destroy: function geometryDestroyFn()
    {
        if (this.vertexBufferAllocation)
        {
            this.vertexBufferManager.free(this.vertexBufferAllocation);
            delete this.vertexBufferManager;
            delete this.vertexBufferAllocation;
        }
        if (this.indexBufferAllocation)
        {
            this.indexBufferManager.free(this.indexBufferAllocation);
            delete this.indexBufferManager;
            delete this.indexBufferAllocation;
        }
        delete this.vertexBuffer;
        delete this.indexBuffer;
        delete this.vertexData;
        delete this.indexData;
        delete this.semantics;
        delete this.first;
        delete this.halfExtents;
        delete this.reference;
        delete this.surfaces;
    }
};

//
// Geometry Constructor
//
Geometry.create = function geometryCreateFn()
{
    var geometry = new Geometry();
    geometry.reference = Reference.create(geometry);
    geometry.surfaces = {};
    geometry.type = "rigid";
    return geometry;
};

//
// Geometry Instance
//
function GeometryInstance() {}

GeometryInstance.prototype =
{
    version: 1,

    maxUpdateValue: Number.MAX_VALUE,

    //
    // clone
    //
    clone: function geometryInstanceCloneFn()
    {
        var newInstance = GeometryInstance.create(this.geometry,
                                                  this.surface,
                                                  this.sharedMaterial);

        if (this.disabled)
        {
            newInstance.disabled = true;
        }

        return newInstance;
    },

    //
    // isSkinned
    //
    isSkinned : function geometryInstanceIsSkinnedFn()
    {
        if (this.geometry.skeleton)
        {
            return true;
        }
        return false;
    },

    //
    // setNode
    //
    setNode : function geometryInstanceSetNodeFn(node)
    {
        if (this.node)
        {
            if (this.hasCustomWorldExtents())
            {
                this.node.renderableWorldExtentsRemoved();
            }
        }

        this.node = node;

        if (this.node)
        {
            if (this.hasCustomWorldExtents())
            {
                this.node.renderableWorldExtentsUpdated(false);
            }
        }
        this.worldExtentsUpdate = -1;
    },

    //
    // getNode
    //
    getNode : function geometryInstanceGetNodeFn()
    {
        return this.node;
    },

    //
    // setMaterial
    //
    setMaterial : function geometryInstanceSetMaterialFn(material)
    {
        material.reference.add();
        this.sharedMaterial.reference.remove();

        this.sharedMaterial = material;

        this.rendererInfo = undefined;
    },

    //
    // getMaterial
    //
    getMaterial : function geometryInstanceGetMaterialFn()
    {
        return this.sharedMaterial;
    },

    //
    // getWorldExtents
    //
    getWorldExtents: function geometryInstanceGetWorldExtentsFn()
    {
        //Note: This method is only valid on a clean node.
        var worldExtents = this.worldExtents;
        var node = this.node;
        if (node.worldUpdate > this.worldExtentsUpdate)
        {
            this.worldExtentsUpdate = node.worldUpdate;

            var center = this.center;
            var halfExtents = this.halfExtents;

            var world = node.world;
            var m0 = world[0];
            var m1 = world[1];
            var m2 = world[2];
            var m3 = world[3];
            var m4 = world[4];
            var m5 = world[5];
            var m6 = world[6];
            var m7 = world[7];
            var m8 = world[8];

            var ct0 = world[9];
            var ct1 = world[10];
            var ct2 = world[11];
            if (center)
            {
                var c0 = center[0];
                var c1 = center[1];
                var c2 = center[2];
                ct0 += (m0 * c0 + m3 * c1 + m6 * c2);
                ct1 += (m1 * c0 + m4 * c1 + m7 * c2);
                ct2 += (m2 * c0 + m5 * c1 + m8 * c2);
            }

            var h0 = halfExtents[0];
            var h1 = halfExtents[1];
            var h2 = halfExtents[2];
            var ht0 = ((m0 < 0 ? -m0 : m0) * h0 + (m3 < 0 ? -m3 : m3) * h1 + (m6 < 0 ? -m6 : m6) * h2);
            var ht1 = ((m1 < 0 ? -m1 : m1) * h0 + (m4 < 0 ? -m4 : m4) * h1 + (m7 < 0 ? -m7 : m7) * h2);
            var ht2 = ((m2 < 0 ? -m2 : m2) * h0 + (m5 < 0 ? -m5 : m5) * h1 + (m8 < 0 ? -m8 : m8) * h2);

            worldExtents[0] = (ct0 - ht0);
            worldExtents[1] = (ct1 - ht1);
            worldExtents[2] = (ct2 - ht2);
            worldExtents[3] = (ct0 + ht0);
            worldExtents[4] = (ct1 + ht1);
            worldExtents[5] = (ct2 + ht2);
        }
        return worldExtents;
    },

    //
    // addCustomWorldExtents
    //
    addCustomWorldExtents: function geometryInstanceAddCustomWorldExtentsFn(customWorldExtents)
    {
        var worldExtents = this.worldExtents;
        worldExtents[0] = customWorldExtents[0];
        worldExtents[1] = customWorldExtents[1];
        worldExtents[2] = customWorldExtents[2];
        worldExtents[3] = customWorldExtents[3];
        worldExtents[4] = customWorldExtents[4];
        worldExtents[5] = customWorldExtents[5];
        var alreadyHadCustomExtents = (this.worldExtentsUpdate === this.maxUpdateValue);
        this.worldExtentsUpdate = this.maxUpdateValue;
        this.node.renderableWorldExtentsUpdated(alreadyHadCustomExtents);
    },

    //
    // removeCustomWorldExtents
    //
    removeCustomWorldExtents: function geometryInstanceRemoveCustomWorldExtentsFn()
    {
        this.worldExtentsUpdate = -1;
        this.node.renderableWorldExtentsRemoved();
    },

    //
    // getCustomWorldExtents
    //
    getCustomWorldExtents: function geometryInstanceGetCustomWorldExtentsFn()
    {
        if (this.worldExtentsUpdate === this.maxUpdateValue)
        {
            return this.worldExtents;
        }
        return undefined;
    },

    //
    // hasCustomWorldExtents
    //
    hasCustomWorldExtents: function geometryInstanceHasCustomWorldExtentsFn()
    {
        return this.worldExtentsUpdate === this.maxUpdateValue;
    },

    //
    // destroy
    //
    destroy: function geometryInstanceDestroyFn()
    {
        if (this.geometry.reference)
        {
            this.geometry.reference.remove();
        }

        if (this.sharedMaterial.reference)
        {
            this.sharedMaterial.reference.remove();
        }

        delete this.surface;
        delete this.geometry;
        delete this.sharedMaterial;
        delete this.techniqueParameters;
        delete this.halfExtents;
        delete this.center;
        delete this.worldExtentsUpdate;
        delete this.drawParameters;
        delete this.renderInfo;
        delete this.sorting;
    },

    //
    // prepareDrawParameters
    //
    prepareDrawParameters: function geometryInstancePrepareFn(drawParameters)
    {
        var surface = this.surface;
        var geometry = this.geometry;
        drawParameters.setVertexBuffer(0, geometry.vertexBuffer);
        drawParameters.setSemantics(0, this.semantics);

        drawParameters.primitive = surface.primitive;

        drawParameters.firstIndex = surface.first;

        if (surface.indexBuffer)
        {
            drawParameters.indexBuffer = surface.indexBuffer;
            drawParameters.count = surface.numIndices;
        }
        else
        {
            drawParameters.count = surface.numVertices;
        }
    }
};

//
// Constructor function
//
GeometryInstance.create = function geometryInstanceCreateFn(geometry,
                                                            surface,
                                                            sharedMaterial)
{
    var instance = new GeometryInstance();
    var graphicsDevice = TurbulenzEngine.getGraphicsDevice(); //Maybe null when running on the server.

    instance.geometry = geometry;
    instance.geometry.reference.add();
    instance.geometryType = geometry.type;
    instance.surface = surface;
    instance.semantics = geometry.semantics;

    instance.halfExtents = geometry.halfExtents;
    instance.center = geometry.center;

    instance.techniqueParameters = graphicsDevice ? graphicsDevice.createTechniqueParameters(): null;
    instance.sharedMaterial = sharedMaterial;
    if (instance.sharedMaterial)
    {
        instance.sharedMaterial.reference.add();
    }
    instance.worldExtents = new instance.arrayConstructor(6);
    instance.worldExtentsUpdate = -1;
    instance.worldUpdate = -1;

    instance.node = undefined;
    instance.rendererInfo = undefined;

    return instance;
};

// Detect correct typed arrays
(function () {
    GeometryInstance.prototype.arrayConstructor = Array;
    if (typeof Float32Array !== "undefined")
    {
        var testArray = new Float32Array(4);
        var textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            GeometryInstance.prototype.arrayConstructor = Float32Array;
        }
    }
}());

// Copyright (c) 2010-2012 Turbulenz Limited

/*global Reference: false */

//
// Material
//
function Material() {}
Material.prototype =
{
    version: 1,

    //
    // getName
    //
    getName: function materialGetNameFn()
    {
        return this.name;
    },

    //
    // setName
    //
    setName: function materialSetNameFn(name)
    {
        this.name = name;
    },

    //
    // loadTextures
    //
    loadTextures: function materialLoadTexturesFn(textureManager)
    {
        var materialTextureNames = this.texturesNames;
        for (var p in materialTextureNames)
        {
            if (materialTextureNames.hasOwnProperty(p))
            {
                var textureName = materialTextureNames[p];
                textureManager.load(textureName);
                this.setTextureInstance(p, textureManager.getInstance(textureName));
            }
        }
    },

    //
    // setTextureInstance
    //
    setTextureInstance: function materialSetTextureInstanceFn(propertryName, textureInstance)
    {
        if (!this.textureInstances)
        {
            this.textureInstances = {};
        }
        var oldInstance = this.textureInstances[propertryName];
        if (oldInstance !== textureInstance)
        {
            if (oldInstance && oldInstance.unsubscribeTextureChanged)
            {
                oldInstance.unsubscribeTextureChanged(this.onTextureChanged);
            }
            this.textureInstances[propertryName] = textureInstance;
            this.techniqueParameters[propertryName] = textureInstance.texture;
            textureInstance.subscribeTextureChanged(this.onTextureChanged);
            textureInstance.reference.add();
        }
    },

    //
    // destroy
    //
    destroy: function materialDestroyFn()
    {
        delete this.techniqueParameters;

        var textureInstance;
        var textureInstances = this.textureInstances;
        for (var p in textureInstances)
        {
            if (textureInstances.hasOwnProperty(p))
            {
                textureInstance = textureInstances[p];
                textureInstance.unsubscribeTextureChanged(this.onTextureChanged);
                textureInstance.reference.remove();
            }
        }
        delete this.textureInstances;
        delete this.textureNames;
    }
};

//
// Material Constructor
//
Material.create = function materialCreateFn(graphicsDevice)
{
    var newMaterial = new Material();
    newMaterial.reference = Reference.create(newMaterial);
    newMaterial.techniqueParameters = graphicsDevice.createTechniqueParameters();
    newMaterial.meta = {};

    newMaterial.onTextureChanged = function materialOnTextureChangedFn(textureInstance)
    {
        var textureInstanceTexture = textureInstance.texture;
        var material = newMaterial;
        var materialTechniqueParameters = material.techniqueParameters;
        var materialTextureInstances = material.textureInstances;

        for (var p in materialTextureInstances)
        {
            if (materialTextureInstances.hasOwnProperty(p))
            {
                if (materialTextureInstances[p] === textureInstance)
                {
                    materialTechniqueParameters[p] = textureInstanceTexture;
                }
            }
        }
    };

    return newMaterial;
};

// Copyright (c) 2010-2012 Turbulenz Limited
/*global TurbulenzEngine: false */

//
// Light
//
function Light() {}

Light.prototype =
{
    version: 1,

    //
    // clone
    //
    clone : function lightCloneFn()
    {
        var clone = new Light();

        clone.name = this.name;
        clone.spot = this.spot;
        clone.ambient = this.ambient;
        clone.point = this.point;
        clone.fog = this.fog;
        clone.global = this.global;
        clone.directional = this.directional;
        clone.color = (this.color && this.color.slice());
        clone.direction = (this.direction && this.direction.slice());
        clone.origin = (this.origin && this.origin.slice());
        clone.frustum = (this.frustum && this.frustum.slice());
        clone.frustumNear = this.frustumNear;
        clone.center = (this.center && this.center.slice());
        clone.halfExtents = (this.halfExtents && this.halfExtents.slice());
        clone.radius = this.radius;
        clone.shadows = this.shadows;
        clone.dynamicshadows = this.dynamicshadows;
        clone.disabled = this.disabled;
        clone.techniqueParameters = this.techniqueParameters;

        return clone;
    },

    //
    // isGlobal
    //
    isGlobal : function lightIsGlobalFn()
    {
        return this.global;
    }
};

//
// Light create
//
Light.create = function lightCreateFn(params)
{
    var light = new Light();

    var mathDevice = TurbulenzEngine.getMathDevice();
    var v3Build = mathDevice.v3Build;

    var abs = Math.abs;
    var max = Math.max;

    if (params.name)
    {
        light.name = params.name;
    }

    light.color = params.color && params.color.length ? params.color :  mathDevice.v3BuildOne();

    if (params.directional)
    {
        light.directional = true;
    }
    else if (params.spot)
    {
        light.spot = true;
    }
    else if (params.ambient)
    {
        light.ambient = true;
    }
    else
    {
        light.point = true;
    }

    light.origin = params.origin;

    var target = params.target;
    if (target || light.spot)
    {
        if (!target)
        {
            target = v3Build.call(mathDevice, 0, 0, -(params.radius || 1));
        }

        var right = params.right || mathDevice.v3BuildXAxis();
        var up = params.up || mathDevice.v3BuildYAxis();
        var end = params.end || target;

        light.frustum = mathDevice.m33Build(right, up, end);
        var d0 = (abs(right[0]) + abs(up[0]));
        var d1 = (abs(right[1]) + abs(up[1]));
        var d2 = (abs(right[2]) + abs(up[2]));
        var e0 = end[0];
        var e1 = end[1];
        var e2 = end[2];
        var c0, c1, c2;
        var start = params.start;
        if (start)
        {
            target = mathDevice.v3Normalize(target);
            light.frustumNear = (mathDevice.v3Dot(target, start) / mathDevice.v3Dot(target, end));
            c0 = ((e0 + start[0]) * 0.5);
            c1 = ((e1 + start[1]) * 0.5);
            c2 = ((e2 + start[2]) * 0.5);
        }
        else
        {
            light.frustumNear = 0;
            c0 = (e0 * 0.5);
            c1 = (e1 * 0.5);
            c2 = (e2 * 0.5);
        }
        light.center = mathDevice.v3Build(c0, c1, c2);
        light.halfExtents = mathDevice.v3Build(max(abs(e0 - d0 - c0), abs(e0 + d0 - c0)),
                                               max(abs(e1 - d1 - c1), abs(e1 + d1 - c1)),
                                               max(abs(e2 - d2 - c2), abs(e2 + d2 - c2)));
    }
    else
    {
        var halfExtents = params.halfExtents;
        if (halfExtents)
        {
            light.halfExtents = (halfExtents.length && halfExtents) || mathDevice.v3BuildZero();
        }
        else
        {
            var radius = params.radius;
            if (radius)
            {
                light.radius = radius;
                light.halfExtents = mathDevice.v3ScalarBuild(radius);
            }
        }
    }

    light.direction = params.direction;

    if (params.shadows || params.dynamicshadows)
    {
        light.shadows = true;

        if (params.dynamicshadows)
        {
            light.dynamicshadows = true;
        }
    }

    if (params.disabled)
    {
        light.disabled = true;
    }

    var material = params.material;
    if (material)
    {
        var techniqueParameters = material.techniqueParameters;

        light.techniqueParameters = techniqueParameters;

        var metaMaterial = material.meta;
        if (metaMaterial)
        {
            var ambient = metaMaterial.ambient;
            if (ambient)
            {
                light.ambient = true;
            }

            var fog = metaMaterial.fog;
            if (fog)
            {
                light.fog = true;
            }
        }
    }

    if (!light.halfExtents &&
        !light.radius &&
        !light.target)
    {
        light.global = true;
    }

    return light;
};


//
// Light Instance
//
function LightInstance() {}

LightInstance.prototype =
{
    version: 1,

    //
    // setMaterial
    //
    setMaterial : function lightInstanceSetMaterialFn(material)
    {
        // TODO: this is really being set on the light not the instance so
        // we either need to move the materials and meta to the instance or remove this
        // and create Scene.setLightMaterial

        this.light.sharedMaterial = material;

        var meta = material.meta;
        if (material.meta)
        {
            var ambient = meta.ambient;
            if (ambient)
            {
                this.light.ambient = true;
            }
            else
            {
                if (this.light.ambient)
                {
                    delete this.light.ambient;
                }
            }

            var fog = meta.fog;
            if (fog)
            {
                this.light.fog = true;
            }
            else
            {
                if (this.light.fog)
                {
                    delete this.light.fog;
                }
            }
        }
    },

    //
    // setNode
    //
    setNode : function lightInstanceSetNodeFn(node)
    {
        this.node = node;
        this.worldExtentsUpdate = -1;
    },

    //
    // getNode
    //
    getNode : function lightInstanceGetNodeFn(node)
    {
        return this.node;
    },

    //
    // getWorldExtents
    //
    getWorldExtents: function  lightInstanceGetWorldExtentsFn()
    {
        //Note: This method is only valid on a clean node.
        var worldExtents = this.worldExtents;
        var node = this.node;
        if (node.worldUpdate !== this.worldExtentsUpdate)
        {
            //Note: set this.worldExtentsUpdate to -1 if local extents change.
            // If we need custom extents we can set worldExtentsUpdate to some distinct value <0.
            this.worldExtentsUpdate = node.worldUpdate;

            var light = this.light;

            var world = node.world;
            var m0 = world[0];
            var m1 = world[1];
            var m2 = world[2];
            var m3 = world[3];
            var m4 = world[4];
            var m5 = world[5];
            var m6 = world[6];
            var m7 = world[7];
            var m8 = world[8];

            var ct0 = world[9];
            var ct1 = world[10];
            var ct2 = world[11];

            if (light.spot)
            {
                var minX, minY, minZ, maxX, maxY, maxZ, pX, pY, pZ;
                minX = ct0;
                minY = ct1;
                minZ = ct2;
                maxX = ct0;
                maxY = ct1;
                maxZ = ct2;

                //var transform = md.m33MulM43(light.frustum, world);
                //var p0 = md.m43TransformPoint(transform, md.v3Build(-1, -1, 1));
                //var p1 = md.m43TransformPoint(transform, md.v3Build(1, -1, 1));
                //var p2 = md.m43TransformPoint(transform, md.v3Build(-1, 1, 1));
                //var p3 = md.m43TransformPoint(transform, md.v3Build(1, 1, 1));
                var f = light.frustum;
                var f0 = f[0];
                var f1 = f[1];
                var f2 = f[2];
                var f3 = f[3];
                var f4 = f[4];
                var f5 = f[5];
                var f6 = f[6];
                var f7 = f[7];
                var f8 = f[8];

                ct0 += (m0 * f6 + m3 * f7 + m6 * f8);
                ct1 += (m1 * f6 + m4 * f7 + m7 * f8);
                ct2 += (m2 * f6 + m5 * f7 + m8 * f8);

                var abs = Math.abs;
                var d0 = (abs(m0 * f0 + m3 * f1 + m6 * f2) + abs(m0 * f3 + m3 * f4 + m6 * f5));
                var d1 = (abs(m1 * f0 + m4 * f1 + m7 * f2) + abs(m1 * f3 + m4 * f4 + m7 * f5));
                var d2 = (abs(m2 * f0 + m5 * f1 + m8 * f2) + abs(m2 * f3 + m5 * f4 + m8 * f5));
                pX = (ct0 - d0);
                pY = (ct1 - d1);
                pZ = (ct2 - d2);
                if (minX > pX)
                {
                    minX = pX;
                }
                if (minY > pY)
                {
                    minY = pY;
                }
                if (minZ > pZ)
                {
                    minZ = pZ;
                }

                pX = (ct0 + d0);
                pY = (ct1 + d1);
                pZ = (ct2 + d2);
                if (maxX < pX)
                {
                    maxX = pX;
                }
                if (maxY < pY)
                {
                    maxY = pY;
                }
                if (maxZ < pZ)
                {
                    maxZ = pZ;
                }

                worldExtents[0] = minX;
                worldExtents[1] = minY;
                worldExtents[2] = minZ;
                worldExtents[3] = maxX;
                worldExtents[4] = maxY;
                worldExtents[5] = maxZ;
            }
            else
            {
                var center = light.center;
                var halfExtents = light.halfExtents;

                if (center)
                {
                    var c0 = center[0];
                    var c1 = center[1];
                    var c2 = center[2];
                    ct0 += (m0 * c0 + m3 * c1 + m6 * c2);
                    ct1 += (m1 * c0 + m4 * c1 + m7 * c2);
                    ct2 += (m2 * c0 + m5 * c1 + m8 * c2);
                }

                var h0 = halfExtents[0];
                var h1 = halfExtents[1];
                var h2 = halfExtents[2];
                var ht0 = ((m0 < 0 ? -m0 : m0) * h0 + (m3 < 0 ? -m3 : m3) * h1 + (m6 < 0 ? -m6 : m6) * h2);
                var ht1 = ((m1 < 0 ? -m1 : m1) * h0 + (m4 < 0 ? -m4 : m4) * h1 + (m7 < 0 ? -m7 : m7) * h2);
                var ht2 = ((m2 < 0 ? -m2 : m2) * h0 + (m5 < 0 ? -m5 : m5) * h1 + (m8 < 0 ? -m8 : m8) * h2);

                worldExtents[0] = (ct0 - ht0);
                worldExtents[1] = (ct1 - ht1);
                worldExtents[2] = (ct2 - ht2);
                worldExtents[3] = (ct0 + ht0);
                worldExtents[4] = (ct1 + ht1);
                worldExtents[5] = (ct2 + ht2);
            }
        }
        return worldExtents;
    },

    //
    // clone
    //
    clone: function lightInstanceCloneFn()
    {
        var newInstance = LightInstance.create(this.light);
        return newInstance;
    }
};

//
// Constructor function
//
LightInstance.create = function lightInstanceCreateFn(light)
{
    var instance = new LightInstance();

    instance.node = undefined;
    instance.light = light;
    instance.worldExtents = new instance.arrayConstructor(6);
    instance.worldExtentsUpdate = -1;

    return instance;
};

// Detect correct typed arrays
(function () {
    LightInstance.prototype.arrayConstructor = Array;
    if (typeof Float32Array !== "undefined")
    {
        var testArray = new Float32Array(4);
        var textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            LightInstance.prototype.arrayConstructor = Float32Array;
        }
    }
}());

// Copyright (c) 2010-2012 Turbulenz Limited
/*global TurbulenzEngine: false*/
/*global Utilities: false*/
/*global Observer: false*/

//
// SceneNode
//
function SceneNode() {}

//
//SceneNode.makePath
//
SceneNode.makePath = function sceneNodeMakePathFn(parentPath, childName)
{
    return parentPath + "/" + childName;
};

//
//SceneNode.invalidSetLocalTransform
//
SceneNode.invalidSetLocalTransform = function sceneNodeInvlaidSetLocalTransformFn()
{
    Utilities.assert(false, "setLocalTransform can not be called on static nodes.");
};

SceneNode.prototype =
{
    version: 1,

    //
    //getName
    //
    getName: function sceneNodeGetNameFn()
    {
        return this.name;
    },

    //
    //getPath
    //
    getPath: function sceneNodeGetPathFn()
    {
        if (this.parent)
        {
            return SceneNode.makePath(this.parent.getPath(), this.name);
        }
        return this.name;
    },

    //
    //getParent
    //
    getParent: function sceneNodeGetParentFn()
    {
        return this.parent;
    },

    //
    //setParentHelper
    //
    setParentHelper: function sceneNodeHelperSetParentFn(parent)
    {
        //***Only valid to call from addChild()/removeChild() ***
        this.parent = parent;
        this.notifiedParent = false;
        this.dirtyWorld = false;
        this.setDirtyWorldTransform();
    },

    //
    //addChild
    //
    addChild: function sceneNodeAddChildFn(child)
    {
        if (child.parent)
        {
            child.parent.removeChild(child);
        }
        else
        {
            //Child was a root node
            if (child.scene)
            {
                child.scene.removeRootNode(child);
            }
        }

        if (!this.children)
        {
            this.children = [];
            this.childNeedsUpdateCount = 0;
        }
        this.children.push(child);
        child.setParentHelper(this);

        if (this.dynamic && !child.dynamic)
        {
            child.setDynamic();
        }
    },

    //
    //removeChild
    //
    removeChild: function sceneNodeRemoveChildFn(child)
    {
        var children = this.children;
        if (children)
        {
            if (child.notifiedParent)
            {
                this.childUpdated();
            }
            var numChildren = children.length;
            for (var n = 0; n < numChildren; n += 1)
            {
                if (children[n] === child)
                {
                    var root = this.getRoot();
                    if (root.scene)
                    {
                        child.removedFromScene(root.scene);   //Maybe decouple with an event.
                    }
                    children.splice(n, 1);
                    child.setParentHelper(null);
                    return;
                }
            }
        }
        Utilities.assert(false, "Invalid child");
    },

    //
    //findChild
    //
    findChild: function sceneNodeFindChildFn(name)
    {
        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var childIndex = 0; childIndex < numChildren; childIndex += 1)
            {
                if (children[childIndex].name === name)
                {
                    return children[childIndex];
                }
            }
        }
        return undefined;
    },

    //
    // clone
    //
    clone: function sceneNodeCloneFn(newNodeName)
    {
        var newNode = SceneNode.create({name: newNodeName || this.name,
                                              local: this.local,
                                              dynamic: this.dynamic,
                                              disabled: this.disabled});

        // Clone renderables
        var renderables = this.renderables;
        if (renderables)
        {
            var numRenderables = renderables.length;

            for (var i = 0; i < numRenderables; i += 1)
            {
                var renderable = renderables[i];
                newNode.addRenderable(renderable.clone());
            }
        }

        // Clone lights
        var lights = this.lights;
        if (lights)
        {
            var numLights = lights.length;
            for (var l = 0; l < numLights; l += 1)
            {
                var light = lights[l];
                newNode.addLightInstance(light.clone());
            }
        }

        if (this.clonedObserver)
        {
            this.clonedObserver.notify({oldNode: this,
                                        newNode: newNode});
        }

        var childNodes = this.children;
        if (childNodes)
        {
            var numChildren = childNodes.length;
            for (var c = 0; c < numChildren; c += 1)
            {
                newNode.addChild(childNodes[c].clone());
            }
        }

        return newNode;
    },

    //
    //getRoot
    //
    getRoot: function sceneNodeGetRootFn()
    {
        var result = this;
        while (result.parent)
        {
            result = result.parent;
        }
        return result;
    },

    //
    // isInScene
    //
    isInScene: function sceneNodeIsInSceneFn()
    {
        if (this.getRoot().scene)
        {
            return true;
        }
        return false;
    },

    //
    //removedFromScene
    //
    removedFromScene: function sceneNodeRemovedFromSceneFn(scene)
    {
        //private function

        if (this.aabbTreeIndex !== undefined)
        {
            if (this.dynamic)
            {
                scene.dynamicSpatialMap.remove(this);
            }
            else
            {
                scene.staticSpatialMap.remove(this);
                scene.staticNodesChangeCounter += 1;
            }
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var childIndex = 0; childIndex < numChildren; childIndex += 1)
            {
                children[childIndex].removedFromScene(scene);
            }
        }
    },

    //
    //setLocalTransform
    //
    setLocalTransform: function sceneNodeSetLocalTransformFn(matrix)
    {
        if (matrix !== this.local)
        {
            this.local = this.mathDevice.m43Copy(matrix, this.local);
        }

        //inlined non-recursive setDirtyWorldTransform()
        function setDirtyWorldTransformHelperFn(nodes)
        {
            var numRemainingNodes = nodes.length;
            var node, index, child;
            do
            {
                numRemainingNodes -= 1;
                node = nodes[numRemainingNodes];

                node.dirtyWorld = true;

                if (!node.customWorldExtents && node.localExtents)
                {
                    node.dirtyWorldExtents = true;
                }

                var children = node.children;
                if (children)
                {
                    var numChildren = children.length;

                    if (!node.childNeedsUpdateCount)
                    {
                        // Common case of propagating down to clean children
                        node.childNeedsUpdateCount = numChildren;
                        for (index = 0; index < numChildren; index += 1)
                        {
                            child = children[index];
                            child.notifiedParent = true;

                            nodes[numRemainingNodes] = child;
                            numRemainingNodes += 1;
                        }
                    }
                    else
                    {
                        // One or more children dirty
                        for (index = 0; index < numChildren; index += 1)
                        {
                            child = children[index];
                            if (!child.dirtyWorld)
                            {
                                if (!child.notifiedParent)
                                {
                                    child.notifiedParent = true;
                                    node.childNeedsUpdateCount += 1;
                                }

                                nodes[numRemainingNodes] = child;
                                numRemainingNodes += 1;
                            }
                        }
                    }
                }
            }
            while (0 < numRemainingNodes);
        }

        if (!this.dirtyWorld)
        {
            //inlined updateRequired()
            var parent = this.parent;
            if (parent)
            {
                if (!this.notifiedParent)
                {
                    this.notifiedParent = true;
                    parent.childNeedsUpdate();
                }
            }
            else
            {
                //Root nodes
                var scene = this.scene;
                if (scene)
                {
                    var dirtyRoots = scene.dirtyRoots;
                    if (!dirtyRoots)
                    {
                        dirtyRoots = {};
                        scene.dirtyRoots = dirtyRoots;
                    }
                    dirtyRoots[this.name] = this;
                }
            }

            setDirtyWorldTransformHelperFn([this]);
        }
    },

    //
    //getLocalTransform
    //
    getLocalTransform: function sceneNodeSetLocalTransformFn()
    {
        return this.local;
    },

    //
    //setDirtyWorldTransform
    //
    setDirtyWorldTransform: function sceneNodeSetDirtyWorldTransformFn()
    {
        //private function
        if (this.dirtyWorld)
        {
            return;
        }

        function setDirtyWorldTransformHelperFn()
        {
            this.dirtyWorld = true;

            if (!this.customWorldExtents && this.localExtents)
            {
                this.dirtyWorldExtents = true;
            }

            var children = this.children;
            if (children)
            {
                var numChildren = children.length;
                var index;
                var child;

                if (!this.childNeedsUpdateCount)
                {
                    // Common case of propagating down to clean children
                    this.childNeedsUpdateCount = numChildren;
                    for (index = 0; index < numChildren; index += 1)
                    {
                        child = children[index];
                        child.notifiedParent = true;
                        setDirtyWorldTransformHelperFn.call(child);
                    }
                }
                else
                {
                    // One or more children dirty
                    for (index = 0; index < numChildren; index += 1)
                    {
                        child = children[index];
                        if (!child.dirtyWorld)
                        {
                            if (!child.notifiedParent)
                            {
                                child.notifiedParent = true;
                                this.childNeedsUpdateCount += 1;
                            }
                            setDirtyWorldTransformHelperFn.call(child);
                        }
                    }
                }
            }
        }

        //inlined updateRequired()
        if (this.parent)
        {
            if (!this.notifiedParent)
            {
                this.parent.childNeedsUpdate();
                this.notifiedParent = true;
            }
        }
        else
        {
            //Root nodes
            var scene = this.scene;
            if (scene)
            {
                if (!scene.dirtyRoots)
                {
                    scene.dirtyRoots = {};
                }
                scene.dirtyRoots[this.name] = this;
            }
        }

        setDirtyWorldTransformHelperFn.call(this);
    },

    //
    //getWorldTransform
    //
    getWorldTransform: function sceneNodeGetWorldTransformFn()
    {
        if (this.dirtyWorld)
        {
            this.dirtyWorld = false;
            this.worldUpdate += 1;
            this.checkUpdateRequired();

            var parent = this.parent;
            var local = this.local;
            if (parent)
            {
                var parentWorld = parent.getWorldTransform();
                if (local)
                {
                    this.world = this.mathDevice.m43Mul(local, parentWorld, this.world);
                }
                else
                {
                    this.world = this.mathDevice.m43Copy(parentWorld, this.world);
                }
            }
            else
            {
                this.world =  this.mathDevice.m43Copy(local, this.world);
            }
        }
        return this.world;
    },

    //
    //setDynamic
    //
    setDynamic: function sceneNodeSetDynamicFn()
    {
        if (!this.dynamic)
        {
            if (this.aabbTreeIndex !== undefined)
            {
                var scene = this.getRoot().scene;
                scene.staticSpatialMap.remove(this);
                scene.staticNodesChangeCounter += 1;
                delete this.aabbTreeIndex;
            }
            delete this.setLocalTransform; //Allowed to move again.

            var worldExtents = this.getWorldExtents();  //If there is any dirty state then its possible that even if it still has an aabbTreeIndex it may no longer.
            if (worldExtents)
            {
                this.getRoot().scene.dynamicSpatialMap.update(this, worldExtents);
            }
            this.dynamic = true;
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var n = 0; n < numChildren; n += 1)
            {
                children[n].setDynamic();
            }
        }
    },

    //
    //setStatic
    //
    setStatic: function sceneNodeSetStaticFn()
    {
        if (this.dynamic)
        {
            if (this.aabbTreeIndex !== undefined)
            {
                this.getRoot().scene.dynamicSpatialMap.remove(this);
                delete this.aabbTreeIndex;
            }

            this.setLocalTransform = SceneNode.invalidSetLocalTransform;

            var worldExtents = this.getWorldExtents();  //If there is any dirty state then its possible that even if it still has an aabbTreeIndex it may no longer.
            if (worldExtents)
            {
                var scene = this.getRoot().scene;
                if (scene)
                {
                    scene.staticSpatialMap.update(this, worldExtents);
                    scene.staticNodesChangeCounter += 1;
                }
            }

            delete this.dirtyWorldExtents;
            delete this.worldExtentsUpdate;
            delete this.dirtyWorld;
            delete this.notifiedParent;
            delete this.dynamic;
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var n = 0; n < numChildren; n += 1)
            {
                children[n].setStatic();
            }
        }
    },

    //
    //setDisabled
    //
    setDisabled: function sceneNodeSetDisabled(disabled)
    {
        if (disabled)
        {
            this.disabled = true;
        }
        else
        {
            delete this.disabled;
        }
    },

    //
    //getDisabled
    //
    getDisabled: function sceneNodeGetDisabled()
    {
        return this.disabled ? true : false;
    },

    //
    //enableHierarchy
    //
    enableHierarchy: function sceneNodeDisableHierarchyFn(enabled)
    {
        this.setDisabled(!enabled);

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var c = 0; c < numChildren; c += 1)
            {
                children[c].enableHierarchy(enabled);
            }
        }
    },

    //
    //childUpdated
    //
    childUpdated: function sceneNodeChildUpdatedFn()
    {
        //Private function
        //Utilities.assert(this.childNeedsUpdateCount >= 0, "Child update logic incorrect");
        this.childNeedsUpdateCount -= 1;
        if (this.childNeedsUpdateCount === 0 && this.dirtyWorld === false && this.dirtyWorldExtents === false)
        {   //no longer dirty
            if (this.parent)
            {
                this.parent.childUpdated();
                this.notifiedParent = false;
            }
        }
    },

    //
    //childNeedsUpdate
    //
    childNeedsUpdate: function sceneNodeChildNeedsUpdateFn()
    {
        //Private function
        this.updateRequired();        //propagate to the root node.
        this.childNeedsUpdateCount += 1;
    },

    //
    //updateRequired
    //
    updateRequired: function sceneNodeUpdateRequiredFn()
    {
        //Private function
        var parent = this.parent;
        if (parent)
        {
            if (!this.notifiedParent)
            {
                this.notifiedParent = true;
                parent.childNeedsUpdate();
            }
        }
        else
        {
            //Root nodes
            var scene = this.scene;
            if (scene)
            {
                var dirtyRoots = scene.dirtyRoots;
                if (!dirtyRoots)
                {
                    dirtyRoots = {};
                    scene.dirtyRoots = dirtyRoots;
                }
                dirtyRoots[this.name] = this;
            }
        }
    },

    //
    //checkUpdateRequired
    //
    checkUpdateRequired: function sceneNodeCheckUpdateRequiredFn()
    {
        //private function
        if (this.notifiedParent)
        {
            if (!this.dirtyWorldExtents &&
               !this.dirtyWorld &&
               !this.childNeedsUpdateCount)
            {
                this.parent.childUpdated();
                this.notifiedParent = false;
            }
        }
    },

    //
    //update
    //
    update: function sceneNodeUpdateFn(scene)
    {
        this.updateHelper(this.mathDevice, (scene || this.scene), [this]);
    },

    // PRIVATE
    updateHelper: function sceneNodeUpdateHelperFn(mathDevice, scene, nodes)
    {
        var node, parent, index, worldExtents;
        var numNodes = nodes.length;
        var m43Copy = mathDevice.m43Copy;
        var m43Mul = mathDevice.m43Mul;
        do
        {
            numNodes -= 1;
            node = nodes[numNodes];

            if (node.dirtyWorld)
            {
                node.dirtyWorld = false;
                node.worldUpdate += 1;

                parent = node.parent;
                if (parent)
                {
                    var local = node.local;
                    if (local)
                    {
                        node.world = m43Mul.call(mathDevice, local, parent.world, node.world);
                    }
                    else
                    {
                        node.world = m43Copy.call(mathDevice, parent.world, node.world);
                    }
                }
                else
                {
                    node.world = m43Copy.call(mathDevice, node.local, node.world);
                }
            }

            if (node.dirtyWorldExtents)
            {
                if (node.customWorldExtents)
                {
                    node.worldExtents = node.customWorldExtents;
                }
                else
                {
                    if (node.dirtyLocalExtents)
                    {
                        node.updateLocalExtents();
                    }

                    if (node.numCustomRenderableWorldExtents)
                    {
                        var renderable, extents, minX, minY, minZ, maxX, maxY, maxZ;
                        var renderables = node.renderables;
                        var numRenderables = renderables.length;
                        var empty = true;

                        for (index = 0; index < numRenderables; index += 1)
                        {
                            renderable = renderables[index];
                            extents = renderable.getCustomWorldExtents();
                            if (extents)
                            {
                                minX = extents[0];
                                minY = extents[1];
                                minZ = extents[2];
                                maxX = extents[3];
                                maxY = extents[4];
                                maxZ = extents[5];
                                index += 1;
                                empty = false;
                                break;
                            }
                        }

                        for (; index < numRenderables; index += 1)
                        {
                            renderable = renderables[index];
                            extents = renderable.getCustomWorldExtents();
                            if (extents)
                            {
                                if (minX > extents[0])
                                {
                                    minX = extents[0];
                                }
                                if (minY > extents[1])
                                {
                                    minY = extents[1];
                                }
                                if (minZ > extents[2])
                                {
                                    minZ = extents[2];
                                }

                                if (maxX < extents[3])
                                {
                                    maxX = extents[3];
                                }
                                if (maxY < extents[4])
                                {
                                    maxY = extents[4];
                                }
                                if (maxZ < extents[5])
                                {
                                    maxZ = extents[5];
                                }
                            }
                        }

                        if (empty)
                        {
                            // This should not happen...
                            delete node.worldExtents;
                        }
                        else
                        {
                            worldExtents = node.worldExtents;
                            if (!worldExtents)
                            {
                                worldExtents = new node.arrayConstructor(6);
                                node.worldExtents = worldExtents;
                            }
                            worldExtents[0] = minX;
                            worldExtents[1] = minY;
                            worldExtents[2] = minZ;
                            worldExtents[3] = maxX;
                            worldExtents[4] = maxY;
                            worldExtents[5] = maxZ;
                        }
                    }
                    else if (node.localExtents)
                    {
                        //get center and half extents
                        var localExtentsCenter = node.localExtentsCenter;
                        var localHalfExtents = node.localHalfExtents;
                        var c0 = localExtentsCenter[0];
                        var c1 = localExtentsCenter[1];
                        var c2 = localExtentsCenter[2];
                        var h0 = localHalfExtents[0];
                        var h1 = localHalfExtents[1];
                        var h2 = localHalfExtents[2];

                        var world = node.world;
                        var m0 = world[0];
                        var m1 = world[1];
                        var m2 = world[2];
                        var m3 = world[3];
                        var m4 = world[4];
                        var m5 = world[5];
                        var m6 = world[6];
                        var m7 = world[7];
                        var m8 = world[8];

                        var ct0 = world[9];
                        var ct1 = world[10];
                        var ct2 = world[11];
                        if (c0 !== 0 ||
                            c1 !== 0 ||
                            c2 !== 0)
                        {
                            ct0 += (m0 * c0 + m3 * c1 + m6 * c2);
                            ct1 += (m1 * c0 + m4 * c1 + m7 * c2);
                            ct2 += (m2 * c0 + m5 * c1 + m8 * c2);
                        }

                        var ht0 = ((m0 < 0 ? -m0 : m0) * h0 + (m3 < 0 ? -m3 : m3) * h1 + (m6 < 0 ? -m6 : m6) * h2);
                        var ht1 = ((m1 < 0 ? -m1 : m1) * h0 + (m4 < 0 ? -m4 : m4) * h1 + (m7 < 0 ? -m7 : m7) * h2);
                        var ht2 = ((m2 < 0 ? -m2 : m2) * h0 + (m5 < 0 ? -m5 : m5) * h1 + (m8 < 0 ? -m8 : m8) * h2);

                        worldExtents = node.worldExtents;
                        if (!worldExtents)
                        {
                            worldExtents = new node.arrayConstructor(6);
                            node.worldExtents = worldExtents;
                        }
                        worldExtents[0] = (ct0 - ht0);
                        worldExtents[1] = (ct1 - ht1);
                        worldExtents[2] = (ct2 - ht2);
                        worldExtents[3] = (ct0 + ht0);
                        worldExtents[4] = (ct1 + ht1);
                        worldExtents[5] = (ct2 + ht2);
                    }
                    else
                    {
                        //no object with size so no extents.
                        delete node.worldExtents;
                    }
                }

                node.dirtyWorldExtents = false;
                node.worldExtentsUpdate = true;
            }

            if (node.worldExtentsUpdate)
            {
                node.worldExtentsUpdate = false;

                worldExtents = node.worldExtents;
                if (worldExtents)
                {
                    if (node.dynamic)
                    {
                        scene.dynamicSpatialMap.update(node, worldExtents);
                    }
                    else
                    {
                        scene.staticSpatialMap.update(node, worldExtents);
                        scene.staticNodesChangeCounter += 1;
                        //Remove things that are no longer relevant.
                        node.setLocalTransform = SceneNode.invalidSetLocalTransform;  //no longer allowed to move it.
                        delete node.dirtyWorldExtents;
                        delete node.worldExtentsUpdate;
                        delete node.dirtyWorld;
                        delete node.notifiedParent;
                    }
                }
                else if (node.aabbTreeIndex !== undefined)
                {
                    if (node.dynamic)
                    {
                        scene.dynamicSpatialMap.remove(node);
                    }
                    else
                    {
                        scene.staticSpatialMap.remove(node);
                        scene.staticNodesChangeCounter += 1;
                    }
                }
            }

            if (node.childNeedsUpdateCount)
            {
                node.childNeedsUpdateCount = 0;

                var children = node.children;
                if (children)
                {
                    var numChildren = children.length;
                    for (index = 0; index < numChildren; index += 1)
                    {
                        var child = children[index];
                        if (child.notifiedParent)
                        {
                            nodes[numNodes] = child;
                            numNodes += 1;
                        }
                    }
                }
            }

            if (node.notifiedParent)
            {
                node.notifiedParent = false;
            }
        }
        while (0 < numNodes);
    },

    //
    //updateLocalExtents
    //
    updateLocalExtents: function sceneNodeUpdateLocalExtentsFn()
    {
        var localExtents, center, halfExtents;
        var hasExtents = false;
        if (this.customLocalExtents)
        {
            this.localExtents = this.customLocalExtents;
            hasExtents = true;
        }
        else
        {
            var renderables = this.renderables;
            var lights = this.lightInstances;
            if (renderables || lights)
            {
                var maxValue = Number.MAX_VALUE;
                var minValue = -maxValue;
                var min = Math.min;
                var max = Math.max;
                var h0, h1, h2, c0, c1, c2;

                var localExtents0 = maxValue;
                var localExtents1 = maxValue;
                var localExtents2 = maxValue;
                var localExtents3 = minValue;
                var localExtents4 = minValue;
                var localExtents5 = minValue;

                if (renderables)
                {
                    var numRenderables = renderables.length;
                    for (var index = 0; index < numRenderables; index += 1)
                    {
                        var renderable = renderables[index];
                        halfExtents = renderable.halfExtents;
                        if (halfExtents && !renderable.hasCustomWorldExtents())
                        {
                            h0 = halfExtents[0];
                            h1 = halfExtents[1];
                            h2 = halfExtents[2];

                            center = renderable.center;
                            if (center)
                            {
                                c0 = center[0];
                                c1 = center[1];
                                c2 = center[2];

                                localExtents0 = min(localExtents0, (c0 - h0));
                                localExtents1 = min(localExtents1, (c1 - h1));
                                localExtents2 = min(localExtents2, (c2 - h2));

                                localExtents3 = max(localExtents3, (c0 + h0));
                                localExtents4 = max(localExtents4, (c1 + h1));
                                localExtents5 = max(localExtents5, (c2 + h2));
                            }
                            else
                            {
                                localExtents0 = min(localExtents0, - h0);
                                localExtents1 = min(localExtents1, - h1);
                                localExtents2 = min(localExtents2, - h2);

                                localExtents3 = max(localExtents3, + h0);
                                localExtents4 = max(localExtents4, + h1);
                                localExtents5 = max(localExtents5, + h2);
                            }
                        }
                    }
                }

                if (lights)
                {
                    var numLights = lights.length;
                    for (var lindex = 0; lindex < numLights; lindex += 1)
                    {
                        var light = lights[lindex].light;
                        halfExtents = light.halfExtents;
                        if (halfExtents)
                        {
                            h0 = halfExtents[0];
                            h1 = halfExtents[1];
                            h2 = halfExtents[2];

                            center = light.center;
                            if (center)
                            {
                                c0 = center[0];
                                c1 = center[1];
                                c2 = center[2];

                                localExtents0 = min(localExtents0, (c0 - h0));
                                localExtents1 = min(localExtents1, (c1 - h1));
                                localExtents2 = min(localExtents2, (c2 - h2));

                                localExtents3 = max(localExtents3, (c0 + h0));
                                localExtents4 = max(localExtents4, (c1 + h1));
                                localExtents5 = max(localExtents5, (c2 + h2));
                            }
                            else
                            {
                                localExtents0 = min(localExtents0, - h0);
                                localExtents1 = min(localExtents1, - h1);
                                localExtents2 = min(localExtents2, - h2);

                                localExtents3 = max(localExtents3, + h0);
                                localExtents4 = max(localExtents4, + h1);
                                localExtents5 = max(localExtents5, + h2);
                            }
                        }
                    }
                }

                localExtents = new this.arrayConstructor(6);
                localExtents[0] = localExtents0;
                localExtents[1] = localExtents1;
                localExtents[2] = localExtents2;
                localExtents[3] = localExtents3;
                localExtents[4] = localExtents4;
                localExtents[5] = localExtents5;
                this.localExtents = localExtents;
                hasExtents = true;
            }
        }
        if (hasExtents)
        {
            localExtents = this.localExtents;

            center = (this.localExtentsCenter || new this.arrayConstructor(3));
            center[0] = (localExtents[3] + localExtents[0]) * 0.5;
            center[1] = (localExtents[4] + localExtents[1]) * 0.5;
            center[2] = (localExtents[5] + localExtents[2]) * 0.5;
            this.localExtentsCenter = center;

            halfExtents = (this.localHalfExtents || new this.arrayConstructor(3));
            halfExtents[0] = (localExtents[3] - center[0]);
            halfExtents[1] = (localExtents[4] - center[1]);
            halfExtents[2] = (localExtents[5] - center[2]);
            this.localHalfExtents = halfExtents;
        }
        else
        {
            delete this.localExtents;
            delete this.localExtentsCenter;
            delete this.localHalfExtents;
        }

        this.dirtyLocalExtents = false;
    },

    //
    //getLocalExtents
    //
    getLocalExtents: function sceneNodeGetLocalExtentsFn()
    {
        if (this.dirtyLocalExtents)
        {
            this.updateLocalExtents();
        }
        return this.localExtents; //Can be undefined if no local extents. These are not transformed by the local transform matrix.
    },

    //
    //updateWorldExtents
    //
    updateWorldExtents: function sceneNodeUpdateWorldExtentsFn()
    {
        if (this.dirtyWorldExtents)
        {
            if (this.customWorldExtents)
            {
                this.worldExtents = this.customWorldExtents;
            }
            else
            {
                if (this.dirtyLocalExtents)
                {
                    this.updateLocalExtents();
                }

                var worldExtents;

                if (this.numCustomRenderableWorldExtents)
                {
                    var index, renderable, extents, minX, minY, minZ, maxX, maxY, maxZ;
                    var renderables = this.renderables;
                    var numRenderables = renderables.length;
                    var empty = true;

                    for (index = 0; index < numRenderables; index += 1)
                    {
                        renderable = renderables[index];
                        extents = renderable.getCustomWorldExtents();
                        if (extents)
                        {
                            minX = extents[0];
                            minY = extents[1];
                            minZ = extents[2];
                            maxX = extents[3];
                            maxY = extents[4];
                            maxZ = extents[5];
                            index += 1;
                            empty = false;
                            break;
                        }
                    }

                    for (; index < numRenderables; index += 1)
                    {
                        renderable = renderables[index];
                        extents = renderable.getCustomWorldExtents();
                        if (extents)
                        {
                            if (minX > extents[0])
                            {
                                minX = extents[0];
                            }
                            if (minY > extents[1])
                            {
                                minY = extents[1];
                            }
                            if (minZ > extents[2])
                            {
                                minZ = extents[2];
                            }

                            if (maxX < extents[3])
                            {
                                maxX = extents[3];
                            }
                            if (maxY < extents[4])
                            {
                                maxY = extents[4];
                            }
                            if (maxZ < extents[5])
                            {
                                maxZ = extents[5];
                            }
                        }
                    }

                    if (empty)
                    {
                        // This should not happen...
                        delete this.worldExtents;
                    }
                    else
                    {
                        worldExtents = this.worldExtents;
                        if (!worldExtents)
                        {
                            worldExtents = new this.arrayConstructor(6);
                            this.worldExtents = worldExtents;
                        }
                        worldExtents[0] = minX;
                        worldExtents[1] = minY;
                        worldExtents[2] = minZ;
                        worldExtents[3] = maxX;
                        worldExtents[4] = maxY;
                        worldExtents[5] = maxZ;
                    }
                }
                else if (this.localExtents)
                {
                    //get center and half extents
                    var localExtentsCenter = this.localExtentsCenter;
                    var localHalfExtents = this.localHalfExtents;
                    var c0 = localExtentsCenter[0];
                    var c1 = localExtentsCenter[1];
                    var c2 = localExtentsCenter[2];
                    var h0 = localHalfExtents[0];
                    var h1 = localHalfExtents[1];
                    var h2 = localHalfExtents[2];

                    var world = this.world;
                    var m0 = world[0];
                    var m1 = world[1];
                    var m2 = world[2];
                    var m3 = world[3];
                    var m4 = world[4];
                    var m5 = world[5];
                    var m6 = world[6];
                    var m7 = world[7];
                    var m8 = world[8];

                    var ct0 = world[9];
                    var ct1 = world[10];
                    var ct2 = world[11];
                    if (c0 !== 0 ||
                        c1 !== 0 ||
                        c2 !== 0)
                    {
                        ct0 += (m0 * c0 + m3 * c1 + m6 * c2);
                        ct1 += (m1 * c0 + m4 * c1 + m7 * c2);
                        ct2 += (m2 * c0 + m5 * c1 + m8 * c2);
                    }

                    var ht0 = ((m0 < 0 ? -m0 : m0) * h0 + (m3 < 0 ? -m3 : m3) * h1 + (m6 < 0 ? -m6 : m6) * h2);
                    var ht1 = ((m1 < 0 ? -m1 : m1) * h0 + (m4 < 0 ? -m4 : m4) * h1 + (m7 < 0 ? -m7 : m7) * h2);
                    var ht2 = ((m2 < 0 ? -m2 : m2) * h0 + (m5 < 0 ? -m5 : m5) * h1 + (m8 < 0 ? -m8 : m8) * h2);

                    worldExtents = this.worldExtents;
                    if (!worldExtents)
                    {
                        worldExtents = new this.arrayConstructor(6);
                        this.worldExtents = worldExtents;
                    }
                    worldExtents[0] = (ct0 - ht0);
                    worldExtents[1] = (ct1 - ht1);
                    worldExtents[2] = (ct2 - ht2);
                    worldExtents[3] = (ct0 + ht0);
                    worldExtents[4] = (ct1 + ht1);
                    worldExtents[5] = (ct2 + ht2);
                }
                else
                {
                    //no object with size so no extents.
                    delete this.worldExtents;
                }
            }

            this.dirtyWorldExtents = false;
            this.worldExtentsUpdate = true;

            this.checkUpdateRequired();
        }
    },

    //
    //getWorldExtents
    //
    getWorldExtents: function sceneNodeGetWorldExtentsFn()
    {   //This is its own extents, not it and all its children.
        if (this.dirtyWorldExtents)
        {
            this.updateWorldExtents();
        }
        return this.worldExtents;
    },

    //
    //addCustomLocalExtents
    //
    addCustomLocalExtents: function sceneNodeAddCustomLocalExtentsFn(localExtents)
    {
        var customWorldExtents = this.customWorldExtents;
        if (!customWorldExtents)
        {
            this.customWorldExtents = localExtents.slice();
        }
        else
        {
            customWorldExtents[0] = localExtents[0];
            customWorldExtents[1] = localExtents[1];
            customWorldExtents[2] = localExtents[2];
            customWorldExtents[3] = localExtents[3];
            customWorldExtents[4] = localExtents[4];
            customWorldExtents[5] = localExtents[5];
        }
        this.dirtyWorldExtents = true;
        this.dirtyLocalExtents = true;
        this.updateRequired();
    },

    //
    //removeCustomLocalExtents
    //
    removeCustomLocalExtents: function sceneNodeRemoveCustomLocalExtentsFn()
    {
        delete this.customLocalExtents;
        this.dirtyWorldExtents = true;
        this.dirtyLocalExtents = true;
        this.updateRequired();
    },

    //
    //getCustomLocalExtents
    //
    getCustomLocalExtents: function sceneNodeGetCustomLocalExtentsFn()
    {
        return this.customLocalExtents;
    },

    //
    //addCustomWorldExtents
    //
    addCustomWorldExtents: function sceneNodeAddCustomWorldExtentsFn(worldExtents)
    {
        var customWorldExtents = this.customWorldExtents;
        if (!customWorldExtents)
        {
            this.customWorldExtents = worldExtents.slice();
        }
        else
        {
            customWorldExtents[0] = worldExtents[0];
            customWorldExtents[1] = worldExtents[1];
            customWorldExtents[2] = worldExtents[2];
            customWorldExtents[3] = worldExtents[3];
            customWorldExtents[4] = worldExtents[4];
            customWorldExtents[5] = worldExtents[5];
        }
        this.dirtyWorldExtents = true;
        this.updateRequired();
    },

    //
    //removeCustomWorldExtents
    //
    removeCustomWorldExtents: function sceneNodeRemoveCustomWorldExtentsFn()
    {
        delete this.customWorldExtents;
        this.dirtyWorldExtents = true;
        this.updateRequired();
    },

    //
    //getCustomWorldExtents
    //
    getCustomWorldExtents: function sceneNodeGetCustomWorldExtentsFn()
    {
        return this.customWorldExtents;
    },

    //
    //renderableWorldExtentsUpdated
    //
    renderableWorldExtentsUpdated: function sceneRenderableWorldExtentsUpdatedFn(wasAlreadyCustom)
    {
        if (!this.customWorldExtents)
        {
            this.dirtyWorldExtents = true;
            this.updateRequired();
        }

        if (!wasAlreadyCustom)
        {
            this.dirtyLocalExtents = true;
            this.numCustomRenderableWorldExtents = this.numCustomRenderableWorldExtents ? this.numCustomRenderableWorldExtents + 1 : 1;
        }
    },

    //
    //renderableWorldExtentsRemoved
    //
    renderableWorldExtentsRemoved: function sceneRenderableWorldExtentsRemovedFn()
    {
        if (!this.customWorldExtents)
        {
            this.dirtyWorldExtents = true;
            this.updateRequired();
        }
        this.dirtyLocalExtents = true;
        this.numCustomRenderableWorldExtents -= 1;
    },

    //
    //calculateHierarchyWorldExtents
    //
    calculateHierarchyWorldExtents: function sceneNodeCalculateHierarchyWorldExtentsFn()
    {
        function calculateNodeExtentsFn(sceneNode, totalExtents)
        {
            var valid = false;

            var worldExtents = sceneNode.getWorldExtents();
            if (worldExtents)
            {
                totalExtents[0] = (totalExtents[0] < worldExtents[0] ? totalExtents[0] : worldExtents[0]);
                totalExtents[1] = (totalExtents[1] < worldExtents[1] ? totalExtents[1] : worldExtents[1]);
                totalExtents[2] = (totalExtents[2] < worldExtents[2] ? totalExtents[2] : worldExtents[2]);
                totalExtents[3] = (totalExtents[3] > worldExtents[3] ? totalExtents[3] : worldExtents[3]);
                totalExtents[4] = (totalExtents[4] > worldExtents[4] ? totalExtents[4] : worldExtents[4]);
                totalExtents[5] = (totalExtents[5] > worldExtents[5] ? totalExtents[5] : worldExtents[5]);
                valid = true;
            }

            var children = sceneNode.children;
            if (children)
            {
                var numChildren = children.length;
                for (var n = 0; n < numChildren; n += 1)
                {
                    valid = (calculateNodeExtentsFn(children[n], totalExtents) || valid);
                }
            }

            return valid;
        }

        var maxValue = Number.MAX_VALUE;
        var totalExtents = new this.arrayConstructor(6);
        totalExtents[0] = maxValue;
        totalExtents[1] = maxValue;
        totalExtents[2] = maxValue;
        totalExtents[3] = -maxValue;
        totalExtents[4] = -maxValue;
        totalExtents[5] = -maxValue;

        if (calculateNodeExtentsFn(this, totalExtents))
        {
            return totalExtents;
        }
        else
        {
            return undefined;
        }
    },

    //
    //addRenderable
    //
    addRenderable: function sceneNodeAddRenderableFn(renderable)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.renderables)
        {
            this.renderables = [];
        }
        this.renderables.push(renderable);
        renderable.setNode(this);
        this.dirtyLocalExtents = true;
    },

    //
    //addRenderableArray
    //
    addRenderableArray: function sceneNodeAddRenderableArrayFn(additionalRenderables)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.renderables)
        {
            this.renderables = [];
        }
        var renderables = this.renderables;
        var length = additionalRenderables.length;
        for (var index = 0; index < length; index += 1)
        {
            renderables.push(additionalRenderables[index]);
            additionalRenderables[index].setNode(this);
        }
        this.dirtyLocalExtents = true;
    },

    //
    //removeRenderable
    //
    removeRenderable: function sceneNodeRemoveRenderableFn(renderable)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        var renderables = this.renderables;
        var numRenderables = renderables.length;
        for (var index = 0; index < numRenderables; index += 1)
        {
            if (renderables[index] === renderable)
            {
                renderables[index].setNode(null);
                renderables.splice(index, 1);
                this.dirtyLocalExtents = true;
                return;
            }
        }
        Utilities.assert(false, "Invalid renderable");
    },

    //
    //hasRenderables
    //
    hasRenderables: function sceneNodeHasRenderables()
    {
        return this.renderables && this.renderables.length;
    },

    //
    //addLightInstance
    //
    addLightInstance: function sceneNodeAddLightInstance(lightInstance)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.lightInstances)
        {
            this.lightInstances = [];
        }
        this.lightInstances.push(lightInstance);
        lightInstance.setNode(this);
        this.dirtyLocalExtents = true;
    },

    //
    //addLightInstanceArray
    //
    addLightInstanceArray: function sceneNodeAddLightInstanceArray(additionalLightInstances)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        if (!this.lightInstances)
        {
            this.lightInstances = [];
        }

        var lightInstances = this.lightInstances;
        var length = additionalLightInstances.length;
        for (var index = 0; index < length; index += 1)
        {
            additionalLightInstances[index].setNode(this);
            lightInstances.push(additionalLightInstances[index]);
        }

        this.dirtyLocalExtents = true;
    },

    //
    //removeLightInstance
    //
    removeLightInstance: function sceneNodeRemoveLightInstance(lightInstance)
    {
        this.dirtyWorldExtents = true;
        this.updateRequired();
        var lightInstances = this.lightInstances;
        var numLights = lightInstances.length;
        for (var index = 0; index < numLights; index += 1)
        {
            if (lightInstances[index] === lightInstance)
            {
                lightInstance.setNode(null);
                lightInstances.splice(index, 1);
                this.dirtyLocalExtents = true;
                return;
            }
        }
        Utilities.assert(false, "Invalid light");
    },

    //
    //hasLightInstances
    //
    hasLightInstances: function sceneNodeHasLightInstances()
    {
        return this.lightInstances && this.lightInstances.length;
    },

    //
    //destroy
    //
    destroy: function sceneNodeDestroy()
    {
        //Should only be called when parent is null
        Utilities.assert(!this.parent, "SceneNode should be remove from parent before destroy is called");

        if (this.destroyedObserver)
        {
            this.destroyedObserver.notify({node: this});
        }

        var children = this.children;
        if (children)
        {
            var numChildren = children.length;
            for (var childIndex = numChildren - 1;  childIndex >= 0; childIndex -= 1)
            {
                var child = children[childIndex];
                this.removeChild(child);
                child.destroy();
            }
        }

        var renderables = this.renderables;
        if (renderables)
        {
            var numRenderables = renderables.length;
            for (var renderableIndex = numRenderables - 1; renderableIndex >= 0; renderableIndex -= 1)
            {
                var renderable = renderables[renderableIndex];
                if (renderable.destroy)
                {
                    renderable.destroy();
                }
            }
            this.renderables = [];
        }

        if (this.lightInstances)
        {
            this.lightInstances = [];
        }

        delete this.scene;
    },

    //
    //subscribeCloned
    //
    subscribeCloned: function sceneNodeSubscribeClonedFn(observerFunction)
    {
        if (!this.clonedObserver)
        {
            this.clonedObserver = Observer.create();
        }
        this.clonedObserver.subscribe(observerFunction);
    },

    //
    //unsubscribeCloned
    //
    unsubscribeCloned: function sceneNodeUnsubscribeClonedFn(observerFunction)
    {
        this.clonedObserver.unsubscribe(observerFunction);
    },

    //
    //subscribeDestroyed
    //
    subscribeDestroyed: function sceneNodeSubscribeDestroyedFn(observerFunction)
    {
        if (!this.destroyedObserver)
        {
            this.destroyedObserver = Observer.create();
        }
        this.destroyedObserver.subscribe(observerFunction);
    },

    //
    //unsubscribeDestroyed
    //
    unsubscribeDestroyed: function sceneNodeDestroyedFn(observerFunction)
    {
        this.destroyedObserver.unsubscribe(observerFunction);
    }
};

//
//SceneNode.create
//
SceneNode.create = function sceneNodeCreateFn(params)
{
    var sceneNode = new SceneNode();
    sceneNode.name = params.name;

    var md = TurbulenzEngine.getMathDevice();
    sceneNode.mathDevice = md;

    if (params.dynamic)
    {
        sceneNode.dynamic = params.dynamic;
    }
    if (params.disabled)
    {
        sceneNode.disabled = params.disabled;
    }

    sceneNode.dirtyWorldExtents = true;
    sceneNode.dirtyLocalExtents = true;
    sceneNode.worldUpdate = 0; //Counter of number of times modified.

    var local = params.local;
    if (local)
    {
        sceneNode.local = md.m43Copy(local);
    }
    else
    {
        sceneNode.local = md.m43BuildIdentity();
    }
    local = sceneNode.local;
    sceneNode.world = md.m43Copy(local);

    return sceneNode;
};

// Detect correct typed arrays
(function () {
    SceneNode.prototype.arrayConstructor = Array;
    if (typeof Float32Array !== "undefined")
    {
        var testArray = new Float32Array(4);
        var textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            SceneNode.prototype.arrayConstructor = Float32Array;
        }
    }
}());

// Copyright (c) 2009-2012 Turbulenz Limited
/*global AABBTree*/
/*global Material*/
/*global SceneNode*/
/*global Geometry*/
/*global GeometryInstance*/
/*global Light*/
/*global LightInstance*/
/*global Utilities*/
/*global VertexBufferManager*/
/*global IndexBufferManager*/
/*global window*/
/*global alert*/
/*global Uint16Array*/
/*global Uint32Array*/
/*global Float32Array*/

//
// Scene
//
function Scene() {}
Scene.prototype =
{
    version: 1,

    //
    // findNode
    //
    findNode: function sceneFindNodeFn(nodePath)
    {
        //simple case of root node
        var result =  this.rootNodesMap[nodePath];
        if (result)
        {
            return result;
        }

        //else find node in turn
        var names = nodePath.split("/");
        var rootName = names[0];
        result =  this.rootNodesMap[rootName];

        for (var depth = 1; result && depth < names.length;  depth += 1)
        {
            result = result.findChild(names[depth]);
        }
        return result;
    },

    //
    // addRootNode
    //
    addRootNode: function addRootNodeFn(rootNode)
    {
        // Add the root to the top level nodes list and update the scene hierarchys
        Utilities.assert(rootNode.name, "Root nodes must be named");
        Utilities.assert(!rootNode.scene, "Root node already in a scene");
        Utilities.assert(!this.rootNodesMap[rootNode.name], "Root node with the same name exits in the scene");

        rootNode.scene = this;
        this.rootNodes.push(rootNode);
        if (!this.dirtyRoots)
        {
            this.dirtyRoots = {};
        }
        this.dirtyRoots[rootNode.name] = rootNode;
        this.rootNodesMap[rootNode.name] = rootNode;
    },

    //
    // removeRootNode
    //
    removeRootNode : function removeRootNodeFn(rootNode)
    {
        Utilities.assert(rootNode.scene === this, "Root node is not in the scene");
        rootNode.removedFromScene(this);
        var rootNodes = this.rootNodes;
        var numRootNodes = rootNodes.length;
        for (var n = 0; n < numRootNodes; n += 1)
        {
            if (rootNode === rootNodes[n])
            {
                rootNodes.splice(n, 1);
                break;
            }
        }
        if (this.dirtyRoots)
        {
            delete this.dirtyRoots[rootNode.name];
        }
        delete this.rootNodesMap[rootNode.name];
        delete rootNode.scene;
    },

    //
    // addLight
    //
    addLight: function sceneAddLightFn(light)
    {
        this.lights[light.name] = light;

        if (light.isGlobal())
        {
            this.globalLights.push(light);
        }
    },

    //
    // removeLight
    //
    removeLight: function sceneRemoveLightFn(light)
    {
        delete this.lights[light.name];

        if (light.isGlobal())
        {
            var globalLights = this.globalLights;
            var numGlobalLights = globalLights.length;
            for (var index = 0; index < numGlobalLights; index += 1)
            {
                if (light === globalLights[index])
                {
                    globalLights.splice(index, 1);
                    break;
                }
            }
        }
    },

    //
    // getLight
    //
    getLight: function sceneGetLightFn(name)
    {
        return this.lights[name];
    },

    //
    // getGlobalLights
    //
    getGlobalLights: function sceneGetGlobalLightsFn()
    {
        return this.globalLights;
    },

    //
    // calculateNumNodes
    //
    calculateNumNodes: function calculateNumNodesFn(nodes)
    {
        var numNodes = nodes.length;
        var numTotalNodes = numNodes;
        for (var n = 0; n < numNodes; n += 1)
        {
            var children = nodes[n].children;
            if (children)
            {
                numTotalNodes += calculateNumNodesFn(children);
            }
        }
        return numTotalNodes;
    },

    //
    // buildPortalPlanes
    //
    buildPortalPlanes: function buildPortalPlanesFn(points, planes, cX, cY, cZ, frustumPlanes)
    {
        var numPoints = points.length;
        var numFrustumPlanes = frustumPlanes.length;
        var numPlanes = 0;
        var n, np, nnp, p, plane, numVisiblePointsPlane;

        var culledByPlane = [];
        culledByPlane.length = numPoints;
        np = 0;
        do
        {
            culledByPlane[np] = [];
            np += 1;
        }
        while (np < numPoints);

        n = 0;
        do
        {
            plane = frustumPlanes[n];
            var pl0 = plane[0];
            var pl1 = plane[1];
            var pl2 = plane[2];
            var pl3 = plane[3];
            numVisiblePointsPlane = 0;

            np = 0;
            do
            {
                p = points[np];
                if ((pl0 * p[0] + pl1 * p[1] + pl2 * p[2]) >= pl3)
                {
                    numVisiblePointsPlane += 1;
                }
                else
                {
                    culledByPlane[np][n] = true;
                }
                np += 1;
            }
            while (np < numPoints);

            if (numVisiblePointsPlane === 0)
            {
                planes.length = 0;
                return false;
            }
            else if (numVisiblePointsPlane < numPoints)
            {
                planes[numPlanes] = plane;
                numPlanes += 1;
            }
            n += 1;
        }
        while (n < numFrustumPlanes);

        var allPointsVisible = (numPlanes === 0);

        var newPoints = [];
        newPoints.length = numPoints;
        np = 0;
        do
        {
            p = points[np];
            newPoints[np] = [(p[0] - cX), (p[1] - cY), (p[2] - cZ)];
            np += 1;
        }
        while (np < numPoints);

        var sqrt = Math.sqrt;
        np = 0;
        do
        {
            nnp = (np + 1);
            if (nnp >= numPoints)
            {
                nnp = 0;
            }

            // Skip plane if both points were culled by the same frustum plane
            var culled0 = culledByPlane[np];
            var culled1 = culledByPlane[nnp];
            var maxCulled = (culled0.length < culled1.length ? culled0.length : culled1.length);
            for (n = 0; n < maxCulled; n += 1)
            {
                if (culled0[n] && culled1[n])
                {
                    break;
                }
            }
            if (n < maxCulled)
            {
                np += 1;
                continue;
            }

            p = newPoints[np];
            var p0X = p[0];
            var p0Y = p[1];
            var p0Z = p[2];

            p = newPoints[nnp];
            var p1X = p[0];
            var p1Y = p[1];
            var p1Z = p[2];

            // n = cross(p0, p1)
            var nX = ((p0Y * p1Z) - (p0Z * p1Y));
            var nY = ((p0Z * p1X) - (p0X * p1Z));
            var nZ = ((p0X * p1Y) - (p0Y * p1X));

            // normalize(n)
            var lnsq = ((nX * nX) + (nY * nY) + (nZ * nZ));
            if (lnsq === 0)
            {
                planes.length = 0;
                return false;
            }
            var lnrcp = 1.0 / sqrt(lnsq);
            nX *= lnrcp;
            nY *= lnrcp;
            nZ *= lnrcp;

            // d = dot(n, c)
            var d = ((nX * cX) + (nY * cY) + (nZ * cZ));

            planes[numPlanes] = [nX, nY, nZ, d];
            numPlanes += 1;

            np += 1;
        }
        while (np < numPoints);

        return allPointsVisible;
    },

    //
    // findAreaIndex
    //
    findAreaIndex: function findAreaIndexFn(bspNodes, cX, cY, cZ)
    {
        var numNodes = bspNodes.length;
        var nodeIndex = 0;
        var node, plane;
        do
        {
            node = bspNodes[nodeIndex];
            plane = node.plane;
            nodeIndex = (((plane[0] * cX) + (plane[1] * cY) + (plane[2] * cZ)) < plane[3] ? node.neg : node.pos);
            if (nodeIndex <= 0)
            {
                return -(nodeIndex + 1);
            }
        }
        while (nodeIndex < numNodes);
        return -1;
    },

    //
    // findAreaIndicesAABB
    //
    findAreaIndicesAABB: function findAreaIndicesAABBFn(bspNodes, n0, n1, n2, p0, p1, p2)
    {
        var numNodes = bspNodes.length;
        var areaIndices = [];
        var visitedArea = [];
        var stack = [0];
        var numNodesStack = 1;
        var nodeIndex, node, plane, areaIndex;
        do
        {
            numNodesStack -= 1;
            nodeIndex = stack[numNodesStack];
            do
            {
                node = bspNodes[nodeIndex];
                plane = node.plane;
                var d0 = plane[0];
                var d1 = plane[1];
                var d2 = plane[2];
                var d3 = plane[3];
                if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < d3)
                {
                    nodeIndex = node.neg;
                }
                else
                {
                    if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) <= d3)
                    {
                        nodeIndex = node.neg;
                        if (nodeIndex <= 0)
                        {
                            if (nodeIndex < 0)
                            {
                                areaIndex = -(nodeIndex + 1);
                                if (!visitedArea[areaIndex])
                                {
                                    visitedArea[areaIndex] = true;
                                    areaIndices.push(areaIndex);
                                }
                            }
                        }
                        else
                        {
                            stack[numNodesStack] = nodeIndex;
                            numNodesStack += 1;
                        }
                    }
                    nodeIndex = node.pos;
                }
                if (nodeIndex <= 0)
                {
                    if (nodeIndex < 0)
                    {
                        areaIndex = -(nodeIndex + 1);
                        if (!visitedArea[areaIndex])
                        {
                            visitedArea[areaIndex] = true;
                            areaIndices.push(areaIndex);
                        }
                    }
                    break;
                }
            }
            while (nodeIndex < numNodes);
        }
        while (0 < numNodesStack);
        return areaIndices;
    },

    //
    // findVisiblePortals
    //
    findVisiblePortals: function sceneFindVisiblePortalsFn(areaIndex, cX, cY, cZ)
    {
        var buildPortalPlanes = this.buildPortalPlanes;
        var visiblePortals = this.visiblePortals;
        var oldNumVisiblePortals = visiblePortals.length;
        var frustumPlanes = this.frustumPlanes;
        var numFrustumPlanes = frustumPlanes.length;
        var queryCounter = this.getQueryCounter();
        var areas = this.areas;
        var portals, numPortals, portal, plane, area, n, portalPlanes, portalItem;
        var numVisiblePortals = 0;

        // Cull portals behind camera
        // (do NOT use nearPlane directly because areaIndex is based on the camera position)
        var nearPlane  = this.nearPlane;
        var nearPlane0 = nearPlane[0];
        var nearPlane1 = nearPlane[1];
        var nearPlane2 = nearPlane[2];
        frustumPlanes[numFrustumPlanes] = [nearPlane0, nearPlane1, nearPlane2, ((nearPlane0 * cX) + (nearPlane1 * cY) + (nearPlane2 * cZ))];

        area = areas[areaIndex];
        portals = area.portals;
        numPortals = portals.length;
        for (n = 0; n < numPortals; n += 1)
        {
            portal = portals[n];
            if (portal.disabled)
            {
                continue;
            }
            portal.queryCounter = queryCounter;
            plane = portal.plane;
            if (((plane[0] * cX) + (plane[1] * cY) + (plane[2] * cZ)) < plane[3])
            {
                if (numVisiblePortals < oldNumVisiblePortals)
                {
                    portalItem = visiblePortals[numVisiblePortals];
                    portalPlanes = portalItem.planes;
                    portalPlanes.length = 0;
                }
                else
                {
                    portalPlanes = [];
                }
                buildPortalPlanes(portal.points, portalPlanes, cX, cY, cZ, frustumPlanes);
                if (0 < portalPlanes.length)
                {
                    if (numVisiblePortals < oldNumVisiblePortals)
                    {
                        portalItem.portal = portal;
                        portalItem.area   = portal.area;
                    }
                    else
                    {
                        visiblePortals[numVisiblePortals] = {
                                portal: portal,
                                planes: portalPlanes,
                                area: portal.area
                            };
                    }
                    numVisiblePortals += 1;
                }
            }
        }

        frustumPlanes.length = numFrustumPlanes; // remove camera plane, not needed to cull nodes

        if (0 < numVisiblePortals)
        {
            var numPortalPlanes, nextArea, plane0, plane1, plane2, plane3, planes, allPointsVisible;
            var currentPortalIndex = 0;
            do
            {
                portalItem = visiblePortals[currentPortalIndex];
                currentPortalIndex += 1;
                portalPlanes = portalItem.planes;
                numPortalPlanes = portalPlanes.length;
                portal = portalItem.portal;
                areaIndex = portalItem.area;

                portalPlanes[numPortalPlanes] = portal.plane; // Add current plane to cull portals behind

                area = areas[areaIndex];
                portals = area.portals;
                numPortals = portals.length;
                for (n = 0; n < numPortals; n += 1)
                {
                    portal = portals[n];
                    nextArea = portal.area;
                    if (nextArea !== areaIndex &&
                        portal.queryCounter !== queryCounter &&
                        !portal.disabled)
                    {
                        plane = portal.plane;
                        plane0 = plane[0];
                        plane1 = plane[1];
                        plane2 = plane[2];
                        plane3 = plane[3];
                        if (((plane0 * cX) + (plane1 * cY) + (plane2 * cZ)) < plane3)
                        {
                            if (numVisiblePortals < oldNumVisiblePortals)
                            {
                                portalItem = visiblePortals[numVisiblePortals];
                                planes = portalItem.planes;
                                planes.length = 0;
                            }
                            else
                            {
                                planes = [];
                            }
                            allPointsVisible = buildPortalPlanes(portal.points, planes, cX, cY, cZ, portalPlanes);
                            if (0 < planes.length)
                            {
                                if (allPointsVisible)
                                {
                                    portal.queryCounter = queryCounter;
                                }
                                if (numVisiblePortals < oldNumVisiblePortals)
                                {
                                    portalItem.portal = portal;
                                    portalItem.area   = nextArea;
                                }
                                else
                                {
                                    visiblePortals[numVisiblePortals] = {
                                            portal: portal,
                                            planes: planes,
                                            area: nextArea
                                        };
                                }
                                numVisiblePortals += 1;
                            }
                        }
                        else
                        {
                            portal.queryCounter = queryCounter;
                        }
                    }
                }

                portalPlanes.length = numPortalPlanes; // remove current plane, not needed to cull nodes
            }
            while (currentPortalIndex < numVisiblePortals);
        }

        if (numVisiblePortals < oldNumVisiblePortals)
        {
            visiblePortals.length = numVisiblePortals;
        }
    },

    //
    // findVisibleNodes
    //
    findVisibleNodes: function sceneFindVisibleNodesFn(camera, visibleNodes)
    {
        var frustumPlanes = this.frustumPlanes;
        var useAABBTrees = true;
        var areas = this.areas;
        if (areas)
        {
            var cameraMatrix = camera.matrix;
            var cX = cameraMatrix[9];
            var cY = cameraMatrix[10];
            var cZ = cameraMatrix[11];

            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            this.cameraAreaIndex = areaIndex;

            if (areaIndex >= 0)
            {
                camera.getFrustumExtents(this.cameraExtents);
                var cameraMinExtent0 = this.cameraExtents[0];
                var cameraMinExtent1 = this.cameraExtents[1];
                var cameraMinExtent2 = this.cameraExtents[2];
                var cameraMaxExtent0 = this.cameraExtents[3];
                var cameraMaxExtent1 = this.cameraExtents[4];
                var cameraMaxExtent2 = this.cameraExtents[5];

                this.findVisiblePortals(areaIndex, cX, cY, cZ);

                var area, na, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    area = areas[na];
                    nodes = area.nodes;
                    numNodes = area.numStaticNodes;
                    if (nodes.length > numNodes)
                    {
                        nodes.length = numNodes;
                    }
                    area.addedDynamicNodes = false;
                }

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var dynamicSpatialMap = this.dynamicSpatialMap;
                var visiblePortals = this.visiblePortals;
                var numVisiblePortals = visiblePortals.length;
                var queryCounter = this.getQueryCounter();
                var numVisibleNodes = visibleNodes.length;
                var n, node, np, portalItem, portalPlanes;

                area = areas[areaIndex];
                nodes = area.nodes;
                area.addedDynamicNodes = true;

                var areaExtent = area.extents;
                var areaMinExtent0 = areaExtent[0];
                var areaMinExtent1 = areaExtent[1];
                var areaMinExtent2 = areaExtent[2];
                var areaMaxExtent0 = areaExtent[3];
                var areaMaxExtent1 = areaExtent[4];
                var areaMaxExtent2 = areaExtent[5];
                var combinedExtents = (this.float32ArrayConstructor ?
                                       new this.float32ArrayConstructor(6) :
                                       new Array(6));
                combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);

                dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    if (isInsidePlanesAABB(node.worldExtents, frustumPlanes))
                    {
                        visibleNodes[numVisibleNodes] = node;
                        numVisibleNodes += 1;
                    }
                }

                for (np = 0; np < numVisiblePortals; np += 1)
                {
                    portalItem = visiblePortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.nodes;

                    if (!area.addedDynamicNodes)
                    {
                        area.addedDynamicNodes = true;
                        areaExtent = area.extents;
                        areaMinExtent0 = areaExtent[0];
                        areaMinExtent1 = areaExtent[1];
                        areaMinExtent2 = areaExtent[2];
                        areaMaxExtent0 = areaExtent[3];
                        areaMaxExtent1 = areaExtent[4];
                        areaMaxExtent2 = areaExtent[5];
                        combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                        combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                        combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                        combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                        combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                        combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);
                        dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                            {
                                node.queryCounter = queryCounter;
                                visibleNodes[numVisibleNodes] = node;
                                numVisibleNodes += 1;
                            }
                        }
                    }
                }

                useAABBTrees = false;
            } /*
            else
            {
                Utilities.log("Camera outside areas!");
            }*/
        }

        if (useAABBTrees)
        {
            this.staticSpatialMap.getVisibleNodes(frustumPlanes, visibleNodes);

            this.dynamicSpatialMap.getVisibleNodes(frustumPlanes, visibleNodes);
        }
    },

    //
    // findVisibleNodesTree
    //
    findVisibleNodesTree: function sceneFindVisibleNodesTreeFn(tree, camera, visibleNodes)
    {
        var frustumPlanes = this.frustumPlanes;
        var useAABBTree = true;
        var areas = this.areas;
        if (areas)
        {
            // Assume scene.update has been called before this function
            var areaIndex = this.cameraAreaIndex; //this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            if (areaIndex >= 0)
            {
                //this.findVisiblePortals(areaIndex, cX, cY, cZ);

                //camera.getFrustumExtents(this.cameraExtents);
                var cameraMinExtent0 = this.cameraExtents[0];
                var cameraMinExtent1 = this.cameraExtents[1];
                var cameraMinExtent2 = this.cameraExtents[2];
                var cameraMaxExtent0 = this.cameraExtents[3];
                var cameraMaxExtent1 = this.cameraExtents[4];
                var cameraMaxExtent2 = this.cameraExtents[5];

                var externalNodesStack = this.externalNodesStack;

                var areaExtent;
                var areaMinExtent0, areaMinExtent1, areaMinExtent2;
                var areaMaxExtent0, areaMaxExtent1, areaMaxExtent2;
                var combinedExtents = (this.float32ArrayConstructor ?
                                       new this.float32ArrayConstructor(6) :
                                       new Array(6));

                var area, na, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    area = areas[na];
                    nodes = area.externalNodes;
                    if (nodes)
                    {
                        nodes.length = 0;
                        externalNodesStack.push(nodes);
                        area.externalNodes = null;
                    }
                }

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var findOverlappingAreas = this.findOverlappingAreas;
                var findAreaIndex = this.findAreaIndex;
                var visiblePortals = this.visiblePortals;
                var numVisiblePortals = visiblePortals.length;
                var queryCounter = this.getQueryCounter();
                var bspNodes = this.bspNodes;
                var numVisibleNodes = visibleNodes.length;
                var portalPlanes;
                var n, node, nodeExtents, np, portalItem;
                var cX, cY, cZ, nodeAreaIndex, overlappingAreas, numOverlappingAreas;

                area = areas[areaIndex];
                nodes = area.externalNodes;

                if (!nodes)
                {
                    if (0 < externalNodesStack.length)
                    {
                        nodes = externalNodesStack.pop();
                    }
                    else
                    {
                        nodes = [];
                    }
                    area.externalNodes = nodes;

                    areaExtent = area.extents;
                    areaMinExtent0 = areaExtent[0];
                    areaMinExtent1 = areaExtent[1];
                    areaMinExtent2 = areaExtent[2];
                    areaMaxExtent0 = areaExtent[3];
                    areaMaxExtent1 = areaExtent[4];
                    areaMaxExtent2 = areaExtent[5];
                    combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                    combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                    combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                    combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                    combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                    combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);

                    tree.getOverlappingNodes(combinedExtents, nodes);

                    // Check which ones actually belong to the area
                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        nodeExtents = node.worldExtents;
                        cX = (nodeExtents[0] + nodeExtents[3]) * 0.5;
                        cY = (nodeExtents[1] + nodeExtents[4]) * 0.5;
                        cZ = (nodeExtents[2] + nodeExtents[5]) * 0.5;
                        nodeAreaIndex = findAreaIndex(bspNodes, cX, cY, cZ);
                        if (nodeAreaIndex >= 0 &&
                            areaIndex !== nodeAreaIndex)
                        {
                            overlappingAreas = findOverlappingAreas.call(this, nodeAreaIndex, nodeExtents, true);
                            numOverlappingAreas = overlappingAreas.length;
                            for (na = 0; na < numOverlappingAreas; na += 1)
                            {
                                if (overlappingAreas[na] === area)
                                {
                                    break;
                                }
                            }
                            if (na >= numOverlappingAreas)
                            {
                                numNodes -= 1;
                                if (n < numNodes)
                                {
                                    nodes[n] = nodes[numNodes];
                                    n -= 1; // compensate for the n += 1 on the for loop
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                    nodes.length = numNodes;
                }

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    if (isInsidePlanesAABB(node.worldExtents, frustumPlanes))
                    {
                        visibleNodes[numVisibleNodes] = node;
                        numVisibleNodes += 1;
                    }
                }

                for (np = 0; np < numVisiblePortals; np += 1)
                {
                    portalItem = visiblePortals[np];
                    portalPlanes = portalItem.planes;
                    areaIndex = portalItem.area;
                    area = areas[areaIndex];
                    nodes = area.externalNodes;

                    if (!nodes)
                    {
                        if (0 < externalNodesStack.length)
                        {
                            nodes = externalNodesStack.pop();
                        }
                        else
                        {
                            nodes = [];
                        }
                        area.externalNodes = nodes;

                        areaExtent = area.extents;
                        areaMinExtent0 = areaExtent[0];
                        areaMinExtent1 = areaExtent[1];
                        areaMinExtent2 = areaExtent[2];
                        areaMaxExtent0 = areaExtent[3];
                        areaMaxExtent1 = areaExtent[4];
                        areaMaxExtent2 = areaExtent[5];
                        combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                        combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                        combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                        combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                        combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                        combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);

                        tree.getOverlappingNodes(combinedExtents, nodes);

                        // Check which ones actually belong to the area
                        numNodes = nodes.length;
                        for (n = 0; n < numNodes; n += 1)
                        {
                            node = nodes[n];
                            nodeExtents = node.worldExtents;
                            cX = (nodeExtents[0] + nodeExtents[3]) * 0.5;
                            cY = (nodeExtents[1] + nodeExtents[4]) * 0.5;
                            cZ = (nodeExtents[2] + nodeExtents[5]) * 0.5;
                            nodeAreaIndex = findAreaIndex(bspNodes, cX, cY, cZ);
                            if (nodeAreaIndex >= 0 &&
                                areaIndex !== nodeAreaIndex)
                            {
                                overlappingAreas = findOverlappingAreas.call(this, nodeAreaIndex, nodeExtents, true);
                                numOverlappingAreas = overlappingAreas.length;
                                for (na = 0; na < numOverlappingAreas; na += 1)
                                {
                                    if (overlappingAreas[na] === area)
                                    {
                                        break;
                                    }
                                }
                                if (na >= numOverlappingAreas)
                                {
                                    numNodes -= 1;
                                    if (n < numNodes)
                                    {
                                        nodes[n] = nodes[numNodes];
                                        n -= 1; // compensate for the n += 1 on the for loop
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                        nodes.length = numNodes;
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                            {
                                node.queryCounter = queryCounter;
                                visibleNodes[numVisibleNodes] = node;
                                numVisibleNodes += 1;
                            }
                        }
                    }
                }

                useAABBTree = false;
            }
        }

        if (useAABBTree)
        {
            tree.getVisibleNodes(frustumPlanes, visibleNodes);
        }
    },

    //
    // buildPortalPlanesNoFrustum
    //
    buildPortalPlanesNoFrustum: function buildPortalPlanesNoFrustum(points, cX, cY, cZ)
    {
        var numPoints = points.length;
        var planes = [];
        var numPlanes = 0;
        var newPoints = [];
        var np, p;

        newPoints.length = numPoints;
        np = 0;
        do
        {
            p = points[np];
            newPoints[np] = [(p[0] - cX), (p[1] - cY), (p[2] - cZ)];
            np += 1;
        }
        while (np < numPoints);

        var sqrt = Math.sqrt;
        np = 0;
        do
        {
            p = newPoints[np];
            var p0X = p[0];
            var p0Y = p[1];
            var p0Z = p[2];

            p = newPoints[((np + 1) < numPoints ? (np + 1) : 0)];
            var p1X = p[0];
            var p1Y = p[1];
            var p1Z = p[2];

            // n = cross(p0, p1)
            var nX = ((p0Y * p1Z) - (p0Z * p1Y));
            var nY = ((p0Z * p1X) - (p0X * p1Z));
            var nZ = ((p0X * p1Y) - (p0Y * p1X));
            var lnsq = ((nX * nX) + (nY * nY) + (nZ * nZ));
            if (lnsq === 0)
            {
                return false;
            }
            var lnrcp = 1.0 / sqrt(lnsq);
            nX *= lnrcp;
            nY *= lnrcp;
            nZ *= lnrcp;

            // d = dot(n, c)
            var d = ((nX * cX) + (nY * cY) + (nZ * cZ));

            planes[numPlanes] = [nX, nY, nZ, d];
            numPlanes += 1;

            np += 1;
        }
        while (np < numPoints);

        return planes;
    },

    //
    // findOverlappingPortals
    //
    findOverlappingPortals: function sceneFindOverlappingPortalsFn(areaIndex, cX, cY, cZ, extents, overlappingPortals)
    {
        var portals, numPortals, n, portal, plane, d0, d1, d2, offset, area, portalExtents, planes;
        var buildPortalPlanesNoFrustum = this.buildPortalPlanesNoFrustum;
        var queryCounter = this.getQueryCounter();
        var areas = this.areas;
        var numOverlappingPortals = 0;

        var min0 = extents[0];
        var min1 = extents[1];
        var min2 = extents[2];
        var max0 = extents[3];
        var max1 = extents[4];
        var max2 = extents[5];

        area = areas[areaIndex];
        portals = area.portals;
        numPortals = portals.length;
        for (n = 0; n < numPortals; n += 1)
        {
            portal = portals[n];
            if (portal.disabled)
            {
                continue;
            }

            portal.queryCounter = queryCounter;

            portalExtents = portal.extents;
            if (portalExtents[0] < max0 &&
                portalExtents[1] < max1 &&
                portalExtents[2] < max2 &&
                portalExtents[3] > min0 &&
                portalExtents[4] > min1 &&
                portalExtents[5] > min2)
            {
                plane = portal.plane;
                d0 = plane[0];
                d1 = plane[1];
                d2 = plane[2];
                offset = plane[3];
                if (((d0 * cX) + (d1 * cY) + (d2 * cZ)) < offset &&
                    (d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= offset)
                {
                    planes = buildPortalPlanesNoFrustum(portal.points, cX, cY, cZ);
                    if (planes)
                    {
                        overlappingPortals[numOverlappingPortals] = {
                                portal: portal,
                                planes: planes,
                                area: portal.area
                            };
                        numOverlappingPortals += 1;
                    }
                }
            }
        }

        if (0 < numOverlappingPortals)
        {
            var portalItem, parentPlanes, nextArea;
            var currentPortalIndex = 0;
            do
            {
                portalItem = overlappingPortals[currentPortalIndex];
                currentPortalIndex += 1;
                parentPlanes = portalItem.planes;
                areaIndex = portalItem.area;
                portal = portalItem.portal;

                area = areas[areaIndex];
                portals = area.portals;
                numPortals = portals.length;
                for (n = 0; n < numPortals; n += 1)
                {
                    portal = portals[n];
                    nextArea = portal.area;
                    if (nextArea !== areaIndex &&
                        portal.queryCounter !== queryCounter &&
                        !portal.disabled)
                    {
                        portalExtents = portal.extents;
                        if (portalExtents[0] < max0 &&
                            portalExtents[1] < max1 &&
                            portalExtents[2] < max2 &&
                            portalExtents[3] > min0 &&
                            portalExtents[4] > min1 &&
                            portalExtents[5] > min2)
                        {
                            plane = portal.plane;
                            d0 = plane[0];
                            d1 = plane[1];
                            d2 = plane[2];
                            offset = plane[3];
                            if (((d0 * cX) + (d1 * cY) + (d2 * cZ)) < offset &&
                                (d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= offset)
                            {
                                planes = buildPortalPlanesNoFrustum(portal.points, cX, cY, cZ);
                                if (planes)
                                {
                                    portal.queryCounter = queryCounter;
                                    overlappingPortals[numOverlappingPortals] = {
                                            portal: portal,
                                            planes: parentPlanes.concat(planes),
                                            area: nextArea
                                        };
                                    numOverlappingPortals += 1;
                                }
                            }
                            else
                            {
                                portal.queryCounter = queryCounter;
                            }
                        }
                        else
                        {
                            portal.queryCounter = queryCounter;
                        }
                    }
                }
            }
            while (currentPortalIndex < numOverlappingPortals);
        }
    },

    //
    // findOverlappingNodes
    //
    findOverlappingNodes: function sceneFindOverlappingNodesFn(tree, origin, extents, overlappingNodes)
    {
        var useAABBTree = true;
        var areas = this.areas;
        if (areas)
        {
            // Assume scene.update has been called before this function
            var cX = origin[0];
            var cY = origin[1];
            var cZ = origin[2];
            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            if (areaIndex >= 0)
            {
                var externalNodesStack = this.externalNodesStack;

                var na, area, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    area = areas[na];
                    nodes = area.externalNodes;
                    if (nodes)
                    {
                        nodes.length = 0;
                        externalNodesStack.push(nodes);
                        area.externalNodes = null;
                    }
                }

                var minExtent0 = extents[0];
                var minExtent1 = extents[1];
                var minExtent2 = extents[2];
                var maxExtent0 = extents[3];
                var maxExtent1 = extents[4];
                var maxExtent2 = extents[5];

                area = areas[areaIndex];
                var areaExtents = area.extents;
                var testMinExtent0 = areaExtents[0];
                var testMinExtent1 = areaExtents[1];
                var testMinExtent2 = areaExtents[2];
                var testMaxExtent0 = areaExtents[3];
                var testMaxExtent1 = areaExtents[4];
                var testMaxExtent2 = areaExtents[5];

                var overlappingPortals = [];
                this.findOverlappingPortals(areaIndex, cX, cY, cZ, extents, overlappingPortals);

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var queryCounter = this.getQueryCounter();
                var numOverlappingPortals = overlappingPortals.length;
                var numOverlappingNodes = overlappingNodes.length;
                var portalPlanes;
                var n, node, np, portalItem;

                if (0 < externalNodesStack.length)
                {
                    nodes = externalNodesStack.pop();
                }
                else
                {
                    nodes = [];
                }
                area.externalNodes = nodes;

                var testExtents = this.testExtents;
                testExtents[0] = (testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0);
                testExtents[1] = (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1);
                testExtents[2] = (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2);
                testExtents[3] = (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0);
                testExtents[4] = (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1);
                testExtents[5] = (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2);

                tree.getOverlappingNodes(testExtents, nodes);

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    overlappingNodes[numOverlappingNodes] = node;
                    numOverlappingNodes += 1;
                }

                for (np = 0; np < numOverlappingPortals; np += 1)
                {
                    portalItem = overlappingPortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.externalNodes;

                    if (!nodes)
                    {
                        if (0 < externalNodesStack.length)
                        {
                            nodes = externalNodesStack.pop();
                        }
                        else
                        {
                            nodes = [];
                        }
                        area.externalNodes = nodes;
                        areaExtents = area.extents;
                        testMinExtent0 = areaExtents[0];
                        testMinExtent1 = areaExtents[1];
                        testMinExtent2 = areaExtents[2];
                        testMaxExtent0 = areaExtents[3];
                        testMaxExtent1 = areaExtents[4];
                        testMaxExtent2 = areaExtents[5];

                        testExtents[0] = (testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0);
                        testExtents[1] = (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1);
                        testExtents[2] = (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2);
                        testExtents[3] = (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0);
                        testExtents[4] = (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1);
                        testExtents[5] = (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2);

                        tree.getOverlappingNodes(testExtents, nodes);
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                            {
                                node.queryCounter = queryCounter;
                                overlappingNodes[numOverlappingNodes] = node;
                                numOverlappingNodes += 1;
                            }
                        }
                    }
                }

                useAABBTree = false;
            }
        }

        if (useAABBTree)
        {
            tree.getOverlappingNodes(extents, overlappingNodes);
        }
    },

    //
    // findStaticOverlappingNodes
    //
    findStaticOverlappingNodes: function sceneFindStaticOverlappingNodesFn(origin, extents, overlappingNodes)
    {
        this.findOverlappingNodes(this.staticSpatialMap, origin, extents, overlappingNodes);
    },

    //
    // findDynamicOverlappingNodes
    //
    findDynamicOverlappingNodes: function sceneFindDynamicOverlappingNodesFn(origin, extents, overlappingNodes)
    {
        this.findOverlappingNodes(this.dynamicSpatialMap, origin, extents, overlappingNodes);
    },

    //
    // findOverlappingRenderables
    //
    findOverlappingRenderables: function sceneFindOverlappingRenderablesFn(tree, origin, extents, overlappingRenderables)
    {
        var numOverlappingRenderables = overlappingRenderables.length;
        var minExtent0 = extents[0];
        var minExtent1 = extents[1];
        var minExtent2 = extents[2];
        var maxExtent0 = extents[3];
        var maxExtent1 = extents[4];
        var maxExtent2 = extents[5];

        var overlappingNodes = [];
        var useAABBTree = true;
        var areas = this.areas;

        var node;
        var numNodes;
        var nodeIndex;
        var renderable;
        var renderables;
        var numRenderables;
        var nodeExtents;
        var renderableIndex;
        var renderableExtents;

        if (areas)
        {
            // Assume scene.update has been called before this function
            var cX = origin[0];
            var cY = origin[1];
            var cZ = origin[2];
            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            if (areaIndex >= 0)
            {
                var externalNodesStack = this.externalNodesStack;

                var na, area, nodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    area = areas[na];
                    nodes = area.externalNodes;
                    if (nodes)
                    {
                        nodes.length = 0;
                        externalNodesStack.push(nodes);
                        area.externalNodes = null;
                    }
                }

                area = areas[areaIndex];
                var areaExtents = area.extents;
                var testMinExtent0 = areaExtents[0];
                var testMinExtent1 = areaExtents[1];
                var testMinExtent2 = areaExtents[2];
                var testMaxExtent0 = areaExtents[3];
                var testMaxExtent1 = areaExtents[4];
                var testMaxExtent2 = areaExtents[5];

                var overlappingPortals = [];
                this.findOverlappingPortals(areaIndex, cX, cY, cZ, extents, overlappingPortals);

                var isInsidePlanesAABB = this.isInsidePlanesAABB;
                var isFullyInsidePlanesAABB = this.isFullyInsidePlanesAABB;
                var queryCounter = this.getQueryCounter();
                var numOverlappingPortals = overlappingPortals.length;
                var portalPlanes;
                var n, np, portalItem;
                var allVisible;

                if (0 < externalNodesStack.length)
                {
                    nodes = externalNodesStack.pop();
                }
                else
                {
                    nodes = [];
                }
                area.externalNodes = nodes;

                var testExtents = this.testExtents;
                testExtents[0] = (testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0);
                testExtents[1] = (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1);
                testExtents[2] = (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2);
                testExtents[3] = (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0);
                testExtents[4] = (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1);
                testExtents[5] = (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2);

                tree.getOverlappingNodes(testExtents, nodes);

                numNodes = nodes.length;
                for (nodeIndex = 0; nodeIndex < numNodes; nodeIndex += 1)
                {
                    node = nodes[nodeIndex];
                    node.queryCounter = queryCounter;
                    renderables = node.renderables;
                    if (renderables)
                    {
                        numRenderables = renderables.length;
                        if (numRenderables === 1)
                        {
                            overlappingRenderables[numOverlappingRenderables] = renderables[0];
                            numOverlappingRenderables += 1;
                        }
                        else
                        {
                            // Check if node is fully inside
                            nodeExtents = node.worldExtents;
                            if (nodeExtents[0] >= minExtent0 &&
                                nodeExtents[1] >= minExtent1 &&
                                nodeExtents[2] >= minExtent2 &&
                                nodeExtents[3] <= maxExtent0 &&
                                nodeExtents[4] <= maxExtent1 &&
                                nodeExtents[5] <= maxExtent2)
                            {
                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                {
                                    overlappingRenderables[numOverlappingRenderables] = renderables[renderableIndex];
                                    numOverlappingRenderables += 1;
                                }
                            }
                            else
                            {
                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                {
                                    renderable = renderables[renderableIndex];
                                    renderableExtents = renderable.getWorldExtents();
                                    if (renderableExtents[3] >= minExtent0 &&
                                        renderableExtents[4] >= minExtent1 &&
                                        renderableExtents[5] >= minExtent2 &&
                                        renderableExtents[0] <= maxExtent0 &&
                                        renderableExtents[1] <= maxExtent1 &&
                                        renderableExtents[2] <= maxExtent2)
                                    {
                                        overlappingRenderables[numOverlappingRenderables] = renderable;
                                        numOverlappingRenderables += 1;
                                    }
                                }
                            }
                        }
                    }
                }

                for (np = 0; np < numOverlappingPortals; np += 1)
                {
                    portalItem = overlappingPortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.externalNodes;

                    if (!nodes)
                    {
                        if (0 < externalNodesStack.length)
                        {
                            nodes = externalNodesStack.pop();
                        }
                        else
                        {
                            nodes = [];
                        }
                        area.externalNodes = nodes;
                        areaExtents = area.extents;
                        testMinExtent0 = areaExtents[0];
                        testMinExtent1 = areaExtents[1];
                        testMinExtent2 = areaExtents[2];
                        testMaxExtent0 = areaExtents[3];
                        testMaxExtent1 = areaExtents[4];
                        testMaxExtent2 = areaExtents[5];

                        testExtents[0] = (testMinExtent0 > minExtent0 ? testMinExtent0 : minExtent0);
                        testExtents[1] = (testMinExtent1 > minExtent1 ? testMinExtent1 : minExtent1);
                        testExtents[2] = (testMinExtent2 > minExtent2 ? testMinExtent2 : minExtent2);
                        testExtents[3] = (testMaxExtent0 < maxExtent0 ? testMaxExtent0 : maxExtent0);
                        testExtents[4] = (testMaxExtent1 < maxExtent1 ? testMaxExtent1 : maxExtent1);
                        testExtents[5] = (testMaxExtent2 < maxExtent2 ? testMaxExtent2 : maxExtent2);

                        tree.getOverlappingNodes(testExtents, nodes);
                    }

                    numNodes = nodes.length;
                    for (n = 0; n < numNodes; n += 1)
                    {
                        node = nodes[n];
                        if (node.queryCounter !== queryCounter)
                        {
                            allVisible = true;

                            renderables = node.renderables;
                            if (renderables)
                            {
                                nodeExtents = node.worldExtents;
                                if (isInsidePlanesAABB(nodeExtents, portalPlanes))
                                {
                                    numRenderables = renderables.length;
                                    if (numRenderables === 1)
                                    {
                                        renderable = renderables[0];
                                        if (renderable.queryCounter !== queryCounter)
                                        {
                                            renderable.queryCounter = queryCounter;
                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                            numOverlappingRenderables += 1;
                                        }
                                    }
                                    else
                                    {
                                        // Check if node is fully inside
                                        if (nodeExtents[0] >= minExtent0 &&
                                            nodeExtents[1] >= minExtent1 &&
                                            nodeExtents[2] >= minExtent2 &&
                                            nodeExtents[3] <= maxExtent0 &&
                                            nodeExtents[4] <= maxExtent1 &&
                                            nodeExtents[5] <= maxExtent2)
                                        {
                                            if (isFullyInsidePlanesAABB(nodeExtents, portalPlanes))
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        renderable.queryCounter = queryCounter;
                                                        overlappingRenderables[numOverlappingRenderables] = renderable;
                                                        numOverlappingRenderables += 1;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        if (isInsidePlanesAABB(renderable.getWorldExtents(), portalPlanes))
                                                        {
                                                            renderable.queryCounter = queryCounter;
                                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                                            numOverlappingRenderables += 1;
                                                        }
                                                        else
                                                        {
                                                            allVisible = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else
                                        {
                                            if (isFullyInsidePlanesAABB(nodeExtents, portalPlanes))
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        renderableExtents = renderable.getWorldExtents();
                                                        if (renderableExtents[3] >= minExtent0 &&
                                                            renderableExtents[4] >= minExtent1 &&
                                                            renderableExtents[5] >= minExtent2 &&
                                                            renderableExtents[0] <= maxExtent0 &&
                                                            renderableExtents[1] <= maxExtent1 &&
                                                            renderableExtents[2] <= maxExtent2)
                                                        {
                                                            renderable.queryCounter = queryCounter;
                                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                                            numOverlappingRenderables += 1;
                                                        }
                                                        else
                                                        {
                                                            allVisible = false;
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                                                {
                                                    renderable = renderables[renderableIndex];
                                                    if (renderable.queryCounter !== queryCounter)
                                                    {
                                                        renderableExtents = renderable.getWorldExtents();
                                                        if (renderableExtents[3] >= minExtent0 &&
                                                            renderableExtents[4] >= minExtent1 &&
                                                            renderableExtents[5] >= minExtent2 &&
                                                            renderableExtents[0] <= maxExtent0 &&
                                                            renderableExtents[1] <= maxExtent1 &&
                                                            renderableExtents[2] <= maxExtent2 &&
                                                            isInsidePlanesAABB(renderableExtents, portalPlanes))
                                                        {
                                                            renderable.queryCounter = queryCounter;
                                                            overlappingRenderables[numOverlappingRenderables] = renderable;
                                                            numOverlappingRenderables += 1;
                                                        }
                                                        else
                                                        {
                                                            allVisible = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    allVisible = false;
                                }
                            }

                            if (allVisible)
                            {
                                node.queryCounter = queryCounter;
                            }
                        }
                    }
                }
                useAABBTree = false;
            }
        }

        if (useAABBTree)
        {
            tree.getOverlappingNodes(extents, overlappingNodes);
            numNodes = overlappingNodes.length;
            for (nodeIndex = 0; nodeIndex < numNodes; nodeIndex += 1)
            {
                node = overlappingNodes[nodeIndex];
                renderables = node.renderables;
                if (renderables)
                {
                    numRenderables = renderables.length;
                    if (numRenderables === 1)
                    {
                        overlappingRenderables[numOverlappingRenderables] = renderables[0];
                        numOverlappingRenderables += 1;
                    }
                    else
                    {
                        // Check if node is fully inside
                        nodeExtents = node.worldExtents;
                        if (nodeExtents[0] >= minExtent0 &&
                            nodeExtents[1] >= minExtent1 &&
                            nodeExtents[2] >= minExtent2 &&
                            nodeExtents[3] <= maxExtent0 &&
                            nodeExtents[4] <= maxExtent1 &&
                            nodeExtents[5] <= maxExtent2)
                        {
                            for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                            {
                                overlappingRenderables[numOverlappingRenderables] = renderables[renderableIndex];
                                numOverlappingRenderables += 1;
                            }
                        }
                        else
                        {
                            for (renderableIndex = 0; renderableIndex < numRenderables; renderableIndex += 1)
                            {
                                renderable = renderables[renderableIndex];
                                renderableExtents = renderable.getWorldExtents();
                                if (renderableExtents[3] >= minExtent0 &&
                                    renderableExtents[4] >= minExtent1 &&
                                    renderableExtents[5] >= minExtent2 &&
                                    renderableExtents[0] <= maxExtent0 &&
                                    renderableExtents[1] <= maxExtent1 &&
                                    renderableExtents[2] <= maxExtent2)
                                {
                                    overlappingRenderables[numOverlappingRenderables] = renderable;
                                    numOverlappingRenderables += 1;
                                }
                            }
                        }
                    }
                }
            }
        }
    },

    //
    // findStaticOverlappingRenderables
    //
    findStaticOverlappingRenderables: function sceneFindStaticOverlappingRenderablesFn(origin, extents, overlappingRenderables)
    {
        this.findOverlappingRenderables(this.staticSpatialMap, origin, extents, overlappingRenderables);
    },

    //
    // findDynamicOverlappingRenderables
    //
    findDynamicOverlappingRenderables: function sceneFindDynamicOverlappingRenderablesFn(origin, extents, overlappingRenderables)
    {
        this.findOverlappingRenderables(this.dynamicSpatialMap, origin, extents, overlappingRenderables);
    },

    //
    // cloneRootNode
    //
    cloneRootNode: function cloneRootNodeFn(rootNode, newInstanceName)
    {
        var newNode = rootNode.clone(newInstanceName);
        this.addRootNode(newNode);
        return newNode;
    },

    //
    // updateVisibleNodes
    //
    updateVisibleNodes: function sceneUpdateVisibleNodesFn(camera)
    {
        var visibleNodes = this.visibleNodes;
        visibleNodes.length = 0;
        var numVisibleNodes = 0;

        var visibleRenderables = this.visibleRenderables;
        visibleRenderables.length = 0;
        var numVisibleRenderables = 0;

        var visibleLights = this.visibleLights;
        visibleLights.length = 0;
        var numVisibleLights = 0;

        this.extractFrustumPlanes(camera);

        var frameIndex = this.frameIndex;
        var maxDistance = 0;
        var nearPlane = this.nearPlane;
        var d0 = nearPlane[0];
        var d1 = nearPlane[1];
        var d2 = nearPlane[2];
        var offset = nearPlane[3];
        var n = 0;
        var node;

        var queryCounter = this.getQueryCounter();
        var isInsidePlanesAABB = this.isInsidePlanesAABB;
        var isFullyInsidePlanesAABB = this.isFullyInsidePlanesAABB;

        //
        // sceneProcessVisibleNodeFn helper
        //
        function sceneProcessVisibleNodeFn(node, planes, cameraExtents)
        {
            var n0, n1, n2, p0, p1, p2, distance;
            var extents = node.worldExtents;
            var allVisible = true;

            if (node.frameVisible !== frameIndex)
            {
                node.frameVisible = frameIndex;

                n0 = extents[0];
                n1 = extents[1];
                n2 = extents[2];
                p0 = extents[3];
                p1 = extents[4];
                p2 = extents[5];

                // Frustum tests do return some false positives, check bounding boxes
                if (cameraExtents[3] > n0 &&
                    cameraExtents[4] > n1 &&
                    cameraExtents[5] > n2 &&
                    p0 > cameraExtents[0] &&
                    p1 > cameraExtents[1] &&
                    p2 > cameraExtents[2])
                {
                    distance = ((d0 * (d0 > 0 ? p0 : n0)) + (d1 * (d1 > 0 ? p1 : n1)) + (d2 * (d2 > 0 ? p2 : n2)) - offset);
                }
                else
                {
                    distance = -1;
                }

                node.distance = distance;
                if (0 < distance)
                {
                    //This signifies any part of the node is visible, but not necessarily all.
                    visibleNodes[numVisibleNodes] = node;
                    numVisibleNodes += 1;
                }
            }
            else
            {
                distance = node.distance;
            }

            if (0 < distance)
            {
                if (!node.disabled)
                {
                    var renderable, i, lightInstance, l;
                    var renderables = node.renderables;
                    var numRenderables = (renderables ? renderables.length : 0);

                    var lights = node.lightInstances;
                    var numLights = (lights ? lights.length : 0);

                    var fullyVisible = (1 < (numLights + numRenderables) ?
                                        isFullyInsidePlanesAABB(extents, planes) :
                                        false);

                    if (renderables)
                    {
                        if (numRenderables === 1 && !lights)
                        {
                            for (i = 0; i < numRenderables; i += 1)
                            {
                                renderable = renderables[i];
                                if (!renderable.disabled &&
                                    renderable.queryCounter !== queryCounter)
                                {
                                    if (maxDistance < distance)
                                    {
                                        maxDistance = distance;
                                    }
                                    renderable.distance = distance;
                                    renderable.frameVisible = frameIndex;
                                    renderable.queryCounter = queryCounter;
                                    visibleRenderables[numVisibleRenderables] = renderable;
                                    numVisibleRenderables += 1;
                                }
                            }
                        }
                        else
                        {
                            for (i = 0; i < numRenderables; i += 1)
                            {
                                renderable = renderables[i];
                                if (!renderable.disabled &&
                                    renderable.queryCounter !== queryCounter)
                                {
                                    extents = renderable.getWorldExtents();
                                    if (fullyVisible || isInsidePlanesAABB(extents, planes))
                                    {
                                        n0 = extents[0];
                                        n1 = extents[1];
                                        n2 = extents[2];
                                        p0 = extents[3];
                                        p1 = extents[4];
                                        p2 = extents[5];

                                        // Frustum tests do return some false positives, check bounding boxes
                                        if (fullyVisible ||
                                            (cameraExtents[3] > n0 &&
                                             cameraExtents[4] > n1 &&
                                             cameraExtents[5] > n2 &&
                                             p0 > cameraExtents[0] &&
                                             p1 > cameraExtents[1] &&
                                             p2 > cameraExtents[2]))
                                        {
                                            distance = ((d0 * (d0 > 0 ? p0 : n0)) + (d1 * (d1 > 0 ? p1 : n1)) + (d2 * (d2 > 0 ? p2 : n2)) - offset);
                                        }
                                        else
                                        {
                                            distance -= 1;
                                        }

                                        if (0 < distance)
                                        {
                                            if (maxDistance < distance)
                                            {
                                                maxDistance = distance;
                                            }
                                            renderable.distance = distance;
                                            renderable.frameVisible = frameIndex;
                                            renderable.queryCounter = queryCounter;
                                            visibleRenderables[numVisibleRenderables] = renderable;
                                            numVisibleRenderables += 1;
                                        }
                                        else
                                        {
                                            allVisible = false;
                                        }
                                    }
                                    else
                                    {
                                        allVisible = false;
                                    }
                                }
                            }
                        }
                    }

                    if (lights)
                    {
                        if (numLights === 1 && !renderables)
                        {
                            for (l = 0; l < numLights; l += 1)
                            {
                                lightInstance = lights[l];
                                if (!lightInstance.disabled &&
                                    lightInstance.queryCounter !== queryCounter &&
                                    !lightInstance.light.isGlobal())
                                {
                                    lightInstance.distance = distance;
                                    lightInstance.frameVisible = frameIndex;
                                    lightInstance.queryCounter = queryCounter;
                                    visibleLights[numVisibleLights] = lightInstance;
                                    numVisibleLights += 1;
                                }
                            }
                        }
                        else
                        {
                            for (l = 0; l < numLights; l += 1)
                            {
                                lightInstance = lights[l];
                                if (!lightInstance.disabled &&
                                    lightInstance.queryCounter !== queryCounter &&
                                    !lightInstance.light.isGlobal())
                                {
                                    extents = lightInstance.getWorldExtents();
                                    if (fullyVisible || isInsidePlanesAABB(extents, planes))
                                    {
                                        n0 = extents[0];
                                        n1 = extents[1];
                                        n2 = extents[2];
                                        p0 = extents[3];
                                        p1 = extents[4];
                                        p2 = extents[5];

                                        // Frustum tests do return some false positives, check bounding boxes
                                        if (fullyVisible ||
                                            (cameraExtents[3] > n0 &&
                                             cameraExtents[4] > n1 &&
                                             cameraExtents[5] > n2 &&
                                             p0 > cameraExtents[0] &&
                                             p1 > cameraExtents[1] &&
                                             p2 > cameraExtents[2]))
                                        {
                                            distance = ((d0 * (d0 > 0 ? p0 : n0)) + (d1 * (d1 > 0 ? p1 : n1)) + (d2 * (d2 > 0 ? p2 : n2)) - offset);
                                        }
                                        else
                                        {
                                            distance -= 1;
                                        }

                                        if (0 < distance)
                                        {
                                            lightInstance.distance = distance;
                                            lightInstance.frameVisible = frameIndex;
                                            lightInstance.queryCounter = queryCounter;
                                            visibleLights[numVisibleLights] = lightInstance;
                                            numVisibleLights += 1;
                                        }
                                        else
                                        {
                                            allVisible = false;
                                        }
                                    }
                                    else
                                    {
                                        allVisible = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (allVisible)
            {
                node.queryCounter = queryCounter;
            }
        }

        // findVisibleNodes
        var cameraExtents = this.cameraExtents;
        var cameraMinExtent0, cameraMinExtent1, cameraMinExtent2;
        var cameraMaxExtent0, cameraMaxExtent1, cameraMaxExtent2;

        camera.getFrustumExtents(cameraExtents);

        var frustumPlanes = this.frustumPlanes;
        var useAABBTrees = true;
        var areas = this.areas;
        if (areas)
        {
            var cameraMatrix = camera.matrix;
            var cX = cameraMatrix[9];
            var cY = cameraMatrix[10];
            var cZ = cameraMatrix[11];

            var areaIndex = this.findAreaIndex(this.bspNodes, cX, cY, cZ);
            this.cameraAreaIndex = areaIndex;

            if (areaIndex >= 0)
            {
                cameraMinExtent0 = cameraExtents[0];
                cameraMinExtent1 = cameraExtents[1];
                cameraMinExtent2 = cameraExtents[2];
                cameraMaxExtent0 = cameraExtents[3];
                cameraMaxExtent1 = cameraExtents[4];
                cameraMaxExtent2 = cameraExtents[5];

                this.findVisiblePortals(areaIndex, cX, cY, cZ);

                var area, na, nodes, numNodes;
                var numAreas = areas.length;
                for (na = 0; na < numAreas; na += 1)
                {
                    area = areas[na];
                    nodes = area.nodes;
                    numNodes = area.numStaticNodes;
                    if (nodes.length > numNodes)
                    {
                        nodes.length = numNodes;
                    }
                    area.addedDynamicNodes = false;
                }

                var dynamicSpatialMap = this.dynamicSpatialMap;
                var visiblePortals = this.visiblePortals;
                var numVisiblePortals = visiblePortals.length;

                var np, portalItem, portalPlanes;

                area = areas[areaIndex];
                nodes = area.nodes;
                area.addedDynamicNodes = true;

                var areaExtent = area.extents;
                var areaMinExtent0 = areaExtent[0];
                var areaMinExtent1 = areaExtent[1];
                var areaMinExtent2 = areaExtent[2];
                var areaMaxExtent0 = areaExtent[3];
                var areaMaxExtent1 = areaExtent[4];
                var areaMaxExtent2 = areaExtent[5];
                var combinedExtents = (this.float32ArrayConstructor ?
                                       new this.float32ArrayConstructor(6) :
                                       new Array(6));
                combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);

                dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);

                numNodes = nodes.length;
                for (n = 0; n < numNodes; n += 1)
                {
                    node = nodes[n];
                    node.queryCounter = queryCounter;
                    if (isInsidePlanesAABB(node.worldExtents, frustumPlanes))
                    {
                        sceneProcessVisibleNodeFn(node, frustumPlanes, cameraExtents);
                    }
                }

                for (np = 0; np < numVisiblePortals; np += 1)
                {
                    portalItem = visiblePortals[np];
                    portalPlanes = portalItem.planes;
                    area = areas[portalItem.area];
                    nodes = area.nodes;

                    // Frustum tests do return some false positives, check bounding boxes
                    areaExtent = area.extents;
                    areaMinExtent0 = areaExtent[0];
                    areaMinExtent1 = areaExtent[1];
                    areaMinExtent2 = areaExtent[2];
                    areaMaxExtent0 = areaExtent[3];
                    areaMaxExtent1 = areaExtent[4];
                    areaMaxExtent2 = areaExtent[5];
                    if (cameraMaxExtent0 > areaMinExtent0 &&
                        cameraMaxExtent1 > areaMinExtent1 &&
                        cameraMaxExtent2 > areaMinExtent2 &&
                        areaMaxExtent0 > cameraMinExtent0 &&
                        areaMaxExtent1 > cameraMinExtent1 &&
                        areaMaxExtent2 > cameraMinExtent2)
                    {
                        if (!area.addedDynamicNodes)
                        {
                            area.addedDynamicNodes = true;
                            combinedExtents[0] = (areaMinExtent0 < cameraMinExtent0 ? cameraMinExtent0 : areaMinExtent0);
                            combinedExtents[1] = (areaMinExtent1 < cameraMinExtent1 ? cameraMinExtent1 : areaMinExtent1);
                            combinedExtents[2] = (areaMinExtent2 < cameraMinExtent2 ? cameraMinExtent2 : areaMinExtent2);
                            combinedExtents[3] = (areaMaxExtent0 > cameraMaxExtent0 ? cameraMaxExtent0 : areaMaxExtent0);
                            combinedExtents[4] = (areaMaxExtent1 > cameraMaxExtent1 ? cameraMaxExtent1 : areaMaxExtent1);
                            combinedExtents[5] = (areaMaxExtent2 > cameraMaxExtent2 ? cameraMaxExtent2 : areaMaxExtent2);
                            dynamicSpatialMap.getOverlappingNodes(combinedExtents, nodes);
                        }

                        numNodes = nodes.length;
                        for (n = 0; n < numNodes; n += 1)
                        {
                            node = nodes[n];
                            if (node.queryCounter !== queryCounter)
                            {
                                if (isInsidePlanesAABB(node.worldExtents, portalPlanes))
                                {
                                    sceneProcessVisibleNodeFn(node, portalPlanes, cameraExtents);
                                }
                            }
                        }
                    }
                }

                useAABBTrees = false;
            }
        }

        if (useAABBTrees)
        {
            var queryVisibleNodes = [];
            this.staticSpatialMap.getVisibleNodes(frustumPlanes, queryVisibleNodes);
            this.dynamicSpatialMap.getVisibleNodes(frustumPlanes, queryVisibleNodes);
            var numQueryVisibleNodes = queryVisibleNodes.length;
            if (numQueryVisibleNodes)
            {
                n = 0;
                do
                {
                    sceneProcessVisibleNodeFn(queryVisibleNodes[n], frustumPlanes, cameraExtents);
                    n += 1;
                }
                while (n < numQueryVisibleNodes);
            }
        }

        this.maxDistance = (maxDistance + camera.nearPlane);

        if (this.maxDistance < camera.farPlane)
        {
            var oldNumVisibleRenderables = numVisibleRenderables;
            var oldNumVisibleLights = numVisibleLights;
            var renderable, lightInstance, extents;

            // The camera extents may be different and some objects could be discarded
            camera.getFrustumExtents(cameraExtents, this.maxDistance);
            cameraMinExtent0 = cameraExtents[0];
            cameraMinExtent1 = cameraExtents[1];
            cameraMinExtent2 = cameraExtents[2];
            cameraMaxExtent0 = cameraExtents[3];
            cameraMaxExtent1 = cameraExtents[4];
            cameraMaxExtent2 = cameraExtents[5];

            n = 0;
            while (n < numVisibleRenderables)
            {
                renderable = visibleRenderables[n];
                extents = renderable.getWorldExtents();
                if (extents[0] > cameraMaxExtent0 ||
                    extents[1] > cameraMaxExtent1 ||
                    extents[2] > cameraMaxExtent2 ||
                    extents[3] < cameraMinExtent0 ||
                    extents[4] < cameraMinExtent1 ||
                    extents[5] < cameraMinExtent2)
                {
                    renderable.frameVisible -= 1;
                    numVisibleRenderables -= 1;
                    if (n < numVisibleRenderables)
                    {
                        visibleRenderables[n] = visibleRenderables[numVisibleRenderables];
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    n += 1;
                }
            }

            n = 0;
            while (n < numVisibleLights)
            {
                lightInstance = visibleLights[n];
                extents = lightInstance.getWorldExtents();
                if (extents[0] > cameraMaxExtent0 ||
                    extents[1] > cameraMaxExtent1 ||
                    extents[2] > cameraMaxExtent2 ||
                    extents[3] < cameraMinExtent0 ||
                    extents[4] < cameraMinExtent1 ||
                    extents[5] < cameraMinExtent2)
                {
                    lightInstance.frameVisible -= 1;
                    numVisibleLights -= 1;
                    if (n < numVisibleLights)
                    {
                        visibleLights[n] = visibleLights[numVisibleLights];
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    n += 1;
                }
            }

            if (oldNumVisibleRenderables !== numVisibleRenderables ||
                oldNumVisibleLights !== numVisibleLights)
            {
                visibleRenderables.length = numVisibleRenderables;
                visibleLights.length = numVisibleLights;

                n = 0;
                while (n < numVisibleNodes)
                {
                    node = visibleNodes[n];
                    extents = node.worldExtents;
                    if (extents[0] > cameraMaxExtent0 ||
                        extents[1] > cameraMaxExtent1 ||
                        extents[2] > cameraMaxExtent2 ||
                        extents[3] < cameraMinExtent0 ||
                        extents[4] < cameraMinExtent1 ||
                        extents[5] < cameraMinExtent2)
                    {
                        node.frameVisible -= 1;
                        numVisibleNodes -= 1;
                        if (n < numVisibleNodes)
                        {
                            visibleNodes[n] = visibleNodes[numVisibleNodes];
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        n += 1;
                    }
                }

                visibleNodes.length = numVisibleNodes;
            }
        }

        this.frameIndex += 1;
    },

    //
    // getCurrentVisibleNodes
    //
    getCurrentVisibleNodes: function sceneGetCurrentVisibleNodesFn()
    {
        return this.visibleNodes;
    },

    //
    // getCurrentVisibleRenderables
    //
    getCurrentVisibleRenderables: function sceneGetCurrentVisibleRenderablesFn()
    {
        return this.visibleRenderables;
    },

    //
    // getCurrentVisibleLights
    //
    getCurrentVisibleLights: function sceneGetCurrentVisibleLightsFn()
    {
        return this.visibleLights;
    },

    //
    // updateNodes
    //
    updateNodes: function sceneUpdateNodesFn()
    {
        var dirtyRoots = this.dirtyRoots;
        if (dirtyRoots)
        {
            var nodesToUpdate = [];
            var numNodesToUpdate = 0;
            for (var root in dirtyRoots)
            {
                if (dirtyRoots.hasOwnProperty(root))
                {
                    nodesToUpdate[numNodesToUpdate] = dirtyRoots[root];
                    numNodesToUpdate += 1;
                }
            }
            delete this.dirtyRoots;
            dirtyRoots = null;
            if (0 < numNodesToUpdate)
            {
                SceneNode.prototype.updateHelper(this.md, this, nodesToUpdate);
            }
        }
    },

    //
    // update
    //
    update: function sceneUpdateFn()
    {
        this.updateNodes();
        this.staticSpatialMap.finalize();
        this.dynamicSpatialMap.finalize();
        this.updateExtents();

        if (this.areas &&
            this.staticNodesChangeCounter !== this.areaInitalizeStaticNodesChangeCounter)
        {
            //Note this leaves extents of areas as large as they ever got.
            this.initializeAreas();
        }
    },

    //
    // updateExtents
    //
    updateExtents: function sceneUpdateExtentsFn()
    {
        var rootStaticNode = this.staticSpatialMap.getRootNode();
        var rootDynamicNode = this.dynamicSpatialMap.getRootNode();
        var sceneExtents = this.extents;

        var extents;
        if (rootStaticNode)
        {
            extents = rootStaticNode.extents;

            if (rootDynamicNode)
            {
                var minStaticX, minStaticY, minStaticZ, maxStaticX, maxStaticY, maxStaticZ;
                var minDynamicX, minDynamicY, minDynamicZ, maxDynamicX, maxDynamicY, maxDynamicZ;

                minStaticX = extents[0];
                minStaticY = extents[1];
                minStaticZ = extents[2];
                maxStaticX = extents[3];
                maxStaticY = extents[4];
                maxStaticZ = extents[5];

                extents = rootDynamicNode.extents;
                minDynamicX = extents[0];
                minDynamicY = extents[1];
                minDynamicZ = extents[2];
                maxDynamicX = extents[3];
                maxDynamicY = extents[4];
                maxDynamicZ = extents[5];

                sceneExtents[0] = (minStaticX < minDynamicX ? minStaticX : minDynamicX);
                sceneExtents[1] = (minStaticY < minDynamicY ? minStaticY : minDynamicY);
                sceneExtents[2] = (minStaticZ < minDynamicZ ? minStaticZ : minDynamicZ);
                sceneExtents[3] = (maxStaticX > maxDynamicX ? maxStaticX : maxDynamicX);
                sceneExtents[4] = (maxStaticY > maxDynamicY ? maxStaticY : maxDynamicY);
                sceneExtents[5] = (maxStaticZ > maxDynamicZ ? maxStaticZ : maxDynamicZ);
            }
            else
            {
                sceneExtents[0] = extents[0];
                sceneExtents[1] = extents[1];
                sceneExtents[2] = extents[2];
                sceneExtents[3] = extents[3];
                sceneExtents[4] = extents[4];
                sceneExtents[5] = extents[5];
            }
        }
        else
        {
            if (rootDynamicNode)
            {
                extents = rootDynamicNode.extents;

                sceneExtents[0] = extents[0];
                sceneExtents[1] = extents[1];
                sceneExtents[2] = extents[2];
                sceneExtents[3] = extents[3];
                sceneExtents[4] = extents[4];
                sceneExtents[5] = extents[5];
            }
            else
            {
                sceneExtents[0] = 0;
                sceneExtents[1] = 0;
                sceneExtents[2] = 0;
                sceneExtents[3] = 0;
                sceneExtents[4] = 0;
                sceneExtents[5] = 0;
            }
        }
    },

    //
    //  getExtents
    //
    getExtents: function sceneGetExtentsFn()
    {
        if (this.dirtyRoots)
        {
            this.updateNodes();
            this.staticSpatialMap.finalize();
            this.dynamicSpatialMap.finalize();
            this.updateExtents();
        }
        return this.extents;
    },

    //
    //  loadMaterial
    //
    loadMaterial: function loadMaterialFn(graphicsDevice, textureManager, effectManager, materialName, material)
    {
        var materials = this.materials;

        // Check materials if the materialName has already been added
        if (!materials[materialName])
        {
            var effectName = material.effect || "default";
            var newMaterial = this.createMaterial(materialName, material, effectName, null, null, graphicsDevice);
            if (newMaterial)
            {
                delete newMaterial.effectName;
                var effect = effectManager.get(effectName);
                if (effect)
                {
                    effect.prepareMaterial(newMaterial);
                }
                newMaterial.loadTextures(textureManager);
                return true;
            }
        }
        return false;
    },

    //
    // hasMaterial
    //
    hasMaterial: function sceneHasMaterialFn(materialName)
    {
        var material = this.materials[materialName];
        if (material)
        {
            return true;
        }
        return false;
    },

    //
    // getMaterial
    //
    getMaterial: function sceneGetMaterialFn(materialName)
    {
        return this.materials[materialName];
    },

    //
    // Draw nodes with same technique, mostly for debugging
    //
    drawNodesArray: function sceneDrawNodesArrayFn(nodes, gd, globalMaterial, technique, renderUpdate)
    {
        var numNodes = nodes.length;
        if (numNodes > 0)
        {
            var setTechnique = gd.setTechnique;
            var setTechniqueParameters = gd.setTechniqueParameters;
            var setStream = gd.setStream;
            var setIndexBuffer = gd.setIndexBuffer;
            var drawIndexed = gd.drawIndexed;
            var draw = gd.draw;
            var currentSharedTechniqueParameters = null;
            var currentVertexBuffer = null;
            var currentSemantics = null;
            var node, shape, sharedTechniqueParameters, techniqueParameters, vertexBuffer, semantics, surface, indexBuffer;
            var renderables, renderable, numRenderables, i;
            var n = 0;
            setTechnique.call(gd, technique);
            setTechniqueParameters.call(gd, globalMaterial);
            do
            {
                node = nodes[n];
                renderables = node.renderables;
                if (renderables)
                {
                    numRenderables = renderables.length;
                    for (i = 0; i < numRenderables; i += 1)
                    {
                        renderable = renderables[i];

                        renderUpdate.call(renderable);

                        shape = renderable.geometry;
                        vertexBuffer = shape.vertexBuffer;
                        semantics = shape.semantics;
                        surface = renderable.surface;
                        sharedTechniqueParameters = renderable.sharedMaterial.techniqueParameters;
                        techniqueParameters = renderable.techniqueParameters;

                        if (currentSharedTechniqueParameters !== sharedTechniqueParameters)
                        {
                            currentSharedTechniqueParameters = sharedTechniqueParameters;
                            setTechniqueParameters.call(gd, sharedTechniqueParameters, techniqueParameters);
                        }
                        else
                        {
                            setTechniqueParameters.call(gd, techniqueParameters);
                        }

                        if (currentVertexBuffer !== vertexBuffer ||
                            currentSemantics !== semantics)
                        {
                            currentVertexBuffer = vertexBuffer;
                            currentSemantics = semantics;
                            setStream.call(gd, vertexBuffer, semantics);
                        }

                        indexBuffer = surface.indexBuffer;
                        if (indexBuffer)
                        {
                            setIndexBuffer.call(gd, indexBuffer);

                            drawIndexed.call(gd, surface.primitive, surface.numIndices, surface.first);
                        }
                        else
                        {
                            //Utilities.log("" + surface.primitive + " ," + surface.numVertices + " ," + surface.first);
                            draw.call(gd, surface.primitive, surface.numVertices, surface.first);
                        }
                    }
                }

                n += 1;
            }
            while (n < numNodes);
        }
    },

    drawVisibleNodes: function sceneDrawVisibleNodesFn(gd, globalTechniqueParameters, technique, renderUpdate)
    {
        this.drawNodesArray(this.visibleNodes, gd, globalTechniqueParameters, technique, renderUpdate);
    },

    //
    // clearMaterials
    //
    clearMaterials: function sceneClearMaterialsFn()
    {
        var onMaterialDestroyed = this.onMaterialDestroyed;
        var materials = this.materials;
        if (materials)
        {
            for (var p in materials)
            {
                if (materials.hasOwnProperty(p))
                {
                    materials[p].reference.unsubscribeDestroyed(onMaterialDestroyed);
                }
            }
        }
        this.materials = {};
    },

    //
    // clearShapes
    //
    clearShapes: function sceneClearShapesFn()
    {
        var onGeometryDestroyed = this.onGeometryDestroyed;
        var shapes = this.shapes;
        if (shapes)
        {
            for (var p in shapes)
            {
                if (shapes.hasOwnProperty(p))
                {
                    shapes[p].reference.unsubscribeDestroyed(onGeometryDestroyed);
                }
            }
        }
        this.shapes = {};
    },

    //
    // clearShapesVertexData
    //
    clearShapesVertexData: function sceneClearShapesVertexDataFn()
    {
        var shapes = this.shapes;
        var shape;
        if (shapes)
        {
            for (var p in shapes)
            {
                if (shapes.hasOwnProperty(p))
                {
                    shape = shapes[p];
                    delete shape.vertexData;
                    delete shape.indexData;
                    var surfaces = shape.surfaces;
                    if (surfaces)
                    {
                        for (var s in surfaces)
                        {
                            if (surfaces.hasOwnProperty(s))
                            {
                                var surface = surfaces[s];
                                delete surface.vertexData;
                                delete surface.indexData;
                            }
                        }
                    }
                }
            }
        }
    },

    //
    // clearRootNodes
    //
    clearRootNodes: function sceneRootNodesFn()
    {
        var rootNodes = this.rootNodes;
        if (rootNodes)
        {
            var rootLength = rootNodes.length;
            for (var rootIndex = 0; rootIndex < rootLength; rootIndex += 1)
            {
                rootNodes[rootIndex].destroy();
            }
        }
        this.rootNodes = [];
        delete this.dirtyRoots;
        this.rootNodesMap = {};
    },

    //
    // clear
    //
    clear: function sceneClearFn()
    {
        this.effects = [];
        this.effectsMap = {};
        this.semantics = {};
        this.lights = {};
        this.globalLights = [];
        this.clearRootNodes();
        this.clearMaterials();
        this.clearShapes();
        this.staticSpatialMap = AABBTree.create(true);
        this.dynamicSpatialMap = AABBTree.create();
        this.frustumPlanes = [];
        this.animations = {};
        this.skeletons = {};
        this.extents = [];
        this.visibleNodes = [];
        this.visibleRenderables = [];
        this.visibleLights = [];
        this.cameraAreaIndex = -1;
        this.cameraExtents = (this.float32ArrayConstructor ?
                              new this.float32ArrayConstructor(6) :
                              new Array(6));
        this.visiblePortals = [];
        this.frameIndex = 0;
        this.queryCounter = 0;
        this.staticNodesChangeCounter = 0;
        this.testExtents = (this.float32ArrayConstructor ?
                            new this.float32ArrayConstructor(6) :
                            new Array(6));
        this.externalNodesStack = [];
    },

    //
    // endLoading
    //
    endLoading: function sceneEndLoadingFn(onload)
    {
        this.initializeNodes();
        this.initializeAreas();
        if (onload)
        {
            onload(this);
        }
    },

    //
    // initializeNodes
    //
    initializeNodes: function sceneInitializeNodesFn()
    {
        this.updateNodes();
        this.staticSpatialMap.finalize();
        this.updateExtents();
    },

    //
    // addAreaStaticNodes
    //
    addAreaStaticNodes: function addAreaStaticNodesFn()
    {
        var findAreaIndicesAABB = this.findAreaIndicesAABB;
        var findAreaIndex = this.findAreaIndex;
        var scene = this;

        function addAreasNodeFn(bspNodes, areas)
        {
            if (this.dynamic)
            {
                return;
            }

            if (this.hasRenderables() || (this.hasLightInstances() && this.worldExtents))
            {
                var extents = this.worldExtents;
                var min0 = extents[0];
                var min1 = extents[1];
                var min2 = extents[2];
                var max0 = extents[3];
                var max1 = extents[4];
                var max2 = extents[5];
                var area, na;
                var cX, cY, cZ;
                if (!this.hasRenderables() &&
                    this.lightInstances.length === 1 &&
                    this.lightInstances[0].light.spot)
                {
                    var world = this.world;
                    cX = world[9];
                    cY = world[10];
                    cZ = world[11];
                }
                else
                {
                    cX = (min0 + max0) * 0.5;
                    cY = (min1 + max1) * 0.5;
                    cZ = (min2 + max2) * 0.5;
                }
                var areaIndex = findAreaIndex(bspNodes, cX, cY, cZ);
                if (areaIndex >= 0)
                {
                    area = areas[areaIndex];
                    area.nodes.push(this);

                    var overlappingAreas = scene.findOverlappingAreas(areaIndex, extents);
                    var numOverlappingAreas = overlappingAreas.length;
                    for (na = 0; na < numOverlappingAreas; na += 1)
                    {
                        overlappingAreas[na].nodes.push(this);
                    }
                }
                else
                {
                    var areaFound = false;
                    var areaExtents;
                    for (;;)
                    {
                        var areaIndices = findAreaIndicesAABB(bspNodes, min0, min1, min2, max0, max1, max2);
                        var numAreaIndices = areaIndices.length;
                        if (0 < numAreaIndices)
                        {
                            // 1st try: only attach to overlapping areas
                            na = 0;
                            do
                            {
                                area = areas[areaIndices[na]];
                                areaExtents = area.extents;
                                if (areaExtents[0] <= max0 &&
                                    areaExtents[1] <= max1 &&
                                    areaExtents[2] <= max2 &&
                                    areaExtents[3] >= min0 &&
                                    areaExtents[4] >= min1 &&
                                    areaExtents[5] >= min2)
                                {
                                    area.nodes.push(this);
                                    areaFound = true;
                                }
                                na += 1;
                            }
                            while (na < numAreaIndices);
                            if (!areaFound)
                            {
                                // 2nd try: attach to any areas from bsp query
                                na = 0;
                                do
                                {
                                    areas[areaIndices[na]].nodes.push(this);
                                    na += 1;
                                }
                                while (na < numAreaIndices);
                            }
                            break;
                        }
                        else
                        {
                            // 3nd try: increase bounding box
                            var delta = Math.max((max0 - min0), (max1 - min1), (max2 - min2)) / 20;
                            min0 -= delta;
                            min1 -= delta;
                            min2 -= delta;
                            max0 += delta;
                            max1 += delta;
                            max2 += delta;
                        }
                    }
                }
            }
            var children = this.children;
            if (children)
            {
                var numChildren = children.length;
                for (var nc = 0; nc < numChildren; nc += 1)
                {
                    addAreasNodeFn.call(children[nc], bspNodes, areas);
                }
            }
        }

        var rootNodes = this.rootNodes;
        var numRootNodes = rootNodes.length;
        var bspNodes = this.bspNodes;
        var areas = this.areas;
        for (var n = 0; n < numRootNodes; n += 1)
        {
            addAreasNodeFn.call(rootNodes[n], bspNodes, areas);
        }
    },

    //
    // findOverlappingAreas
    //
    findOverlappingAreas: function sceneFindOverlappingAreasFn(startAreaIndex, extents, avoidDisabled)
    {
        var area, portals, numPortals, n, portal, plane, d0, d1, d2, portalExtents, areaIndex, nextArea;
        var queryCounter = this.getQueryCounter();
        var areas = this.areas;
        var portalsStack = [];
        var numPortalsStack = 0;
        var overlappingAreas = [];
        var numOverlappingAreas = 0;

        var min0 = extents[0];
        var min1 = extents[1];
        var min2 = extents[2];
        var max0 = extents[3];
        var max1 = extents[4];
        var max2 = extents[5];

        area = areas[startAreaIndex];
        area.queryCounter = queryCounter;

        portals = area.portals;
        numPortals = portals.length;
        for (n = 0; n < numPortals; n += 1)
        {
            portal = portals[n];
            if (avoidDisabled && portal.disabled)
            {
                continue;
            }
            portal.queryCounter = queryCounter;

            portalExtents = portal.extents;
            if (portalExtents[0] < max0 &&
                portalExtents[1] < max1 &&
                portalExtents[2] < max2 &&
                portalExtents[3] > min0 &&
                portalExtents[4] > min1 &&
                portalExtents[5] > min2)
            {
                plane = portal.plane;
                d0 = plane[0];
                d1 = plane[1];
                d2 = plane[2];
                if ((d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= plane[3])
                {
                    portalsStack[numPortalsStack] = portal;
                    numPortalsStack += 1;
                }
            }
        }

        while (0 < numPortalsStack)
        {
            numPortalsStack -= 1;
            portal = portalsStack[numPortalsStack];

            areaIndex = portal.area;
            area = areas[areaIndex];
            if (area.queryCounter !== queryCounter)
            {
                area.queryCounter = queryCounter;
                overlappingAreas[numOverlappingAreas] = area;
                numOverlappingAreas += 1;
            }

            portals = area.portals;
            numPortals = portals.length;
            for (n = 0; n < numPortals; n += 1)
            {
                portal = portals[n];
                if (avoidDisabled && portal.disabled)
                {
                    continue;
                }
                nextArea = portal.area;
                if (nextArea !== areaIndex &&
                    nextArea !== startAreaIndex &&
                    portal.queryCounter !== queryCounter)
                {
                    portal.queryCounter = queryCounter;

                    portalExtents = portal.extents;
                    if (portalExtents[0] < max0 &&
                        portalExtents[1] < max1 &&
                        portalExtents[2] < max2 &&
                        portalExtents[3] > min0 &&
                        portalExtents[4] > min1 &&
                        portalExtents[5] > min2)
                    {
                        plane = portal.plane;
                        d0 = plane[0];
                        d1 = plane[1];
                        d2 = plane[2];
                        if ((d0 * (d0 < 0 ? min0 : max0) + d1 * (d1 < 0 ? min1 : max1) + d2 * (d2 < 0 ? min2 : max2)) >= plane[3])
                        {
                            portalsStack[numPortalsStack] = portal;
                            numPortalsStack += 1;
                        }
                    }
                }
            }
        }

        return overlappingAreas;
    },

    //
    // checkAreaDynamicNodes
    //
    checkAreaDynamicNodes: function checkAreaDynamicNodesFn()
    {
        var findAreaIndicesAABB = this.findAreaIndicesAABB;
        var dynamicSpatialMap = this.dynamicSpatialMap;
        var bspNodes = this.bspNodes;
        var areas = this.areas;

        function checkAreaNodeFn()
        {
            if (this.dynamic &&
                (this.hasRenderables() || (this.hasLightInstances() && this.worldExtents)))
            {
                var extents = this.worldExtents;
                var min0 = extents[0];
                var min1 = extents[1];
                var min2 = extents[2];
                var max0 = extents[3];
                var max1 = extents[4];
                var max2 = extents[5];
                var pad = false;
                var areaFound = false;
                var na;
                for (;;)
                {
                    var areaIndices = findAreaIndicesAABB(bspNodes, min0, min1, min2, max0, max1, max2);
                    var numAreaIndices = areaIndices.length;
                    if (0 < numAreaIndices)
                    {
                        na = 0;
                        do
                        {
                            var area = areas[areaIndices[na]];
                            var areaExtent = area.extents;
                            if (areaExtent[0] <= max0 &&
                                areaExtent[1] <= max1 &&
                                areaExtent[2] <= max2 &&
                                areaExtent[3] >= min0 &&
                                areaExtent[4] >= min1 &&
                                areaExtent[5] >= min2)
                            {
                                areaFound = true;
                                break;
                            }
                            na += 1;
                        }
                        while (na < numAreaIndices);
                    }
                    if (areaFound)
                    {
                        break;
                    }
                    var delta = Math.max((max0 - min0), (max1 - min1), (max2 - min2)) / 20;
                    min0 -= delta;
                    min1 -= delta;
                    min2 -= delta;
                    max0 += delta;
                    max1 += delta;
                    max2 += delta;
                    pad = true;
                }
                if (pad)
                {   //TODO: This alters extents but the developer would expect them to remain constant if they are responsible for them.
                    extents[0] = min0;
                    extents[1] = min1;
                    extents[2] = min2;
                    extents[3] = max0;
                    extents[4] = max1;
                    extents[5] = max2;
                    dynamicSpatialMap.update(this, extents);
                }
            }
            var children = this.children;
            if (children)
            {
                var numChildren = children.length;
                for (var nc = 0; nc < numChildren; nc += 1)
                {
                    checkAreaNodeFn.call(children[nc]);
                }
            }
        }

        var rootNodes = this.rootNodes;
        var numRootNodes = rootNodes.length;
        for (var n = 0; n < numRootNodes; n += 1)
        {
            checkAreaNodeFn.call(rootNodes[n]);
        }
    },

    //
    // initializeAreas
    //
    initializeAreas: function sceneInitializeAreasFn()
    {
        var areas = this.areas;
        if (areas)
        {
            var numAreas = areas.length;
            var n, area, target, extents, areaExtents;
            for (n = 0; n < numAreas; n += 1)
            {
                area = areas[n];
                target = area.target;
                area.nodes = [];
                extents = target.calculateHierarchyWorldExtents();
                if (extents)
                {
                    areaExtents = area.extents;
                    areaExtents[0] = (extents[0] < areaExtents[0] ? extents[0] : areaExtents[0]);
                    areaExtents[1] = (extents[1] < areaExtents[1] ? extents[1] : areaExtents[1]);
                    areaExtents[2] = (extents[2] < areaExtents[2] ? extents[2] : areaExtents[2]);
                    areaExtents[3] = (extents[3] > areaExtents[3] ? extents[3] : areaExtents[3]);
                    areaExtents[4] = (extents[4] > areaExtents[4] ? extents[4] : areaExtents[4]);
                    areaExtents[5] = (extents[5] > areaExtents[5] ? extents[5] : areaExtents[5]);
                }
            }

            this.addAreaStaticNodes();

            this.checkAreaDynamicNodes();

            for (n = 0; n < numAreas; n += 1)
            {
                area = areas[n];
                area.numStaticNodes = area.nodes.length;
            }
        }
        this.areaInitalizeStaticNodesChangeCounter = this.staticNodesChangeCounter;
    },

    //
    // createMaterial
    //
    createMaterial: function createMaterialFn(materialName, fileMaterial, effectName, fileEffects, fileImages, graphicsDevice)
    {
        var materials = this.materials;

        var material = Material.create(graphicsDevice);
        var param, filename, effectType, p;

        // Effect associated, load from file
        if (fileEffects)
        {
            var fileEffect = fileEffects[effectName];
            if (fileEffect)
            {
                var effectParameters = fileEffect.parameters;
                for (p in effectParameters)
                {
                    if (effectParameters.hasOwnProperty(p))
                    {
                        param = effectParameters[p];
                        if (typeof param === 'string')
                        {
                            if (fileImages)
                            {
                                filename = fileImages[param] || param;
                            }
                            else
                            {
                                filename = param;
                            }

                            if (!material.texturesNames)
                            {
                                material.texturesNames = {};
                            }
                            material.texturesNames[p] = filename;
                            material.techniqueParameters[p] = null;
                        }
                        else
                        {
                            material.techniqueParameters[p] = param;
                        }
                    }
                }
                effectType = fileEffect.type;
            }
            else
            {
                effectType = effectName;
            }
        }
        else
        {
            effectType = effectName;
        }

        var materialParameters = fileMaterial.parameters;
        for (p in materialParameters)
        {
            if (materialParameters.hasOwnProperty(p))
            {
                param = materialParameters[p];
                if (typeof param === 'string')
                {
                    if (fileImages)
                    {
                        filename = fileImages[param] || param;
                    }
                    else
                    {
                        filename = param;
                    }

                    if (!material.texturesNames)
                    {
                        material.texturesNames = {};
                    }
                    material.texturesNames[p] = filename;

                    material.techniqueParameters[p] = null;
                }
                else
                {
                    material.techniqueParameters[p] = param;
                }
            }
        }

        material.effectName = effectType;

        if (fileMaterial.meta)
        {
            material.meta = fileMaterial.meta;
        }

        materials[materialName] = material;
        material.name = materialName;
        material.reference.subscribeDestroyed(this.onMaterialDestroyed);

        return material;
    },

    //
    // loadMaterials
    //
    loadMaterials: function sceneLoadMaterialsFn(loadParams)
    {
        var sceneData = loadParams.data;
        var gd = loadParams.graphicsDevice;
        var textureManager = loadParams.textureManager;
        var createMaterial = this.createMaterial;

        if (!loadParams.append)
        {
            this.effects = [];
            this.effectsMap = {};
            this.clearMaterials();
        }

        // Import materials
        var fileMaterials = sceneData.materials;
        if (fileMaterials)
        {
            var fileImages = sceneData.images;
            var fileEffects = sceneData.effects;
            var materials = this.materials;
            for (var m in fileMaterials)
            {
                if (fileMaterials.hasOwnProperty(m) &&
                    !materials[m])
                {
                    var fileMaterial = fileMaterials[m];
                    var effectName = (fileMaterial.effect || "default");
                    createMaterial.call(this, m, fileMaterial, effectName, fileEffects, fileImages, gd, textureManager);
                }
            }
        }
    },

    //
    // loadSkeletons
    //
    loadSkeletons: function sceneLoadSkeletonsFn(loadParams)
    {
        var sceneData = loadParams.data;
        var fileSkeletons = sceneData.skeletons;

        var md = this.md;
        var m43Build = md.m43Build;

        var invLTM, bindPose;

        for (var s in fileSkeletons)
        {
            if (fileSkeletons.hasOwnProperty(s))
            {
                var skeleton = fileSkeletons[s];

                var numJoints = skeleton.numNodes;
                var invLTMs = skeleton.invBoneLTMs;
                var bindPoses = skeleton.bindPoses;

                // copy the inv bone ltms and bind poses to make them native
                for (var b = 0; b < numJoints; b += 1)
                {
                    invLTM = invLTMs[b];
                    bindPose = bindPoses[b];

                    invLTMs[b] = m43Build.apply(md, invLTM);
                    bindPoses[b] = m43Build.apply(md, bindPose);
                }
                this.skeletons[s] = skeleton;
            }
        }
    },

    //
    // loadShape
    //
    loadShape: function sceneLoadShapeFn(shapeName, fileShapeName, loadParams)
    {
        var shape = this.shapes[shapeName];

        if (!shape)
        {
            var cachedSemantics = this.semantics;

            var sceneData = loadParams.data;
            var gd = loadParams.graphicsDevice;
            var keepVertexData = loadParams.keepVertexData;
            var fileShapes = sceneData.geometries;
            var fileShape = fileShapes[fileShapeName];
            var sources = fileShape.sources;
            var inputs = fileShape.inputs;
            var skeletonName = fileShape.skeleton;

            shape = Geometry.create();

            if (skeletonName)
            {
                var skeleton = this.skeletons[skeletonName];
                if (skeleton)
                {
                    shape.skeleton = skeleton;
                    shape.type = "skinned";
                }
                else
                {
                    // Failed to load skeleton so just draw bind pose
                    shape.type = "rigid";
                }
            }
            else
            {
                shape.type = "rigid";
            }

            if (gd)
            {
                // First calculate data about the vertex streams
                var offset, stride;
                var destStride;
                var destFormat;
                var maxOffset = 0;
                var vertexSources = [];

                var isUByte4Range = function isUByte4RangeFn(minVal, maxVal)
                {
                    return (minVal >= 0) && (maxVal <= 255) && (maxVal > 1);
                };

                var areInRange = function areInRangeFn(minVals, maxVals, isRangeFn)
                {
                    var numVals = minVals.length;
                    if (maxVals.length !== numVals)
                    {
                        return false;
                    }
                    for (var valIdx = 0 ; valIdx < numVals ; valIdx += 1)
                    {
                        if (!isRangeFn(minVals[valIdx], maxVals[valIdx]))
                        {
                            return false;
                        }
                    }
                    return true;
                };

                var formatMap = loadParams.vertexFormatMap || {};

                for (var input in inputs)
                {
                    if (inputs.hasOwnProperty(input))
                    {
                        var fileInput = inputs[input];
                        offset = fileInput.offset;
                        if (offset > maxOffset)
                        {
                            maxOffset = offset;
                        }
                        var fileSource = sources[fileInput.source];
                        var fileSourceStride = fileSource.stride;

                        // If the caller gave a preferred format, try
                        // to use it.

                        destFormat = formatMap[input];
                        destStride = fileSourceStride;

                        // If we got a caller preference, check for a
                        // new stride

                        if (destFormat)
                        {
                            if (destFormat.indexOf("4"))
                            {
                                destStride = 4;
                            }
                            else if (destFormat.indexOf("3")) {
                                destStride = 3;
                            }
                            else if (destFormat.indexOf("2"))
                            {
                                destStride = 2;
                            }
                            else if (destFormat.indexOf("1"))
                            {
                                destStride = 1;
                            }
                            else
                            { /* ERROR */
                                destFormat = null;
                            }
                        }

                        // No preferred format, make our own choice

                        if (!destFormat)
                        {
                            // Check for appropriate formats.  Make
                            // assumptions based on semantic names.

                            if (input === "BLENDINDICES" || input === "BLENDINDICES0")
                            {
                                if (fileSourceStride === 4 &&
                                    areInRange(fileSource.min, fileSource.max, isUByte4Range))
                                {
                                    destFormat = "UBYTE4";
                                }
                            }

                            // if (input == "NORMAL" || input == "NORMAL0")
                            // {
                            //     if (fileSourceStride == 3)
                            //     {
                            //         Check range is within [-1,1]

                            //         destFormat = "BYTE";
                            //         destFormatNormalized = true;
                            //         destStride = 4;
                            //     }
                            // }
                        }

                        // If we still don't have a format, revert to FLOATn

                        if (!destFormat)
                        {
                            destFormat = "FLOAT" + fileSourceStride;
                        }

                        vertexSources.push({
                            semantic: input,
                            offset: offset,
                            data: fileSource.data,
                            stride: fileSourceStride,
                            destFormat: destFormat,
                            destStride: destStride
                        });
                    }
                }
                var indicesPerVertex = (maxOffset + 1);

                if (0 < maxOffset)
                {
                    var vertexSourcesCompare = function (vertexSourceA, vertexSourceB)
                    {
                        if (vertexSourceA.offset === vertexSourceB.offset)
                        {
                            var semanticA = vertexSourceA.semantic;
                            if (typeof semanticA === 'string')
                            {
                                semanticA = gd['SEMANTIC_' + semanticA];
                            }
                            var semanticB = vertexSourceB.semantic;
                            if (typeof semanticB === 'string')
                            {
                                semanticB = gd['SEMANTIC_' + semanticB];
                            }
                            return (semanticA - semanticB);
                        }
                        else
                        {
                            return (vertexSourceA.offset - vertexSourceB.offset);
                        }
                    };
                    vertexSources.sort(vertexSourcesCompare);
                }

                var numVertexSources = vertexSources.length;
                var semanticsNames = [];
                var attributes = [];
                var useFloatArray = (this.float32ArrayConstructor ? true : false);
                var numValuesPerVertex = 0;
                var vs, vertexSource;
                for (vs = 0; vs < numVertexSources; vs += 1)
                {
                    vertexSource = vertexSources[vs];
                    semanticsNames[vs] = vertexSource.semantic;
                    destFormat = vertexSource.destFormat;
                    if (useFloatArray)
                    {
                        if (typeof destFormat === "string")
                        {
                            if (destFormat[0] !== "F")
                            {
                                useFloatArray = false;
                            }
                        }
                        else
                        {
                            if (destFormat !== gd.VERTEXFORMAT_FLOAT1 &&
                                destFormat !== gd.VERTEXFORMAT_FLOAT2 &&
                                destFormat !== gd.VERTEXFORMAT_FLOAT3 &&
                                destFormat !== gd.VERTEXFORMAT_FLOAT4)
                            {
                                useFloatArray = false;
                            }
                        }
                    }
                    attributes[vs] = destFormat;
                    numValuesPerVertex += vertexSource.stride;
                }

                // Now parse the surfaces to work out primitive types and the total vertex count
                var numVertices, totalNumVertices = 0;
                var noSurfaces = false;
                var surfaces = fileShape.surfaces;
                if (!surfaces)
                {
                    noSurfaces = true;
                    surfaces = {
                        singleSurface: {
                            triangles: fileShape.triangles,
                            lines: fileShape.lines,
                            numPrimitives: fileShape.numPrimitives
                        }
                    };
                }

                var surface;
                var destSurface;
                var faces;
                var s;

                for (s in surfaces)
                {
                    if (surfaces.hasOwnProperty(s))
                    {
                        surface = surfaces[s];
                        destSurface = {};
                        shape.surfaces[s] = destSurface;

                        faces = surface.triangles;
                        var primitive, vertexPerPrimitive;
                        if (faces)
                        {
                            primitive = gd.PRIMITIVE_TRIANGLES;
                            vertexPerPrimitive = 3;
                        }
                        else
                        {
                            faces = surface.lines;
                            if (faces)
                            {
                                primitive = gd.PRIMITIVE_LINES;
                                vertexPerPrimitive = 2;
                            }
                        }
                        destSurface.primitive = primitive;
                        destSurface.faces = faces;

                        if (faces)
                        {
                            if (1 < indicesPerVertex)
                            {
                                numVertices = (surface.numPrimitives * vertexPerPrimitive);
                                destSurface.numVertices = numVertices;
                            }
                            else
                            {

                                numVertices = (vertexSources[0].data.length / vertexSources[0].stride);
                                if (numVertices > faces.length)
                                {
                                    numVertices = faces.length;
                                }
                                destSurface.numVertices = numVertices;
                            }
                        }
                    }
                }

                // For cases where > 1-index per vertex we process it to create 1-index per vertex from data

                var updateSingleIndexTables =
                    function updateSingleIndexTablesFn(surface, indicesPerVertex,
                                                       verticesAsIndexLists,
                                                       verticesAsIndexListTable)
                {
                    var faces = surface.faces;
                    var numVerts = faces.length / indicesPerVertex;

                    var singleIndices = [];
                    singleIndices[numVerts - 1] = 0;

                    var hashIndexList = function hashIndexListFn(indexList)
                    {
                        return indexList.join(",");
                    };

                    var vertIdx = 0;
                    var srcIdx = 0;
                    var nextSrcIdx = indicesPerVertex;

                    while (srcIdx < faces.length)
                    {
                        var thisVert = faces.slice(srcIdx, nextSrcIdx);
                        var thisVertHash = hashIndexList(thisVert);

                        var thisVertIndex = verticesAsIndexListTable[thisVertHash];
                        if (!thisVertIndex)
                        {
                            // New index - add to tables

                            thisVertIndex = verticesAsIndexLists.length;
                            verticesAsIndexLists[thisVertIndex] = thisVert;
                            verticesAsIndexListTable[thisVertHash] = thisVertIndex;
                        }

                        singleIndices[vertIdx] = thisVertIndex;

                        srcIdx = nextSrcIdx;
                        nextSrcIdx += indicesPerVertex;
                        vertIdx += 1;
                    }

                    surface.faces = singleIndices;
                };

                if (indicesPerVertex > 1)
                {
                    // [ [a,b,c], [d,e,f], ... ]
                    var verticesAsIndexLists = [];
                    var verticesAsIndexListTable = {};

                    var shapeSurfaces = shape.surfaces;
                    for (s in shapeSurfaces)
                    {
                        if (shapeSurfaces.hasOwnProperty(s))
                        {
                            var shapeSurface = shapeSurfaces[s];
                            updateSingleIndexTables(shapeSurface,
                                                    indicesPerVertex,
                                                    verticesAsIndexLists,
                                                    verticesAsIndexListTable);
                        }
                    }

                    // recalc totalNumVertices

                    totalNumVertices = verticesAsIndexLists.length;

                    // Recreate vertex buffer data on the vertexSources

                    for (var vertSource in vertexSources)
                    {
                        if (vertexSources.hasOwnProperty(vertSource))
                        {
                            vertexSource = vertexSources[vertSource];
                            var thisSourceOffset = vertexSource.offset;
                            var thisSourceStride = vertexSource.stride;
                            var thisSourceData = vertexSource.data;

                            var newData = new Array(thisSourceStride * totalNumVertices);

                            // For each entry in index list

                            var vertIdx = 0;
                            while (vertIdx < totalNumVertices)
                            {
                                var newVBIdx = thisSourceStride * vertIdx;
                                var oldVBIdx = thisSourceStride * verticesAsIndexLists[vertIdx][thisSourceOffset];

                                // Copy the vertex data out of the vertex buffer

                                for (var attrIdx = 0 ;
                                     attrIdx < thisSourceStride ;
                                     attrIdx += 1)
                                {
                                    newData[newVBIdx + attrIdx] =
                                        thisSourceData[oldVBIdx + attrIdx];
                                }

                                vertIdx += 1;
                            }

                            vertexSource.data = newData;
                            vertexSource.offset = 0;
                        }
                    }

                    indicesPerVertex = 1;
                }

                Utilities.assert(indicesPerVertex === 1);

                totalNumVertices = vertexSources[0].data.length / vertexSources[0].stride;

                var vertexBufferManager = (loadParams.vertexBufferManager || this.vertexBufferManager);
                if (!vertexBufferManager)
                {
                    vertexBufferManager = VertexBufferManager.create(gd);
                    this.vertexBufferManager = vertexBufferManager;
                }

                var indexBufferManager = (loadParams.indexBufferManager || this.indexBufferManager);
                if (!indexBufferManager)
                {
                    indexBufferManager = IndexBufferManager.create(gd);
                    this.indexBufferManager = indexBufferManager;
                }

                var baseIndex;
                var vertexBuffer = null;
                var vertexBufferAllocation = vertexBufferManager.allocate(totalNumVertices, attributes);
                vertexBuffer = vertexBufferAllocation.vertexBuffer;
                if (!vertexBuffer)
                {
                    return undefined;
                }

                shape.vertexBuffer = vertexBuffer;
                shape.vertexBufferManager = vertexBufferManager;
                shape.vertexBufferAllocation = vertexBufferAllocation;

                baseIndex = vertexBufferAllocation.baseIndex;

                var indexBufferAllocation;
                var t, index, nextIndex;
                //
                // We no have the simple case of each index maps to one vertex so create one vertex buffer and fill in.
                //
                var vertexData = (useFloatArray ?
                                  new this.float32ArrayConstructor(totalNumVertices * numValuesPerVertex) :
                                  new Array(totalNumVertices * numValuesPerVertex));
                var vertexDataCount = 0;
                for (t = 0; t < totalNumVertices; t += 1)
                {
                    vs = 0;
                    do
                    {
                        vertexSource = vertexSources[vs];
                        var sourceData = vertexSource.data;
                        stride = vertexSource.stride;
                        index = t * stride;
                        nextIndex = (index + stride);
                        destStride = vertexSource.destStride;
                        do
                        {
                            vertexData[vertexDataCount] = sourceData[index];
                            vertexDataCount += 1;
                            index += 1;
                        }
                        while (index < nextIndex);

                        while (stride < destStride)
                        {
                            vertexData[vertexDataCount] = 0;
                            vertexDataCount += 1;
                            destStride -= 1;
                        }

                        vs += 1;
                    }
                    while (vs < numVertexSources);
                }
                vertexBuffer.setData(vertexData, baseIndex, totalNumVertices);

                // Count total num indices
                var isSequentialIndices = function isSequentialIndicesFn(indices, numIndices)
                {
                    var baseIndex = indices[0];
                    var n;
                    for (n = 1; n < numIndices; n += 1)
                    {
                        if (indices[n] !== (baseIndex + n))
                        {
                            return false;
                        }
                    }
                    return true;
                };

                var totalNumIndices = 0;
                var numIndices;

                for (s in surfaces)
                {
                    if (surfaces.hasOwnProperty(s))
                    {
                        destSurface = shape.surfaces[s];
                        faces = destSurface.faces;
                        if (faces)
                        {
                            numIndices = faces.length;
                            if (!isSequentialIndices(faces, numIndices))
                            {
                                totalNumIndices += numIndices;
                            }
                        }
                    }
                }

                var indexBuffer, indexBufferData, indexBufferBaseIndex, indexBufferOffset, maxIndex;
                if (0 < totalNumIndices)
                {
                    maxIndex = (baseIndex + totalNumVertices - 1);

                    indexBufferAllocation = indexBufferManager.allocate(totalNumIndices,
                                                                        (maxIndex < 65536 ? 'USHORT' : 'UINT'));
                    indexBuffer = indexBufferAllocation.indexBuffer;
                    if (!indexBuffer)
                    {
                        return undefined;
                    }

                    shape.indexBufferManager = indexBufferManager;
                    shape.indexBufferAllocation = indexBufferAllocation;

                    if (maxIndex < 65536 &&
                        this.uint16ArrayConstructor)
                    {
                        indexBufferData = new this.uint16ArrayConstructor(totalNumIndices);
                    }
                    else if (this.uint32ArrayConstructor)
                    {
                        indexBufferData = new this.uint32ArrayConstructor(totalNumIndices);
                    }
                    else
                    {
                        indexBufferData = new Array(totalNumIndices);
                    }

                    indexBufferBaseIndex = indexBufferAllocation.baseIndex;
                    indexBufferOffset = 0;
                }

                // Fill index buffers
                for (s in surfaces)
                {
                    if (surfaces.hasOwnProperty(s))
                    {
                        destSurface = shape.surfaces[s];

                        faces = destSurface.faces;
                        delete destSurface.faces;

                        if (faces)
                        {
                            // Vertices already de-indexed (1 index per vert)
                            numIndices = faces.length;

                            //See if they are all sequential, in which case we don't need an index buffer
                            if (!isSequentialIndices(faces, numIndices))
                            {
                                destSurface.indexBuffer = indexBuffer;
                                destSurface.numIndices = numIndices;
                                destSurface.first = (indexBufferBaseIndex + indexBufferOffset);

                                if (baseIndex)
                                {
                                    for (t = 0; t < numIndices; t += 1)
                                    {
                                        indexBufferData[indexBufferOffset] = (baseIndex + faces[t]);
                                        indexBufferOffset += 1;
                                    }
                                }
                                else
                                {
                                    for (t = 0; t < numIndices; t += 1)
                                    {
                                        indexBufferData[indexBufferOffset] = faces[t];
                                        indexBufferOffset += 1;
                                    }
                                }

                                if (keepVertexData)
                                {
                                    if (maxIndex < 65536 &&
                                        this.uint16ArrayConstructor)
                                    {
                                        destSurface.indexData = new this.uint16ArrayConstructor(faces);
                                    }
                                    else if (this.uint32ArrayConstructor)
                                    {
                                        destSurface.indexData = new this.uint32ArrayConstructor(faces);
                                    }
                                    else
                                    {
                                        destSurface.indexData = faces;
                                    }
                                }
                            }
                            else
                            {
                                destSurface.first = (baseIndex + faces[0]);
                            }

                            faces = null;

                            if (keepVertexData)
                            {
                                destSurface.vertexData = vertexData;
                            }
                        }
                        else
                        {
                            delete shape.surfaces[s];
                        }
                    }
                }

                if (indexBuffer)
                {
                    indexBuffer.setData(indexBufferData, indexBufferBaseIndex, totalNumIndices);
                    indexBufferData = null;
                }

                //Utilities.log("Buffers creation time: " + (TurbulenzEngine.time - startTime));

                var semanticsHash = semanticsNames.join();
                var semantics = cachedSemantics[semanticsHash];
                if (!semantics)
                {
                    semantics = gd.createSemantics(semanticsNames);
                    cachedSemantics[semanticsHash] = semantics;
                }
                shape.semantics = semantics;

                if (noSurfaces)
                {
                    // TODO: could remove this and always have surfaces
                    surface = shape.surfaces.singleSurface;

                    if (surface)
                    {
                        shape.primitive = surface.primitive;
                        if (keepVertexData)
                        {
                            shape.vertexData = surface.vertexData;
                        }

                        shape.first = surface.first;

                        if (surface.indexBuffer)
                        {
                            shape.indexBuffer = surface.indexBuffer;
                            shape.numIndices = surface.numIndices;
                            if (keepVertexData)
                            {
                                shape.indexData = surface.indexData;
                            }
                        }
                        else
                        {
                            shape.numVertices = surface.numVertices;
                        }
                    }

                    delete shape.surfaces;
                }
            }

            if (inputs.POSITION)
            {
                var positions = sources[inputs.POSITION.source];
                var minPos = positions.min;
                var maxPos = positions.max;
                if (minPos && maxPos)
                {
                    var min0 = minPos[0];
                    var min1 = minPos[1];
                    var min2 = minPos[2];
                    var max0 = maxPos[0];
                    var max1 = maxPos[1];
                    var max2 = maxPos[2];

                    var halfExtents = (this.float32ArrayConstructor ?
                                       new this.float32ArrayConstructor(3) :
                                       new Array(3));
                    shape.halfExtents = halfExtents;
                    if (min0 !== -max0 || min1 !== -max1 || min2 !== -max2)
                    {
                        var center = (this.float32ArrayConstructor ?
                                      new this.float32ArrayConstructor(3) :
                                      new Array(3));
                        shape.center = center;
                        center[0] = (min0 + max0) * 0.5;
                        center[1] = (min1 + max1) * 0.5;
                        center[2] = (min2 + max2) * 0.5;
                        halfExtents[0] = (max0 - center[0]);
                        halfExtents[1] = (max1 - center[1]);
                        halfExtents[2] = (max2 - center[2]);
                    }
                    else
                    {
                        halfExtents[0] = (max0 - min0) * 0.5;
                        halfExtents[1] = (max1 - min1) * 0.5;
                        halfExtents[2] = (max2 - min2) * 0.5;
                    }
                }
                //else
                //{
                    //TODO: add warning that we have no extents information
                //}
            }

            this.shapes[shapeName] = shape;
            shape.name = shapeName;
            shape.reference.subscribeDestroyed(this.onGeometryDestroyed);
        }
        return shape;
    },

    streamShapes: function sceneStreamShapesFn(loadParams, postLoadFn)
    {
        // Firstly build an array listing all the shapes we need to load
        var yieldFn = loadParams.yieldFn;
        var scene = this;
        var shapesNamePrefix = loadParams.shapesNamePrefix;
        var sceneData = loadParams.data;
        var fileShapes = sceneData.geometries;
        var loadCustomShapeFn = loadParams.loadCustomShapeFn;

        var shapesToLoad = [];
        var customShapesToLoad = [];

        for (var fileShapeName in fileShapes)
        {
            if (fileShapes.hasOwnProperty(fileShapeName))
            {
                var fileShape = fileShapes[fileShapeName];
                if (fileShape.meta && fileShape.meta.graphics)
                {
                    if (fileShape.meta.custom)
                    {
                        customShapesToLoad.push(fileShapeName);
                    }
                    else
                    {
                        shapesToLoad.push(fileShapeName);
                    }
                }
            }
        }

        function sceneLoadNextShapeFn()
        {
            var nextShape = shapesToLoad.pop();

            var shapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + nextShape) : nextShape);
            scene.loadShape(shapeName, nextShape, loadParams);

            if (shapesToLoad.length)
            {
                yieldFn(sceneLoadNextShapeFn);
            }
            else
            {
                yieldFn(postLoadFn);
            }
        }

        function sceneLoadNextCustomShapeFn()
        {
            var nextShape = customShapesToLoad.pop();

            var shapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + nextShape) : nextShape);
            loadCustomShapeFn.call(scene, shapeName, nextShape, loadParams);

            if (customShapesToLoad.length)
            {
                yieldFn(sceneLoadNextCustomShapeFn);
            }
            else if (shapesToLoad.length)
            {
                yieldFn(sceneLoadNextShapeFn);
            }
            else
            {
                yieldFn(postLoadFn);
            }
        }

        if (customShapesToLoad.length)
        {
            yieldFn(sceneLoadNextCustomShapeFn);
        }
        else if (shapesToLoad.length)
        {
            yieldFn(sceneLoadNextShapeFn);
        }
        else
        {
            yieldFn(postLoadFn);
        }
    },

    //
    // Load lights
    //
    loadLights: function sceneLoadLightsFn(loadParams)
    {
        var sceneData = loadParams.data;
        var textureManager = loadParams.textureManager;

        if (!loadParams.append)
        {
            this.lights = {};
            this.globalLights = [];
        }

        var fileLights = sceneData.lights;
        var lights = this.lights;
        var globalLights = this.globalLights;
        var materials = this.materials;
        var beget = Utilities.beget;

        var md = loadParams.mathDevice;
        var v3Build = md.v3Build;

        for (var l in fileLights)
        {
            if (fileLights.hasOwnProperty(l) &&
                !lights[l])
            {
                var fileLight = fileLights[l];

                // convert to create parameters
                var lightParams = beget(fileLight);

                var type = fileLight.type;
                if (type === 'directional')
                {
                    lightParams.directional = true;
                }
                else if (type === 'spot')
                {
                    lightParams.spot = true;
                }
                else if (type === 'ambient')
                {
                    lightParams.ambient = true;
                }
                else //if (type === 'point')
                {
                    lightParams.point = true;
                }

                // Convert to MathDevice objects
                lightParams.color = fileLight.color && v3Build.apply(md, fileLight.color);

                /*jshint white: false*/
                lightParams.origin = fileLight.origin && v3Build.apply(md, fileLight.origin);
                lightParams.center = fileLight.center && v3Build.apply(md, fileLight.center);
                lightParams.target = fileLight.target && v3Build.apply(md, fileLight.target);
                lightParams.right =  fileLight.right  && v3Build.apply(md, fileLight.right);
                lightParams.up =     fileLight.up     && v3Build.apply(md, fileLight.up);
                lightParams.start =  fileLight.start  && v3Build.apply(md, fileLight.start);
                lightParams.end =    fileLight.end    && v3Build.apply(md, fileLight.end);
                lightParams.direction = fileLight.direction && v3Build.apply(md, fileLight.direction);
                /*jshint white: true*/

                lightParams.halfExtents = fileLight.halfextents && v3Build.apply(md, fileLight.halfextents);

                var materialName = fileLight.material;
                if (materialName)
                {
                    var material = materials[materialName];
                    if (material)
                    {
                        lightParams.material = material;

                        if (material.effectName)
                        {
                            delete material.effectName;
                            material.loadTextures(textureManager);
                        }
                    }
                }

                var light = Light.create(lightParams);
                lights[l] = light;
                if (light.isGlobal())
                {
                    globalLights.push(light);
                }
            }
        }
    },

    //
    // loadNodes
    //
    loadNodes: function sceneLoadNodesFn(loadParams)
    {
        var sceneData = loadParams.data;
        var gd = loadParams.graphicsDevice;
        var textureManager = loadParams.textureManager;
        var effectManager = loadParams.effectManager;
        var baseScene = loadParams.baseScene;
        var keepCameras = loadParams.keepCameras;
        var keepLights = loadParams.keepLights;
        var disableNodes = loadParams.disabled;

        if (!loadParams.append)
        {
            this.clearRootNodes();
            this.staticSpatialMap = AABBTree.create(true);
            this.dynamicSpatialMap = AABBTree.create();
        }

        var loadCustomGeometryInstanceFn = loadParams.loadCustomGeometryInstanceFn;

        var md = this.md;
        var m43Build = md.m43Build;
        var materials = this.materials;
        var lights = this.lights;
        var currentScene = this;

        var baseMaterials;
        if (baseScene)
        {
            baseMaterials = baseScene.materials;
        }
        var baseMatrix = loadParams.baseMatrix;
        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var shapesNamePrefix = loadParams.shapesNamePrefix;

        function copyNodeFn(nodeName, parentNodePath, baseNode, materialSkin)
        {
            var nodePath = parentNodePath ? (parentNodePath + "/" + nodeName) : nodeName;

            var node = SceneNode.create({name: nodeName,
                                         local: this.matrix && m43Build.apply(md, this.matrix),
                                         dynamic: this.dynamic || baseNode.dynamic || loadParams.dynamic});

            var effect;

            var customgeometryinstance = this.customgeometryinstances;
            if (customgeometryinstance && loadCustomGeometryInstanceFn)
            {
                for (var ci in customgeometryinstance)
                {
                    if (customgeometryinstance.hasOwnProperty(ci))
                    {
                        var fileCustomGeometryInstance = customgeometryinstance[ci];
                        var customGeometryInstance = loadCustomGeometryInstanceFn.call(currentScene, fileCustomGeometryInstance, loadParams);

                        if (customGeometryInstance)
                        {
                            node.addRenderable(customGeometryInstance);
                        }
                    }
                }
            }

            var geometryinstances = this.geometryinstances;
            if (geometryinstances)
            {
                for (var gi in geometryinstances)
                {
                    if (geometryinstances.hasOwnProperty(gi))
                    {
                        var fileGeometryInstance = geometryinstances[gi];
                        var fileShapeName = fileGeometryInstance.geometry;
                        var shapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + fileShapeName) : fileShapeName);
                        var nodeShape = currentScene.loadShape(shapeName, fileShapeName, loadParams);

                        if (gd)
                        {
                            var sharedMaterialName = fileGeometryInstance.material;
                            if (materialSkin && sceneData.skins)
                            {
                                var skin = sceneData.skins[materialSkin];
                                if (skin)
                                {
                                    var newMaterialName = skin[sharedMaterialName];
                                    if (newMaterialName)
                                    {
                                        sharedMaterialName = newMaterialName;
                                    }
                                }
                            }
                            var sharedMaterial = materials[sharedMaterialName];
                            if (!sharedMaterial)
                            {
                                if (baseScene)
                                {
                                    sharedMaterial = baseMaterials[sharedMaterialName];
                                }

                                if (!sharedMaterial)
                                {
                                    //Utilities.log("Unknown material '" + sharedMaterialName + "'");
                                    return undefined;
                                }
                                materials[sharedMaterialName] = sharedMaterial;
                                sharedMaterial.name = sharedMaterialName;
                                sharedMaterial.reference.subscribeDestroyed(currentScene.onMaterialDestroyed);
                            }
                            effect = sharedMaterial.effect;
                            if (!effect)
                            {
                                // Load the textures since if the effect is undefined then scene.loadMaterial
                                // has not yet been called for this material
                                sharedMaterial.loadTextures(textureManager);
                                var effectName = sharedMaterial.effectName;
                                delete sharedMaterial.effectName;
                                effect = effectManager.get(effectName);
                                if (effect)
                                {
                                    effect.prepareMaterial(sharedMaterial);
                                }
                            }

                            var surfaces = nodeShape.surfaces;
                            var surface = (surfaces ? surfaces[fileGeometryInstance.surface] : nodeShape);

                            var geometryInstance = GeometryInstance.create(nodeShape,
                                                                           surface,
                                                                           sharedMaterial);
                            node.addRenderable(geometryInstance);

                            if (fileGeometryInstance.disabled)
                            {
                                geometryInstance.disabled = true;
                            }

                        }
                        else
                        {
                            node.addRenderable(GeometryInstance.create(nodeShape));
                        }
                    }
                }
            }

            // Check for a camera on the node
            if (this.camera)
            {
                if (keepCameras)
                {
                    node.camera = this.camera;
                }
            }

            // Check for any instances of lights attached to the node
            var fileLightInstances = this.lightinstances;
            if (fileLightInstances && keepLights)
            {
                for (var li in fileLightInstances)
                {
                    if (fileLightInstances.hasOwnProperty(li))
                    {
                        var fileLightInstance = fileLightInstances[li];
                        var light = lights[fileLightInstance.light];
                        if (light && !light.global)
                        {
                            var lightInstance = LightInstance.create(light);
                            node.addLightInstance(lightInstance);
                            if (fileLightInstance.disabled)
                            {
                                lightInstance.disabled = true;
                            }
                        }
                    }
                }
            }

            if (this.reference)
            {
                alert("Found unresolved node reference during scene loading");
            }

            if (this.kinematic || baseNode.kinematic)
            {
                node.kinematic = true;
            }

            if ((this.disabled || baseNode.disabled) && (disableNodes !== false))
            {
                node.disabled = true;
            }

            var fileChildren = this.nodes;

            if (fileChildren)
            {
                for (var c in fileChildren)
                {
                    if (fileChildren.hasOwnProperty(c))
                    {
                        if (!node.findChild(c))
                        {
                            var child = copyNodeFn.call(fileChildren[c], c, nodePath, node, this.skin || materialSkin);
                            if (child)
                            {
                                node.addChild(child);
                            }
                        }
                    }
                }
            }

            return node;
        }

        var fileNodes = sceneData.nodes;
        var parentNode = loadParams.parentNode;

        var emptyNode = {};
        for (var fn in fileNodes)
        {
            if (fileNodes.hasOwnProperty(fn))
            {
                var fileNode = fileNodes[fn];
                var nodeName = fn;
                var nodePath = (nodesNamePrefix ? (nodesNamePrefix + "/" + fn) : fn);
                var overloadedNode = currentScene.findNode(nodePath); //If a node with the same name exist already we update that.

                var node = copyNodeFn.call(fileNode,
                                           nodeName,
                                           nodesNamePrefix,
                                           (overloadedNode || parentNode || emptyNode),
                                           fileNode.skin || loadParams.materialSkin);
                if (node)
                {
                    if (parentNode && !overloadedNode)
                    {
                        parentNode.addChild(node);
                    }

                    if (baseMatrix)
                    {
                        if (node.local)
                        {
                            node.setLocalTransform(md.m43Mul(node.getLocalTransform(), baseMatrix));
                        }
                        else
                        {
                            node.setLocalTransform(baseMatrix);
                        }
                    }
                    else
                    {
                        if (!node.local)
                        {
                            node.setLocalTransform(md.m43BuildIdentity());
                        }
                    }

                    if (disableNodes)
                    {
                        node.enableHierarchy(false);
                    }

                    if (overloadedNode)
                    {
                        //Utilities.log("Overloaded node '" + nodePath + "'");

                        var overloadedMatrix = overloadedNode.local;
                        if (overloadedMatrix && node.local)
                        {
                            node.local = md.m43Mul(node.local, overloadedMatrix);
                            overloadedNode.setLocalTransform(node.local);
                            delete node.local;
                        }

                        var overloadedChildren = overloadedNode.children;
                        if (overloadedChildren && node.children)
                        {
                            //Utilities.log("Concat children of node '" + nodePath + "'");
                            while (node.children.length)
                            {
                                var child = node.children[0];
                                if (!overloadedNode.findChild(child.name))
                                {
                                    overloadedNode.addChild(child);
                                }
                                node.removeChild(child);
                            }
                        }

                        for (var on in node)
                        {   //TODO: This really doesn't work other than simple objects....
                            if (node.hasOwnProperty(on))
                            {
                                overloadedNode[on] = node[on];
                            }
                        }
                        node = null;
                    }
                    else if (!parentNode)
                    {
                        this.addRootNode(node);
                    }
                }
            }
        }
    },

    //
    // loadAreas
    //
    loadAreas: function sceneLoadAreasNodesFn(loadParams)
    {
        var sceneData = loadParams.data;

        var fileAreas = sceneData.areas;
        if (!fileAreas)
        {
            return;
        }

        var numFileAreas = fileAreas.length;
        if (numFileAreas <= 0)
        {
            return;
        }

        if (!loadParams.append)
        {
            delete this.areas;
        }

        var areas = this.areas;
        if (!areas)
        {
            areas = [];
            this.areas = areas;
        }

        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var md = this.md;
        var planeNormalize = this.planeNormalize;
        var baseIndex = areas.length;

        var maxValue = Number.MAX_VALUE;

        for (var fa = 0; fa < numFileAreas; fa += 1)
        {
            var fileArea = fileAreas[fa];

            var targetName = fileArea.target;
            if (nodesNamePrefix)
            {
                targetName = (nodesNamePrefix + "/" + targetName);
            }
            var target = this.findNode(targetName);
            if (!target)
            {
                //Utilities.log("Missing target: " + targetName);
                baseIndex -= 1;
                continue;
            }

            var matrix = target.getWorldTransform();
            var m0 = matrix[0];
            var m1 = matrix[1];
            var m2 = matrix[2];
            var m3 = matrix[3];
            var m4 = matrix[4];
            var m5 = matrix[5];
            var m6 = matrix[6];
            var m7 = matrix[7];
            var m8 = matrix[8];
            var m9 = matrix[9];
            var m10 = matrix[10];
            var m11 = matrix[11];

            var minAreaX = maxValue;
            var minAreaY = maxValue;
            var minAreaZ = maxValue;
            var maxAreaX = -maxValue;
            var maxAreaY = -maxValue;
            var maxAreaZ = -maxValue;

            var filePortals = fileArea.portals;
            var numFilePortals = filePortals.length;
            var portals = [];
            var filePortal, filePoints, points, numPoints, np, filePoint;
            for (var fp = 0; fp < numFilePortals; fp += 1)
            {
                var minX = maxValue;
                var minY = maxValue;
                var minZ = maxValue;
                var maxX = -maxValue;
                var maxY = -maxValue;
                var maxZ = -maxValue;
                var c0 = 0;
                var c1 = 0;
                var c2 = 0;
                filePortal = filePortals[fp];
                filePoints = filePortal.points;
                numPoints = filePoints.length;
                points = [];
                for (np = 0; np < numPoints; np += 1)
                {
                    filePoint = filePoints[np];
                    var fp0 = filePoint[0];
                    var fp1 = filePoint[1];
                    var fp2 = filePoint[2];
                    var p0 = (m0 * fp0 + m3 * fp1 + m6 * fp2 + m9);
                    var p1 = (m1 * fp0 + m4 * fp1 + m7 * fp2 + m10);
                    var p2 = (m2 * fp0 + m5 * fp1 + m8 * fp2 + m11);
                    /*jshint white: false */
                    if (p0 < minX) { minX = p0; }
                    if (p1 < minY) { minY = p1; }
                    if (p2 < minZ) { minZ = p2; }
                    if (p0 > maxX) { maxX = p0; }
                    if (p1 > maxY) { maxY = p1; }
                    if (p2 > maxZ) { maxZ = p2; }
                    /*jshint white: true */
                    c0 += p0;
                    c1 += p1;
                    c2 += p2;
                    points.push(md.v3Build(p0, p1, p2));
                }
                /*jshint white: false */
                if (minX < minAreaX) { minAreaX = minX; }
                if (minY < minAreaY) { minAreaY = minY; }
                if (minZ < minAreaZ) { minAreaZ = minZ; }
                if (maxX > maxAreaX) { maxAreaX = maxX; }
                if (maxY > maxAreaY) { maxAreaY = maxY; }
                if (maxZ > maxAreaZ) { maxAreaZ = maxZ; }
                /*jshint white: true */
                var normal = md.v3Cross(md.v3Sub(points[1], points[0]), md.v3Sub(points[2], points[0]));

                var portalExtents = (this.float32ArrayConstructor ?
                                     new this.float32ArrayConstructor(6) :
                                     new Array(6));
                portalExtents[0] = minX;
                portalExtents[1] = minY;
                portalExtents[2] = minZ;
                portalExtents[3] = maxX;
                portalExtents[4] = maxY;
                portalExtents[5] = maxZ;

                var portalOrigin = (this.float32ArrayConstructor ?
                                    new this.float32ArrayConstructor(3) :
                                    new Array(3));
                portalOrigin[0] = (c0 / numPoints);
                portalOrigin[1] = (c1 / numPoints);
                portalOrigin[2] = (c2 / numPoints);

                var portal = {
                    area: (baseIndex + filePortal.area),
                    points: points,
                    origin: portalOrigin,
                    extents: portalExtents,
                    plane: planeNormalize(normal[0], normal[1], normal[2], md.v3Dot(normal, points[0]))
                };
                portals.push(portal);
            }

            var areaExtents = (this.float32ArrayConstructor ?
                               new this.float32ArrayConstructor(6) :
                               new Array(6));
            areaExtents[0] = minAreaX;
            areaExtents[1] = minAreaY;
            areaExtents[2] = minAreaZ;
            areaExtents[3] = maxAreaX;
            areaExtents[4] = maxAreaY;
            areaExtents[5] = maxAreaZ;

            var area = {
                target: target,
                portals: portals,
                extents: areaExtents,
                externalNodes: null
            };
            areas.push(area);
        }

        // Keep bsp tree
        var ArrayConstructor = (this.float32ArrayConstructor ?
                                this.float32ArrayConstructor :
                                Array);
        var fileBspNodes = sceneData.bspnodes;
        var numBspNodes = fileBspNodes.length;
        var bspNodes = [];
        bspNodes.length = numBspNodes;
        this.bspNodes = bspNodes;
        for (var bn = 0; bn < numBspNodes; bn += 1)
        {
            var fileBspNode = fileBspNodes[bn];
            var plane = fileBspNode.plane;
            var nodePlane = new ArrayConstructor(4);
            nodePlane[0] = plane[0];
            nodePlane[1] = plane[1];
            nodePlane[2] = plane[2];
            nodePlane[3] = -plane[3];
            bspNodes[bn] = {
                    plane: nodePlane,
                    pos: fileBspNode.pos,
                    neg: fileBspNode.neg
                };
        }
    },

    //
    // load
    //
    load: function sceneLoadFn(loadParams)
    {
        var scene = this;

        if (!loadParams.append)
        {
            this.clearShapes();
            this.semantics = {};
        }

        var sceneCompleteLoadStage = function sceneCompleteLoadStageFn()
        {
            if (loadParams.keepLights)
            {
                scene.loadLights(loadParams);
            }

            scene.loadNodes(loadParams);

            if (loadParams.physicsManager)
            {
                loadParams.physicsManager.loadNodes(loadParams, scene);
            }

            scene.loadAreas(loadParams);

            scene.endLoading(loadParams.onload);
        };

        if (loadParams.graphicsDevice)
        {
            this.loadMaterials(loadParams);
        }

        // Needs to be called before the geometry is loaded by loadNodes or streamShapes
        scene.loadSkeletons(loadParams);

        var yieldFn = loadParams.yieldFn;
        if (yieldFn)
        {
            var streamNodesStage = function sceneStreamNodesStage()
            {
                scene.streamShapes(loadParams, sceneCompleteLoadStage);
            };
            yieldFn(streamNodesStage);
        }
        else
        {
            sceneCompleteLoadStage();
        }
    },

    planeNormalize : function scenePlaneNormalizeFn(a, b, c, d, output)
    {
        if (!output)
        {
            var float32ArrayConstructor = Scene.prototype.float32ArrayConstructor;
            output = (float32ArrayConstructor ?
                      new float32ArrayConstructor(4) :
                      new Array(4));
        }

        var lsq = ((a * a) + (b * b) + (c * c));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            output[0] = (a * lr);
            output[1] = (b * lr);
            output[2] = (c * lr);
            output[3] = (d * lr);
        }
        else
        {
            output[0] = 0;
            output[1] = 0;
            output[2] = 0;
            output[3] = 0;
        }

        return output;
    },

    isInsidePlanesAABB : function sceneIsInsidePlanesAABBFn(extents, planes)
    {
        var n0 = extents[0];
        var n1 = extents[1];
        var n2 = extents[2];
        var p0 = extents[3];
        var p1 = extents[4];
        var p2 = extents[5];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isFullyInsidePlanesAABB : function sceneIsFullyInsidePlanesAABBFn(extents, planes)
    {
        var n0 = extents[0];
        var n1 = extents[1];
        var n2 = extents[2];
        var p0 = extents[3];
        var p1 = extents[4];
        var p2 = extents[5];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    extractFrustumPlanes: function sceneExtractFrustumPlanesFn(camera)
    {
        var planeNormalize = this.planeNormalize;
        var m = camera.viewProjectionMatrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];
        var planes = this.frustumPlanes;

        // Negate 'd' here to avoid doing it on the isVisible functions
        planes[0] = planeNormalize((m3 + m0), (m7 + m4), (m11 + m8), -(m15 + m12), planes[0]); // left
        planes[1] = planeNormalize((m3 - m0), (m7 - m4), (m11 - m8), -(m15 - m12), planes[1]); // right
        planes[2] = planeNormalize((m3 - m1), (m7 - m5), (m11 - m9), -(m15 - m13), planes[2]); // top
        planes[3] = planeNormalize((m3 + m1), (m7 + m5), (m11 + m9), -(m15 + m13), planes[3]); // bottom

        if (this.areas)
        {
            if (planes.length > 4)
            {
                planes.length = 4;
            }
        }
        else
        {
            planes[4] = planeNormalize((m3 - m2), (m7 - m6), (m11 - m10), -(m15 - m14), planes[4]); // far
        }

        this.nearPlane = planeNormalize((m3 + m2), (m7 + m6), (m11 + m10), -(m15 + m14), this.nearPlane);  // near

        return planes;
    },

    //
    // calculateHullScreenExtents
    //
    calculateHullScreenExtents : function sceneCalculateHullScreenExtents(polygons, screenExtents)
    {
        // Sutherland-Hodgman polygon clipping algorithm
        function clipLine(va, vb, axis, positive, out)
        {
            var a = va[axis];
            var b = vb[axis];
            var aw = va[3];
            var bw = vb[3];
            var t = 0.0;
            var bInside = true;
            if (positive)
            {
                if (a > aw)
                {
                    if (b <= bw)
                    {
                        if (b < bw)
                        {
                            t = ((aw - a) / ((b - a) - (bw - aw)));
                        }
                    }
                    else
                    {
                        // both out
                        return;
                    }
                }
                else if (b > bw)
                {
                    if (a < aw)
                    {
                        t = ((aw - a) / ((b - a) - (bw - aw)));
                    }
                    bInside = false;
                }
            }
            else
            {
                if (a < -aw)
                {
                    if (b >= -bw)
                    {
                        if (b > -bw)
                        {
                            t = ((- aw - a) / ((b - a) + (bw - aw)));
                        }
                    }
                    else
                    {
                        // both out
                        return;
                    }
                }
                else if (b < -bw)
                {
                    if (a > -aw)
                    {
                        t = ((- aw - a) / ((b - a) + (bw - aw)));
                    }
                    bInside = false;
                }
            }

            if (t > 0.0)
            {
                var ax = va[0];
                var ay = va[1];
                var az = va[2];
                var bx = vb[0];
                var by = vb[1];
                var bz = vb[2];
                out.push([ (ax + (t * (bx - ax))),
                           (ay + (t * (by - ay))),
                           (az + (t * (bz - az))),
                           (aw + (t * (bw - aw))) ]);
            }

            if (bInside)
            {
                out.push(vb);
            }
        }

        var minX =  1.0;
        var maxX = -1.0;
        var minY =  1.0;
        var maxY = -1.0;

        var numPolygons = polygons.length;
        for (var n = 0; n < numPolygons; n += 1)
        {
            var points = polygons[n];
            var numPoints, p, a, b, out;
            for (var positive = 0; positive < 2; positive += 1)
            {
                for (var axis = 0; axis < 3; axis += 1)
                {
                    numPoints = points.length;
                    if (!numPoints)
                    {
                        break;
                    }
                    out = [];
                    for (p = 0; p < numPoints; p += 1)
                    {
                        if (p < 1)
                        {
                            a = points[numPoints - 1];
                        }
                        else
                        {
                            a = points[p - 1];
                        }
                        b = points[p];
                        clipLine(a, b, axis, positive, out);
                    }
                    points = out;
                }
            }

            numPoints = points.length;
            for (p = 0; p < numPoints; p += 1)
            {
                a = points[p];
                var ax = a[0];
                var ay = a[1];
                var aw = a[3];
                if (aw === 0)
                {
                    ax = (ax >= 0 ? 1 : -1);
                    ay = (ay >= 0 ? 1 : -1);
                }
                else
                {
                    var rcpa = 1.0 / aw;
                    ax *= rcpa;
                    ay *= rcpa;
                }
                if (minX > ax)
                {
                    minX = ax;
                }
                if (maxX < ax)
                {
                    maxX = ax;
                }
                if (minY > ay)
                {
                    minY = ay;
                }
                if (maxY < ay)
                {
                    maxY = ay;
                }
            }
        }

        if (minX >= maxX || minY >= maxY)
        {
            return undefined;
        }

        if (minX < -1.0)
        {
            minX = -1.0;
        }
        if (maxX > 1.0)
        {
            maxX = 1.0;
        }
        if (minY < -1.0)
        {
            minY = -1.0;
        }
        if (maxY > 1.0)
        {
            maxY = 1.0;
        }

        if (!screenExtents)
        {
            screenExtents = (this.float32ArrayConstructor ?
                             new this.float32ArrayConstructor(4) :
                             new Array(4));
        }
        screenExtents[0] = minX;
        screenExtents[1] = minY;
        screenExtents[2] = maxX;
        screenExtents[3] = maxY;
        return screenExtents;
    },

    //
    // calculateLightsScreenExtents
    //
    calculateLightsScreenExtents : function sceneCalculateLightsScreenExtentsFn(camera)
    {
        var visibleLights = this.visibleLights;
        var numVisibleLights = visibleLights.length;
        if (numVisibleLights > 0)
        {
            var matrix, transform, halfExtents, center, hx, hy, hz, p0, p1, p2, p3, p4, p5, p6, p7, st, polygons;
            var lightInstance, light, worldViewProjectionMatrix;
            var viewProjectionMatrix = camera.viewProjectionMatrix;
            var calculateHullScreenExtents = this.calculateHullScreenExtents;
            var md = this.md;
            var m44Transform = md.m44Transform;
            var m43MulM44 = md.m43MulM44;
            var v4Build = md.v4Build;
            var spotA = v4Build.call(md, -1, -1, 1, 1);
            var spotB = v4Build.call(md,  1, -1, 1, 1);
            var spotC = v4Build.call(md, -1,  1, 1, 1);
            var spotD = v4Build.call(md,  1,  1, 1, 1);
            var n = 0;
            do
            {
                lightInstance = visibleLights[n];
                light = lightInstance.light;
                if (light)
                {
                    if (light.global)
                    {
                        continue;
                    }

                    matrix = lightInstance.node.world;

                    if (light.spot)
                    {
                        transform = md.m33MulM43(light.frustum, matrix, transform);

                        worldViewProjectionMatrix = m43MulM44.call(md, transform, viewProjectionMatrix, worldViewProjectionMatrix);

                        p0 = m44Transform.call(md, worldViewProjectionMatrix, spotA, p0);
                        p1 = m44Transform.call(md, worldViewProjectionMatrix, spotB, p1);
                        p2 = m44Transform.call(md, worldViewProjectionMatrix, spotC, p2);
                        p3 = m44Transform.call(md, worldViewProjectionMatrix, spotD, p3);

                        st = v4Build.call(md, matrix[9], matrix[10], matrix[11], 1, st);
                        st = m44Transform.call(md, viewProjectionMatrix, st, st);

                        polygons = [ [st, p0, p1],
                                     [st, p1, p3],
                                     [st, p2, p0],
                                     [st, p3, p2],
                                     [p2, p3, p1, p0]];
                    }
                    else
                    {
                        halfExtents = light.halfExtents;
                        if (!light.fog)
                        {
                            center = light.center;
                            if (center)
                            {
                                matrix = transform = md.m43Offset(matrix, center, transform);
                            }
                        }

                        hx = halfExtents[0];
                        hy = halfExtents[1];
                        hz = halfExtents[2];

                        worldViewProjectionMatrix = m43MulM44.call(md, matrix, viewProjectionMatrix, worldViewProjectionMatrix);

                        p0 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, - hy, - hz, 1, p0), p0);
                        p1 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, - hy, - hz, 1, p1), p1);
                        p2 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, - hy, + hz, 1, p2), p2);
                        p3 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, - hy, + hz, 1, p3), p3);
                        p4 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, + hy, - hz, 1, p4), p4);
                        p5 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, + hy, - hz, 1, p5), p5);
                        p6 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, + hx, + hy, + hz, 1, p6), p6);
                        p7 = m44Transform.call(md, worldViewProjectionMatrix, v4Build.call(md, - hx, + hy, + hz, 1, p7), p7);

                        polygons = [ [p3, p2, p1, p0],
                                     [p4, p5, p6, p7],
                                     [p0, p1, p5, p4],
                                     [p7, p6, p2, p3],
                                     [p4, p7, p3, p0],
                                     [p1, p2, p6, p5] ];
                    }

                    lightInstance.screenExtents = calculateHullScreenExtents(polygons, lightInstance.screenExtents);
                }

                n += 1;
            }
            while (n < numVisibleLights);
        }
    },

    //
    // destroy
    //
    destroy: function sceneDestroyFn()
    {
        this.clear();
        if (this.vertexBufferManager)
        {
            this.vertexBufferManager.destroy();
            delete this.vertexBufferManager;
        }
        if (this.indexBufferManager)
        {
            this.indexBufferManager.destroy();
            delete this.indexBufferManager;
        }
    },

    getQueryCounter: function sceneGetQueryCounter()
    {
        var queryCounter = this.queryCounter;
        this.queryCounter = (queryCounter + 1);
        return queryCounter;
    }
};

// Constructor function
Scene.create = function sceneCreateFn(mathDevice)
{
    var newScene = new Scene();
    newScene.md = mathDevice;
    newScene.clear();

    newScene.onGeometryDestroyed = function sceneOnGeometryDestroyedFn(geometry)
    {
        var scene = newScene;
        geometry.reference.unsubscribeDestroyed(scene.onGeometryDestroyed);
        delete scene.shapes[geometry.name];
    };

    newScene.onMaterialDestroyed = function sceneOnMaterialDestroyedFn(material)
    {
        var scene = newScene;
        material.reference.unsubscribeDestroyed(scene.onMaterialDestroyed);
        delete scene.materials[material.name];
    };

    return newScene;
};

// Detect correct typed arrays
(function () {
    var testArray, textDescriptor;
    if (typeof Uint16Array !== "undefined")
    {
        testArray = new Uint16Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Uint16Array]')
        {
            Scene.prototype.uint16ArrayConstructor = Uint16Array;
        }
    }
    if (typeof Uint32Array !== "undefined")
    {
        testArray = new Uint32Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Uint32Array]')
        {
            Scene.prototype.uint32ArrayConstructor = Uint32Array;
        }
    }
    if (typeof Float32Array !== "undefined")
    {
        testArray = new Float32Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            Scene.prototype.float32ArrayConstructor = Float32Array;
        }
    }
}());


// Copyright (c) 2009-2011 Turbulenz Limited
/*global Utilities: false*/



function Effect() {}

Effect.prototype =
{
    version : 1,

    //
    // prepareMaterial
    //
    prepareMaterial : function effectPrepareMaterialFn(material)
    {
        material.meta.materialIndex = this.numMaterials;
        material.effect = this;
        this.numMaterials += 1;
    },

    //
    // add
    //
    add : function effectAddFn(geometryType, prepareObject)
    {
        this.geometryType[geometryType] = prepareObject;
    },

    //
    // remove
    //
    remove : function effectRemoveFn(geometryType)
    {
        delete this.geometryType[geometryType];
    },

    //
    // get
    //
    get : function effectGetFn(geometryType)
    {
        return this.geometryType[geometryType];
    },

    //
    // prepare
    //
    prepare : function effectPrepareFn(renderable)
    {
        var prepareObject = this.geometryType[renderable.geometryType];
        if (prepareObject)
        {
            prepareObject.prepare(renderable);
        }
        else
        {
            Utilities.assert(false, "Unsupported or missing geometryType");
        }
    }

};

Effect.create = function effectCreateFn(name)
{
    var effect = new Effect();

    effect.name = name;
    effect.geometryType = {};
    effect.numMaterials = 0;

    return effect;
};


//
// EffectManager
//
function EffectManager() {}

EffectManager.prototype =
{
    version : 1,

    //
    // add
    //
    add : function effectAddFn(effect)
    {
        Utilities.assert(this.effects[effect.name] === undefined);
        this.effects[effect.name] = effect;
    },

    //
    // remove
    //
    remove : function effectManagerRemoveFn(name)
    {
        delete this.effects[name];
    },

    //
    // map
    //
    map : function effectManagerMapFn(destination, source)
    {
        this.effects[destination] = this.effects[source];
    },

    //
    // get
    //
    get : function effectManagerGetFn(name)
    {
        var effect = this.effects[name];
        if (!effect)
        {
            return this.effects["default"];
        }
        return effect;
    }
};

EffectManager.create = function effectManagerCreateFn()
{
    var effectManager = new EffectManager();

    effectManager.effects = {};

    return effectManager;
};

// Copyright (c) 2009-2012 Turbulenz Limited

/*global Observer: false*/
/*global TurbulenzEngine: false*/



/**
  @class  Shader manager
  @private

  @since TurbulenzEngine 0.1.0
*/
function ShaderManager() {}
ShaderManager.prototype =
{
    /**
      Version number
      @memberOf ShaderManager
      @constant
      @type number
    */
    version : 1
};

/**
  @constructs Constructs a ShaderManager object.

  @param {GraphicsDevice} gd Graphics device
  @param {RequestHandler} rh RequestHandler device
  @param {Shader} ds Default shader
  @param {Element} log Logging element

  @return {ShaderManager} object, null if failed
*/
ShaderManager.create = function shaderManagerCreateFn(gd, rh, ds, errorCallback, log)
{
    if (!errorCallback)
    {
        errorCallback = function (e) {};
    }

    var defaultShaderName = "default";

    var defaultShader;
    if (ds)
    {
        defaultShader = ds;
    }
    else
    {
        /*jshint white: false*/
        var shaderParams =
        {
            "version": 1,
            "name": "default.cgfx",
            "parameters":
            {
                "worldViewProjection":
                {
                    "type": "float",
                    "rows": 4,
                    "columns": 4
                },
                "diffuse":
                {
                    "type": "sampler2D"
                }
            },
            "techniques":
            {
                "textured3D":
                [
                    {
                        "parameters": ["worldViewProjection","diffuse"],
                        "semantics": ["POSITION","TEXCOORD0"],
                        "states":
                        {
                            "DepthTestEnable": true,
                            "DepthFunc": 515,
                            "DepthMask": true,
                            "CullFaceEnable": true,
                            "CullFace": 1029,
                            "BlendEnable": false
                        },
                        "programs": ["vp","fp"]
                    }
                ]
            },
            "programs":
            {
                "fp":
                {
                    "type": "fragment",
                    "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[1];vec4 _ret_0;uniform sampler2D diffuse;void main()\n{_ret_0=texture2D(diffuse,tz_TexCoord[0].xy);gl_FragColor=_ret_0;}"
                },
                "vp":
                {
                    "type": "vertex",
                    "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[1];attribute vec4 ATTR8;attribute vec4 ATTR0;\nvec4 _OUTpos1;vec2 _OUTuv1;uniform vec4 worldViewProjection[4];void main()\n{_OUTpos1=ATTR0.xxxx*worldViewProjection[0]+ATTR0.yyyy*worldViewProjection[1]+ATTR0.zzzz*worldViewProjection[2]+worldViewProjection[3];_OUTuv1=ATTR8.xy;tz_TexCoord[0].xy=ATTR8.xy;gl_Position=_OUTpos1;}"
                }
            }
        };
        /*jshint white: true*/

        defaultShader = gd.createShader(shaderParams);
        if (!defaultShader)
        {
            errorCallback("Default shader not created.");
        }
    }

    var shaders = {};
    var loadingShader = {};
    var loadedObservers = {};
    var numLoadingShaders = 0;
    var pathRemapping = null;
    var pathPrefix = "";

    shaders[defaultShaderName] = defaultShader;

    /**
      Creates shader from an cgfx file

      @memberOf ShaderManager.prototype
      @public
      @function
      @name load

      @param {string} path Path to the cgfx file

      @return {Shader} object, returns the default shader if the file at given path is not yet loaded
    */
    function loadShaderFn(path, onShaderLoaded)
    {
        if (path === undefined)
        {
            errorCallback("Invalid texture path passed to ShaderManager.Load");
        }
        var shader = shaders[path];
        if (!shader)
        {
            if (!loadingShader[path])
            {
                loadingShader[path] = true;
                numLoadingShaders += 1;

                var observer = Observer.create();
                loadedObservers[path] = observer;
                if (onShaderLoaded)
                {
                    observer.subscribe(onShaderLoaded);
                }

                var shaderLoaded = function shaderLoadedFn(shaderText, status, callContext)
                {
                    if (shaderText)
                    {
                        var shaderParameters = JSON.parse(shaderText);
                        var s = gd.createShader(shaderParameters);
                        if (s)
                        {
                            shaders[path] = s;
                        }
                        else
                        {
                            delete shaders[path];
                        }

                        observer.notify(s);
                        delete loadedObservers[path];
                    }
                    else
                    {
                        if (log)
                        {
                            log.innerHTML += "ShaderManager.load:&nbsp;'" + path + "' failed to load<br>";
                        }
                        delete shaders[path];
                    }
                    delete loadingShader[path];

                    numLoadingShaders -= 1;
                };

                rh.request({
                    src: ((pathRemapping && pathRemapping[path]) || (pathPrefix + path)),
                    onload: shaderLoaded
                });
            }
            else if (onShaderLoaded)
            {
                loadedObservers[path].subscribe(onShaderLoaded);
            }

            return defaultShader;
        }
        else if (onShaderLoaded)
        {
            // the callback should always be called asynchronously
            TurbulenzEngine.setTimeout(function shaderAlreadyLoadedFn()
                {
                    onShaderLoaded(shader);
                }, 0);
        }

        return shader;
    }

    /**
      Alias one shader to another name

      @memberOf ShaderManager.prototype
      @public
      @function
      @name map

      @param {string} dst Name of the alias
      @param {string} src Name of the shader to be aliased
    */
    function mapShaderFn(dst, src)
    {
        shaders[dst] = shaders[src];
    }

    /**
      Get shader created from a given shader file or with the given name

      @memberOf ShaderManager.prototype
      @public
      @function
      @name get

      @param {string} path Path or name of the shader

      @return {Shader} object, returns the default shader if the shader is not yet loaded or the shader file didn't exist
    */
    function getShaderFn(path)
    {
        var shader = shaders[path];
        if (!shader)
        {
            return defaultShader;
        }
        return shader;
    }

    /**
      Removes a shader from the manager

      @memberOf ShaderManager.prototype
      @public
      @function
      @name remove

      @param {string} path Path or name of the shader
    */
    function removeShaderFn(path)
    {
        if (typeof shaders[path] !== 'undefined')
        {
            delete shaders[path];
        }
    }

    /**
      Reloads a shader

      @memberOf ShaderManager.prototype
      @public
      @function
      @name reload

      @param {string} path Path or name of the shader
    */
    function reloadShaderFn(path, callback)
    {
        removeShaderFn(path);
        loadShaderFn(path, callback);
    }

    var sm = new ShaderManager();

    if (log)
    {
        sm.load = function loadShaderLogFn(path, callback)
        {
            log.innerHTML += "ShaderManager.load:&nbsp;'" + path + "'<br>";
            return loadShaderFn(path, callback);
        };

        sm.map = function mapShaderLogFn(dst, src)
        {
            log.innerHTML += "ShaderManager.map:&nbsp;'" + src + "' -> '" + dst + "'<br>";
            mapShaderFn(dst, src);
        };

        sm.get = function getShaderLogFn(path)
        {
            log.innerHTML += "ShaderManager.get:&nbsp;'" + path + "'<br>";
            return getShaderFn(path);
        };

        sm.remove = function removeShaderLogFn(path)
        {
            log.innerHTML += "ShaderManager.remove:&nbsp;'" + path + "'<br>";
            removeShaderFn(path);
        };

        sm.reload = function reloadShaderLogFn(path, callback)
        {
            log.innerHTML += "ShaderManager. reload:&nbsp;'" + path + "'<br>";
            reloadShaderFn(path, callback);
        };
    }
    else
    {
        sm.load = loadShaderFn;
        sm.map = mapShaderFn;
        sm.get = getShaderFn;
        sm.remove = removeShaderFn;
        sm.reload = reloadShaderFn;
    }

    /**
      Reloads all shaders

      @memberOf ShaderManager.prototype
      @public
      @function
      @name reloadAll
    */
    sm.reloadAll = function reloadAllShadersFn()
    {
        for (var t in shaders)
        {
            if (shaders.hasOwnProperty(t) && t !== defaultShaderName)
            {
                reloadShaderFn(t);
            }
        }
    };

    /**
      Get object containing all loaded shaders

      @memberOf ShaderManager.prototype
      @public
      @function
      @name getAll

      @return {object}
    */
    sm.getAll = function getAllShadersFn()
    {
        return shaders;
    };

    /**
      Get number of shaders pending

      @memberOf ShaderManager.prototype
      @public
      @function
      @name getNumLoadingShaders

      @return {number}
    */
    sm.getNumPendingShaders = function getNumPendingShadersFn()
    {
        return numLoadingShaders;
    };

    /**
      Check if a shader is not pending

      @memberOf ShaderManager.prototype
      @public
      @function
      @name isShaderLoaded

      @param {string} path Path or name of the shader

      @return {boolean}
    */
    sm.isShaderLoaded = function isShaderLoadedFn(path)
    {
        return !loadingShader[path];
    };

    /**
      Check if a shader is missing

      @memberOf ShaderManager.prototype
      @public
      @function
      @name isShaderMissing

      @param {string} path Path or name of the shader

      @return {boolean}
    */
    sm.isShaderMissing = function isShaderMissingFn(path)
    {
        return !shaders[path];
    };

    /**
      Set path remapping dictionary

      @memberOf ShaderManager.prototype
      @public
      @function
      @name setPathRemapping

      @param {string} prm Path remapping dictionary
      @param {string} assetUrl Asset prefix for all assets loaded
    */
    sm.setPathRemapping = function setPathRemappingFn(prm, assetUrl)
    {
        pathRemapping = prm;
        pathPrefix = assetUrl;
    };

    sm.destroy = function shaderManagerDestroyFn()
    {
        if (shaders)
        {
            var p;
            for (p in shaders)
            {
                if (shaders.hasOwnProperty(p))
                {
                    var shader = shaders[p];
                    if (shader)
                    {
                        shader.destroy();
                    }
                }
            }
            shaders = null;
        }

        defaultShader = null;
        loadingShader = null;
        loadedObservers = null;
        numLoadingShaders = 0;
        pathRemapping = null;
        pathPrefix = null;
        rh = null;
        gd = null;
    };

    return sm;
};

// Copyright (c) 2009-2012 Turbulenz Limited



/*global Reference: false*/
/*global Observer: false*/
/*global TurbulenzEngine: false*/

function TextureInstance() {}
TextureInstance.prototype =
{
    version : 1,

    //
    // setTexture
    //
    setTexture: function textureInstanceSetTexture(texture)
    {
        this.texture = texture;
        if (this.textureChangedObserver)
        {
            this.textureChangedObserver.notify(this);
        }
    },

    //
    // getTexture
    //
    getTexture: function textureInstanceGetTexture()
    {
        return this.texture;
    },

    //
    // subscribeTextureChanged
    //
    subscribeTextureChanged: function textureInstanceSubscribeTextureChanged(observerFunction)
    {
        if (!this.textureChangedObserver)
        {
            this.textureChangedObserver = Observer.create();
        }
        this.textureChangedObserver.subscribe(observerFunction);
    },

    //
    // usubscribeTextureChanged
    //
    unsubscribeTextureChanged: function textureInstanceunsubscribeTextureChangedFn(observerFunction)
    {
        this.textureChangedObserver.unsubscribe(observerFunction);
    },

    //
    // destroy
    //
    destroy: function textureInstanceDestroy()
    {
        if (this.texture.name !== "default")
        {
            this.texture.destroy();
        }
        delete this.texture;
        delete this.textureChangedObserver;
    }
};

//
// TextureInstance.create
//
TextureInstance.create = function textureInstanceCreate(name, texture)
{
    var textureInstance = new TextureInstance();
    textureInstance.name = name;
    textureInstance.texture = texture;
    textureInstance.reference = Reference.create(textureInstance);

    return textureInstance;
};


/**
  @class  Texture manager
  @private

  @since TurbulenzEngine 0.1.0
*/
function TextureManager() {}
TextureManager.prototype =
{
    /**
      Version number
      @memberOf TextureManager
      @constant
      @type number
    */
    version : 1,

   /**
      Adds external texture

      @memberOf TextureManager.prototype
      @public
      @function
      @name add

      @param {string} name Name of the texture
      @param {Texture} texture Texture
    */
    add: function textureManagerAddFn(name, texture, internal)
    {
        var textureInstance = this.textureInstances[name];
        if (!textureInstance)
        {
            this.textureInstances[name] = TextureInstance.create(name, texture);
            this.textureInstances[name].reference.subscribeDestroyed(this.onTextureInstanceDestroyed);
        }
        else
        {
            textureInstance.setTexture(texture);
        }

        if (internal)
        {
            this.internalTexture[name] = true;
            this.textureInstances[name].reference.add();
        }
    },

    /**
      Get texture created from a given file or with the given name

      @memberOf TextureManager.prototype
      @public
      @function
      @name get

      @param {string} path Path or name of the texture

      @return {Texture} object, returns the default texture if the texture is not yet loaded or the file didn't exist
    */
    get: function textureManagerGetFn(path)
    {
        var instance = this.textureInstances[path];
        if (!instance)
        {
            return this.defaultTexture;
        }
        return instance.getTexture();
    },

    //
    // getInstanceFn
    //
    getInstance: function textureManagerGetInstanceFn(path)
    {
        return this.textureInstances[path];
    },

    /**
      Creates texture from an image file

      @memberOf TextureManager.prototype
      @public
      @function
      @name load

      @param {string} path Path to the image file
      @param {boolean} nomipmaps True to disable mipmaps
      @param {function} onTextureLoaded function to call once the texture is loaded

      @return {Texture} object, returns the default Texture if the file at given path is not yet loaded
    */

    load: function textureManagerLoadFn(path, nomipmaps, onTextureLoaded)
    {
        var that = this;

        if (path === undefined)
        {
            this.errorCallback("Invalid texture path passed to TextureManager.Load");
        }
        var textureInstance = this.textureInstances[path];
        if (!textureInstance ||
            (textureInstance.texture === this.defaultTexture &&
             path !== "default"))
        {
            if (!textureInstance)
            {
                this.add(path, this.defaultTexture, false);
            }

            if (!(path in this.loadingTexture))
            {
                if (0 === this.numLoadingArchives)
                {
                    this.loadingTexture[path] = true;
                    this.numLoadingTextures += 1;

                    var mipmaps = true;
                    if (nomipmaps)
                    {
                        mipmaps = false;
                    }

                    var loadedObserver = Observer.create();
                    this.loadedTextureObservers[path] = loadedObserver;
                    if (onTextureLoaded)
                    {
                        loadedObserver.subscribe(onTextureLoaded);
                    }

                    var textureLoaded = function textureLoadedFn(texture, status)
                    {
                        if (status === 200 && texture)
                        {
                            that.add(path, texture, false);
                        }

                        loadedObserver.notify(texture);
                        delete that.loadedTextureObservers[path];

                        //Missing textures are left with the previous, usually default, texture.
                        delete that.loadingTexture[path];
                        that.numLoadingTextures -= 1;
                    };

                    var textureRequest = function textureRequestFn(url, onload, callContext)
                    {
                        var texture = that.graphicsDevice.createTexture({
                            src     : url,
                            mipmaps : mipmaps,
                            onload  : onload
                        });
                        if (!texture)
                        {
                            that.errorCallback("Texture '" + url + "' not created.");
                        }
                    };

                    this.requestHandler.request({
                        src: ((this.pathRemapping && this.pathRemapping[path]) || (this.pathPrefix + path)),
                        requestFn: textureRequest,
                        onload: textureLoaded
                    });
                }
                else
                {
                    this.delayedTextures[path] = {
                        nomipmaps: nomipmaps,
                        onload: onTextureLoaded
                    };

                    return this.get(path);
                }
            }
            else if (onTextureLoaded)
            {
                this.loadedTextureObservers[path].subscribe(onTextureLoaded);
            }

            return this.get(path);
        }
        else
        {
            var texture = this.get(path);
            if (onTextureLoaded)
            {
                // the callback should always be called asynchronously
                TurbulenzEngine.setTimeout(function textureAlreadyLoadedFn()
                    {
                        onTextureLoaded(texture);
                    }, 0);
            }
            return texture;
        }
    },

    /**
      Alias one texture to another name

      @memberOf TextureManager.prototype
      @public
      @function
      @name map

      @param {string} dst Name of the alias
      @param {string} src Name of the texture to be aliased
    */
    map: function textureManagerMapFn(dst, src)
    {
        if (!this.textureInstances[dst])
        {
            this.textureInstances[dst] = TextureInstance.create(dst, this.textureInstances[src].getTexture());
            this.textureInstances[dst].reference.subscribeDestroyed(this.onTextureInstanceDestroyed);
        }
        else
        {
            this.textureInstances[dst].setTexture(this.textureInstances[src].getTexture());
        }
        this.internalTexture[dst] = true;
    },

    /**
      Removes a texture from the manager

      @memberOf TextureManager.prototype
      @public
      @function
      @name remove

      @param {string} path Path or name of the texture
    */
    remove: function textureManagerRemoveFn(path)
    {
        if (!this.internalTexture[path])
        {
            if (path in this.textureInstances)
            {
                this.textureInstances[path].reference.unsubscribeDestroyed(this.onTextureInstanceDestroyed);
                delete this.textureInstances[path];
            }
        }
    },

    /**
      Loads a textures archive

      @memberOf TextureManager.prototype
      @public
      @function
      @name loadArchive

      @param {string} path Path to the archive file
      @param {boolean} nomipmaps True to disable mipmaps
    */
    loadArchive: function textureManagerLoadArchiveFn(path, nomipmaps, onTextureLoaded, onArchiveLoaded)
    {
        var that = this;
        var archive = this.archivesLoaded[path];
        if (!archive)
        {
            if (!(path in this.loadingArchives))
            {
                var mipmaps = true;
                if (nomipmaps)
                {
                    mipmaps = false;
                }
                this.loadingArchives[path] = { textures: {} };
                this.numLoadingArchives += 1;

                var observer = Observer.create();
                this.loadedArchiveObservers[path] = observer;
                if (onArchiveLoaded)
                {
                    observer.subscribe(onArchiveLoaded);
                }

                var textureArchiveLoaded = function textureArchiveLoadedFn(success, status)
                {
                    var loadedArchive;
                    if (status === 200 && success)
                    {
                        loadedArchive = { textures: that.loadingArchives[path].textures };
                        that.archivesLoaded[path] = loadedArchive;
                    }

                    observer.notify(loadedArchive);
                    delete that.loadedArchiveObservers[path];

                    delete that.loadingArchives[path];
                    that.numLoadingArchives -= 1;
                    if (0 === that.numLoadingArchives)
                    {
                        var name;
                        for (name in that.delayedTextures)
                        {
                            if (that.delayedTextures.hasOwnProperty(name))
                            {
                                var delayedTexture = that.delayedTextures[name];
                                that.load(name,
                                              delayedTexture.nomipmaps,
                                              delayedTexture.onload);
                            }
                        }
                        that.delayedTextures = {};
                    }
                };

                var requestTextureArchive = function requestTextureArchiveFn(url, onload)
                {
                    var ontextureload = function ontextureloadFn(texture)
                    {
                        var name = texture.name;
                        if (!(name in that.textureInstances) || that.textureInstances[name].texture === that.defaultTexture)
                        {
                            that.add(name, texture, false);
                            that.loadingArchives[path].textures[name] = texture;
                        }

                        if (onTextureLoaded)
                        {
                            onTextureLoaded(texture);
                        }

                        delete that.delayedTextures[name];
                        if (path in that.loadingTexture)
                        {
                            delete that.loadingTexture[path];
                            that.numLoadingTextures -= 1;
                        }
                    };

                    if (!that.graphicsDevice.loadTexturesArchive({
                        src: url,
                        mipmaps: mipmaps,
                        ontextureload: ontextureload,
                        onload: onload
                    }))
                    {
                        that.errorCallback("Archive '" + path + "' not loaded.");
                    }
                };

                that.requestHandler.request({
                    src: ((that.pathRemapping && that.pathRemapping[path]) || (that.pathPrefix + path)),
                    requestFn: requestTextureArchive,
                    onload: textureArchiveLoaded
                });
            }
            else if (onTextureLoaded)
            {
                this.loadedArchiveObservers[path].subscribe(function textureArchiveLoadedFn()
                    {
                        var archive = that.archivesLoaded[path];
                        var texturesInArchive = archive.textures;
                        var t;
                        for (t in texturesInArchive)
                        {
                            if (texturesInArchive.hasOwnProperty(t))
                            {
                                // the texture has already been loaded so we call onload manaually
                                onTextureLoaded(texturesInArchive[t]);
                            }
                        }
                        if (onArchiveLoaded)
                        {
                            onArchiveLoaded(archive);
                        }
                    });
            }
        }
        else
        {
            if (onTextureLoaded)
            {
                var texturesInArchive = archive.textures;
                var numTexturesLoading = 0;

                var textureAlreadyLoadedWrapper = function textureAlreadyLoadedWrapper(texture)
                {
                    return function textureAlreadyLoadedFn()
                    {
                        onTextureLoaded(texture);
                        numTexturesLoading -= 1;
                        if (numTexturesLoading === 0 && onArchiveLoaded)
                        {
                            onArchiveLoaded(archive);
                        }
                    };
                };

                var t;
                for (t in texturesInArchive)
                {
                    if (texturesInArchive.hasOwnProperty(t))
                    {
                        numTexturesLoading += 1;
                        // the callback should always be called asynchronously
                        TurbulenzEngine.setTimeout(textureAlreadyLoadedWrapper(texturesInArchive[t]), 0);
                    }
                }
            }
        }
    },

    /**
      Check if an archive is not pending

      @memberOf TextureManager.prototype
      @public
      @function
      @name isArchiveLoaded

      @param {string} path Path or name of the archive

      @return {boolean}
    */
    isArchiveLoaded: function textureManagerIsArchiveLoadedFn(path)
    {
        return path in this.archivesLoaded;
    },

    /**
      Removes a textures archive and all the textures it references.

      @memberOf TextureManager.prototype
      @public
      @function
      @name removeArchive

      @param {string} path Path of the archive file
    */
    removeArchive: function textureManagerRemoveArchiveFn(path)
    {
        if (path in this.archivesLoaded)
        {
            var archiveTextures = this.archivesLoaded[path].textures;
            var texture;
            for (texture in archiveTextures)
            {
                if (archiveTextures.hasOwnProperty(texture))
                {
                    this.remove(texture);
                }
            }
            delete this.archivesLoaded[path];
        }
    },

    /**
      Get object containing all loaded textures

      @memberOf TextureManager.prototype
      @public
      @function
      @name getAll

      @return {object}
    */
    getAll: function  textureManagerGetAllFn()
    {
        return this.textureInstances;
    },

    /**
      Get number of textures pending

      @memberOf TextureManager.prototype
      @public
      @function
      @name getNumLoadingTextures

      @return {number}
    */
    getNumPendingTextures: function textureManagerGetNumPendingTexturesFn()
    {
        return (this.numLoadingTextures + this.numLoadingArchives);
    },

    /**
      Check if a texture is not pending

      @memberOf TextureManager.prototype
      @public
      @function
      @name isTextureLoaded

      @param {string} path Path or name of the texture

      @return {boolean}
    */
    isTextureLoaded: function textureManagerIsTextureLoadedFn(path)
    {
        return (!(path in this.loadingTexture) && !(path in this.delayedTextures));
    },

    /**
      Check if a texture is missing

      @memberOf TextureManager.prototype
      @public
      @function
      @name isTextureMissing

      @param {string} path Path or name of the texture

      @return {boolean}
    */
    isTextureMissing: function textureManagerIsTextureMissingFn(path)
    {
        return !(path in this.textureInstances);
    },

    /**
      Set path remapping dictionary

      @memberOf TextureManager.prototype
      @public
      @function
      @name setPathRemapping

      @param {string} prm Path remapping dictionary
      @param {string} assetUrl Asset prefix for all assets loaded
    */
    setPathRemapping: function textureManagerSetPathRemappingFn(prm, assetUrl)
    {
        this.pathRemapping = prm;
        this.pathPrefix = assetUrl;
    },

    addProceduralTexture: function textureManagerAddProceduralTexture(params)
    {
        var name = params.name;
        var procTexture = this.graphicsDevice.createTexture(params);
        if (!procTexture)
        {
            this.errorCallback("Failed to create '" + name + "' texture.");
        }
        else
        {
            this.add(name, procTexture, true);
        }
    },

    destroy: function textureManagerDestroyFn()
    {
        if (this.textureInstances)
        {
            var p;
            for (p in this.textureInstances)
            {
                if (this.textureInstances.hasOwnProperty(p))
                {
                    var textureInstance = this.textureInstances[p];
                    if (textureInstance)
                    {
                        textureInstance.destroy();
                    }
                }
            }
            this.textureInstances = null;
        }

        if (this.defaultTexture)
        {
            this.defaultTexture.destroy();
            this.defaultTexture = null;
        }

        this.loadingTexture = null;
        this.loadedTextureObservers = null;
        this.delayedTextures = null;
        this.numLoadingTextures = 0;
        this.archivesLoaded = null;
        this.loadingArchives = null;
        this.loadedArchiveObservers = null;
        this.numLoadingArchives = 0;
        this.internalTexture = null;
        this.pathRemapping = null;
        this.pathPrefix = null;
        this.requestHandler = null;
        this.graphicsDevice = null;
    }
};

/**
  @constructs Constructs a TextureManager object.

  @param {GraphicsDevice} graphicsDevice Graphics device
  @param {Texture} dt Default texture
  @param {Element} log Logging element

  @return {TextureManager} object, null if failed
*/
TextureManager.create = function textureManagerCreateFn(graphicsDevice, requestHandler, dt, errorCallback, log)
{
    var textureManager = new TextureManager();

    if (!errorCallback)
    {
        errorCallback = function (e) {};
    }

    var defaultTextureName = "default";

    var defaultTexture;
    if (dt)
    {
        defaultTexture = dt;
    }
    else
    {
        defaultTexture = graphicsDevice.createTexture({
            name    : defaultTextureName,
            width   : 2,
            height  : 2,
            depth   : 1,
            format  : 'R8G8B8A8',
            cubemap : false,
            mipmaps : true,
            dynamic : false,
            data    : [255,  20, 147, 255,
                       255,   0,   0, 255,
                       255, 255, 255, 255,
                       255,  20, 147, 255]
        });
        if (!defaultTexture)
        {
            errorCallback("Default texture not created.");
        }
    }

    textureManager.textureInstances = {};
    textureManager.loadingTexture = {};
    textureManager.loadedTextureObservers = {};
    textureManager.delayedTextures = {};
    textureManager.numLoadingTextures = 0;
    textureManager.archivesLoaded = {};
    textureManager.loadingArchives = {};
    textureManager.loadedArchiveObservers = {};
    textureManager.numLoadingArchives = 0;
    textureManager.internalTexture = {};
    textureManager.pathRemapping = null;
    textureManager.pathPrefix = "";

    textureManager.graphicsDevice = graphicsDevice;
    textureManager.requestHandler = requestHandler;
    textureManager.defaultTexture = defaultTexture;
    textureManager.errorCallback = errorCallback;

    //
    // onTextureInstanceDestroyed callback
    //
    textureManager.onTextureInstanceDestroyed = function onTextureInstanceDestroyed(textureInstance)
    {
        textureInstance.reference.unsubscribeDestroyed(onTextureInstanceDestroyed);
        delete textureManager.textureInstances[textureInstance.name];
    };

    if (log)
    {
        textureManager.add = function addTextureLogFn(name, tex)
        {
            log.innerHTML += "TextureManager.add:&nbsp;'" + name + "'";
            return textureManager.prototype.add(name, tex);
        };

        textureManager.load = function loadTextureLogFn(path, nomipmaps)
        {
            log.innerHTML += "TextureManager.load:&nbsp;'" + path + "'";
            return textureManager.prototype.load(path, nomipmaps);
        };

        textureManager.loadArchive = function loadArchiveLogFn(path, nomipmaps)
        {
            log.innerHTML += "TextureManager.loadArchive:&nbsp;'" + path + "'";
            return textureManager.prototype.loadArchive(path, nomipmaps);
        };

        textureManager.isArchiveLoaded = function isArchiveLoadedLogFn(path)
        {
            log.innerHTML += "TextureManager.isArchiveLoaded:&nbsp;'" + path + "'";
            return textureManager.prototype.isArchiveLoaded(path);
        };

        textureManager.removeArchive = function removeArchiveLogFn(path)
        {
            log.innerHTML += "TextureManager.removeArchive:&nbsp;'" + path + "'";
            return textureManager.prototype.removeArchive(path);
        };

        textureManager.map = function mapTextureLogFn(dst, src)
        {
            log.innerHTML += "TextureManager.map:&nbsp;'" + src + "' -> '" + dst + "'";
            textureManager.prototype.map(dst, src);
        };

        textureManager.get = function getTextureLogFn(path)
        {
            log.innerHTML += "TextureManager.get:&nbsp;'" + path + "'";
            return textureManager.prototype.get(path);
        };

        textureManager.getInstance = function getTextureInstanceLogFn(path)
        {
            log.innerHTML += "TextureManager.getInstance:&nbsp;'" + path + "'";
            return textureManager.prototype.getInstance(path);
        };

        textureManager.remove = function removeTextureLogFn(path)
        {
            log.innerHTML += "TextureManager.remove:&nbsp;'" + path + "'";
            textureManager.prototype.remove(path);
        };
    }

    // Add procedural textures
    textureManager.add(defaultTextureName, defaultTexture, true);

    textureManager.addProceduralTexture({
        name    : "white",
        width   : 2,
        height  : 2,
        depth   : 1,
        format  : 'R8G8B8A8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : [255, 255, 255, 255,
                   255, 255, 255, 255,
                   255, 255, 255, 255,
                   255, 255, 255, 255]
    });

    textureManager.addProceduralTexture({
        name    : "black",
        width   : 2,
        height  : 2,
        depth   : 1,
        format  : 'R8G8B8A8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : [0, 0, 0, 255,
                   0, 0, 0, 255,
                   0, 0, 0, 255,
                   0, 0, 0, 255]
    });

    textureManager.addProceduralTexture({
        name    : "flat",
        width   : 2,
        height  : 2,
        depth   : 1,
        format  : 'R8G8B8A8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : [128, 128, 255, 255,
                   128, 128, 255, 255,
                   128, 128, 255, 255,
                   128, 128, 255, 255]
    });

    var abs = Math.abs;
    var x, y;
    var quadraticData = [];
    for (y = 0; y < 4; y += 1)
    {
        for (x = 0; x < 32; x += 1)
        {
            var s = ((x + 0.5) * (2.0 / 32.0) - 1.0);
            s = abs(s) - (1.0 / 32.0);
            var value = (1.0 - (s * 2.0) + (s * s));
            if (value <= 0)
            {
                quadraticData.push(0);
            }
            else if (value >= 1)
            {
                quadraticData.push(255);
            }
            else
            {
                quadraticData.push(value * 255);
            }
        }
    }
    textureManager.addProceduralTexture({
        name    : "quadratic",
        width   : 32,
        height  : 4,
        depth   : 1,
        format  : 'L8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : quadraticData
    });
    quadraticData = null;

    var nofalloffData = [];
    for (y = 0; y < 4; y += 1)
    {
        nofalloffData.push(0);
        for (x = 1; x < 31; x += 1)
        {
            nofalloffData.push(255);
        }
        nofalloffData.push(0);
    }
    textureManager.addProceduralTexture({
        name    : "nofalloff",
        width   : 32,
        height  : 4,
        depth   : 1,
        format  : 'L8',
        cubemap : false,
        mipmaps : true,
        dynamic : false,
        data    : nofalloffData
    });
    nofalloffData = null;

    return textureManager;
};

// Copyright (c) 2010-2011 Turbulenz Limited

//
// renderingCommonGetTechniqueIndexFn
//
function renderingCommonGetTechniqueIndexFn(techniqueName)
{
    var dataStore = renderingCommonGetTechniqueIndexFn;
    var techniqueIndex = dataStore.techniquesIndexMap[techniqueName];
    if (techniqueIndex === undefined)
    {
        techniqueIndex = dataStore.numTechniques;
        dataStore.techniquesIndexMap[techniqueName] = techniqueIndex;
        dataStore.numTechniques += 1;
    }
    return techniqueIndex;
}

renderingCommonGetTechniqueIndexFn.techniquesIndexMap = {};
renderingCommonGetTechniqueIndexFn.numTechniques = 0;

//
// renderingCommonSortKeyFn
//
function renderingCommonSortKeyFn(techniqueIndex, materialIndex)
{
    return techniqueIndex * 0x10000 + materialIndex % 0x10000;
}

//
// renderingCommonCreateRendererInfoFn
//
function renderingCommonCreateRendererInfoFn(renderable)
{
    var rendererInfo = {};
    renderable.rendererInfo = rendererInfo;
    var effect = renderable.sharedMaterial.effect;

    if (effect.prepare)
    {
        effect.prepare(renderable);
    }

    return rendererInfo;
}

//
// renderingCommonAddDrawParameterFastestFn
//
function renderingCommonAddDrawParameterFastestFn(drawParameters)
{
    var array = this.array;
    array[array.length] = drawParameters;
}

// Copyright (c) 2009-2012 Turbulenz Limited

//
// DefaultRendering
//

/*global TurbulenzEngine: false*/
/*global renderingCommonCreateRendererInfoFn: false*/
/*global renderingCommonGetTechniqueIndexFn: false*/
/*global renderingCommonSortKeyFn: false */
/*global Effect: false*/

function DefaultRendering() {}

DefaultRendering.numPasses = 3;
DefaultRendering.passIndex =  { opaque: 0, decal: 1, transparent: 2 };

DefaultRendering.prototype =
{
    version : 1,

    updateShader: function defaultRenderingUpdateShaderFn(sm)
    {
    },

    sortRenderablesAndLights: function defaultRenderingSortRenderablesAndLightsFn(camera, scene)
    {
        var index;
        var passes = this.passes;
        var numPasses = DefaultRendering.numPasses;
        for (index = 0; index < numPasses; index += 1)
        {
            passes[index] = [];
        }

        var drawParametersArray;
        var numDrawParameters;
        var drawParameters;
        var drawParametersIndex;

        var visibleRenderables = scene.getCurrentVisibleRenderables();
        var numVisibleRenderables = visibleRenderables.length;
        if (numVisibleRenderables > 0)
        {
            var renderable, meta, pass, passIndex;
            var transparent = DefaultRendering.passIndex.transparent;
            var n = 0;
            do
            {
                renderable = visibleRenderables[n];

                var rendererInfo = renderable.rendererInfo;
                if (!rendererInfo)
                {
                    rendererInfo = renderingCommonCreateRendererInfoFn(renderable);
                }

                meta = renderable.sharedMaterial.meta;

                if (meta.far)
                {
                    renderable.distance = 1.e38;
                }

                rendererInfo.renderUpdate.call(renderable, camera);

                drawParametersArray = renderable.drawParameters;
                numDrawParameters = drawParametersArray.length;
                for (drawParametersIndex = 0; drawParametersIndex < numDrawParameters; drawParametersIndex += 1)
                {
                    drawParameters = drawParametersArray[drawParametersIndex];
                    passIndex = drawParameters.userData.passIndex;
                    if (passIndex === transparent)
                    {
                        drawParameters.sortKey = renderable.distance;
                    }
                    pass = passes[passIndex];
                    pass[pass.length] = drawParameters;
                }

                // this renderer does not care about lights

                n += 1;
            }
            while (n < numVisibleRenderables);

        }
    },

    update: function defaultRenderingUpdateFn(gd, camera, scene, currentTime)
    {
        scene.updateVisibleNodes(camera);

        this.sortRenderablesAndLights(camera, scene);

        var md = this.md;
        var globalTechniqueParameters = this.globalTechniqueParameters;
        globalTechniqueParameters.eyePosition = md.m43Pos(camera.matrix, globalTechniqueParameters.eyePosition);
        globalTechniqueParameters.time = currentTime;
        this.camera = camera;
        this.scene = scene;
    },

    updateBuffers: function defaultRenderingUpdateBuffersFn(gd, deviceWidth, deviceHeight)
    {
        return true;
    },

    draw: function defaultRenderingDrawFn(gd,
                                          clearColor,
                                          drawDecalsFn,
                                          drawTransparentFn,
                                          drawDebugFn)
    {
        var globalTechniqueParameters = this.globalTechniqueParameters;
        var globalTechniqueParametersArray = [globalTechniqueParameters];

        gd.clear(clearColor, 1.0, 0);

        if (this.wireframe)
        {
            this.scene.drawWireframe(gd, this.sm, this.camera, this.wireframeInfo);

            if (drawDecalsFn)
            {
                drawDecalsFn();
            }

            if (drawTransparentFn)
            {
                drawTransparentFn();
            }
        }
        else
        {

            gd.drawArray(this.passes[DefaultRendering.passIndex.opaque], globalTechniqueParametersArray, -1);

            gd.drawArray(this.passes[DefaultRendering.passIndex.decal], globalTechniqueParametersArray, -1);

            if (drawDecalsFn)
            {
                drawDecalsFn();
            }

            gd.drawArray(this.passes[DefaultRendering.passIndex.transparent], globalTechniqueParametersArray, 1);

            if (drawTransparentFn)
            {
                drawTransparentFn();
            }
        }

        if (drawDebugFn)
        {
            drawDebugFn();
        }
    },


    setGlobalLightPosition: function defaultRenderingSetGlobalLightPositionFn(pos)
    {
        this.globalTechniqueParameters.lightPosition = pos;
    },

    setGlobalLightColor: function defaultRenderingSetGlobalLightColorFn(color)
    {
        this.globalTechniqueParameters.lightColor = color;
    },

    setAmbientColor: function defaultRenderingSetAmbientColorFn(color)
    {
        this.globalTechniqueParameters.ambientColor = color;
    },

    setDefaultTexture: function defaultRenderingSetDefaultTextureFn(tex)
    {
        this.globalTechniqueParameters.diffuse = tex;
    },

    setWireframe: function defaultRenderingSetWireframe(wireframeEnabled, wireframeInfo)
    {
        this.wireframeInfo = wireframeInfo;
        this.wireframe = wireframeEnabled;
    },

    getDefaultSkinBufferSize: function getDefaultSkinBufferSizeFn()
    {
        return this.defaultSkinBufferSize;
    },

    destroy: function destroyFn()
    {
        delete this.globalTechniqueParameters;
        delete this.passes;
    }
};

//
// defaultPrepareFn
//
DefaultRendering.defaultPrepareFn = function defaultPrepareFn(geometryInstance)
{
    var drawParameters = TurbulenzEngine.getGraphicsDevice().createDrawParameters();
    drawParameters.userData = {};
    geometryInstance.drawParameters = [drawParameters];
    geometryInstance.prepareDrawParameters(drawParameters);

    var sharedMaterial = geometryInstance.sharedMaterial;

    drawParameters.technique = this.technique;

    drawParameters.setTechniqueParameters(0, sharedMaterial.techniqueParameters);
    drawParameters.setTechniqueParameters(1, geometryInstance.techniqueParameters);

    if (sharedMaterial.meta.decal)
    {
        drawParameters.userData.passIndex = DefaultRendering.passIndex.decal;
    }
    else if (sharedMaterial.meta.transparent)
    {
        drawParameters.userData.passIndex = DefaultRendering.passIndex.transparent;
    }
    else
    {
        drawParameters.userData.passIndex = DefaultRendering.passIndex.opaque;
    }

    drawParameters.sortKey = renderingCommonSortKeyFn(this.techniqueIndex, sharedMaterial.meta.materialIndex);

    geometryInstance.rendererInfo.renderUpdate = this.update;
};

//
// Constructor function
//
DefaultRendering.create = function defaultRenderingCreateFn(gd, md, shaderManager, effectsManager)
{
    var dr = new DefaultRendering();

    dr.md = md;
    dr.sm = shaderManager;

    dr.globalTechniqueParameters = gd.createTechniqueParameters({
            lightPosition : md.v3Build(1000.0, 1000.0, 0.0),
            lightColor : md.v3BuildOne(),
            ambientColor : md.v3Build(0.2, 0.2, 0.3),
            eyePosition : md.v3BuildZero(),
            time : 0.0
        });

    dr.passes = [[], [], []];

    var onShaderLoaded = function onShaderLoadedFn(shader)
    {
        var skinBones = shader.getParameter("skinBones");
        dr.defaultSkinBufferSize = skinBones.rows * skinBones.columns;
    };

    shaderManager.load("shaders/defaultrendering.cgfx", onShaderLoaded);
    shaderManager.load("shaders/standard.cgfx");
    shaderManager.load("shaders/debug.cgfx");

    // Prepare effects
    var m43MulM44 = md.m43MulM44;
    var m43Transpose = md.m43Transpose;
    var m33InverseTranspose = md.m33InverseTranspose;

    function defaultUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var matrix = this.node.world;
        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
        if (this.techniqueParametersUpdated !== this.node.worldUpdate)
        {
            this.techniqueParametersUpdated = this.node.worldUpdate;
            techniqueParameters.worldTranspose = m43Transpose.call(md, matrix, techniqueParameters.worldTranspose);
            techniqueParameters.worldInverseTranspose = m33InverseTranspose.call(md, matrix, techniqueParameters.worldInverseTranspose);
        }
    }

    function defaultSkinnedUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var matrix = this.node.world;
        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
        if (this.techniqueParametersUpdated !== this.node.worldUpdate)
        {
            this.techniqueParametersUpdated = this.node.worldUpdate;
            techniqueParameters.worldTranspose = m43Transpose.call(md, matrix, techniqueParameters.worldTranspose);
            techniqueParameters.worldInverseTranspose = m33InverseTranspose.call(md, matrix, techniqueParameters.worldInverseTranspose);
        }
        var skinController = this.skinController;
        if (skinController)
        {
            techniqueParameters.skinBones = skinController.output;
            skinController.update();
        }
    }

    function defaultBlendUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        techniqueParameters.worldViewProjection = m43MulM44.call(md, this.node.world, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
    }

    function defaultBlendSkinnedUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        techniqueParameters.worldViewProjection = m43MulM44.call(md, this.node.world, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
        var skinController = this.skinController;
        if (skinController)
        {
            techniqueParameters.skinBones = skinController.output;
            skinController.update();
        }
    }

    function defaultSkyboxUpdateFn(camera)
    {
        var techniqueParameters = this.techniqueParameters;
        var matrix = this.node.world;
        techniqueParameters.worldViewProjection = m43MulM44.call(md, matrix, camera.viewProjectionMatrix, techniqueParameters.worldViewProjection);
        if (this.techniqueParametersUpdated !== this.node.worldUpdate)
        {
            this.techniqueParametersUpdated = this.node.worldUpdate;
            techniqueParameters.worldTranspose = m43Transpose.call(md, matrix, techniqueParameters.worldTranspose);
        }
    }

    function debugLinesPrepareFn(geometryInstance)
    {
        DefaultRendering.defaultPrepareFn.call(this, geometryInstance);
        var techniqueParameters = geometryInstance.techniqueParameters;
        techniqueParameters.constantColor = geometryInstance.sharedMaterial.meta.constantColor;
    }

    function defaultPrepareFn(geometryInstance)
    {
        DefaultRendering.defaultPrepareFn.call(this, geometryInstance);
        //For untextured objects we need to choose a technique that uses materialColor instead.
        var techniqueParameters = geometryInstance.sharedMaterial.techniqueParameters;
        var diffuse = techniqueParameters.diffuse;
        if (diffuse === undefined)
        {
            if (!techniqueParameters.materialColor)
            {
                techniqueParameters.materialColor = md.v4BuildOne();
            }
        }
        else if (diffuse.length === 4)
        {
            techniqueParameters.diffuse = techniqueParameters.diffuse_map;
            techniqueParameters.materialColor = md.v4Build.apply(md, diffuse);
        }
    }

    function flatPrepareFn(geometryInstance)
    {
        defaultPrepareFn.call(this, geometryInstance);

        //For untextured objects we need to switch techniques.
        var techniqueParameters = geometryInstance.sharedMaterial.techniqueParameters;
        if (!techniqueParameters.diffuse)
        {
            var shader = shaderManager.get("shaders/standard.cgfx");
            if (geometryInstance.geometryType === "skinned")
            {
                geometryInstance.drawParameters[0].technique = shader.getTechnique("flat_skinned");
            }
            else
            {
                geometryInstance.drawParameters[0].technique = shader.getTechnique("flat");
            }
        }
    }

    function loadTechniques(shaderManager)
    {
        var that = this;

        var callback = function shaderLoadedCallbackFn(shader)
        {
            that.shader = shader;
            that.technique = shader.getTechnique(that.techniqueName);
            that.techniqueIndex =  renderingCommonGetTechniqueIndexFn(that.techniqueName);
        };
        shaderManager.load(this.shaderName, callback);
    }

    dr.defaultPrepareFn = defaultPrepareFn;
    dr.defaultUpdateFn = defaultUpdateFn;

    var effect;
    var effectTypeData;
    var skinned = "skinned";
    var rigid = "rigid";

    // Register the effects

    //
    // constant
    //
    effect = Effect.create("constant");
    effectsManager.add(effect);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : "shaders/standard.cgfx",
                        techniqueName : "flat",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : "shaders/standard.cgfx",
                        techniqueName : "flat_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // lambert
    //
    effect = Effect.create("lambert");
    effectsManager.add(effect);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : "shaders/standard.cgfx",
                        techniqueName : "lambert",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : "shaders/standard.cgfx",
                        techniqueName : "lambert_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // blinn
    //
    effect = Effect.create("blinn");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "blinn",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "blinn_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // blinn_nocull
    //
    effect = Effect.create("blinn_nocull");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "blinn_nocull",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "blinn_skinned_nocull",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // phong
    //
    effect = Effect.create("phong");
    effectsManager.add(effect);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : "shaders/standard.cgfx",
                        techniqueName : "phong",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : flatPrepareFn,
                        shaderName : "shaders/standard.cgfx",
                        techniqueName : "phong_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // debug_lines_constant
    //
    effect = Effect.create("debug_lines_constant");
    effectsManager.add(effect);

    effectTypeData = {  prepare : debugLinesPrepareFn,
                        shaderName : "shaders/debug.cgfx",
                        techniqueName : "debug_lines_constant",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // debug_normals
    //
    effect = Effect.create("debug_normals");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/debug.cgfx",
                        techniqueName : "debug_normals",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/debug.cgfx",
                        techniqueName : "debug_normals_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // debug_tangents
    //
    effect = Effect.create("debug_tangents");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/debug.cgfx",
                        techniqueName : "debug_tangents",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/debug.cgfx",
                        techniqueName : "debug_tangents_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // debug_binormals
    //
    effect = Effect.create("debug_binormals");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/debug.cgfx",
                        techniqueName : "debug_binormals",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/debug.cgfx",
                        techniqueName : "debug_binormals_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap
    //
    effect = Effect.create("normalmap");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_specularmap
    //
    effect = Effect.create("normalmap_specularmap");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_specularmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_specularmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_specularmap_alphamap
    //
    effect = Effect.create("normalmap_specularmap_alphamap");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_specularmap_alphamap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // normalmap_alphatest
    //
    effect = Effect.create("normalmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_alphatest",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_alphatest_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);


    //
    // normalmap_specularmap_alphatest
    //
    effect = Effect.create("normalmap_specularmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_specularmap_alphatest",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_specularmap_alphatest_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_glowmap
    //
    effect = Effect.create("normalmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_glowmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_glowmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // normalmap_specularmap_glowmap
    //
    effect = Effect.create("normalmap_specularmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_specularmap_glowmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "normalmap_specularmap_glowmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap
    //
    effect = Effect.create("rxgb_normalmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_specularmap
    //
    effect = Effect.create("rxgb_normalmap_specularmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_specularmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_specularmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_alphatest
    //
    effect = Effect.create("rxgb_normalmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_alphatest",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_alphatest_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_specularmap_alphatest
    //
    effect = Effect.create("rxgb_normalmap_specularmap_alphatest");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_specularmap_alphatest",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_specularmap_alphatest_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_glowmap
    //
    effect = Effect.create("rxgb_normalmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_glowmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_glowmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // rxgb_normalmap_specularmap_glowmap
    //
    effect = Effect.create("rxgb_normalmap_specularmap_glowmap");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_specularmap_glowmap",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "rxgb_normalmap_specularmap_glowmap_skinned",
                        update : defaultSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // add
    //
    effect = Effect.create("add");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "add",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "add_skinned",
                        update : defaultBlendSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // add_particle
    //
    effect = Effect.create("add_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "add_particle",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // blend
    //
    effect = Effect.create("blend");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "blend",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "blend_skinned",
                        update : defaultBlendSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // blend_particle
    //
    effect = Effect.create("blend_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "blend_particle",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // translucent
    //
    effect = Effect.create("translucent");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "translucent",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "translucent_skinned",
                        update : defaultBlendSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // translucent_particle
    //
    effect = Effect.create("translucent_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "translucent_particle",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // filter
    //
    effect = Effect.create("filter");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "filter",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "filter_skinned",
                        update : defaultBlendSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // invfilter
    //
    effect = Effect.create("invfilter");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "invfilter",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // invfilter_particle
    //
    effect = Effect.create("invfilter_particle");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "invfilter_particle",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // glass
    //
    effect = Effect.create("glass");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "glass",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // glass_env
    //
    effect = Effect.create("glass_env");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "glass_env",
                        update : defaultUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // modulate2
    //
    effect = Effect.create("modulate2");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "modulate2",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "modulate2_skinned",
                        update : defaultBlendSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // skybox
    //
    effect = Effect.create("skybox");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "skybox",
                        update : defaultSkyboxUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    //
    // env
    //
    effect = Effect.create("env");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "env",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "env_skinned",
                        update : defaultBlendSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    //
    // flare
    //
    effect = Effect.create("flare");
    effectsManager.add(effect);
    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "add",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectsManager.map("default", "blinn");

    //
    // glowmap
    //
    effect = Effect.create("glowmap");
    effectsManager.add(effect);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "glowmap",
                        update : defaultBlendUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(rigid, effectTypeData);

    effectTypeData = {  prepare : defaultPrepareFn,
                        shaderName : "shaders/defaultrendering.cgfx",
                        techniqueName : "glowmap_skinned",
                        update : defaultBlendSkinnedUpdateFn,
                        loadTechniques : loadTechniques };
    effectTypeData.loadTechniques(shaderManager);
    effect.add(skinned, effectTypeData);

    return dr;
};

// Copyright (c) 2010-2012 Turbulenz Limited
/*global TurbulenzEngine:false*/
/*global VMath:false*/

//
// ResourceLoader
//
function ResourceLoader() {}
ResourceLoader.prototype =
{
    version: 1,

    //
    // clear
    //
    clear: function resourceLoaderClearFn()
    {
        this.nodesMap = {};
        this.referencesPending = {};
        this.numReferencesPending = 0;
        this.animationsPending = {};
    },

    //
    // endLoading
    //
    endLoading: function resourceLoaderEndLoadingFn(onload)
    {
        this.referencesPending = {};
        this.animationsPending = {};

        if (onload)
        {
            onload(this.data);
        }
    },

    resolveShapes: function resourceLoaderResolveShapesFn(loadParams)
    {
        function copyObjectFn(o)
        {
            var newObj = { };
            for (var p in o)
            {
                if (o.hasOwnProperty(p))
                {
                    newObj[p] = o[p];
                }
            }
            return newObj;
        }

        var shapesNamePrefix = loadParams.shapesNamePrefix;
        // we reuse shapesNamePrefix to save adding prefixes for everything
        var skeletonNamePrefix = loadParams.shapesNamePrefix;
        var sceneData = loadParams.data;
        var fileShapes = sceneData.geometries;
        var targetShapes = this.data.geometries;
        if (!targetShapes)
        {
            targetShapes = {};
            this.data.geometries = targetShapes;
        }

        for (var fileShapeName in fileShapes)
        {
            if (fileShapes.hasOwnProperty(fileShapeName))
            {
                var fileShape = fileShapes[fileShapeName];
                var targetShapeName = (shapesNamePrefix ? (shapesNamePrefix + "-" + fileShapeName) : fileShapeName);

                // Update the skeleton reference
                var fileSkeletonName = fileShape.skeleton;
                if (fileSkeletonName)
                {
                    // the shape has to be copied if it has a skeleton as the same shape
                    // can be used with multiple skeletons
                    targetShapes[targetShapeName] = copyObjectFn(fileShape);
                    targetShapes[targetShapeName].skeleton = (skeletonNamePrefix ? (skeletonNamePrefix + "-" + fileSkeletonName) : fileSkeletonName);
                }
                else
                {
                    targetShapes[targetShapeName] = fileShape;
                }
            }
        }
    },

    resolveSkeletons: function resourceLoaderResolveSkeletonsFn(loadParams)
    {
        // we reuse shapesNamePrefix to save adding prefixes for everything
        var skeletonNamePrefix = loadParams.shapesNamePrefix;
        var sceneData = loadParams.data;
        var fileSkeletons = sceneData.skeletons;
        var targetSkeletons = this.data.skeletons;
        if (!targetSkeletons)
        {
            targetSkeletons = {};
            this.data.skeletons = targetSkeletons;
        }

        for (var fileSkeletonName in fileSkeletons)
        {
            if (fileSkeletons.hasOwnProperty(fileSkeletonName))
            {
                var fileSkeleton = fileSkeletons[fileSkeletonName];
                var targetSkeletonName = (skeletonNamePrefix ? (skeletonNamePrefix + "-" + fileSkeletonName) : fileSkeletonName);
                targetSkeletons[targetSkeletonName] = fileSkeleton;
            }
        }
    },

    //
    // Resolve animations
    //
    resolveAnimations: function resourceLoaderResolveAnimationsFn(loadParams)
    {
        var sceneData = loadParams.data;

        var fileAnims = sceneData.animations;
        if (!fileAnims)
        {
            return;
        }

        var currentLoader = this;
        var anims = currentLoader.data.animations;
        if (!anims)
        {
            anims = {};
            currentLoader.data.animations = anims;
        }

        function postLoadReference(sceneText)
        {
            if (sceneText)
            {
                var sceneData = JSON.parse(sceneText);
                var animations = sceneData.animations;
                for (var anim in animations)
                {
                    if (animations.hasOwnProperty(anim))
                    {
                        anims[anim] = animations[anim];
                    }
                }
            }
            //Utilities.log("resolved ref for " + anim + " count now " + (currentLoader.numReferencesPending-1));
            currentLoader.numReferencesPending -= 1;
            if (currentLoader.numReferencesPending <= 0)
            {
                currentLoader.endLoading(loadParams.onload);
            }
        }

        // Import animations
        var requestOwner = (loadParams.request ? loadParams : TurbulenzEngine);
        for (var a in fileAnims)
        {
            if (fileAnims.hasOwnProperty(a))
            {
                var reference = fileAnims[a].reference;
                if (reference)
                {
                    if (!this.animationsPending[a])
                    {
                        this.animationsPending[a] = true;
                        this.numReferencesPending += 1;
                        //Utilities.log("adding ref for " + a + " count now " + this.numReferencesPending);
                        delete fileAnims[a].reference;

                        loadParams.requestHandler.request({
                            src: reference,
                            requestOwner: requestOwner,
                            onload: postLoadReference
                        });
                    }
                }
                else
                {
                    anims[a] = fileAnims[a];
                }
            }
        }
    },


    //
    // resolveNodes
    //
    resolveNodes: function resourceLoaderResolveNodesFn(loadParams)
    {
        var sceneData = loadParams.data;

        var references = this.referencesPending;
        var numReferences = 0;
        var nodesMap = this.nodesMap;

        var currentLoader = this;

        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var shapesNamePrefix = loadParams.shapesNamePrefix;

        var requestOwner = (loadParams.request ? loadParams : TurbulenzEngine);

        function copyObjectFn(o)
        {
            var newObj = { };
            for (var p in o)
            {
                if (o.hasOwnProperty(p))
                {
                    newObj[p] = o[p];
                }
            }
            return newObj;
        }

        function resolveNodeFn(fileNode, nodeName, parentNodePath)
        {
            // We're changing a node which may be referenced multiple times so take a copy
            var node = copyObjectFn(fileNode);
            var nodePath = parentNodePath ? (parentNodePath + "/" + nodeName) : nodeName;

            var reference = node.reference;
            if (reference)
            {
                //Utilities.log("Reference resolve for " + nodePath);

                var internalReferenceIndex = reference.indexOf("#");
                if (internalReferenceIndex === -1)
                {
                    var referenceParameters = references[reference];
                    if (!referenceParameters || referenceParameters.length === 0 || !node.inplace)
                    {
                        numReferences += 1;
                        //Utilities.log("adding ref for " + nodePath + " numrefs now " + numReferences);

                        var sceneParameters = copyObjectFn(loadParams);
                        sceneParameters.append = true;
                        if (node.inplace)
                        {
                            sceneParameters.nodesNamePrefix = parentNodePath;
                            sceneParameters.shapesNamePrefix = null;
                            sceneParameters.parentNode = null;
                        }
                        else
                        {
                            sceneParameters.nodesNamePrefix = nodePath;
                            sceneParameters.shapesNamePrefix = reference;
                            sceneParameters.parentNode = node;
                        }
                        if (node.skin)
                        {
                            sceneParameters.skin = node.skin;
                        }

                        if (!referenceParameters || referenceParameters.length === 0)
                        {
                            referenceParameters = [sceneParameters];
                            references[reference] = referenceParameters;

                            var loadReference = function (sceneText)
                            {
                                var numInstances = referenceParameters.length;
                                var sceneData;
                                if (sceneText)
                                {
                                    sceneData = JSON.parse(sceneText);
                                }
                                else
                                {
                                    // Make sure we can call scene load to correctly deal with reference
                                    // counts when a reference is missing
                                    sceneData = {};
                                }
                                var params;
                                for (var n = 0; n < numInstances; n += 1)
                                {
                                    params = referenceParameters[n];
                                    params.data = sceneData;
                                    params.isReference = true;
                                    currentLoader.resolve(params);
                                }
                                referenceParameters.length = 0;
                            };

                            loadParams.requestHandler.request({
                                    src: reference,
                                    requestOwner: requestOwner,
                                    onload: loadReference
                                });
                        }
                        else
                        {
                            referenceParameters.push(sceneParameters);
                        }
                    }
                }
                delete node.reference;
                delete node.inplace;
            }

            var geometryinstances = node.geometryinstances;
            if (shapesNamePrefix && geometryinstances)
            {
                // Need to deep copy the geometry instances dictionary because we're prefixing the names
                node.geometryinstances = { };
                for (var gi in geometryinstances)
                {
                    if (geometryinstances.hasOwnProperty(gi))
                    {
                        node.geometryinstances[gi] = copyObjectFn(geometryinstances[gi]);
                        var geometryInstance = node.geometryinstances[gi];

                        //Utilities.log("prefixing " + geometryInstance.geometry + " with " + shapesNamePrefix);
                        geometryInstance.geometry = shapesNamePrefix + "-" + geometryInstance.geometry;
                    }
                }
            }

            var fileChildren = fileNode.nodes;
            if (fileChildren)
            {
                node.nodes = {};
                for (var c in fileChildren)
                {
                    if (fileChildren.hasOwnProperty(c))
                    {
                        var childPath = nodePath + "/" + c;
                        if (!nodesMap[childPath])
                        {
                            node.nodes[c] = resolveNodeFn(fileChildren[c], c, nodePath);
                            nodesMap[childPath] = node.nodes[c];
                        }
                    }
                }
            }

            return node;
        }

        var fileNodes = sceneData.nodes;
        var parentNode = loadParams.parentNode;
        for (var fn in fileNodes)
        {
            if (fileNodes.hasOwnProperty(fn) && fileNodes[fn])
            {
                var nodeName = fn;
                var fileNode = resolveNodeFn(fileNodes[fn], nodeName, nodesNamePrefix);
                var nodePath = (nodesNamePrefix ? (nodesNamePrefix + "/" + fn) : fn);
                var overloadedNode = nodesMap[nodePath];

                if (overloadedNode)
                {
                    //Utilities.log("Overloaded node '" + nodePath + "'");

                    var overloadedMatrix = overloadedNode.matrix;
                    if (overloadedMatrix && fileNode.matrix)
                    {
                        overloadedNode.matrix = VMath.m43Mul(fileNode.matrix, overloadedMatrix);
                        overloadedMatrix = null;
                    }

                    var overloadedChildren = overloadedNode.nodes;
                    if (overloadedChildren && fileNode.nodes)
                    {
                        //Utilities.log("Concat children of node '" + nodePath + "'");
                        for (var c in fileNode.nodes)
                        {
                            if (fileNode.nodes.hasOwnProperty(c))
                            {
                                overloadedChildren[c] = fileNode.nodes[c];
                            }
                        }
                    }
                    else if (fileNode.nodes)
                    {
                        overloadedNode.nodes = fileNode.nodes;
                    }

                    for (var on in fileNode)
                    {
                        if (fileNode.hasOwnProperty(on))
                        {
                            overloadedNode[on] = fileNode[on];
                        }
                    }
                    fileNode = overloadedNode;
                }
                else
                {
                    if (loadParams.isReference && parentNode)
                    {
                        if (!parentNode.nodes)
                        {
                            parentNode.nodes = {};
                        }
                        parentNode.nodes[fn] = fileNode;
                    }
                    else
                    {
                        this.data.nodes[fn] = fileNode;
                    }

                    nodesMap[nodePath] = fileNode;
                }
            }
        }

        this.numReferencesPending += numReferences;
        //Utilities.log("total refs now " + this.numReferencesPending);
    },

    //
    // loadPhysicsNodes
    //
    resolvePhysicsNodes: function resourceLoaderResolvePhysicsNodesFn(loadParams)
    {
        var sceneData = loadParams.data;
        var nodesNamePrefix = loadParams.nodesNamePrefix;
        var shapesNamePrefix = loadParams.shapesNamePrefix;

        function begetFn(o)
        {
            var F = function () { };
            F.prototype = o;
            return new F();
        }

        var fileModels = sceneData.physicsmodels;
        var targetFileModels = this.data.physicsmodels;
        if (!targetFileModels)
        {
            targetFileModels = {};
            this.data.physicsmodels = targetFileModels;
        }

        for (var fm in fileModels)
        {
            if (fileModels.hasOwnProperty(fm))
            {
                var fileModel = fileModels[fm];

                if (shapesNamePrefix)
                {
                    var newModelName = shapesNamePrefix ? shapesNamePrefix + "-" + fm : fm;

                    var model = begetFn(fileModel);
                    targetFileModels[newModelName] = model;

                    var geometry = model.geometry;
                    if (geometry)
                    {
                        model.geometry = shapesNamePrefix ? shapesNamePrefix + "-" + geometry : geometry;
                    }
                }
                else
                {
                    targetFileModels[fm] = fileModel;
                }
            }
        }

        var fileNodes = sceneData.physicsnodes;
        var targetFileNodes = this.data.physicsnodes;
        if (!targetFileNodes)
        {
            targetFileNodes = {};
            this.data.physicsnodes = targetFileNodes;
        }

        for (var fn in fileNodes)
        {
            if (fileNodes.hasOwnProperty(fn))
            {
                var fileNode = fileNodes[fn];

                if (nodesNamePrefix || shapesNamePrefix)
                {
                    var targetName = fileNode.target;
                    targetName = nodesNamePrefix ? (nodesNamePrefix + "/" + targetName) : targetName;

                    var node = begetFn(fileNode);
                    node.target = targetName;

                    node.body = shapesNamePrefix ? shapesNamePrefix + "-" + fileNode.body : fileNode.body;

                    var newNodeName = nodesNamePrefix ? (nodesNamePrefix + "/" + fn) : fn;
                    targetFileNodes[newNodeName] = node;
                }
                else
                {
                    targetFileNodes[fn] = fileNode;
                }
            }
        }
    },

    //
    // loadAreas
    //
    resolveAreas: function resourceLoaderResolveAreasFn(loadParams)
    {
        var sceneData = loadParams.data;

        var fileAreas = sceneData.areas;
        if (!fileAreas)
        {
            return;
        }

        var numFileAreas = fileAreas.length;
        if (numFileAreas <= 0)
        {
            return;
        }

        var targetAreas = this.data.areas;
        if (!targetAreas)
        {
            targetAreas = [];
            this.data.areas = targetAreas;
        }

        var nodesNamePrefix = loadParams.nodesNamePrefix;

        for (var fa = 0; fa < numFileAreas; fa += 1)
        {
            var fileArea = fileAreas[fa];

            if (nodesNamePrefix)
            {
                var targetName = fileArea.target;
                fileArea.target = (nodesNamePrefix + "/" + targetName);
            }
            targetAreas.push(fileArea);
        }
    },

    //
    // resolve
    //
    resolve: function resourceLoaderResolveFn(loadParams)
    {
        if (!loadParams.append)
        {
            this.data = { nodes: {} };
        }

        // Start by simply copying any dictionaries which we don't special case
        var appendData = loadParams.data;
        for (var d in appendData)
        {
            if (d !== "nodes" &&
                d !== "skeletons" &&
                d !== "geometries" &&
                d !== "animations" &&
                d !== "areas" &&
                d !== "physicsnodes" &&
                d !== "physicsmodels")
            {
                if (appendData.hasOwnProperty(d))
                {
                    var dict = appendData[d];
                    var targetDict = this.data[d];
                    if (!targetDict)
                    {
                        this.data[d] = dict;
                    }
                    else
                    {
                        for (var e in dict)
                        {
                            if (dict.hasOwnProperty(e) && !targetDict[e])
                            {
                                targetDict[e] = dict[e];
                            }
                        }
                    }
                }
            }
        }

        this.resolveShapes(loadParams);

        this.resolveSkeletons(loadParams);

        this.resolveAnimations(loadParams);

        this.resolveNodes(loadParams);

        this.resolvePhysicsNodes(loadParams);

        this.resolveAreas(loadParams);

        if (loadParams.isReference)
        {
            this.numReferencesPending -= 1;
            //Utilities.log("loaded ref now " + this.numReferencesPending);
        }

        if (this.numReferencesPending <= 0)
        {
            this.endLoading(loadParams.onload);
        }

    },

    //
    // load
    //
    load: function resourceLoaderLoadFn(assetPath, loadParams)
    {
        var loader = this;
        var dataReceived = function dataReceivedFn(text)
        {
            var sceneData = {};
            if (text)
            {
                sceneData = JSON.parse(text);
            }

            loadParams.data = sceneData;
            loadParams.append = false;
            loader.resolve(loadParams);
        };

        loadParams.requestHandler.request({
                src: assetPath,
                requestOwner: loadParams.request ? loadParams : TurbulenzEngine,
                onload: dataReceived
            });
    }

};

// Constructor function
ResourceLoader.create = function resourceLoaderCreateFn()
{
    var rl = new ResourceLoader();
    rl.clear();

    rl.skeletonNames = {};

    return rl;
};

// Copyright (c) 2010-2011 Turbulenz Limited

//
// Observer
//
function Observer() {}

Observer.prototype = {
    subscribe: function observerSubscribeFn(subscriber)
    {
        //Check for duplicates
        var subscribers = this.subscribers;
        var length = subscribers.length;
        for (var index = 0; index < length; index += 1)
        {
            if (subscribers[index] === subscriber)
            {
                return;
            }
        }

        subscribers.push(subscriber);
    },

    unsubscribe: function observerUnsubscribeFn(subscriber)
    {
        var subscribers = this.subscribers;
        var length = subscribers.length;
        for (var index = 0; index < length; index += 1)
        {
            if (subscribers[index] === subscriber)
            {
                subscribers.splice(index, 1);
                break;
            }
        }
    },

    unsubscribeAll: function observerUnsubscribeAllFn(subscriber)
    {
        this.subscribers.length = 0;
    },

    // this function can take any number of arguments
    // they are passed on to the subscribers
    notify: function observerNotifyFn()
    {
        // Note that the callbacks might unsubscribe
        var subscribers = this.subscribers;
        var length = this.subscribers.length;
        var index = 0;

        while (index < length)
        {
            subscribers[index].apply(null, arguments);
            if (subscribers.length === length)
            {
                index += 1;
            }
            else
            {
                length = subscribers.length;
            }
        }
    }
};

Observer.create = function observerCreateFn()
{
    var observer = new Observer();
    observer.subscribers = [];
    return observer;
};

// Copyright (c) 2010-2012 Turbulenz Limited

/*global window: false*/
/*global Observer: false*/
/*global TurbulenzEngine: false*/

var Utilities = {};

//
// assert
//
Utilities.skipAsserts = false;
Utilities.assert = function assertFn(test, message)
{
    if (!test)
    {
        if (!this.skipAsserts)
        {
            this.breakInDebugger.doesNotExist(); //Use a function that does not exist. This is caught in the debuggers.
        }
    }
};

//
// beget
//
Utilities.beget = function begetFn(o)
{
    var F = function () { };
    F.prototype = o;
    return new F();
};

//
// log
//
Utilities.log = function logFn()
{
    var console = window.console;
    if (console)
    {
        // "console.log.apply" will crash when using the plugin on Chrome...
        switch (arguments.length)
        {
        case 1:
            console.log(arguments[0]);
            break;
        case 2:
            console.log(arguments[0], arguments[1]);
            break;
        case 3:
            console.log(arguments[0], arguments[1], arguments[2]);
            break;
        case 4:
            console.log(arguments[0], arguments[1], arguments[2], arguments[3]);
            break;
        default:
            // Note: this will fail if using printf-style string formatting
            var args = [].splice.call(arguments, 0);
            console.log(args.join(' '));
            break;
        }
    }
};

Utilities.nearestLowerPow2 = function UtilitiesNearestLowerPow2(num)
{
    /*jshint bitwise: false*/
    num = num | (num >>> 1);
    num = num | (num >>> 2);
    num = num | (num >>> 4);
    num = num | (num >>> 8);
    num = num | (num >>> 16);
    return (num - (num >>> 1));
};

Utilities.nearestUpperPow2 = function UtilitiesNearestUpperPow2(num)
{
    /*jshint bitwise: false*/
    num = num - 1;
    num = num | (num >>> 1);
    num = num | (num >>> 2);
    num = num | (num >>> 4);
    num = num | (num >>> 8);
    num = num | (num >>> 16);
    return (num + 1);
};

var MathDeviceConvert =
{
    v2ToArray : function v2ToJavaScriptArrayFn(v2)
    {
        return [v2[0], v2[1]];
    },

    arrayToV2 : function arrayToV2Fn(mathDevice, v2Array, v2Dest)
    {
        return mathDevice.v2Build(v2Array[0], v2Array[1], v2Dest);
    },

    v3ToArray : function v3ToJavaScriptArrayFn(v3)
    {
        return [v3[0], v3[1], v3[2]];
    },

    arrayToV3 : function arrayToV3Fn(mathDevice, v3Array, v3Dest)
    {
        return mathDevice.v3Build(v3Array[0], v3Array[1], v3Array[2], v3Dest);
    },

    v4ToArray : function v4ToJavaScriptArrayFn(v4)
    {
        return [v4[0], v4[1], v4[2], v4[3]];
    },

    arrayToV4 : function arrayToV4Fn(mathDevice, v4Array, v4Dest)
    {
        return mathDevice.v4Build(v4Array[0], v4Array[1], v4Array[2], v4Array[3], v4Dest);
    },

    quatToArray : function quatToJavaScriptArrayFn(quat)
    {
        return [quat[0], quat[1], quat[2], quat[3]];
    },

    arrayToQuat : function arrayToQuatFn(mathDevice, quatArray, quatDest)
    {
        return mathDevice.quatBuild(quatArray[0], quatArray[1], quatArray[2], quatArray[3], quatDest);
    },

    aabbToArray : function aabbToJavaScriptArrayFn(aabb)
    {
        return [aabb[0], aabb[1], aabb[2],
                aabb[3], aabb[4], aabb[5]];
    },

    arrayToAABB : function arrayToQuatFn(mathDevice, aabbArray, aabbDest)
    {
        return mathDevice.aabbBuild(aabbArray[0], aabbArray[1], aabbArray[2],
                                    aabbArray[3], aabbArray[4], aabbArray[5], aabbDest);
    },

    quatPosToArray : function quatPosToJavaScriptArrayFn(quatPos)
    {
        return [quatPos[0], quatPos[1], quatPos[2], quatPos[3],
                quatPos[4], quatPos[5], quatPos[6]];
    },

    arrayToQuatPos : function arrayToQuatPosFn(mathDevice, quatPosArray, quatPosDest)
    {
        return mathDevice.quatPosBuild(quatPosArray[0], quatPosArray[1], quatPosArray[2], quatPosArray[3],
                                       quatPosArray[4], quatPosArray[5], quatPosArray[6], quatPosDest);
    },

    m33ToArray : function m33ToJavaScriptArrayFn(m33)
    {
        return [m33[0], m33[1], m33[2],
                m33[3], m33[4], m33[5],
                m33[6], m33[7], m33[8]];
    },

    arrayToM33 : function arrayToM33Fn(mathDevice, m33Array, m33Dest)
    {
        return mathDevice.m33Build(m33Array[0], m33Array[1], m33Array[2],
                                   m33Array[3], m33Array[4], m33Array[5],
                                   m33Array[6], m33Array[7], m33Array[8], m33Dest);
    },

    /*jshint white: false*/
    m43ToArray : function m43ToJavaScriptArrayFn(m43)
    {
        return [m43[0], m43[ 1], m43[ 2],
                m43[3], m43[ 4], m43[ 5],
                m43[6], m43[ 7], m43[ 8],
                m43[9], m43[10], m43[11]];
    },

    arrayToM43 : function arrayToM43Fn(mathDevice, m43Array, m43Dest)
    {
        return mathDevice.m43Build(m43Array[0], m43Array[ 1], m43Array[ 2],
                                   m43Array[3], m43Array[ 4], m43Array[ 5],
                                   m43Array[6], m43Array[ 7], m43Array[ 8],
                                   m43Array[9], m43Array[10], m43Array[11], m43Dest);
    },

    m34ToArray : function m34ToJavaScriptArrayFn(m34)
    {
        return [m34[0], m34[1], m34[ 2], m34[ 3],
                m34[4], m34[5], m34[ 6], m34[ 7],
                m34[8], m34[9], m34[10], m34[11]];
    },

    m44ToArray : function m44ToJavaScriptArrayFn(m44)
    {
        return [m44[ 0], m44[ 1], m44[ 2], m44[ 3],
                m44[ 4], m44[ 5], m44[ 6], m44[ 7],
                m44[ 8], m44[ 9], m44[10], m44[11],
                m44[12], m44[13], m44[14], m44[15]];
    },

    arrayToM44 : function arrayToM44Fn(mathDevice, m44Array, m44Dest)
    {
        return mathDevice.m44Build(m44Array[ 0], m44Array[ 1], m44Array[ 2], m44Array[ 3],
                                   m44Array[ 4], m44Array[ 5], m44Array[ 6], m44Array[ 7],
                                   m44Array[ 8], m44Array[ 9], m44Array[10], m44Array[11],
                                   m44Array[12], m44Array[13], m44Array[14], m44Array[15], m44Dest);
    }
    /*jshint white: true*/
};

//
// ajax
//
Utilities.ajax = function utilitiesAjaxFn(params)
{
    // parameters
    var requestText = "";
    var method = params.method;
    var data = params.data || {};
    var encrypted = params.encrypt;
    var signature = null;
    var url = params.url;
    var requestHandler = params.requestHandler;
    var callbackFn = params.callback;

    if (encrypted)
    {
        data.requestUrl = url;

        var str = JSON.stringify(data);

        if (method === "POST")
        {
            str = TurbulenzEngine.encrypt(str);
        }

        requestText += "data=" + encodeURIComponent(str) + "&";

        requestText += "gameSessionId=" + encodeURIComponent(data.gameSessionId);

        signature = TurbulenzEngine.generateSignature(str);
    }
    else if (data)
    {
        var key;
        for (key in data)
        {
            if (data.hasOwnProperty(key))
            {
                if (requestText.length !== 0)
                {
                    requestText += "&";
                }
                if (method === "POST")
                {
                    requestText += key + "=" + data[key];
                }
                else
                {
                    requestText += encodeURIComponent(key) + "=" + encodeURIComponent(data[key]);
                }
            }
        }
    }

    var httpResponseCallback = function httpResponseCallbackFn(xhrResponseText, xhrStatus)
    {
        var sig = this.xhr.getResponseHeader("X-TZ-Signature");

        // break circular reference
        this.xhr.onreadystatechange = null;
        this.xhr = null;

        var response;

        response = JSON.parse(xhrResponseText);
        if (encrypted)
        {
            var validSignature = TurbulenzEngine.verifySignature(xhrResponseText, sig);
            xhrResponseText = null;

            TurbulenzEngine.setTimeout(function () {
                var receivedUrl = response.requestUrl;

                if (validSignature)
                {
                    if (!TurbulenzEngine.encryptionEnabled || receivedUrl === url)
                    {
                        callbackFn(response, xhrStatus);
                        callbackFn = null;
                        return;
                    }
                }

                // If it was a server-side verification fail then pass through the actual message
                if (xhrStatus === 400)
                {
                    callbackFn(response, xhrStatus, "Verification Failed");
                }
                else
                {
                    // Else drop reply
                    callbackFn({msg: "Verification failed", ok: false}, 400, "Verification Failed");
                }
                callbackFn = null;
            }, 0);
        }
        else
        {
            xhrResponseText = null;

            TurbulenzEngine.setTimeout(function () {
                callbackFn(response, xhrStatus);
                callbackFn = null;
            }, 0);
        }
    };

    var httpRequest = function httpRequestFn(url, onload, callContext)
    {
        var xhr;
        if (window.XMLHttpRequest)
        {
            xhr = new window.XMLHttpRequest();
        }
        else if (window.ActiveXObject)
        {
            xhr = new window.ActiveXObject("Microsoft.XMLHTTP");
        }
        else
        {
            if (params.error)
            {
                params.error("No XMLHTTPRequest object could be created");
            }
            return;
        }
        callContext.xhr = xhr;

        var httpCallback = function httpCallbackFn()
        {
            if (xhr.readyState === 4 && TurbulenzEngine && !TurbulenzEngine.isUnloading()) /* 4 == complete */
            {
                var xhrResponseText = xhr.responseText;
                var xhrStatus = xhr.status;
                // Checking xhrStatusText when xhrStatus is 0 causes a silent error!
                var xhrStatusText = (xhrStatus !== 0 && xhr.statusText) || "No connection or cross domain request";

                // Sometimes the browser sets status to 200 OK when the connection is closed
                // before the message is sent (weird!).
                // In order to address this we fail any completely empty responses.
                // Hopefully, nobody will get a valid response with no headers and no body!
                if (xhr.getAllResponseHeaders() === "" && xhrResponseText === "" && xhrStatus === 200 && xhrStatusText === 'OK')
                {
                    onload('', 0);
                    return;
                }

                onload.call(callContext, xhrResponseText, xhrStatus);
            }
        };

        // Send request
        xhr.open(method, ((requestText && (method !== "POST")) ? url + "?" + requestText : url), true);
        if (callbackFn)
        {
            xhr.onreadystatechange = httpCallback;
        }

        if (signature)
        {
            xhr.setRequestHeader("X-TZ-Signature", signature);
        }

        if (method === "POST")
        {
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
            xhr.send(requestText);
        }
        else // method === 'GET'
        {
            xhr.send();
        }
    };

    if (requestHandler)
    {
        requestHandler.request({
            src: url,
            requestFn: httpRequest,
            customErrorHandler: params.customErrorHandler,
            onload: httpResponseCallback
        });
    }
    else
    {
        var callContext = {
            src: url
        };
        httpRequest(url, httpResponseCallback, callContext);
    }
};


//
// ajaxStatusCodes
//

// http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
Utilities.ajaxStatusCodes = {
    0: "No Connection, Timeout Or Cross Domain Request",
    100: "Continue",
    101: "Switching Protocols",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Time-out",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Request Entity Too Large",
    414: "Request-URI Too Large",
    415: "Unsupported Media Type",
    416: "Requested range not satisfiable",
    417: "Expectation Failed",
    429: "Too Many Requests",
    480: "Temporarily Unavailable",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Time-out",
    505: "HTTP Version not supported"
};

//
//Reference
//

// Proxy reference class allowing weak reference to the object
function Reference() {}

Reference.prototype =
{
    version: 1,

    //
    // add
    //
    add: function referenceAddFn()
    {
        this.referenceCount += 1;
    },

    //
    // remove
    //
    remove: function referenceRemovefn()
    {
        this.referenceCount -= 1;
        if (this.referenceCount === 0)
        {
            if (this.destroyedObserver)
            {
                this.destroyedObserver.notify(this.object);
            }
            this.object.destroy();
            this.object = null;
        }
    },

    //
    //subscribeDestroyed
    //
    subscribeDestroyed: function referenceSubscribeDestroyedFn(observerFunction)
    {
        if (!this.destroyedObserver)
        {
            this.destroyedObserver = Observer.create();
        }
        this.destroyedObserver.subscribe(observerFunction);
    },

    //
    //unsubscribeDestroyed
    //
    unsubscribeDestroyed: function referenceDestroyedFn(observerFunction)
    {
        this.destroyedObserver.unsubscribe(observerFunction);
    }
};

//
// create
//
Reference.create = function referenceCreate(object)
{
    var result = new Reference();
    result.object = object;
    result.referenceCount = 0;
    return result;
};


//
// Profile
//
var Profile =
{
    profiles: [],

    sortMode: {alphabetical: 0, duration: 1, max: 2, min: 3, calls: 4},

    //
    // start
    //
    start: function profileStartFn(name)
    {
        var data = this.profiles[name];
        if (!data)
        {
            data = {name: name, calls: 0, duration: 0.0, min: Number.MAX_VALUE, max: 0.0, sumOfSquares: 0.0};
            this.profiles[name] = data;
        }
        data.start = TurbulenzEngine.time;
    },

    //
    // stop
    //
    stop: function profileStopFn(name)
    {
        var end = TurbulenzEngine.time;
        var data = this.profiles[name];
        if (data)
        {
            var duration = end - data.start;
            data.duration += duration;
            data.calls += 1;
            var delta = duration - data.duration / data.calls; // This is an approximation, it should use the mean of all samples (or N random ones) but thats requries samples to be stored
            data.sumOfSquares += delta * delta;

            if (duration > data.max)
            {
                data.max = duration;
            }

            if (duration < data.min)
            {
                data.min = duration;
            }
        }
    },

    //
    // reset
    //
    reset: function profileResetFn()
    {
        this.profiles = [];
    },

    //
    // getReport
    //
    getReport: function profileGetReportFn(sortMode, format)
    {
        var dataArray = [];
        var data;
        var maxDuration = 0.0;
        var name;
        for (name in this.profiles)
        {
            if (this.profiles.hasOwnProperty(name))
            {
                data = this.profiles[name];
                if (maxDuration < data.duration)
                {
                    maxDuration = data.duration;
                }
                dataArray.push(data);
            }
        }

        var compareFunction;

        if (sortMode === Profile.sortMode.alphabetical)
        {
            compareFunction = function compareName(left, right)
                            {
                                return (left.name < right.name) ? -1 : (left.name > right.name) ? 1 : 0;
                            };
        }
        else if (sortMode === Profile.sortMode.max)
        {
            compareFunction = function compareMax(left, right)
                            {
                                return right.max - left.max;
                            };
        }
        else if (sortMode === Profile.sortMode.min)
        {
            compareFunction = function compareMin(left, right)
                            {
                                return right.min - left.min;
                            };
        }
        else if (sortMode === Profile.sortMode.calls)
        {
            compareFunction = function compareCalls(left, right)
                            {
                                return right.calls - left.calls;
                            };
        }
        else // Profile.sortMode.duration or undefined
        {
            compareFunction = function compareDuration(left, right)
                            {
                                return right.duration - left.duration;
                            };
        }

        dataArray.sort(compareFunction);

        var line;
        var text = "";
        var precision = format ? format.precision : 8;
        var percentagePrecision = format ? format.percentagePrecision : 1;
        var seperator = format ? format.seperator : " ";
        var length = dataArray.length;
        var index;
        for (index = 0; index < length; index += 1)
        {
            data = dataArray[index];
            line = data.name;
            line += seperator + data.calls;
            line += seperator + data.duration.toFixed(precision);
            line += seperator + data.max.toFixed(precision);
            line += seperator + data.min.toFixed(precision);
            line += seperator + (data.duration / data.calls).toFixed(precision); // average
            line += seperator + Math.sqrt(data.sumOfSquares / data.calls).toFixed(precision); // approximate standard deviation
            line += seperator + (100 * data.duration / maxDuration).toFixed(percentagePrecision) + "%\n";
            text += line;
        }
        return text;
    }
};

//
// Utilities to use with TurbulenzEngine.stopProfiling() object.
//
var JSProfiling = {};

//
// createArray
//      Creates an array of nodes by merging all duplicate function references in the call profile tree together.
JSProfiling.createArray = function JSProfilingCreateArrayFn(rootNode)
{
    var map = {};
    var array = [];

    if (rootNode.head)
    {
        rootNode = rootNode.head; // Chrome native profiler.
    }

    var processNode = function processNodeFn(node)
    {
        var urlObject = map[node.url];
        if (!urlObject)
        {
            urlObject = {};
            map[node.url] = urlObject;
        }

        var functionName = node.functionName === "" ? "(anonymous)" : node.functionName;

        var functionObject = urlObject[functionName];
        if (!functionObject)
        {
            functionObject = {};
            urlObject[functionName] = functionObject;
        }

        var existingNode = functionObject[node.lineNumber];
        if (!existingNode)
        {
            var newNode = { functionName : functionName,
                            numberOfCalls : node.numberOfCalls,
                            totalTime : node.totalTime,
                            selfTime : node.selfTime,
                            url : node.url,
                            lineNumber : node.lineNumber
                           };

            array[array.length] = newNode;
            functionObject[node.lineNumber] = newNode;
        }
        else
        {
            existingNode.totalTime += node.totalTime;
            existingNode.selfTime += node.selfTime;
            existingNode.numberOfCalls += node.numberOfCalls;
        }

        var children = node.children;
        if (children)
        {
            var numberOfChildren = children.length;
            var childIndex;
            for (childIndex = 0; childIndex < numberOfChildren; childIndex += 1)
            {
                processNode(children[childIndex]);
            }
        }
    };

    processNode(rootNode);

    return array;
};

//
// sort
//
JSProfiling.sort = function JSProfilingSortFn(array, propertyName, descending)
{
    if (!propertyName)
    {
        propertyName = "totalTime";
    }

    var sorterAscending = function (left, right)
    {
        return left[propertyName] - right[propertyName];
    };

    var sorterDescending = function (left, right)
    {
        return right[propertyName] - left[propertyName];
    };

    if (descending === false)
    {
        array.sort(sorterAscending);
    }
    else
    {
        array.sort(sorterDescending);
    }
};

// Copyright (c) 2010-2012 Turbulenz Limited

/*global Utilities: false*/

//
// VertexBufferManager
//

function VertexBufferManager() {}

VertexBufferManager.prototype =
{
    version: 1,

    maxVerticesPerVertexBuffer: 65535,

    numBuckets: 10,

    //
    // bucket
    //
    bucket: function bucketFn(numVertices)
    {
        if (numVertices <= 64)
        {
            if (numVertices <= 16)
            {
                if (numVertices <= 8)
                {
                    return 0;
                }
                return 1;
            }

            if (numVertices <= 32)
            {
                return 2;
            }
            return 3;
        }

        if (numVertices <= 512)
        {
            if (numVertices <= 256)
            {
                if (numVertices <= 128)
                {
                    return 4;
                }
                return 5;
            }
            return 6;
        }

        if (numVertices <= 2048)
        {
            if (numVertices <= 1024)
            {
                return 7;
            }
            return 8;
        }
        return 9;
    },

    //
    // makeBuckets
    //
    makeBuckets: function makeBucketsFn()
    {
        var result = [];

        for (var index = 0; index < this.numBuckets; index += 1)
        {
            result.push({headChunk: null});
        }
        return result;
    },

    //
    // allocate
    //
    allocate: function vertexBufferManagerAllocate(numVertices, attributes)
    {
        var vertexbuffer = null;
        var baseIndex = 0;

        var vertexbufferParameters =
        {
            attributes: attributes,
            dynamic: this.dynamicVertexBuffers
        };

        var poolIndex;
        var maxVerticesPerVertexBuffer = this.maxVerticesPerVertexBuffer;

        var attributesHash = attributes.join();
        var numVertexBuffersPools = this.vertexBuffersPools.length;
        var vertexBuffersPool;

        //Find the pool to allocate from
        for (poolIndex = 0; poolIndex < numVertexBuffersPools; poolIndex += 1)
        {
            if (this.vertexBuffersPools[poolIndex].attributesHash === attributesHash)
            {
                vertexBuffersPool = this.vertexBuffersPools[poolIndex];
                break;
            }
        }

        if (!vertexBuffersPool)
        {
            vertexBuffersPool = { attributesHash: attributesHash,
                                  vertexBufferData: [] };
            this.vertexBuffersPools.push(vertexBuffersPool);
        }

        var vertexBufferData;
        if (numVertices < maxVerticesPerVertexBuffer)
        {
            //Start at the correct size bucket and then look in bigger buckets if there is no suitable space
            //TODO: track last allocation as start point - but needs to be valid.
            for (var bucketIndex = this.bucket(numVertices); !vertexbuffer && bucketIndex < this.numBuckets; bucketIndex += 1)
            {
                var previousChunk;
                for (var vertexBufferIndex = 0; !vertexbuffer && (vertexBufferIndex < vertexBuffersPool.vertexBufferData.length); vertexBufferIndex += 1)
                {
                    vertexBufferData = vertexBuffersPool.vertexBufferData[vertexBufferIndex];

                    //Now find a to chunk allocate from
                    previousChunk = null;

                    for (var chunk = vertexBufferData.bucket[bucketIndex].headChunk; chunk;  chunk = chunk.nextChunk)
                    {
                        if (numVertices <= chunk.length)
                        {
                            vertexbuffer = vertexBufferData.vertexBuffer;
                            baseIndex = chunk.baseIndex;
                            if (numVertices < chunk.length)
                            {
                                chunk.baseIndex = (baseIndex + numVertices);
                                chunk.length -= numVertices;
                                var newBucketIndex = this.bucket(chunk.length);
                                if (newBucketIndex !== bucketIndex)
                                {
                                    if (previousChunk)
                                    {
                                        previousChunk.nextChunk =  chunk.nextChunk;
                                    }
                                    else
                                    {
                                        vertexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                    }
                                    //Add to new bucket
                                    chunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                                    vertexBufferData.bucket[newBucketIndex].headChunk = chunk;
                                }
                            }
                            else
                            {
                                //Allocated whole chunk so remove it.
                                if (previousChunk)
                                {
                                    previousChunk.nextChunk =  chunk.nextChunk;
                                }
                                else
                                {
                                    vertexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                }
                                chunk.vertexBuffer = null;
                            }
                            break;
                        }
                        previousChunk = chunk;
                    }
                }
            }

            if (!vertexbuffer)
            {
                vertexbufferParameters.numVertices = maxVerticesPerVertexBuffer;
                vertexbuffer = this.graphicsDevice.createVertexBuffer(vertexbufferParameters);
                this.debugCreatedVertexBuffers += 1;

                Utilities.assert(vertexbuffer, "VertexBuffer not created.");

                if (vertexbuffer)
                {
                    vertexBufferData = {vertexBuffer: vertexbuffer,
                                        bucket: this.makeBuckets()};

                    vertexBufferData.bucket[this.bucket(maxVerticesPerVertexBuffer - numVertices)].headChunk = {baseIndex: numVertices,
                                                                                                                length: maxVerticesPerVertexBuffer - numVertices,
                                                                                                                nextChunk: null };

                    vertexBuffersPool.vertexBufferData.push(vertexBufferData);
                }
            }
        }

        if (!vertexbuffer)
        {
            vertexbufferParameters.numVertices = numVertices;
            vertexbuffer = this.graphicsDevice.createVertexBuffer(vertexbufferParameters);
            this.debugCreatedVertexBuffers += 1;

            Utilities.assert(vertexbuffer, "VertexBuffer not created.");

            if (vertexbuffer)
            {
                vertexBuffersPool.vertexBufferData.push({vertexBuffer: vertexbuffer,
                                                         bucket: this.makeBuckets()});
            }
        }

        return {
            vertexBuffer: vertexbuffer,
            baseIndex: baseIndex,
            length: numVertices,
            poolIndex: poolIndex
        };
    },

    //
    // free
    //
    free: function vertexBufferManagerFree(allocation)
    {
        var vertexBuffersPool = this.vertexBuffersPools[allocation.poolIndex];
        var vertexBufferData;
        for (var vertexBufferIndex = 0; vertexBufferIndex < vertexBuffersPool.vertexBufferData.length; vertexBufferIndex += 1)
        {
            if (allocation.vertexBuffer === vertexBuffersPool.vertexBufferData[vertexBufferIndex].vertexBuffer)
            {
                vertexBufferData = vertexBuffersPool.vertexBufferData[vertexBufferIndex];
                break;
            }
        }
        //TODO: optimise
        var leftChunk;
        var leftChunkPrevious;
        var rightChunk;
        var rightChunkPrevious;
        var previous;
        for (var bucketIndex = 0; !(leftChunk && rightChunk) && (bucketIndex < this.numBuckets); bucketIndex += 1)
        {
            previous = null;
            for (var chunk = vertexBufferData.bucket[bucketIndex].headChunk; chunk && !(leftChunk && rightChunk);  chunk = chunk.nextChunk)
            {
                if (!leftChunk)
                {
                    if (chunk.baseIndex + chunk.length === allocation.baseIndex)
                    {
                        leftChunk = chunk;
                        leftChunkPrevious = previous;
                    }
                }
                if (!rightChunk)
                {
                    if (chunk.baseIndex === allocation.baseIndex + allocation.length)
                    {
                        rightChunk = chunk;
                        rightChunkPrevious = previous;
                    }
                }
                previous = chunk;
            }
        }

        var oldBucketIndex;
        var newBucketIndex;
        if (leftChunk && rightChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length + rightChunk.length;

            //destroy right - before any move of left, as it previous could be the left...
            if (rightChunkPrevious)
            {
                rightChunkPrevious.nextChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = rightChunkPrevious;
                }
            }
            else
            {
                vertexBufferData.bucket[this.bucket(rightChunk.length)].headChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = null;
                }
            }

            //move left if it needs to
            newBucketIndex = this.bucket(leftChunk.length);
            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    vertexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                vertexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (leftChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length;

            newBucketIndex = this.bucket(leftChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    vertexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                vertexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (rightChunk)
        {
            oldBucketIndex = this.bucket(rightChunk.length);
            rightChunk.baseIndex = allocation.baseIndex;
            rightChunk.length += allocation.length;

            newBucketIndex = this.bucket(rightChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (rightChunkPrevious)
                {
                    rightChunkPrevious.nextChunk =  rightChunk.nextChunk;
                }
                else
                {
                    vertexBufferData.bucket[oldBucketIndex].headChunk = rightChunk.nextChunk;
                }
                //Add to new bucket
                rightChunk.nextChunk = vertexBufferData.bucket[newBucketIndex].headChunk;
                vertexBufferData.bucket[newBucketIndex].headChunk = rightChunk;
            }
        }
        else
        {
            var bucket = vertexBufferData.bucket[this.bucket(allocation.length)];
            bucket.headChunk = {baseIndex: allocation.baseIndex,
                                length: allocation.length,
                                nextChunk: bucket.headChunk};
        }

        //See if the whole thing is free and if so free the VB
        var lastChunk = vertexBufferData.bucket[this.numBuckets - 1].headChunk;
        if (lastChunk && lastChunk.length >= this.maxVerticesPerVertexBuffer)
        {
            vertexBuffersPool.vertexBufferData.splice(vertexBufferIndex, 1);
            vertexBufferData.vertexBuffer.destroy();
            vertexBufferData.vertexBuffer = null;
            vertexBufferData.bucket.length = 0;
            vertexBufferData.bucket = null;
        }
    },

    //
    // destroy
    //
    destroy: function vertexBufferManagerDestroyFn()
    {
        var vertexBuffersPools = this.vertexBuffersPools;
        if (vertexBuffersPools)
        {
            var numVertexBuffersPools = vertexBuffersPools.length;
            var i, j;
            for (i = 0; i < numVertexBuffersPools; i += 1)
            {
                var vertexBuffersPool = vertexBuffersPools[i];

                var vertexBufferDataArray = vertexBuffersPool.vertexBufferData;
                var numVertexBufferData = vertexBufferDataArray.length;
                for (j = 0; j < numVertexBufferData; j += 1)
                {
                    var vertexBufferData = vertexBufferDataArray[j];

                    var bucketArray = vertexBufferData.bucket;
                    if (bucketArray)
                    {
                        bucketArray.length = 0;
                        vertexBufferData.bucket = null;
                    }

                    var vertexbuffer = vertexBufferData.vertexBuffer;
                    if (vertexbuffer)
                    {
                        vertexbuffer.destroy();
                        vertexBufferData.vertexBuffer = null;
                    }
                }
                vertexBufferDataArray.length = 0;
            }
            vertexBuffersPools.length = 0;

            this.vertexBuffersPools = null;
        }

        this.graphicsDevice = null;
    }
};

//
// create
//
VertexBufferManager.create = function vertexBufferManagerCreateFn(graphicsDevice, dynamicVertexBuffers)
{
    var manager = new VertexBufferManager();

    manager.vertexBuffersPools = [];    //Array keyed-off attribute
    manager.debugCreatedVertexBuffers = 0;
    manager.graphicsDevice = graphicsDevice;
    manager.dynamicVertexBuffers = dynamicVertexBuffers ? true : false;

    return manager;
};

// Copyright (c) 2010-2012 Turbulenz Limited

/*global Utilities: false*/

//
// IndexBufferManager
//

function IndexBufferManager() {}

IndexBufferManager.prototype =
{
    version: 1,

    maxIndicesPerIndexBuffer: 65535,

    numBuckets: 10,

    //
    // bucket
    //
    bucket: function bucketFn(numIndices)
    {
        if (numIndices <= 64)
        {
            if (numIndices <= 16)
            {
                if (numIndices <= 8)
                {
                    return 0;
                }
                return 1;
            }

            if (numIndices <= 32)
            {
                return 2;
            }
            return 3;
        }

        if (numIndices <= 512)
        {
            if (numIndices <= 256)
            {
                if (numIndices <= 128)
                {
                    return 4;
                }
                return 5;
            }
            return 6;
        }

        if (numIndices <= 2048)
        {
            if (numIndices <= 1024)
            {
                return 7;
            }
            return 8;
        }
        return 9;
    },

    //
    // makeBuckets
    //
    makeBuckets: function makeBucketsFn()
    {
        var result = [];

        for (var index = 0; index < this.numBuckets; index += 1)
        {
            result.push({headChunk: null});
        }
        return result;
    },

    //
    // allocate
    //
    allocate: function indexBufferManagerAllocate(numIndices, format)
    {
        var indexbuffer = null;
        var baseIndex = 0;

        if (typeof format === "string")
        {
            format = this.graphicsDevice['INDEXFORMAT_' + format];
        }

        var indexbufferParameters =
        {
            format: format,
            dynamic: this.dynamicIndexBuffers
        };

        var poolIndex;
        var maxIndicesPerIndexBuffer = this.maxIndicesPerIndexBuffer;

        var numIndexBuffersPools = this.indexBuffersPools.length;
        var indexBuffersPool;

        //Find the pool to allocate from
        for (poolIndex = 0; poolIndex < numIndexBuffersPools; poolIndex += 1)
        {
            if (this.indexBuffersPools[poolIndex].format === format)
            {
                indexBuffersPool = this.indexBuffersPools[poolIndex];
                break;
            }
        }

        if (!indexBuffersPool)
        {
            indexBuffersPool = { format: format,
                                  indexBufferData: [] };
            this.indexBuffersPools.push(indexBuffersPool);
        }

        var indexBufferData;
        if (numIndices < maxIndicesPerIndexBuffer)
        {
            //Start at the correct size bucket and then look in bigger buckets if there is no suitable space
            //TODO: track last allocation as start point - but needs to be valid.
            for (var bucketIndex = this.bucket(numIndices); !indexbuffer && bucketIndex < this.numBuckets; bucketIndex += 1)
            {
                var previousChunk;
                for (var indexBufferIndex = 0; !indexbuffer && (indexBufferIndex < indexBuffersPool.indexBufferData.length); indexBufferIndex += 1)
                {
                    indexBufferData = indexBuffersPool.indexBufferData[indexBufferIndex];

                    //Now find a to chunk allocate from
                    previousChunk = null;

                    for (var chunk = indexBufferData.bucket[bucketIndex].headChunk; chunk;  chunk = chunk.nextChunk)
                    {
                        if (numIndices <= chunk.length)
                        {
                            indexbuffer = indexBufferData.indexBuffer;
                            baseIndex = chunk.baseIndex;
                            if (numIndices < chunk.length)
                            {
                                chunk.baseIndex = (baseIndex + numIndices);
                                chunk.length -= numIndices;
                                var newBucketIndex = this.bucket(chunk.length);
                                if (newBucketIndex !== bucketIndex)
                                {
                                    if (previousChunk)
                                    {
                                        previousChunk.nextChunk =  chunk.nextChunk;
                                    }
                                    else
                                    {
                                        indexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                    }
                                    //Add to new bucket
                                    chunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                                    indexBufferData.bucket[newBucketIndex].headChunk = chunk;
                                }
                            }
                            else
                            {
                                //Allocated whole chunk so remove it.
                                if (previousChunk)
                                {
                                    previousChunk.nextChunk =  chunk.nextChunk;
                                }
                                else
                                {
                                    indexBufferData.bucket[bucketIndex].headChunk = chunk.nextChunk;
                                }
                                chunk.indexBuffer = null;
                            }
                            break;
                        }
                        previousChunk = chunk;
                    }
                }
            }

            if (!indexbuffer)
            {
                indexbufferParameters.numIndices = maxIndicesPerIndexBuffer;
                indexbuffer = this.graphicsDevice.createIndexBuffer(indexbufferParameters);
                this.debugCreatedIndexBuffers += 1;

                Utilities.assert(indexbuffer, "IndexBuffer not created.");

                if (indexbuffer)
                {
                    indexBufferData = {indexBuffer: indexbuffer,
                                        bucket: this.makeBuckets()};

                    indexBufferData.bucket[this.bucket(maxIndicesPerIndexBuffer - numIndices)].headChunk = {baseIndex: numIndices,
                                                                                                                length: maxIndicesPerIndexBuffer - numIndices,
                                                                                                                nextChunk: null };

                    indexBuffersPool.indexBufferData.push(indexBufferData);
                }
            }
        }

        if (!indexbuffer)
        {
            indexbufferParameters.numIndices = numIndices;
            indexbuffer = this.graphicsDevice.createIndexBuffer(indexbufferParameters);
            this.debugCreatedIndexBuffers += 1;

            Utilities.assert(indexbuffer, "IndexBuffer not created.");

            if (indexbuffer)
            {
                indexBuffersPool.indexBufferData.push({indexBuffer: indexbuffer,
                                                         bucket: this.makeBuckets()});
            }
        }

        return {
            indexBuffer: indexbuffer,
            baseIndex: baseIndex,
            length: numIndices,
            poolIndex: poolIndex
        };
    },

    //
    // free
    //
    free: function indexBufferManagerFree(allocation)
    {
        var indexBuffersPool = this.indexBuffersPools[allocation.poolIndex];
        var indexBufferData;
        for (var indexBufferIndex = 0; indexBufferIndex < indexBuffersPool.indexBufferData.length; indexBufferIndex += 1)
        {
            if (allocation.indexBuffer === indexBuffersPool.indexBufferData[indexBufferIndex].indexBuffer)
            {
                indexBufferData = indexBuffersPool.indexBufferData[indexBufferIndex];
                break;
            }
        }
        //TODO: optimise
        var leftChunk;
        var leftChunkPrevious;
        var rightChunk;
        var rightChunkPrevious;
        var previous;
        for (var bucketIndex = 0; !(leftChunk && rightChunk) && (bucketIndex < this.numBuckets); bucketIndex += 1)
        {
            previous = null;
            for (var chunk = indexBufferData.bucket[bucketIndex].headChunk; chunk && !(leftChunk && rightChunk);  chunk = chunk.nextChunk)
            {
                if (!leftChunk)
                {
                    if (chunk.baseIndex + chunk.length === allocation.baseIndex)
                    {
                        leftChunk = chunk;
                        leftChunkPrevious = previous;
                    }
                }
                if (!rightChunk)
                {
                    if (chunk.baseIndex === allocation.baseIndex + allocation.length)
                    {
                        rightChunk = chunk;
                        rightChunkPrevious = previous;
                    }
                }
                previous = chunk;
            }
        }

        var oldBucketIndex;
        var newBucketIndex;
        if (leftChunk && rightChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length + rightChunk.length;

            //destroy right - before any move of left, as it previous could be the left...
            if (rightChunkPrevious)
            {
                rightChunkPrevious.nextChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = rightChunkPrevious;
                }
            }
            else
            {
                indexBufferData.bucket[this.bucket(rightChunk.length)].headChunk = rightChunk.nextChunk;
                if (rightChunk === leftChunkPrevious)
                {
                    leftChunkPrevious = null;
                }
            }

            //move left if it needs to
            newBucketIndex = this.bucket(leftChunk.length);
            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    indexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                indexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (leftChunk)
        {
            oldBucketIndex = this.bucket(leftChunk.length);
            leftChunk.length += allocation.length;

            newBucketIndex = this.bucket(leftChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (leftChunkPrevious)
                {
                    leftChunkPrevious.nextChunk =  leftChunk.nextChunk;
                }
                else
                {
                    indexBufferData.bucket[oldBucketIndex].headChunk = leftChunk.nextChunk;
                }
                //Add to new bucket
                leftChunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                indexBufferData.bucket[newBucketIndex].headChunk = leftChunk;
            }
        }
        else if (rightChunk)
        {
            oldBucketIndex = this.bucket(rightChunk.length);
            rightChunk.baseIndex = allocation.baseIndex;
            rightChunk.length += allocation.length;

            newBucketIndex = this.bucket(rightChunk.length);

            if (newBucketIndex !== oldBucketIndex)
            {
                if (rightChunkPrevious)
                {
                    rightChunkPrevious.nextChunk =  rightChunk.nextChunk;
                }
                else
                {
                    indexBufferData.bucket[oldBucketIndex].headChunk = rightChunk.nextChunk;
                }
                //Add to new bucket
                rightChunk.nextChunk = indexBufferData.bucket[newBucketIndex].headChunk;
                indexBufferData.bucket[newBucketIndex].headChunk = rightChunk;
            }
        }
        else
        {
            var bucket = indexBufferData.bucket[this.bucket(allocation.length)];
            bucket.headChunk = {baseIndex: allocation.baseIndex,
                                length: allocation.length,
                                nextChunk: bucket.headChunk};
        }

        //See if the whole thing is free and if so free the VB
        var lastChunk = indexBufferData.bucket[this.numBuckets - 1].headChunk;
        if (lastChunk && lastChunk.length >= this.maxIndicesPerIndexBuffer)
        {
            indexBuffersPool.indexBufferData.splice(indexBufferIndex, 1);
            indexBufferData.indexBuffer.destroy();
            indexBufferData.indexBuffer = null;
            indexBufferData.bucket.length = 0;
            indexBufferData.bucket = null;
        }
    },

    //
    // destroy
    //
    destroy: function indexBufferManagerDestroyFn()
    {
        var indexBuffersPools = this.indexBuffersPools;
        if (indexBuffersPools)
        {
            var numIndexBuffersPools = indexBuffersPools.length;
            var i, j;
            for (i = 0; i < numIndexBuffersPools; i += 1)
            {
                var indexBuffersPool = indexBuffersPools[i];

                var indexBufferDataArray = indexBuffersPool.indexBufferData;
                var numIndexBufferData = indexBufferDataArray.length;
                for (j = 0; j < numIndexBufferData; j += 1)
                {
                    var indexBufferData = indexBufferDataArray[j];

                    var bucketArray = indexBufferData.bucket;
                    if (bucketArray)
                    {
                        bucketArray.length = 0;
                        indexBufferData.bucket = null;
                    }

                    var indexbuffer = indexBufferData.indexBuffer;
                    if (indexbuffer)
                    {
                        indexbuffer.destroy();
                        indexBufferData.indexBuffer = null;
                    }
                }
                indexBufferDataArray.length = 0;
            }
            indexBuffersPools.length = 0;

            this.indexBuffersPools = null;
        }

        this.graphicsDevice = null;
    }
};

//
// create
//
IndexBufferManager.create = function indexBufferManagerCreateFn(graphicsDevice, dynamicIndexBuffers)
{
    var manager = new IndexBufferManager();

    manager.indexBuffersPools = [];    //Array keyed-off attribute
    manager.debugCreatedIndexBuffers = 0;
    manager.graphicsDevice = graphicsDevice;
    manager.dynamicIndexBuffers = dynamicIndexBuffers ? true : false;

    return manager;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine*/
/*global Observer*/

function RequestHandler() {}
RequestHandler.prototype =
{
    reasonConnectionLost: 0,
    reasonServiceBusy: 1,

    retryExponential: function requestHandlerExponentialRetryFn(callContext, requestFn, status)
    {
        if (!this.notifiedConnectionLost &&
            TurbulenzEngine.time - this.connectionLostTime > (this.notifyTime * 0.001))
        {
            this.notifiedConnectionLost = true;

            var reason;
            if (status === 0)
            {
                reason = this.reasonConnectionLost;
            }
            else
            {
                reason = this.reasonServiceBusy;
            }
            callContext.reason = reason;
            this.onRequestTimeout(reason, callContext);
        }

        // only the first request with a lost connection continues
        // all following requests wait for a reconnection
        if (this.connected)
        {
            this.connectionLostTime = TurbulenzEngine.time;
            this.notifiedConnectionLost = false;
            this.connected = false;
            this.reconnectTest = callContext;

            callContext.status = status;
        }
        else if (this.reconnectTest !== callContext)
        {
            var reconnectedObserver = this.reconnectedObserver;
            reconnectedObserver.subscribe(function onReconnected()
                {
                    reconnectedObserver.unsubscribe(onReconnected);
                    requestFn();
                });
            return;
        }

        if (callContext.expTime)
        {
            callContext.expTime = 2 * callContext.expTime;
            if (callContext.expTime > this.maxRetryTime)
            {
                callContext.expTime = this.maxRetryTime;
            }
        }
        else
        {
            callContext.expTime = this.initialRetryTime;
        }

        if (callContext.retries)
        {
            callContext.retries += 1;
        }
        else
        {
            callContext.retries = 1;
        }
        TurbulenzEngine.setTimeout(requestFn, callContext.expTime);
    },

    retryAfter: function requestHandlerRetryAfterFn(callContext, retryAfter, requestFn, status)
    {
        if (callContext.retries)
        {
            callContext.retries += 1;
        }
        else
        {
            callContext.firstRetry = TurbulenzEngine.time;
            callContext.retries = 1;
        }

        if (!callContext.notifiedMaxRetries &&
            TurbulenzEngine.time - callContext.firstRetry + retryAfter > this.notifyTime)
        {
            callContext.notifiedMaxRetries = true;

            var reason = this.reasonServiceBusy;
            callContext.reason = reason;
            this.onRequestTimeout(reason, callContext);
        }

        TurbulenzEngine.setTimeout(requestFn, retryAfter * 1000);
    },

    request: function requestHandlerRequestFn(callContext)
    {
        var makeRequest;
        var that = this;

        var responseCallback = function responseCallbackFn(responseAsset, status)
        {
            var xhr = callContext.xhr;
            var sendEventToHandlers = that.sendEventToHandlers;
            var handlers = that.handlers;

            if (xhr)
            {
                var retryAfterHeader = xhr.getResponseHeader("Retry-After");
                if (retryAfterHeader)
                {
                    var retryAfter = parseInt(retryAfterHeader, 10);
                    if (retryAfter > 0)
                    {
                        that.retryAfter(callContext, retryAfter, makeRequest, status);
                        return;
                    }
                }
            }

            // 0 Connection Lost
            // 408 Request Timeout
            // 429 Too Many Requests
            // 480 Temporarily Unavailable
            if (status === 0 || status === 408 || status === 429 || status === 480)
            {
                that.retryExponential(callContext, makeRequest, status);
                return;
            }

            if (!that.connected)
            {
                // Reconnected!
                that.connected = true;
                if (that.reconnectTest === callContext && that.notifiedConnectionLost)
                {
                    that.onReconnected(that.reconnectTest.reason, that.reconnectTest);
                }
                that.reconnectTest = null;
                that.reconnectedObserver.notify();
            }

            if (callContext.customErrorHandler &&
                !callContext.customErrorHandler.call(this, callContext, makeRequest, responseAsset, status))
            {
                return;
            }

            if (that.customErrorHandler &&
                !that.customErrorHandler(callContext, makeRequest, responseAsset, status))
            {
                return;
            }

            if (callContext.onload)
            {
                var nameStr;
                if (responseAsset && responseAsset.name)
                {
                    nameStr = responseAsset.name;
                }
                else
                {
                    nameStr = callContext.src;
                }

                sendEventToHandlers(handlers.eventOnload, {eventType: "eventOnload", name: nameStr});

                callContext.onload(responseAsset, status, callContext);
                callContext.onload = null;
            }
            callContext = null;
        };

        makeRequest = function makeRequestFn()
        {
            if (callContext.requestFn)
            {
                if (callContext.requestOwner)
                {
                    callContext.requestFn.call(callContext.requestOwner, callContext.src, responseCallback, callContext);
                }
                else
                {
                    callContext.requestFn(callContext.src, responseCallback, callContext);
                }
            }
            else if (callContext.requestOwner)
            {
                callContext.requestOwner.request(callContext.src, responseCallback, callContext);
            }
            else
            {
                TurbulenzEngine.request(callContext.src, responseCallback, callContext);
            }
        };

        makeRequest();
    },

    addEventListener : function addEventListenerFn(eventType, eventListener)
    {
        var i;
        var length;
        var eventHandlers;

        if (this.handlers.hasOwnProperty(eventType))
        {
            eventHandlers = this.handlers[eventType];

            if (eventListener)
            {
                // Check handler is not already stored
                length = eventHandlers.length;
                for (i = 0; i < length; i += 1)
                {
                    if (eventHandlers[i] === eventListener)
                    {
                        // Event handler has already been added
                        return;
                    }
                }

                eventHandlers.push(eventListener);
            }
        }
    },

    removeEventListener : function removeEventListenerFn(eventType, eventListener)
    {
        var i;
        var length;
        var eventHandlers;

        if (this.handlers.hasOwnProperty(eventType))
        {
            eventHandlers = this.handlers[eventType];

            if (eventListener)
            {
                length = eventHandlers.length;
                for (i = 0; i < length; i += 1)
                {
                    if (eventHandlers[i] === eventListener)
                    {
                        eventHandlers.splice(i, 1);
                        break;
                    }
                }
            }
        }
    },

    sendEventToHandlers : function sendEventToHandlersFn(eventHandlers, arg0)
    {
        var i;
        var length = eventHandlers.length;

        if (length)
        {
            for (i = 0; i < length; i += 1)
            {
                eventHandlers[i](arg0);
            }
        }
    }
};

RequestHandler.create = function requestHandlerCreateFn(params)
{
    var rh = new RequestHandler();

    rh.initialRetryTime = params.initialRetryTime || 0.5 * 1000;
    rh.notifyTime = params.notifyTime || 4 * 1000;
    rh.maxRetryTime = params.maxRetryTime || 8 * 1000;

    rh.notifiedConnectionLost = false;
    rh.connected = true;
    rh.reconnectedObserver = Observer.create();
    rh.reconnectTest = null;

    rh.onReconnected = params.onReconnected || function onReconnectedFn() {};
    rh.onRequestTimeout = params.onRequestTimeout || function onRequestTimeoutFn(callContext) {};
    var handlers = {};
    rh.handlers = handlers;

    rh.handlers.eventOnload = [];

    return rh;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global BadgeManager: false*/
/*global window: false*/
/*global GameSession: false*/
/*global Turbulenz*/
/*global TurbulenzBridge: false*/
/*global TurbulenzEngine: false*/
/*global Utilities: false*/
/*global MappingTable: false*/
/*global LeaderboardManager: false*/
/*global ServiceRequester: false*/
/*global Badges*/
/*global MultiPlayerSession: false*/
/*global MultiPlayerSessionManager: false*/
/*global Observer*/
/*global StoreManager: false*/
/*global JsLocalStore: false*/

var TurbulenzServices;

function ServiceRequester() {}
ServiceRequester.prototype =
{

    // make a request if the service is available. Same parameters as an
    // Utilities.ajax call with extra argument:
    //     neverDiscard - Never discard the request. Always queues the request
    //                    for when the service is again available. (Ignores
    //                    server preference)
    request: function requestFn(params)
    {
        var discardRequestFn = function discardRequestFn()
        {
            if (params.callback)
            {
                params.callback({'ok': false, 'msg': 'Service Unavailable. Discarding request'}, 503);
            }
        };

        var that = this;
        var serviceStatusObserver = this.serviceStatusObserver;

        var onServiceStatusChange;
        onServiceStatusChange = function onServiceStatusChangeFn(running, discardRequest)
        {
            if (discardRequest)
            {
                if (!params.neverDiscard)
                {
                    serviceStatusObserver.unsubscribe(onServiceStatusChange);
                    discardRequestFn();
                }
            }
            else if (running)
            {
                serviceStatusObserver.unsubscribe(onServiceStatusChange);
                that.request(params);
            }
        };

        if (!this.running)
        {
            if (this.discardRequests && !params.neverDiscard)
            {
                TurbulenzEngine.setTimeout(discardRequestFn, 0);
                return false;
            }

            // we check waiting so that we don't get into an infinite loop of callbacks
            // when a service goes down, then up and then down again before the subscribed
            // callbacks have all been called.
            if (!params.waiting)
            {
                params.waiting = true;
                serviceStatusObserver.subscribe(onServiceStatusChange);
            }
            return true;
        }

        var oldCustomErrorHandler = params.customErrorHandler;
        params.customErrorHandler = function checkServiceUnavailableFn(callContext, makeRequest, responseJSON, status)
        {
            if (status === 503)
            {
                var responseObj = JSON.parse(responseJSON);
                var statusObj = responseObj.data;
                var discardRequests = (statusObj ? statusObj.discardRequests : true);
                that.discardRequests = discardRequests;

                if (discardRequests && !params.neverDiscard)
                {
                    discardRequestFn();
                }
                else
                {
                    serviceStatusObserver.subscribe(onServiceStatusChange);
                }
                TurbulenzServices.serviceUnavailable(that, callContext);
                // An error occurred so return false to avoid calling the success callback
                return false;
            }
            else
            {
                // call the old custom error handler
                if (oldCustomErrorHandler)
                {
                    return oldCustomErrorHandler.call(params.requestHandler, callContext, makeRequest, responseJSON, status);
                }
                return true;
            }
        };

        Utilities.ajax(params);
        return true;
    }
};

ServiceRequester.create = function apiServiceCreateFn(serviceName, params)
{
    var serviceRequester = new ServiceRequester();

    if (!params)
    {
        params = {};
    }

    // we assume everything is working at first
    serviceRequester.running = true;
    serviceRequester.discardRequests = false;
    serviceRequester.serviceStatusObserver = Observer.create();

    serviceRequester.serviceName = serviceName;

    serviceRequester.onServiceUnavailable = params.onServiceUnavailable;
    serviceRequester.onServiceAvailable = params.onServiceAvailable;

    return serviceRequester;
};

//
// TurbulenzServices
//
TurbulenzServices = {

    multiplayerJoinRequestQueue: {
        // A FIFO queue that passes events through to the handler when un-paused and buffers up
        // events while paused
        argsQueue: [],
        handler: function nopFn() {},
        context: undefined,
        paused: true,
        onEvent: function onEventFn(handler, context) {
            this.handler = handler;
            this.context = context;
        },
        push: function pushFn(sessionId)
        {
            var args = [sessionId];
            if (this.paused)
            {
                this.argsQueue.push(args);
            }
            else
            {
                this.handler.apply(this.context, args);
            }
        },
        shift: function shiftFn()
        {
            var args = this.argsQueue.shift();
            return args ? args[0] : undefined;
        },
        clear: function clearFn()
        {
            this.argsQueue = [];
        },
        pause: function pauseFn()
        {
            this.paused = true;
        },
        resume: function resumeFn()
        {
            this.paused = false;
            while (this.argsQueue.length)
            {
                this.handler.apply(this.context, this.argsQueue.shift());
                if (this.paused)
                {
                    break;
                }
            }
        }
    },

    available: function turbulenzServicesAvailableFn()
    {
        return window.gameSlug !== undefined;
    },

    addBridgeEvents: function addBridgeEventsFn()
    {
        var turbulenz = window.top.Turbulenz;
        var turbulenzData = (turbulenz && turbulenz.Data) || {};
        var sessionToJoin = turbulenzData.joinMultiplayerSessionId;
        var that = this;

        var onJoinMultiplayerSession = function onJoinMultiplayerSessionFn(joinMultiplayerSessionId) {
            that.multiplayerJoinRequestQueue.push(joinMultiplayerSessionId);
        };

        var onReceiveConfig = function onReceiveConfigFn(configString) {
            var config = JSON.parse(configString);

            if (config.mode)
            {
                that.mode = config.mode;
            }

            if (config.joinMultiplayerSessionId)
            {
                that.multiplayerJoinRequestQueue.push(config.joinMultiplayerSessionId);
            }

            that.bridgeServices = !!config.bridgeServices;
        };

        // This should go once we have fully moved to the new system
        if (sessionToJoin)
        {
            this.multiplayerJoinRequestQueue.push(sessionToJoin);
        }

        TurbulenzBridge.setOnMultiplayerSessionToJoin(onJoinMultiplayerSession);
        TurbulenzBridge.setOnReceiveConfig(onReceiveConfig);
        TurbulenzBridge.triggerRequestConfig();

        // Setup framework for asynchronous function calls
        this.responseHandlers = [null];
        // 0 is reserved value for no registered callback
        this.responseIndex = 0;
        TurbulenzBridge.on("bridgeservices.response", function (jsondata) { that.routeResponse(jsondata); });
    },

    callOnBridge: function turbulenzServicesCallOnBridgeFn(event, data, callback)
    {
        var request = {
            data: data
        };
        if (callback)
        {
            this.responseIndex += 1;
            this.responseHandlers[this.responseIndex] = callback;
            request.key = this.responseIndex;
        }
        TurbulenzBridge.emit('bridgeservices.' + event, JSON.stringify(request));
    },

    addSignature: function turbulenzServicesAddSignatureFn(data, url)
    {
        var str;
        data.requestUrl = url;
        str = TurbulenzEngine.encrypt(JSON.stringify(data));
        data.str = str;
        data.signature = TurbulenzEngine.generateSignature(str);
        return data;
    },

    routeResponse: function routeResponseFn(jsondata)
    {
        var response = JSON.parse(jsondata);
        var index = response.key || 0;
        var callback = this.responseHandlers[index];
        if (callback)
        {
            this.responseHandlers[index] = null;
            callback(response.data);
        }
    },

    defaultErrorCallback: function turbulenzServicesDefaultErrorCallbackFn(errorMsg, httpStatus) {},

    onServiceUnavailable: function turbulenzServicesOnServiceUnavailableFn(serviceName, callContext) {},
    onServiceAvailable: function turbulenzServicesOnServiceAvailableFn(serviceName, callContext) {},

    createGameSession: function turbulenzServicesCreateGameSession(requestHandler, sessionCreatedFn, errorCallbackFn)
    {
        return GameSession.create(requestHandler, sessionCreatedFn, errorCallbackFn);
    },

    createMappingTable: function turbulenzServicesCreateMappingTable(requestHandler,
                                                                     gameSession,
                                                                     tableRecievedFn,
                                                                     defaultMappingSettings,
                                                                     errorCallbackFn)
    {
        var mappingTable = new MappingTable();
        var mappingTableSettings = gameSession && gameSession.mappingTable;
        if (mappingTableSettings)
        {
            mappingTable.mappingTableURL = mappingTableSettings.mappingTableURL;
            mappingTable.mappingTablePrefix = mappingTableSettings.mappingTablePrefix;
            mappingTable.assetPrefix = mappingTableSettings.assetPrefix;
        }
        else if (defaultMappingSettings)
        {
            mappingTable.mappingTableURL = defaultMappingSettings.mappingTableURL ||
                (defaultMappingSettings.mappingTableURL === "" ? "" : "mapping_table.json");
            mappingTable.mappingTablePrefix = defaultMappingSettings.mappingTablePrefix ||
                (defaultMappingSettings.mappingTablePrefix === "" ? "" : "staticmax/");
            mappingTable.assetPrefix = defaultMappingSettings.assetPrefix ||
                (defaultMappingSettings.assetPrefix === "" ? "" : "missing/");
        }
        else
        {
            mappingTable.mappingTableURL = "mapping_table.json";
            mappingTable.mappingTablePrefix = "staticmax/";
            mappingTable.assetPrefix = "missing/";
        }

        mappingTable.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
        if (!mappingTable.mappingTableURL)
        {
            mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable no mapping table file given");
        }

        function createMappingTableCallbackFn(urlMappingData)
        {
            var urlMapping = urlMappingData.urnmapping || urlMappingData.urnremapping || {};
            mappingTable.urlMapping = urlMapping;

            // Prepend all the mapped physical paths with the asset server
            var mappingTablePrefix = mappingTable.mappingTablePrefix;
            if (mappingTablePrefix)
            {
                var source;
                for (source in urlMapping)
                {
                    if (urlMapping.hasOwnProperty(source))
                    {
                        urlMapping[source] = mappingTablePrefix + urlMapping[source];
                    }
                }
            }

            tableRecievedFn(mappingTable);
        }

        requestHandler.request({
                src: mappingTable.mappingTableURL,
                onload: function jsonifyResponse(jsonResponse, status) {
                    if (status === 200)
                    {
                        var obj = JSON.parse(jsonResponse);
                        createMappingTableCallbackFn(obj);
                        return;
                    }

                    jsonResponse = jsonResponse || { msg: "(no response)"};
                    mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable error with HTTP status " + status + ": " + jsonResponse.msg, status);

                    mappingTable.urlMapping = defaultMappingSettings && (defaultMappingSettings.urnMapping || {});
                    tableRecievedFn(mappingTable);
                }
            });

        return mappingTable;
    },

    createLeaderboardManager: function turbulenzServicesCreateLeaderboardManager(requestHandler,
                                                                                 gameSession,
                                                                                 leaderboardMetaRecieved,
                                                                                 errorCallbackFn)
    {
        return LeaderboardManager.create(requestHandler, gameSession, leaderboardMetaRecieved, errorCallbackFn);
    },

    createBadgeManager: function turbulenzServicesCreateBadgeManager(requestHandler, gameSession)
    {
        return BadgeManager.create(requestHandler, gameSession);
    },

    createStoreManager: function turbulenzServicesCreateStoreManager(requestHandler,
                                                                     gameSession,
                                                                     storeMetaRecieved,
                                                                     errorCallbackFn)
    {
        return StoreManager.create(requestHandler,
                                   gameSession,
                                   storeMetaRecieved,
                                   errorCallbackFn);
    },

    createMultiplayerSessionManager: function turbulenzServicescreateMultiplayerSessionManagerFn(requestHandler,
                                                                                                 gameSession)
    {
        return MultiPlayerSessionManager.create(requestHandler, gameSession);
    },

    createUserProfile: function turbulenzServicesCreateUserProfile(requestHandler,
                                                                   profileRecievedFn,
                                                                   errorCallbackFn)
    {
        var userProfile = {};

        if (!errorCallbackFn)
        {
            errorCallbackFn = TurbulenzServices.defaultErrorCallback;
        }

        function loadUserProfileCallbackFn(userProfileData)
        {
            if (userProfileData && userProfileData.ok)
            {
                userProfileData = userProfileData.data;
                var p;
                for (p in userProfileData)
                {
                    if (userProfileData.hasOwnProperty(p))
                    {
                        userProfile[p] = userProfileData[p];
                    }
                }
            }
        }

        var url = '/api/v1/profiles/user';
        // Can't request files from the hard disk using AJAX
        if (TurbulenzServices.available())
        {
            this.getService('profiles').request({
                url: url,
                method: 'GET',
                callback: function createUserProfileAjaxErrorCheck(jsonResponse, status)
                {
                    if (status === 200)
                    {
                        loadUserProfileCallbackFn(jsonResponse);
                    }
                    else if (errorCallbackFn)
                    {
                        errorCallbackFn("TurbulenzServices.createUserProfile error with HTTP status " + status + ": " + jsonResponse.msg, status);
                    }
                    profileRecievedFn(userProfile);
                },
                requestHandler: requestHandler
            });
        }

        return userProfile;
    },

    sendCustomMetricEvent: function turbulenzServicesSendCustomMetricEvent(eventKey,
                                                                           eventValue,
                                                                           requestHandler,
                                                                           gameSession,
                                                                           errorCallbackFn)
    {
        if (!errorCallbackFn)
        {
            errorCallbackFn = TurbulenzServices.defaultErrorCallback;
        }

        if (!TurbulenzServices.available())
        {
            if (errorCallbackFn)
            {
                errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Service not available",
                                0);
            }
            return;
        }

        // Validation

        if (('string' !== typeof eventKey) || (0 === eventKey.length))
        {
            if (errorCallbackFn)
            {
                errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Event key must be a non-empty string",
                                0);
            }
            return;
        }

        if (isNaN(parseFloat(eventValue)) || !isFinite(eventValue))
        {
            if ('[object Array]' !== Object.prototype.toString.call(eventValue))
            {
                if (errorCallbackFn)
                {
                    errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Event value must be a number or an array of numbers",
                                    0);
                }
                return;
            }

            var i, valuesLength = eventValue.length;
            for (i = 0; i < valuesLength; i += 1)
            {
                if (isNaN(parseFloat(eventValue[i])) || !isFinite(eventValue[i]))
                {
                    if (errorCallbackFn)
                    {
                        errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Event value array elements must be numbers",
                                        0);
                    }
                    return;
                }
            }
        }

        this.getService('customMetrics').request({
            url: '/api/v1/custommetrics/add-event/' + gameSession.gameSlug,
            method: 'POST',
            data: {'key': eventKey, 'value': eventValue, 'gameSessionId': gameSession.gameSessionId},
            callback: function sendCustomMetricEventAjaxErrorCheck(jsonResponse, status)
            {
                if (status !== 200 && errorCallbackFn)
                {
                    errorCallbackFn("TurbulenzServices.sendCustomMetricEvent error with HTTP status " + status + ": " + jsonResponse.msg, status);
                }
            },
            requestHandler: requestHandler,
            encrypt: true
        });
    },


    services: {},
    waitingServices: {},
    pollingServiceStatus: false,
    // milliseconds
    defaultPollInterval: 4000,

    getService: function getServiceFn(serviceName)
    {
        var services = this.services;
        if (services.hasOwnProperty(serviceName))
        {
            return services[serviceName];
        }
        else
        {
            var service = ServiceRequester.create(serviceName);
            services[serviceName] = service;
            return service;
        }
    },

    serviceUnavailable: function serviceUnavailableFn(service, callContext)
    {
        var waitingServices = this.waitingServices;
        var serviceName = service.serviceName;
        if (waitingServices.hasOwnProperty(serviceName))
        {
            return;
        }

        waitingServices[serviceName] = service;

        service.running = false;

        var onServiceUnavailableCallbacks = function onServiceUnavailableCallbacksFn(service)
        {
            var onServiceUnavailable = callContext.onServiceUnavailable;
            if (onServiceUnavailable)
            {
                onServiceUnavailable.call(service, callContext);
            }
            if (service.onServiceUnavailable)
            {
                service.onServiceUnavailable();
            }
            if (TurbulenzServices.onServiceUnavailable)
            {
                TurbulenzServices.onServiceUnavailable(service);
            }
        };

        if (service.discardRequests)
        {
            onServiceUnavailableCallbacks(service);
        }

        if (this.pollingServiceStatus)
        {
            return;
        }

        var that = this;
        var pollServiceStatus;

        var serviceUrl = '/api/v1/service-status/game/read/' + window.gameSlug;
        var servicesStatusCB = function servicesStatusCBFn(responseObj, status)
        {
            if (status === 200)
            {
                var statusObj = responseObj.data;
                var servicesObj = statusObj.services;

                var retry = false;
                var serviceName;
                for (serviceName in waitingServices)
                {
                    if (waitingServices.hasOwnProperty(serviceName))
                    {
                        var service = waitingServices[serviceName];
                        var serviceData = servicesObj[serviceName];
                        var serviceRunning = serviceData.running;

                        service.running = serviceRunning;
                        service.description = serviceData.description;

                        if (serviceRunning)
                        {
                            if (service.discardRequests)
                            {
                                var onServiceAvailable = callContext.onServiceAvailable;
                                if (onServiceAvailable)
                                {
                                    onServiceAvailable.call(service, callContext);
                                }
                                if (service.onServiceAvailable)
                                {
                                    service.onServiceAvailable();
                                }
                                if (TurbulenzServices.onServiceAvailable)
                                {
                                    TurbulenzServices.onServiceAvailable(service);
                                }
                            }

                            delete waitingServices[serviceName];
                            service.discardRequests = false;
                            service.serviceStatusObserver.notify(serviceRunning, service.discardRequests);

                        }
                        else
                        {
                            // if discardRequests has been set
                            if (serviceData.discardRequests && !service.discardRequests)
                            {
                                service.discardRequests = true;
                                onServiceUnavailableCallbacks(service);
                                // discard all waiting requests
                                service.serviceStatusObserver.notify(serviceRunning, service.discardRequests);
                            }
                            retry = true;
                        }
                    }
                }
                if (!retry)
                {
                    this.pollingServiceStatus = false;
                    return;
                }
                TurbulenzEngine.setTimeout(pollServiceStatus, statusObj.pollInterval * 1000);
            }
            else
            {
                TurbulenzEngine.setTimeout(pollServiceStatus, that.defaultPollInterval);
            }
        };

        pollServiceStatus = function pollServiceStatusFn()
        {
            Utilities.ajax({
                url: serviceUrl,
                method: 'GET',
                callback: servicesStatusCB
            });
        };

        pollServiceStatus();
    }

};

if (typeof TurbulenzBridge !== 'undefined')
{
    TurbulenzServices.addBridgeEvents();
}

// Copyright (c) 2011-2012 Turbulenz Limited

/*global Utilities: false*/
/*global TurbulenzBridge: false*/
/*global TurbulenzEngine: false*/
/*global TurbulenzServices: false*/

//
// API
//
function GameSession() {}
GameSession.prototype =
{
    version : 1,
    post_delay: 1000,

    setStatus: function gameSessionSetStatusFn(status)
    {
        if (this.destroyed || this.status === status)
        {
            return;
        }

        this.status = status;
        TurbulenzBridge.setGameSessionStatus(this.gameSessionId, status);
    },

    // callbackFn is for testing only!
    // It will not be called if destroy is called in TurbulenzEngine.onUnload
    destroy: function gameSessionDestroyFn(callbackFn)
    {
        var dataSpec;
        if (this.pendingUpdate)
        {
            TurbulenzEngine.clearTimeout(this.pendingUpdate);
            this.pendingUpdate = null;
        }

        if (!this.destroyed && this.gameSessionId)
        {
            // we can't wait for the callback as the browser doesn't
            // call async callbacks after onbeforeunload has been called
            TurbulenzBridge.destroyedGameSession(this.gameSessionId);
            this.destroyed = true;

            dataSpec = {'gameSessionId': this.gameSessionId};

            if (TurbulenzServices.bridgeServices)
            {
                TurbulenzServices.callOnBridge('gamesession.destroy', dataSpec, callbackFn);
            }
            else
            {
                Utilities.ajax({
                    url: '/api/v1/games/destroy-session',
                    method: 'POST',
                    data: dataSpec,
                    callback: callbackFn,
                    requestHandler: this.requestHandler
                });
            }
        }
        else
        {
            if (callbackFn)
            {
                TurbulenzEngine.setTimeout(callbackFn, 0);
            }
        }
    },

    /**
     * Handle player metadata
     */
    setTeamInfo : function gameSessionSetTeamInfoFn(teamList)
    {
        var sessionData = this.info.sessionData;
        var oldTeamList = sessionData.teamList || [];
        if (teamList.join('#') !== oldTeamList.join('#'))
        {
            sessionData.teamList = teamList;
            this.update();
        }
    },

    setPlayerInfo : function gameSessionSetPlayerInfoFn(playerId, data)
    {
        var playerData = this.info.playerSessionData[playerId];
        var key;
        var dirty = false;

        if (!playerData)
        {
            playerData = {};
            this.info.playerSessionData[playerId] = playerData;
            dirty = true;
        }

        for (key in data)
        {
            if (data.hasOwnProperty(key))
            {
                if (!this.templatePlayerData.hasOwnProperty(key))
                {
                    throw "unknown session data property " + key;
                }
                if (playerData[key] !== data[key])
                {
                    playerData[key] = data[key];
                    dirty = true;
                }
            }
        }

        if (dirty)
        {
            this.update();
        }
    },

    removePlayerInfo : function gameSessionRemovePlayerInfoFn(playerId)
    {
        delete this.info.playerSessionData[playerId];
        this.update();
    },

    clearAllPlayerInfo : function clearAllPlayerInfoFn()
    {
        this.info.playerSessionData = {};
        this.update();
    },

    update: function updateFn()
    {
        if (!this.pendingUpdate)
        {
            // Debounce the update to pick up any other changes.
            this.pendingUpdate = TurbulenzEngine.setTimeout(this.postData, this.post_delay);
        }
    }
};

GameSession.create = function gameSessionCreateFn(requestHandler, sessionCreatedFn, errorCallbackFn)
{
    var gameSession = new GameSession();
    var gameSlug = window.gameSlug;
    var turbulenz = window.top.Turbulenz;
    var turbulenzData = (turbulenz && turbulenz.Data) || {};
    var mode = turbulenzData.mode || TurbulenzServices.mode;
    var createSessionURL = '/api/v1/games/create-session/' + gameSlug;
    var gameSessionRequestCallback = function gameSessionRequestCallbackFn(jsonResponse, status)
    {
        if (status === 200)
        {
            gameSession.mappingTable = jsonResponse.mappingTable;
            gameSession.gameSessionId = jsonResponse.gameSessionId;

            if (sessionCreatedFn)
            {
                sessionCreatedFn(gameSession);
            }

            TurbulenzBridge.createdGameSession(gameSession.gameSessionId);
        }
        else
        {
            gameSession.errorCallbackFn("TurbulenzServices.createGameSession error with HTTP status " + status + ": " + jsonResponse.msg, status);
        }
    };

    gameSession.info = {
        sessionData: {},
        playerSessionData: {}
    };

    gameSession.templatePlayerData = {
        team: null,
        color: null,
        status: null,
        rank: null,
        score: null,
        sortkey: null
    };

    gameSession.postData = function postDataFn()
    {
        TurbulenzBridge.setGameSessionInfo(JSON.stringify(gameSession.info));
        gameSession.pendingUpdate = null;
    };

    gameSession.pendingUpdate = null;

    gameSession.gameSlug = gameSlug;

    gameSession.requestHandler = requestHandler;
    gameSession.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
    gameSession.gameSessionId = null;
    gameSession.service = TurbulenzServices.getService('gameSessions');
    gameSession.status = null;

    if (!TurbulenzServices.available())
    {
        // Call sessionCreatedFn on a timeout to get the same behaviour as the AJAX call
        if (sessionCreatedFn)
        {
            TurbulenzEngine.setTimeout(function sessionCreatedCall()
            {
                sessionCreatedFn(gameSession);
            }, 0);
        }
        return gameSession;
    }

    if (mode)
    {
        createSessionURL += '/' + mode;
    }

    gameSession.service.request({
        url: createSessionURL,
        method: 'POST',
        callback: gameSessionRequestCallback,
        requestHandler: requestHandler,
        neverDiscard: true
    });

    return gameSession;
};

// Copyright (c) 2011 Turbulenz Limited

/*global TurbulenzServices: false*/

//
// API
//
function MappingTable() {}
MappingTable.prototype =
{
    version : 1,

    getURL: function mappingTableGetURL(assetPath, missingCallbackFn)
    {
        var url = this.urlMapping[assetPath];
        if (url)
        {
            return url;
        }
        else
        {
            if (missingCallbackFn)
            {
                missingCallbackFn(assetPath);
            }
            return (this.assetPrefix + assetPath);
        }
    },

    map: function mappingTableMap(logicalPath, physicalPath)
    {
        this.urlMapping[logicalPath] = physicalPath;
    },

    alias: function mappingTableAlias(alias, logicalPath)
    {
        var urlMapping = this.urlMapping;
        urlMapping[alias] = urlMapping[logicalPath];
    }
};

MappingTable.create = function MappingTableCreateFn(params)
{
    var mappingTable = new MappingTable();

    mappingTable.mappingTableURL = params.mappingTableURL;
    mappingTable.mappingTablePrefix = params.mappingTablePrefix;
    mappingTable.assetPrefix = params.assetPrefix;

    mappingTable.errorCallbackFn = params.errorCallback || TurbulenzServices.defaultErrorCallback;
    if (!mappingTable.mappingTableURL)
    {
        mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable no mapping table file given");
    }

    function createMappingTableCallbackFn(urlMappingData)
    {
        var urlMapping = urlMappingData.urnmapping || urlMappingData.urnremapping || {};
        mappingTable.urlMapping = urlMapping;

        // Prepend all the mapped physical paths with the asset server
        var mappingTablePrefix = mappingTable.mappingTablePrefix;
        if (mappingTablePrefix)
        {
            var source;
            for (source in urlMapping)
            {
                if (urlMapping.hasOwnProperty(source))
                {
                    urlMapping[source] = mappingTablePrefix + urlMapping[source];
                }
            }
        }

        params.onload(mappingTable);
    }

    params.requestHandler.request({
            src: mappingTable.mappingTableURL,
            onload: function jsonifyResponse(jsonResponse, status) {
                var obj = JSON.parse(jsonResponse);
                if (status === 200)
                {
                    createMappingTableCallbackFn(obj);
                }
                else
                {
                    mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable error with HTTP status " + status + ": " + jsonResponse.msg, status);
                }
            }
        });

    return mappingTable;
};

// Copyright (c) 2011-2012 Turbulenz Limited
/*global window: false*/
/*global TurbulenzServices: false*/
/*jshint nomen: false*/

/*
 * An object that takes care of communication with the gamesite and, among
 * other things, replaces the deprecated 'osdlib' module.
 *
 * It wraps an EventEmitter instance that is stored on the page and provides
 * methods that manually display the 'loading'-flag, post certain events to
 * the page or request information about a player's settings.
 *
 */
var TurbulenzBridge = {
    _bridge: undefined,

    /**
     * Try to find an 'EventEmitter' object on the page and cache it.
     */
    _initInstance: function _initInstanceFn() {
        var Turbulenz = window.top.Turbulenz;

        if (Turbulenz && Turbulenz.Services)
        {
            var bridge = Turbulenz.Services.bridge;
            if (!bridge)
            {
                return;
            }

            this._bridge = bridge;

            this.emit = bridge.emit;
            // TODO can remove all of these or's after gamesite and hub updates
            this.on = bridge.gameListenerOn || bridge.addListener || bridge.setListener;

            // we cant use off yet becuase the function recieved on the other VM is re-wrapped each time
            //this.off = bridge.gameListenerOff;
            // Legacy functions addListener/setListener
            this.addListener = bridge.gameListenerOn || bridge.addListener || bridge.setListener;
            this.setListener = bridge.gameListenerOn || bridge.setListener;
        }

        if (typeof TurbulenzServices !== 'undefined')
        {
            TurbulenzServices.addBridgeEvents();
        }
    },

    isInitialised: function isInitialisedFn() {
        return this._bridge !== undefined;
    },

    emit: function emitFn() {},

    on: function onFn() {},

    //off: function offFn() {},

    addListener: function addListenerFn() {},

    setListener: function setListenerFn() {},

    /**
     * Message that passes game configuration information from the hosting site
     */
    setOnReceiveConfig: function setOnReceiveConfigFn(callback) {
        this.on('config.set', callback);
    },
    triggerRequestConfig: function triggerRequestConfigFn() {
        this.emit('config.request');
    },

    /**
     * Methods to signal the beginning and end of load/save processes.
     * This will display hints to the player and helps the page
     * to prioritize resources.
     */
    startLoading: function startLoadingFn() {
        this.emit('status.loading.start');
    },

    startSaving: function startSavingFn() {
        this.emit('status.saving.start');
    },

    stopLoading: function stopLoadingFn() {
        this.emit('status.loading.stop');
    },

    stopSaving: function stopSavingFn() {
        this.emit('status.saving.stop');
    },

    /**
     * These methods tell the gamesite the gameSession so it can
     * emit a heartbeat for the message server to detect.
     * gameSessionId - A string for identifying the current game session
     */
    createdGameSession: function createdGameSessionFn(gameSessionId) {
        this.emit('game.session.created', gameSessionId);
    },

    destroyedGameSession: function destroyedGameSessionFn(gameSessionId) {
        this.emit('game.session.destroyed', gameSessionId);
    },

    setGameSessionStatus: function setGameSessionStatusFn(gameSessionId, status) {
        this.emit('game.session.status', gameSessionId, status);
    },

    setGameSessionInfo: function setGameSessionInfoFn(info) {
        this.emit('game.session.info', info);
    },

    /**
     * Update a userbadge. Used by the BadgeManager
     */
    updateUserBadge: function updateUserBadgeFn(badge)
    {
        this.emit('userbadge.update', badge);
    },

    /**
     * Update a leaderboard. Used by the LeaderboardManager
     */
    updateLeaderBoard: function updateLeaderBoardFn(scoreData)
    {
        this.emit('leaderboards.update', scoreData);
    },


    /**
     * Handle multiplayer join events
     */
    setOnMultiplayerSessionToJoin: function setOnMultiplayerSessionToJoinFn(callback) {
        this.on('multiplayer.session.join', callback);
    },

    triggerJoinedMultiplayerSession: function triggerJoinedMultiplayerSessionFn(session) {
        this.emit('multiplayer.session.joined', session);
    },

    triggerLeaveMultiplayerSession: function triggerLeaveMultiplayerSessionFn(sessionId) {
        this.emit('multiplayer.session.leave', sessionId);
    },

    triggerMultiplayerSessionMakePublic: function triggerMultiplayerSessionMakePublicFn(sessionId) {
        this.emit('multiplayer.session.makepublic');
    },

    /**
     * Handle store basket events
     */
    setOnBasketUpdate: function setOnBasketUpdateFn(callback) {
        this.on('basket.site.update', callback);
    },

    triggerBasketUpdate: function triggerBasketUpdateFn(basket) {
        this.emit('basket.game.update', basket);
    },

    triggerUserStoreUpdate: function triggerUserStoreUpdateFn(items) {
        this.emit('store.user.update', items);
    },

    setOnPurchaseConfirmed: function setOnPurchaseConfirmedFn(callback) {
        this.on('purchase.confirmed', callback);
    },

    setOnPurchaseRejected: function setOnPurchaseRejectedFn(callback) {
        this.on('purchase.rejected', callback);
    },

    triggerShowConfirmPurchase: function triggerShowConfirmPurchaseFn() {
        this.emit('purchase.show.confirm');
    },

    triggerFetchStoreMeta: function triggerFetchStoreMetaFn() {
        this.emit('fetch.store.meta');
    },

    setOnStoreMeta: function setOnStoreMetaFn(callback) {
        this.on('store.meta.v2', callback);
    },

    /**
     * Methods to signal changes of the viewport's aspect ratio to the page.
     */
    changeAspectRatio: function changeAspectRatioFn(ratio) {
        this.emit('change.viewport.ratio', ratio);
    },

    /**
     * Methods to set callbacks to react to events happening on the page.
     */
    setOnViewportHide: function setOnViewportHideFn(callback) {
        this.on('change.viewport.hide', callback);
    },

    setOnViewportShow: function setOnViewportShowFn(callback) {
        this.on('change.viewport.show', callback);
    },

    setOnFullscreenOn: function setOnFullscreenOnFn(callback) {
        this.on('change.viewport.fullscreen.on', callback);
    },

    setOnFullscreenOff: function setOnFullscreenOffFn(callback) {
        this.on('change.viewport.fullscreen.off', callback);
    },

    setOnMenuStateChange: function setOnMenuStateChangeFn(callback) {
        this.on('change.menu.state', callback);
    },

    setOnUserStateChange: function setOnUserStateChangeFn(callback) {
        this.on('change.user.state', callback);
    },

    /**
     * Methods to send trigger event-emission on the page. These prompt the  page to trigger
     * the aforementioned corresponding onXXXX methods.
     */

    triggerOnFullscreen: function triggerOnFullscreenQueryFn() {
        this.emit('trigger.viewport.fullscreen');
    },

    triggerOnViewportVisibility: function triggerOnViewportVisibilityQueryFn() {
        this.emit('trigger.viewport.visibility');
    },

    triggerOnMenuStateChange: function triggerOnMenuStateQueryFn() {
        this.emit('trigger.menu.state');
    },

    triggerOnUserStateChange: function triggerOnUserStateQueryFn() {
        this.emit('trigger.user.state');
    },

    /**
     * Methods to send requests for information to the page. These methods can be used to send
     * state-queries. They take a callback function and prompt the page to call it.
     */

    /**
     * callback - a function that takes a single boolean value that will be set to 'true' if the
     * viewport is in fullscreen.
     */
    queryFullscreen: function queryFullscreenFn(callback) {
        this.emit('query.viewport.fullscreen', callback);
    },
    /**
     * callback - a function that takes a single boolean value that will be set to 'true' if the
     * viewport is visible.
     */
    queryViewportVisibility: function queryViewportVisibilityFn(callback) {
        this.emit('query.viewport.visibility', callback);
    },
    /**
     * callback - a function that takes an object-representation of the current menu-state.
     */
    queryMenuState: function queryMenuStateFn(callback) {
        this.emit('query.menu.state', callback);
    },
    /**
     * callback - a function that takes an object-representation of the current state of the user's settings.
     */
    queryUserState: function queryUserStateFn(callback) {
        this.emit('query.user.state', callback);
    }
};

if (!TurbulenzBridge.isInitialised())
{
    TurbulenzBridge._initInstance();
}

// Copyright (c) 2009-2012 Turbulenz Limited

function Floor() {}
Floor.prototype =
{
    version : 1,

    color       : [0.1, 0.1, 1.0, 1.0],
    fadeToColor : [0.95, 0.95, 1.0, 1.0],
    numLines    : 200
};

// Constructor function
Floor.create = function floorCreateFn(gd, md)
{
    var f = new Floor();

    var technique = null;
    var primitive = gd.PRIMITIVE_LINES;
    var vertexFormats = [gd.VERTEXFORMAT_FLOAT2];
    var semantics = gd.createSemantics([gd.SEMANTIC_POSITION]);
    var techniqueParameters = gd.createTechniqueParameters();

    var maxValue = Number.MAX_VALUE;
    var abs = Math.abs;
    var floor = Math.floor;
    var ceil = Math.ceil;

    var frustumMinX = maxValue;
    var frustumMinZ = maxValue;
    var frustumMaxX = -maxValue;
    var frustumMaxZ = -maxValue;

    var addPoint = function addPointFn(px, pz)
    {
        if (frustumMinX > px)
        {
            frustumMinX = px;
        }
        if (frustumMinZ > pz)
        {
            frustumMinZ = pz;
        }
        if (frustumMaxX < px)
        {
            frustumMaxX = px;
        }
        if (frustumMaxZ < pz)
        {
            frustumMaxZ = pz;
        }
    };

    var intersect = function intersetFn(s, e)
    {
        var sy = s[1];
        var ey = e[1];
        var t;
        if (sy > 0.0)
        {
            if (ey < 0.0)
            {
                t = ((-sy) / (ey - sy));
                addPoint(s[0] + t * (e[0] - s[0]),
                         s[2] + t * (e[2] - s[2]));
            }
            else if (ey === 0.0)
            {
                addPoint(e[0], e[2]);
            }
        }
        else if (sy < 0.0)
        {
            if (ey > 0.0)
            {
                t = ((-sy) / (ey - sy));
                addPoint(s[0] + t * (e[0] - s[0]),
                         s[2] + t * (e[2] - s[2]));
            }
            else if (ey === 0.0)
            {
                addPoint(e[0], e[2]);
            }
        }
        else //if (sy == 0.0)
        {
            addPoint(s[0], s[2]);
            if (ey === 0.0)
            {
                addPoint(e[0], e[2]);
            }
        }
    };

    f.render = function floorRenderFn(gd, camera)
    {
        // Calculate intersection with floor
        frustumMinX = maxValue;
        frustumMinZ = maxValue;
        frustumMaxX = -maxValue;
        frustumMaxZ = -maxValue;

        var frustumPoints = camera.getFrustumPoints();
        intersect(frustumPoints[0], frustumPoints[4]);
        intersect(frustumPoints[1], frustumPoints[5]);
        intersect(frustumPoints[2], frustumPoints[6]);
        intersect(frustumPoints[3], frustumPoints[7]);
        intersect(frustumPoints[0], frustumPoints[3]);
        intersect(frustumPoints[1], frustumPoints[2]);
        intersect(frustumPoints[4], frustumPoints[7]);
        intersect(frustumPoints[5], frustumPoints[6]);

        if (this.numLines > 0 &&
            frustumMinX < frustumMaxX &&
            frustumMinZ < frustumMaxZ)
        {
            var halfNumLines = (this.numLines / 2.0);
            var farPlane = camera.farPlane;
            var metersPerLine = floor(floor(2.0 * farPlane) / floor(halfNumLines));
            if (metersPerLine === 0.0)
            {
                metersPerLine = 1;
            }

            var cm = camera.matrix;
            var posX = (floor(cm[9] / metersPerLine) * metersPerLine);
            var posZ = (floor(cm[11] / metersPerLine) * metersPerLine);

            var vp = camera.viewProjectionMatrix;
            var vpRight = md.m44Right(vp);
            var vpAt = md.m44At(vp);
            var vpPos = md.m44Pos(vp);

            var v4ScalarMul = md.v4ScalarMul;

            var worldRight = v4ScalarMul.call(md, vpRight, farPlane);
            var worldUp = md.m44Up(vp);
            var worldAt = md.v4ScalarMul(vpAt, farPlane);
            var worldPos = md.v4Add3(v4ScalarMul.call(md, vpRight, posX), v4ScalarMul.call(md, vpAt, posZ), vpPos);

            techniqueParameters.worldViewProjection = md.m44Build(worldRight,
                                                                    worldUp,
                                                                    worldAt,
                                                                    worldPos,
                                                                    techniqueParameters.worldViewProjection);

            techniqueParameters.color = this.color;
            techniqueParameters.fadeToColor = this.fadeToColor;

            gd.setTechnique(technique);

            gd.setTechniqueParameters(techniqueParameters);

            // Try to draw minimum number of lines
            var invMetersPerLine = 1.0 / metersPerLine;
            var invMaxDistance = 1.0 / farPlane;
            var minX = ((floor(frustumMinX * invMetersPerLine) * metersPerLine) - posX) * invMaxDistance;
            var minZ = ((floor(frustumMinZ * invMetersPerLine) * metersPerLine) - posZ) * invMaxDistance;
            var maxX = ((ceil(frustumMaxX * invMetersPerLine) * metersPerLine) - posX) * invMaxDistance;
            var maxZ = ((ceil(frustumMaxZ * invMetersPerLine) * metersPerLine) - posZ) * invMaxDistance;

            var deltaLine = 2.0 / halfNumLines;
            var maxlinesX = (floor(halfNumLines * (abs(maxZ - minZ) / 2.0)) + 1);
            var maxlinesZ = (floor(halfNumLines * (abs(maxX - minX) / 2.0)) + 1);

            var writer;
            var current;
            var n;

            writer = gd.beginDraw(primitive,
                                  ((maxlinesX * 2) + (maxlinesZ * 2)),
                                  vertexFormats,
                                  semantics);
            if (writer)
            {
                current = minZ;
                for (n = 0; n < maxlinesX; n += 1)
                {
                    writer(minX, current);
                    writer(maxX, current);
                    current += deltaLine;
                }

                current = minX;
                for (n = 0; n < maxlinesZ; n += 1)
                {
                    writer(current, minZ);
                    writer(current, maxZ);
                    current += deltaLine;
                }

                gd.endDraw(writer);

                writer = null;
            }
        }
    };

    /*jshint white: false*/
    var shaderParameters =
    {
        "version": 1,
        "name": "floor.cgfx",
        "parameters":
        {
            "worldViewProjection":
            {
                "type": "float",
                "rows": 4,
                "columns": 4
            },
            "color":
            {
                "type": "float",
                "columns": 4
            },
            "fadeToColor":
            {
                "type": "float",
                "columns": 4
            }
        },
        "techniques":
        {
            "floor":
            [
                {
                    "parameters": ["worldViewProjection","color","fadeToColor"],
                    "semantics": ["POSITION"],
                    "states":
                    {
                        "DepthTestEnable": true,
                        "DepthFunc": 515,
                        "DepthMask": false,
                        "CullFaceEnable": false,
                        "BlendEnable": false
                    },
                    "programs": ["vp_floor","fp_floor"]
                }
            ]
        },
        "programs":
        {
            "fp_floor":
            {
                "type": "fragment",
                "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvec4 _ret_0;float _TMP11;float _a0012;float _TMP15;float _b0020;uniform vec4 color;uniform vec4 fadeToColor;varying vec4 tz_TexCoord[1];void main()\n{_a0012=dot(tz_TexCoord[0].xy,tz_TexCoord[0].xy);_TMP11=1.0/inversesqrt(_a0012);_b0020=min(1.0,_TMP11);_TMP15=max(0.0,_b0020);_ret_0=color+_TMP15*(fadeToColor-color);gl_FragColor=_ret_0;}"
            },
            "vp_floor":
            {
                "type": "vertex",
                "code": "#ifdef GL_ES\nprecision mediump float;precision mediump int;\n#endif\nvarying vec4 tz_TexCoord[1];attribute vec4 ATTR0;\nvec4 _OUTPosition1;vec2 _OUTDistance1;uniform vec4 worldViewProjection[4];void main()\n{_OUTPosition1=ATTR0.xxxx*worldViewProjection[0]+ATTR0.yyyy*worldViewProjection[2]+worldViewProjection[3];_OUTDistance1=ATTR0.xy;tz_TexCoord[0].xy=ATTR0.xy;gl_Position=_OUTPosition1;}"
            }
        }
    };
    /*jshint white: true*/

    var shader = gd.createShader(shaderParameters);
    if (shader)
    {
        technique = shader.getTechnique(0);
        return f;
    }

    return null;
};

// Copyright (c) 2011-2012 Turbulenz Limited

/*global window*/
/*global Touch: false*/
/*global TouchEvent: false*/
/*global TurbulenzEngine: false*/

//
// WebGLInputDevice
//
function WebGLInputDevice() {}
WebGLInputDevice.prototype = {

    version : 1,

    // Public API

    update : function inputDeviceUpdateFn()
    {
        if (!this.isWindowFocused)
        {
            return;
        }

        this.updateGamePad();
    },

    addEventListener : function addEventListenerFn(eventType, eventListener)
    {
        var i;
        var length;
        var eventHandlers;

        if (this.handlers.hasOwnProperty(eventType))
        {
            eventHandlers = this.handlers[eventType];

            if (eventListener)
            {
                // Check handler is not already stored
                length = eventHandlers.length;
                for (i = 0; i < length; i += 1)
                {
                    if (eventHandlers[i] === eventListener)
                    {
                        // Event handler has already been added
                        return;
                    }
                }

                eventHandlers.push(eventListener);
            }
        }
    },

    removeEventListener : function removeEventListenerFn(eventType, eventListener)
    {
        var i;
        var length;
        var eventHandlers;

        if (this.handlers.hasOwnProperty(eventType))
        {
            eventHandlers = this.handlers[eventType];

            if (eventListener)
            {
                length = eventHandlers.length;
                for (i = 0; i < length; i += 1)
                {
                    if (eventHandlers[i] === eventListener)
                    {
                        eventHandlers.splice(i, 1);
                        break;
                    }
                }
            }
        }
    },

    lockMouse : function lockMouseFn()
    {
        if (this.isHovering &&
            this.isWindowFocused)
        {
            this.isMouseLocked = true;
            this.hideMouse();

            this.requestBrowserLock();

            this.setEventHandlersLock();

            return true;
        }
        else
        {
            return false;
        }
    },

    unlockMouse : function unlockMouseFn()
    {
        if (this.isMouseLocked)
        {
            this.isMouseLocked = false;
            this.showMouse();

            this.requestBrowserUnlock();

            this.setEventHandlersUnlock();

            if (this.isOutsideEngine)
            {
                this.isOutsideEngine = false;

                this.isHovering = false;

                this.setEventHandlersMouseLeave();

                // Send mouseout event
                this.sendEventToHandlers(this.handlers.mouseleave);
            }

            // Send mouselocklost event
            this.sendEventToHandlers(this.handlers.mouselocklost);

            return true;
        }
        else
        {
            return false;
        }
    },

    isLocked : function isLockedFn()
    {
        return this.isMouseLocked;
    },

    hideMouse : function hideMouseFn()
    {
        if (this.isHovering)
        {
            if (!this.isCursorHidden)
            {
                this.isCursorHidden = true;
                this.previousCursor = document.body.style.cursor;
                document.body.style.cursor = 'none';
            }

            return true;
        }
        else
        {
            return false;
        }
    },

    showMouse : function showMouseFn()
    {
        if (this.isCursorHidden &&
            !this.isMouseLocked)
        {
            this.isCursorHidden = false;
            document.body.style.cursor = this.previousCursor;
            return true;
        }
        else
        {
            return false;
        }
    },

    isHidden : function isHiddenFn()
    {
        return this.isCursorHidden;
    },

    isFocused : function isFocused()
    {
        return this.isWindowFocused;
    },

    // Cannot convert keycodes to unicode in javascript so return empty strings
    convertToUnicode : function convertToUnicodeFn(keyCodeArray)
    {
        var keyCodeToUnicode = this.keyCodeToUnicode;
        var result = {};
        var length = keyCodeArray.length;
        var i;
        var keyCode;

        for (i = 0; i < length; i += 1)
        {
            keyCode = keyCodeArray[i];
            result[keyCode] = keyCodeToUnicode[keyCode] || "";
        }

        return result;
    },

    // KeyCodes: List of key codes and their values

    keyCodes :
    {
        A : 0,
        B : 1,
        C : 2,
        D : 3,
        E : 4,
        F : 5,
        G : 6,
        H : 7,
        I : 8,
        J : 9,
        K : 10,
        L : 11,
        M : 12,
        N : 13,
        O : 14,
        P : 15,
        Q : 16,
        R : 17,
        S : 18,
        T : 19,
        U : 20,
        V : 21,
        W : 22,
        X : 23,
        Y : 24,
        Z : 25,
        NUMBER_0 : 100,
        NUMBER_1 : 101,
        NUMBER_2 : 102,
        NUMBER_3 : 103,
        NUMBER_4 : 104,
        NUMBER_5 : 105,
        NUMBER_6 : 106,
        NUMBER_7 : 107,
        NUMBER_8 : 108,
        NUMBER_9 : 109,
        LEFT : 200,
        RIGHT : 201,
        UP : 202,
        DOWN : 203,
        LEFT_SHIFT : 300,
        RIGHT_SHIFT : 301,
        LEFT_CONTROL : 302,
        RIGHT_CONTROL : 303,
        LEFT_ALT : 304,
        RIGHT_ALT : 305,
        ESCAPE : 400,
        TAB : 401,
        SPACE :    402,
        BACKSPACE : 403,
        RETURN : 404,
        GRAVE : 500,
        MINUS : 501,
        EQUALS : 502,
        LEFT_BRACKET : 503,
        RIGHT_BRACKET : 504,
        SEMI_COLON : 505,
        APOSTROPHE : 506,
        COMMA : 507,
        PERIOD : 508,
        SLASH: 509,
        BACKSLASH: 510,
        F1 : 600,
        F2 : 601,
        F3 : 602,
        F4 : 603,
        F5 : 604,
        F6 : 605,
        F7 : 606,
        F8 : 607,
        F9 : 608,
        F10 : 609,
        F11 : 610,
        F12 : 611,
        NUMPAD_0 : 612,
        NUMPAD_1 : 613,
        NUMPAD_2 : 614,
        NUMPAD_3 : 615,
        NUMPAD_4 : 616,
        NUMPAD_5 : 617,
        NUMPAD_6 : 618,
        NUMPAD_7 : 619,
        NUMPAD_8 : 620,
        NUMPAD_9 : 621,
        NUMPAD_ENTER : 622,
        NUMPAD_DIVIDE : 623,
        NUMPAD_MULTIPLY : 624,
        NUMPAD_ADD : 625,
        NUMPAD_SUBTRACT : 626,
        LEFT_WIN : 627,
        RIGHT_WIN : 628,
        LEFT_OPTION : 629,
        RIGHT_OPTION : 630,
        CAPS_LOCK : 631,
        INSERT : 632,
        DELETE : 633,
        HOME : 634,
        END : 635,
        PAGE_UP: 636,
        PAGE_DOWN: 637
    },

    mouseCodes :
    {
        BUTTON_0 : 0,
        BUTTON_1 : 1,
        BUTTON_2 : 2,
        DELTA_X : 100,
        DELTA_Y : 101,
        MOUSE_WHEEL : 102
    },

    padCodes :
    {
        UP : 0,
        LEFT : 1,
        DOWN : 2,
        RIGHT : 3,
        A : 4,
        B : 5,
        X : 6,
        Y : 7,
        LEFT_TRIGGER : 8,
        RIGHT_TRIGGER : 9,
        LEFT_SHOULDER : 10,
        RIGHT_SHOULDER : 11,
        LEFT_THUMB : 12,
        LEFT_THUMB_X : 13,
        LEFT_THUMB_Y : 14,
        RIGHT_THUMB : 15,
        RIGHT_THUMB_X : 16,
        RIGHT_THUMB_Y : 17,
        START : 18,
        BACK : 19
    },

    // Private API

    sendEventToHandlers :
    function sendEventToHandlersFn(eventHandlers, arg0, arg1, arg2, arg3,
                                   arg4, arg5)
    {
        var i;
        var length = eventHandlers.length;

        if (length)
        {
            for (i = 0; i < length; i += 1)
            {
                eventHandlers[i](arg0, arg1, arg2, arg3, arg4, arg5);
            }
        }
    },

    sendEventToHandlersASync :
    function sendEventToHandlersASyncFn(handlers, a0, a1, a2, a3, a4, a5)
    {
        var sendEvent = WebGLInputDevice.prototype.sendEventToHandlers;
        TurbulenzEngine.setTimeout(function callSendEventToHandlersFn() {
            sendEvent(handlers, a0, a1, a2, a3, a4, a5);
        }, 0);
    },

    updateGamePad : function updateGamePadFn()
    {
        var magnitude;
        var normalizedMagnitude;

        var gamepads = (navigator.gamepads ||
                        navigator.webkitGamepads ||
                        (navigator.webkitGetGamepads && navigator.webkitGetGamepads()));

        if (gamepads)
        {
            var deadZone = this.padAxisDeadZone;
            var maxAxisRange = this.maxAxisRange;
            var sendEvent = this.sendEventToHandlersASync;
            var handlers = this.handlers;
            var padButtons = this.padButtons;
            var padMap = this.padMap;
            var leftThumbX = 0;
            var leftThumbY = 0;
            var rightThumbX = 0;
            var rightThumbY = 0;

            var numGamePads = gamepads.length;
            for (var i = 0; i < numGamePads; i += 1)
            {
                var gamepad = gamepads[i];
                if (gamepad)
                {
                    // Update button states

                    var buttons = gamepad.buttons;

                    if (this.padTimestampUpdate < gamepad.timestamp)
                    {
                        this.padTimestampUpdate = gamepad.timestamp;

                        var numButtons = buttons.length;
                        for (var n = 0; n < numButtons; n += 1)
                        {
                            var value = buttons[n];
                            if (padButtons[n] !== value)
                            {
                                padButtons[n] = value;

                                var padCode = padMap[n];
                                if (padCode !== undefined)
                                {
                                    if (value)
                                    {
                                        sendEvent(handlers.paddown, padCode);
                                    }
                                    else
                                    {
                                        sendEvent(handlers.padup, padCode);
                                    }
                                }
                            }
                        }
                    }

                    // Update axes states

                    var axes = gamepad.axes;
                    if (axes.length <= 4)
                    {
                        // Axis 1 & 2
                        var lX = axes[0];
                        var lY = -axes[1];
                        magnitude = ((lX * lX) + (lY * lY));

                        if (magnitude > (deadZone * deadZone))
                        {
                            magnitude = Math.sqrt(magnitude);

                            // Normalize lX and lY
                            lX = (lX / magnitude);
                            lY = (lY / magnitude);

                            // Clip the magnitude at its max possible value
                            if (magnitude > maxAxisRange)
                            {
                                magnitude = maxAxisRange;
                            }

                            // Adjust magnitude relative to the end of the dead zone
                            magnitude -= deadZone;

                            // Normalize the magnitude
                            normalizedMagnitude = (magnitude / (maxAxisRange - deadZone));

                            leftThumbX = (lX * normalizedMagnitude);
                            leftThumbY = (lY * normalizedMagnitude);
                        }

                        // Axis 3 & 4
                        var rX = axes[2];
                        var rY = -axes[3];
                        magnitude = ((rX * rX) + (rY * rY));

                        if (magnitude > (deadZone * deadZone))
                        {
                            magnitude = Math.sqrt(magnitude);

                            // Normalize lX and lY
                            rX = (rX / magnitude);
                            rY = (rY / magnitude);

                            // Clip the magnitude at its max possible value
                            if (magnitude > maxAxisRange)
                            {
                                magnitude = maxAxisRange;
                            }

                            // Adjust magnitude relative to the end of the dead zone
                            magnitude -= deadZone;

                            // Normalize the magnitude
                            normalizedMagnitude = (magnitude / (maxAxisRange - deadZone));

                            rightThumbX = (rX * normalizedMagnitude);
                            rightThumbY = (rY * normalizedMagnitude);
                        }


                        sendEvent(handlers.padmove,
                                  leftThumbX, leftThumbY, buttons[6],
                                  rightThumbX, rightThumbY, buttons[7]);
                    }

                    // Our API only supports one active pad...
                    break;
                }
            }
        }
    },

    // Cannot detect locale in canvas mode
    getLocale : function getLocaleFn()
    {
        return "";
    },

    // Returns the local coordinates of the event (i.e. position in Canvas coords)
    getCanvasPosition : function getCanvasPositionFn(event, position)
    {
        if (event.offsetX !== undefined)
        {
            position.x = event.offsetX;
            position.y = event.offsetY;
        }
        else if (event.layerX !== undefined)
        {
            position.x = event.layerX;
            position.y = event.layerY;
        }
    },

    // Called when blurring
    resetKeyStates : function resetKeyStatesFn()
    {
        var keyName;
        var pressedKeys = this.pressedKeys;

        for (keyName in pressedKeys)
        {
            if (pressedKeys.hasOwnProperty(keyName))
            {
                pressedKeys[keyName] = false;
            }
        }
    },

    // Private mouse event methods

    onMouseOver : function onMouseOverFn(event)
    {
        var position = {};
        var mouseOverHandlers = this.handlers.mouseover;

        event.stopPropagation();
        event.preventDefault();

        this.getCanvasPosition(event, position);

        this.lastX = event.screenX;
        this.lastY = event.screenY;

        this.sendEventToHandlers(mouseOverHandlers, position.x, position.y);
    },

    onMouseMove : function onMouseMoveFn(event)
    {
        var mouseMoveHandlers = this.handlers.mousemove;

        var deltaX, deltaY;

        event.stopPropagation();
        event.preventDefault();

        if (this.ignoreNextMouseMoves)
        {
            this.ignoreNextMouseMoves -= 1;
            return;
        }

        if (event.movementX !== undefined)
        {
            deltaX = event.movementX;
            deltaY = event.movementY;
        }
        else if (event.mozMovementX !== undefined)
        {
            deltaX = event.mozMovementX;
            deltaY = event.mozMovementY;
        }
        else if (event.webkitMovementX !== undefined)
        {
            deltaX = event.webkitMovementX;
            deltaY = event.webkitMovementY;
        }
        else
        {
            deltaX = (event.screenX - this.lastX);
            deltaY = (event.screenY - this.lastY);
            if (0 === deltaX && 0 === deltaY)
            {
                return;
            }
        }

        this.lastX = event.screenX;
        this.lastY = event.screenY;

        this.sendEventToHandlers(mouseMoveHandlers, deltaX, deltaY);
    },

    onWheel : function onWheelFn(event)
    {
        var mouseWheelHandlers = this.handlers.mousewheel;

        var scrollDelta;

        event.stopPropagation();
        event.preventDefault();

        if (event.wheelDelta)
        {
            if (window.opera)
            {
                scrollDelta = event.wheelDelta < 0 ? 1 : -1;
            }
            else
            {
                scrollDelta = event.wheelDelta > 0 ? 1 : -1;
            }
        }
        else
        {
            scrollDelta = event.detail < 0 ? 1 : -1;
        }

        this.sendEventToHandlers(mouseWheelHandlers, scrollDelta);
    },

    emptyEvent : function emptyEventFn(event)
    {
        event.stopPropagation();
        event.preventDefault();
    },

    onWindowFocus : function onWindowFocusFn()
    {
        if (this.isHovering &&
            window.document.activeElement === this.canvas)
        {
            this.addInternalEventListener(window, 'mousedown', this.onMouseDown);
        }
    },

    onFocus : function onFocusFn()
    {
        var canvas = this.canvas;
        var handlers = this.handlers;
        var focusHandlers = handlers.focus;

        if (!this.isWindowFocused)
        {
            this.isWindowFocused = true;

            window.focus();
            canvas.focus();

            this.setEventHandlersFocus();

            canvas.oncontextmenu = function () {
                return false;
            };

            this.sendEventToHandlers(focusHandlers);
        }
    },

    onBlur : function onBlurFn()
    {
        var canvas = this.canvas;
        var handlers = this.handlers;
        var blurHandlers = handlers.blur;

        if (this.isMouseLocked)
        {
            this.unlockMouse();
        }

        if (this.isWindowFocused)
        {
            this.isWindowFocused = false;

            this.resetKeyStates();
            this.setEventHandlersBlur();
            canvas.oncontextmenu = null;

            this.sendEventToHandlers(blurHandlers);
        }
    },

    onMouseDown : function onMouseDownFn(event)
    {
        var handlers = this.handlers;

        if (this.isHovering)
        {
            var mouseDownHandlers = handlers.mousedown;
            var button = event.button;
            var position = {};

            this.onFocus();

            event.stopPropagation();
            event.preventDefault();

            if (button < 3)
            {
                button = this.mouseMap[button];
            }

            this.getCanvasPosition(event, position);

            this.sendEventToHandlers(mouseDownHandlers, button, position.x, position.y);
        }
        else
        {
            this.onBlur();
        }
    },

    onMouseUp : function onMouseUpFn(event)
    {
        var mouseUpHandlers = this.handlers.mouseup;

        if (this.isHovering)
        {
            var button = event.button;
            var position = {};

            event.stopPropagation();
            event.preventDefault();

            if (button < 3)
            {
                button = this.mouseMap[button];
            }

            this.getCanvasPosition(event, position);

            this.sendEventToHandlers(mouseUpHandlers, button, position.x, position.y);
        }
    },

    // Private key event methods

    onKeyDown : function onKeyDownFn(event)
    {
        var keyDownHandlers = this.handlers.keydown;
        var pressedKeys = this.pressedKeys;
        var keyCodes = this.keyCodes;

        event.stopPropagation();
        event.preventDefault();

        var keyCode = event.keyCode;
        keyCode = this.keyMap[keyCode];

        var keyLocation = event.keyLocation || event.location;

        if (undefined !== keyCode &&
           (keyCodes.ESCAPE !== keyCode))
        {
            // Handle left / right key locations
            //   DOM_KEY_LOCATION_STANDARD = 0x00;
            //   DOM_KEY_LOCATION_LEFT     = 0x01;
            //   DOM_KEY_LOCATION_RIGHT    = 0x02;
            //   DOM_KEY_LOCATION_NUMPAD   = 0x03;
            //   DOM_KEY_LOCATION_MOBILE   = 0x04;
            //   DOM_KEY_LOCATION_JOYSTICK = 0x05;

            if (2 === keyLocation)
            {
                // The Turbulenz KeyCodes are such that CTRL, SHIFT
                // and ALT have their RIGHT versions exactly one above
                // the LEFT versions.
                keyCode = keyCode + 1;
            }
            if (!pressedKeys[keyCode])
            {
                pressedKeys[keyCode] = true;
                this.sendEventToHandlers(keyDownHandlers, keyCode);
            }
        }
    },

    onKeyUp : function onKeyUpFn(event)
    {
        var keyUpHandlers = this.handlers.keyup;
        var pressedKeys = this.pressedKeys;
        var keyCodes = this.keyCodes;

        event.stopPropagation();
        event.preventDefault();

        var keyCode = event.keyCode;
        keyCode = this.keyMap[keyCode];

        var keyLocation = event.keyLocation || event.location;

        if (keyCode === keyCodes.ESCAPE)
        {
            this.unlockMouse();
        }
        else if (undefined !== keyCode)
        {
            // Handle LEFT / RIGHT.  (See OnKeyDown)

            if (2 === keyLocation)
            {
                keyCode = keyCode + 1;
            }
            if (pressedKeys[keyCode])
            {
                pressedKeys[keyCode] = false;
                this.sendEventToHandlers(keyUpHandlers, keyCode);
            }
        }
    },

    // Private touch event methods

    onTouchStart : function onTouchStartFn(event)
    {
        var eventHandlers = this.handlers.touchstart;

        event.preventDefault();

        // Store new touches
        this.addTouches(event.changedTouches);

        event = this.convertW3TouchEventToTurbulenzTouchEvent(event);

        this.sendEventToHandlers(eventHandlers, event);
    },

    onTouchEnd : function onTouchEndFn(event)
    {
        var eventHandlers = this.handlers.touchend;

        event.preventDefault();

        event = this.convertW3TouchEventToTurbulenzTouchEvent(event);

        // Remove ended touches
        this.removeTouches(event.changedTouches);

        this.sendEventToHandlers(eventHandlers, event);
    },

    onTouchMove : function onTouchMoveFn(event)
    {
        var eventHandlers = this.handlers.touchmove;

        event.preventDefault();

        this.addTouches(event.changedTouches);

        event = this.convertW3TouchEventToTurbulenzTouchEvent(event);

        this.sendEventToHandlers(eventHandlers, event);
    },

    onTouchEnter : function onTouchEnterFn(event)
    {
        var eventHandlers = this.handlers.touchenter;

        event.preventDefault();

        event = this.convertW3TouchEventToTurbulenzTouchEvent(event);

        this.sendEventToHandlers(eventHandlers, event);
    },

    onTouchLeave : function onTouchLeaveFn(event)
    {
        var eventHandlers = this.handlers.touchleave;

        event.preventDefault();

        event = this.convertW3TouchEventToTurbulenzTouchEvent(event);

        this.sendEventToHandlers(eventHandlers, event);
    },

    onTouchCancel : function onTouchCancelFn(event)
    {
        var eventHandlers = this.handlers.touchcancel;

        event.preventDefault();

        event = this.convertW3TouchEventToTurbulenzTouchEvent(event);

        // Remove canceled touches
        this.removeTouches(event.changedTouches);

        this.sendEventToHandlers(eventHandlers, event);
    },

    convertW3TouchEventToTurbulenzTouchEvent : function convertW3TouchEventToTurbulenzTouchEventFn(w3TouchEvent)
    {
        // Initialize changedTouches
        var changedTouches = this.convertW3TouchListToTurbulenzTouchList(w3TouchEvent.changedTouches);

        // Initialize gameTouches
        var gameTouches = this.convertW3TouchListToTurbulenzTouchList(w3TouchEvent.targetTouches);

        // Initialize touches
        var touches = this.convertW3TouchListToTurbulenzTouchList(w3TouchEvent.touches);

        var touchEventParams =
        {
            changedTouches  : changedTouches,
            gameTouches     : gameTouches,
            touches         : touches
        };

        return TouchEvent.create(touchEventParams);
    },

    convertW3TouchListToTurbulenzTouchList : function convertW3TouchListToTurbulenzTouchListFn(w3TouchList)
    {
        // Set changedTouches
        var w3TouchListLength = w3TouchList.length;
        var touchList = [];

        var touch;
        var touchIndex;

        touchList.length = w3TouchListLength;

        for (touchIndex = 0; touchIndex < w3TouchListLength; touchIndex += 1)
        {
            touch = this.getTouchById(w3TouchList[touchIndex].identifier);
            touchList[touchIndex] = touch;
        }

        return touchList;
    },

    convertW3TouchToTurbulenzTouch : function convertW3TouchToTurbulenzTouchFn(w3Touch)
    {
        var canvasElement   = this.canvas;
        var canvasRect      = canvasElement.getBoundingClientRect();

        var touchParams =
        {
            force           : (w3Touch.force || w3Touch.webkitForce || 0),
            identifier      : w3Touch.identifier,
            isGameTouch     : (w3Touch.target === canvasElement),
            positionX       : (w3Touch.pageX - canvasRect.left),
            positionY       : (w3Touch.pageY - canvasRect.top),
            radiusX         : (w3Touch.radiusX || w3Touch.webkitRadiusX || 1),
            radiusY         : (w3Touch.radiusY || w3Touch.webkitRadiusY || 1),
            rotationAngle   : (w3Touch.rotationAngle || w3Touch.webkitRotationAngle || 0)
        };

        return Touch.create(touchParams);
    },

    addTouches : function addTouchesFn(w3TouchList)
    {
        var w3TouchListLength = w3TouchList.length;

        var touchIndex;
        var touch;

        for (touchIndex = 0; touchIndex < w3TouchListLength; touchIndex += 1)
        {
            touch = this.convertW3TouchToTurbulenzTouch(w3TouchList[touchIndex]);
            this.addTouch(touch);
        }
    },

    removeTouches : function removeTouchesFn(w3TouchList)
    {
        var w3TouchListLength = w3TouchList.length;

        var touchIndex;
        var touchId;

        for (touchIndex = 0; touchIndex < w3TouchListLength; touchIndex += 1)
        {
            touchId = w3TouchList[touchIndex].identifier;
            this.removeTouchById(touchId);
        }
    },

    addTouch : function addTouchFn(touch)
    {
        this.touches[touch.identifier] = touch;
    },

    getTouchById : function getTouchByIdFn(id)
    {
        return this.touches[id];
    },

    removeTouchById : function removeTouchByIdFn(id)
    {
        delete this.touches[id];
    },

    // Canvas event handlers

    canvasOnMouseOver : function canvasOnMouseOverFn(event)
    {
        var mouseEnterHandlers = this.handlers.mouseenter;

        if (!this.isMouseLocked)
        {
            this.isHovering = true;

            this.lastX = event.screenX;
            this.lastY = event.screenY;

            this.setEventHandlersMouseEnter();

            // Send mouseover event
            this.sendEventToHandlers(mouseEnterHandlers);
        }
        else
        {
            this.isOutsideEngine = false;
        }
    },

    canvasOnMouseOut : function canvasOnMouseOutFn(event)
    {
        var mouseLeaveHandlers = this.handlers.mouseleave;

        if (!this.isMouseLocked)
        {
            this.isHovering = false;

            if (this.isCursorHidden)
            {
                this.showMouse();
            }

            this.setEventHandlersMouseLeave();

            // Send mouseout event
            this.sendEventToHandlers(mouseLeaveHandlers);
        }
        else
        {
            this.isOutsideEngine = true;
        }
    },

    // This is required in order to detect hovering when we missed the initial mouseover event
    canvasOnMouseDown : function canvasOnMouseDownFn(event)
    {
        var mouseEnterHandlers = this.handlers.mouseenter;

        this.canvas.onmousedown = null;

        if (!this.isHovering)
        {
            this.isHovering = true;

            this.lastX = event.screenX;
            this.lastY = event.screenY;

            this.setEventHandlersMouseEnter();

            this.sendEventToHandlers(mouseEnterHandlers);

            this.onMouseDown(event);
        }

        return false;
    },

    // Window event handlers

    onFullscreenChanged : function onFullscreenChangedFn(event)
    {
        if (this.isMouseLocked)
        {
            if (document.fullscreenEnabled || document.mozFullScreen || document.webkitIsFullScreen)
            {
                this.ignoreNextMouseMoves = 2; // Some browsers will send 2 mouse events with a massive delta
                this.requestBrowserLock();
            }
            else
            {
                // Browsers capture the escape key whilst in fullscreen
                this.unlockMouse();
            }
        }
    },

    // Set event handler methods

    setEventHandlersMouseEnter : function setEventHandlersMouseEnterFn()
    {
        // Add event listener to get focus event
        if (!this.isFocused())
        {
            this.addInternalEventListener(window, 'mousedown', this.onMouseDown);
        }

        this.addInternalEventListener(window, 'mouseup', this.onMouseUp);
        this.addInternalEventListener(window, 'mousemove', this.onMouseOver);
        this.addInternalEventListener(window, 'DOMMouseScroll', this.onWheel);
        this.addInternalEventListener(window, 'mousewheel', this.onWheel);
        this.addInternalEventListener(window, 'click', this.emptyEvent);
    },

    setEventHandlersMouseLeave : function setEventHandlersMouseLeaveFn()
    {
        // We do not need a mousedown listener if not focused
        if (!this.isFocused())
        {
            this.removeInternalEventListener(window, 'mousedown', this.onMouseDown);
        }

        // Remove mouse event listeners
        this.removeInternalEventListener(window, 'mouseup', this.onMouseUp);
        this.removeInternalEventListener(window, 'mousemove', this.onMouseOver);
        this.removeInternalEventListener(window, 'DOMMouseScroll', this.onWheel);
        this.removeInternalEventListener(window, 'mousewheel', this.onWheel);
        this.removeInternalEventListener(window, 'click', this.emptyEvent);
    },

    setEventHandlersFocus : function setEventHandlersFocusFn()
    {
        this.addInternalEventListener(window, 'keydown', this.onKeyDown);
        this.addInternalEventListener(window, 'keyup', this.onKeyUp);
    },

    setEventHandlersBlur : function setEventHandlersBlurFn()
    {
        this.removeInternalEventListener(window, 'keydown', this.onKeyDown);
        this.removeInternalEventListener(window, 'keyup', this.onKeyUp);
        this.removeInternalEventListener(window, 'mousedown', this.onMouseDown);
    },

    setEventHandlersLock : function setEventHandlersLockFn()
    {
        this.removeInternalEventListener(window, 'mousemove', this.onMouseOver);

        this.addInternalEventListener(window, 'mousemove', this.onMouseMove);
        this.addInternalEventListener(window, 'fullscreenchange', this.onFullscreenChanged);
        this.addInternalEventListener(window, 'mozfullscreenchange', this.onFullscreenChanged);
        this.addInternalEventListener(window, 'webkitfullscreenchange', this.onFullscreenChanged);
    },

    setEventHandlersUnlock : function setEventHandlersUnlockFn()
    {
        this.removeInternalEventListener(window, 'webkitfullscreenchange', this.onFullscreenChanged);
        this.removeInternalEventListener(window, 'mozfullscreenchange', this.onFullscreenChanged);
        this.removeInternalEventListener(window, 'fullscreenchange', this.onFullscreenChanged);
        this.removeInternalEventListener(window, 'mousemove', this.onMouseMove);

        this.addInternalEventListener(window, 'mousemove', this.onMouseOver);
    },

    setEventHandlersCanvas : function setEventHandlersCanvasFn()
    {
        var canvas = this.canvas;

        this.addInternalEventListener(canvas, 'mouseover', this.canvasOnMouseOver);
        this.addInternalEventListener(canvas, 'mouseout', this.canvasOnMouseOut);
        this.addInternalEventListener(canvas, 'mousedown', this.canvasOnMouseDown);
    },

    setEventHandlersWindow : function setEventHandlersWindowFn()
    {
        this.addInternalEventListener(window, 'blur', this.onBlur);
        this.addInternalEventListener(window, 'focus', this.onWindowFocus);
    },

    removeEventHandlersWindow : function removeEventHandlersWindowFn()
    {
        this.removeInternalEventListener(window, 'blur', this.onBlur);
        this.removeInternalEventListener(window, 'focus', this.onWindowFocus);
    },

    setEventHandlersTouch : function setEventHandlersTouchFn()
    {
        var canvas = this.canvas;

        this.addInternalEventListener(canvas, 'touchstart', this.onTouchStart);
        this.addInternalEventListener(canvas, 'touchend', this.onTouchEnd);
        this.addInternalEventListener(canvas, 'touchenter', this.onTouchEnter);
        this.addInternalEventListener(canvas, 'touchleave', this.onTouchLeave);
        this.addInternalEventListener(canvas, 'touchmove', this.onTouchMove);
        this.addInternalEventListener(canvas, 'touchcancel', this.onTouchCancel);
    },

    // Helper methods

    addInternalEventListener : function addInternalEventListenerFn(element, eventName, eventHandler)
    {
        var elementEventFlag = this.elementEventFlags[element];
        if (!elementEventFlag)
        {
            this.elementEventFlags[element] = elementEventFlag = {};
        }

        if (!elementEventFlag[eventName])
        {
            elementEventFlag[eventName] = true;

            var boundEventHandler = this.boundFunctions[eventHandler];
            if (!boundEventHandler)
            {
                this.boundFunctions[eventHandler] = boundEventHandler = eventHandler.bind(this);
            }

            element.addEventListener(eventName, boundEventHandler, false);
        }
    },

    removeInternalEventListener : function removeInternalEventListenerFn(element, eventName, eventHandler)
    {
        var elementEventFlag = this.elementEventFlags[element];
        if (elementEventFlag)
        {
            if (elementEventFlag[eventName])
            {
                elementEventFlag[eventName] = false;

                var boundEventHandler = this.boundFunctions[eventHandler];

                element.removeEventListener(eventName, boundEventHandler, false);
            }
        }
    },

    destroy : function destroyFn()
    {
        // Remove all event listeners
        if (this.isLocked())
        {
            this.setEventHandlersUnlock();
        }

        if (this.isHovering)
        {
            this.setEventHandlersMouseLeave();
        }

        if (this.isWindowFocused)
        {
            this.setEventHandlersBlur();
        }

        this.removeEventHandlersWindow();

        var canvas = this.canvas;
        canvas.onmouseover = null;
        canvas.onmouseout = null;
        canvas.onmousedown = null;
    }
};

// Constructor function
WebGLInputDevice.create = function webGLInputDeviceFn(canvas, params)
{
    var id = new WebGLInputDevice();

    id.lastX = 0;
    id.lastY = 0;

    id.touches = {};

    id.boundFunctions = {};
    id.elementEventFlags = {};

    id.canvas = canvas;
    id.isMouseLocked = false;
    id.isHovering = false;
    id.isWindowFocused = false;
    id.isCursorHidden = false;
    id.isOutsideEngine = false; // Used for determining where we are when unlocking
    id.previousCursor = '';
    id.ignoreNextMouseMoves = 0;

    // Used to screen out auto-repeats, dictionary from keycode to bool,
    // true for each key currently pressed down
    id.pressedKeys = {};

    // Game event handlers
    id.handlers =
    {
        keydown : [],
        keyup : [],

        mousedown : [],
        mouseup : [],
        mousewheel : [],
        mouseover : [],
        mousemove : [],

        paddown : [],
        padup : [],
        padmove : [],

        mouseenter : [],
        mouseleave : [],
        focus : [],
        blur : [],
        mouselocklost : [],

        touchstart : [],
        touchend : [],
        touchenter : [],
        touchleave : [],
        touchmove : [],
        touchcancel : []
    };

    // Populate the keyCodeToUnicodeTable.  Just use the 'key' part of
    // the keycodes, overriding some special cases.

    var keyCodeToUnicodeTable = {};
    var keyCodes = id.keyCodes;
    for (var k in keyCodes)
    {
        if (keyCodes.hasOwnProperty(k))
        {
            var code = keyCodes[k];
            keyCodeToUnicodeTable[code] = k;
        }
    }
    keyCodeToUnicodeTable[keyCodes.SPACE] = ' ';
    keyCodeToUnicodeTable[keyCodes.NUMBER_0] = '0';
    keyCodeToUnicodeTable[keyCodes.NUMBER_1] = '1';
    keyCodeToUnicodeTable[keyCodes.NUMBER_2] = '2';
    keyCodeToUnicodeTable[keyCodes.NUMBER_3] = '3';
    keyCodeToUnicodeTable[keyCodes.NUMBER_4] = '4';
    keyCodeToUnicodeTable[keyCodes.NUMBER_5] = '5';
    keyCodeToUnicodeTable[keyCodes.NUMBER_6] = '6';
    keyCodeToUnicodeTable[keyCodes.NUMBER_7] = '7';
    keyCodeToUnicodeTable[keyCodes.NUMBER_8] = '8';
    keyCodeToUnicodeTable[keyCodes.NUMBER_9] = '9';
    keyCodeToUnicodeTable[keyCodes.GRAVE] = '`';
    keyCodeToUnicodeTable[keyCodes.MINUS] = '-';
    keyCodeToUnicodeTable[keyCodes.EQUALS] = '=';
    keyCodeToUnicodeTable[keyCodes.LEFT_BRACKET] = '[';
    keyCodeToUnicodeTable[keyCodes.RIGHT_BRACKET] = ']';
    keyCodeToUnicodeTable[keyCodes.SEMI_COLON] = ';';
    keyCodeToUnicodeTable[keyCodes.APOSTROPHE] = "'";
    keyCodeToUnicodeTable[keyCodes.COMMA] = ',';
    keyCodeToUnicodeTable[keyCodes.PERIOD] = '.';
    keyCodeToUnicodeTable[keyCodes.SLASH] = '/';
    keyCodeToUnicodeTable[keyCodes.BACKSLASH] = '\\';

    // KeyMap: Maps JavaScript keycodes to Turbulenz keycodes - some
    // keycodes are consistent across all browsers and some mappings
    // are browser specific.
    var keyMap = {};

    // A-Z
    keyMap[65] = 0; // A
    keyMap[66] = 1; // B
    keyMap[67] = 2; // C
    keyMap[68] = 3; // D
    keyMap[69] = 4; // E
    keyMap[70] = 5; // F
    keyMap[71] = 6; // G
    keyMap[72] = 7; // H
    keyMap[73] = 8; // I
    keyMap[74] = 9; // J
    keyMap[75] = 10; // K
    keyMap[76] = 11; // L
    keyMap[77] = 12; // M
    keyMap[78] = 13; // N
    keyMap[79] = 14; // O
    keyMap[80] = 15; // P
    keyMap[81] = 16; // Q
    keyMap[82] = 17; // R
    keyMap[83] = 18; // S
    keyMap[84] = 19; // T
    keyMap[85] = 20; // U
    keyMap[86] = 21; // V
    keyMap[87] = 22; // X
    keyMap[88] = 23; // W
    keyMap[89] = 24; // Y
    keyMap[90] = 25; // Z

    // 0-9
    keyMap[48] = 100; // 0
    keyMap[49] = 101; // 1
    keyMap[50] = 102; // 2
    keyMap[51] = 103; // 3
    keyMap[52] = 104; // 4
    keyMap[53] = 105; // 5
    keyMap[54] = 106; // 6
    keyMap[55] = 107; // 7
    keyMap[56] = 108; // 8
    keyMap[57] = 109; // 9

    // Arrow keys
    keyMap[37] = 200; // LEFT
    keyMap[39] = 201; // RIGHT
    keyMap[38] = 202; // UP
    keyMap[40] = 203; // DOWN

    // Modifier keys
    keyMap[16] = 300; // LEFT_SHIFT
    //keyMap[16] = 301; // RIGHT_SHIFT
    keyMap[17] = 302; // LEFT_CONTROL
    //keyMap[17] = 303; // RIGHT_CONTROL
    keyMap[18] = 304; // LEFT_ALT
    keyMap[0] = 305; // RIGHT_ALT

    // Special keys
    keyMap[27] = 400; // ESCAPE
    keyMap[9] = 401; // TAB
    keyMap[32] = 402; // SPACE
    keyMap[8] = 403; // BACKSPACE
    keyMap[13] = 404; // RETURN

    // Punctuation keys
    keyMap[223] = 500; // GRAVE
    keyMap[109] = 501; // MINUS (mozilla - gecko)
    keyMap[189] = 501; // MINUS (ie + webkit)
    keyMap[107] = 502; // EQUALS (mozilla - gecko)
    keyMap[187] = 502; // EQUALS (ie + webkit)
    keyMap[219] = 503; // LEFT_BRACKET
    keyMap[221] = 504; // RIGHT_BRACKET
    keyMap[59] = 505; // SEMI_COLON (mozilla - gecko)
    keyMap[186] = 505; // SEMI_COLON (ie + webkit)
    keyMap[192] = 506; // APOSTROPHE
    keyMap[188] = 507; // COMMA
    keyMap[190] = 508; // PERIOD

    // if Mac OS then overwrite apostrophe and grave key-mappings
    if (navigator.appVersion.indexOf("Mac") !== -1)
    {
        keyMap[192] = 500; // GRAVE (mac webkit)
        keyMap[0] = 500; // GRAVE (mac gecko + safari 5.1)
        keyMap[222] = 506; // APOSTROPHE (mac webkit)
    }

    // Non-standard keys
    keyMap[112] = 600; // F1
    keyMap[113] = 601; // F2
    keyMap[114] = 602; // F3
    keyMap[115] = 603; // F4
    keyMap[116] = 604; // F5
    keyMap[117] = 605; // F6
    keyMap[118] = 606; // F7
    keyMap[119] = 607; // F8
    keyMap[120] = 608; // F9
    keyMap[121] = 609; // F10
    keyMap[122] = 610; // F11
    keyMap[123] = 611; // F12
    //keyMap[45 : 612, // NUMPAD_0 (numlock on/off)
    keyMap[96] = 612; // NUMPAD_0 (numlock on/off)
    //keyMap[35] = 613;, // NUMPAD_1 (numlock on/off)
    keyMap[97] = 613; // NUMPAD_1 (numlock on/off)
    //keyMap[40] = 614; // NUMPAD_2 (numlock on/off)
    keyMap[98] = 614; // NUMPAD_2 (numlock on/off)
    //keyMap[34] = 615; // NUMPAD_3 (numlock on/off)
    keyMap[99] = 615; // NUMPAD_3 (numlock on/off)
    //keyMap[37] = 616;, // NUMPAD_4 (numlock on/off)
    keyMap[100] = 616; // NUMPAD_4 (numlock on/off)
    keyMap[12] = 617; // NUMPAD_5 (numlock on/off)
    keyMap[101] = 617; // NUMPAD_5 (numlock on/off)
    keyMap[144] = 617; // NUMPAD_5 (numlock on/off)
    //keyMap[39] = 618; // NUMPAD_6 (numlock on/off)
    keyMap[102] = 618; // NUMPAD_6 (numlock on/off)
    //keyMap[36] = 619; // NUMPAD_7 (numlock on/off)
    keyMap[103] = 619; // NUMPAD_7 (numlock on/off)
    //keyMap[38] = 620; // NUMPAD_8 (numlock on/off)
    keyMap[104] = 620; // NUMPAD_8 (numlock on/off)
    //keyMap[33] = 621; // NUMPAD_9 (numlock on/off)
    keyMap[105] = 621; // NUMPAD_9 (numlock on/off)
    //keyMap[13] = 622; // NUMPAD_ENTER (numlock on/off)
    keyMap[111] = 623; // NUMPAD_DIVIDE (numlock on/off)
    keyMap[191] = 623; // NUMPAD_DIVIDE (numlock on/off), mac chrome
    keyMap[106] = 624; // NUMPAD_MULTIPLY (numlock on/off)
    //keyMap[107] = 625; // NUMPAD_ADD (numlock on/off)
    //keyMap[109] = 626; // NUMPAD_SUBTRACT (numlock on/off)
    keyMap[91] = 627; // LEFT_WIN
    keyMap[224] = 627; // LEFT_WIN (mac, firefox)
    keyMap[92] = 628; // RIGHT_WIN
    keyMap[93] = 628; // RIGHT_WIN (mac, chrome)
    //: 629, // LEFT_OPTION
    //: 630, // RIGHT_OPTION
    keyMap[20] = 631; // CAPS_LOCK
    keyMap[45] = 632; // INSERT
    keyMap[46] = 633; // DELETE
    keyMap[36] = 634; // HOME
    keyMap[35] = 635; // END
    keyMap[33] = 636; // PAGE_UP
    keyMap[34] = 637; // PAGE_DOWN

    id.keyMap = keyMap;

    // MouseMap: Maps current mouse controls to new controls
    var mouseMap =
    {
        0 : 0,
        1 : 2,
        2 : 1
    };

    id.mouseMap = mouseMap;

    // padMap: Maps current pad buttons to new buttons
    var padMap =
    {
        0 : 4, // A
        1 : 5, // B
        2 : 6, // X
        3 : 7, // Y

        4 : 10, // LEFT_SHOULDER
        5 : 11, // RIGHT_SHOULDER

        8 : 19, // BACK
        9 : 18, // START

        10 : 12, // LEFT_THUMB
        11 : 15, // RIGHT_THUMB

        12 : 0, // UP
        13 : 2, // DOWN
        14 : 1, // LEFT
        15 : 3  // RIGHT
    };

    id.padMap = padMap;

    id.keyCodeToUnicode = keyCodeToUnicodeTable;

    id.padButtons = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    id.padMap = padMap;
    id.padAxisDeadZone = 0.26;
    id.maxAxisRange = 1.0;
    id.padTimestampUpdate = 0;

    // Pointer locking
    var requestPointerLock = (canvas.requestPointerLock    ||
                              canvas.mozRequestPointerLock ||
                              canvas.webkitRequestPointerLock);
    if (requestPointerLock)
    {
        var exitPointerLock = (document.exitPointerLock    ||
                               document.mozExitPointerLock ||
                               document.webkitExitPointerLock);

        id.requestBrowserLock = function requestBrowserLockFn()
        {
            var pointerLockElement = (document.pointerLockElement    ||
                                      document.mozPointerLockElement ||
                                      document.webkitPointerLockElement);
            if (pointerLockElement !== canvas)
            {
                requestPointerLock.call(canvas);
            }
        };

        id.requestBrowserUnlock = function requestBrowserUnlockFn()
        {
            var pointerLockElement = (document.pointerLockElement    ||
                                      document.mozPointerLockElement ||
                                      document.webkitPointerLockElement);
            if (pointerLockElement === canvas)
            {
                exitPointerLock.call(document);
            }
        };
    }
    else
    {
        var pointer = (navigator.pointer || navigator.webkitPointer);
        if (pointer)
        {
            id.requestBrowserLock = function requestBrowserLockFn()
            {
                if (!pointer.isLocked)
                {
                    pointer.lock(canvas);
                }
            };

            id.requestBrowserUnlock = function requestBrowserUnlockFn()
            {
                if (pointer.isLocked)
                {
                    pointer.unlock();
                }
            };
        }
        else
        {
            id.requestBrowserLock = function requestBrowserLockFn() {};
            id.requestBrowserUnlock = function requestBrowserUnlockFn() {};
        }
    }

    // Add canvas mouse event listeners
    id.setEventHandlersCanvas();

    // Add window blur event listener
    id.setEventHandlersWindow();

    // Add canvas touch event listeners
    id.setEventHandlersTouch();

    return id;
};

// Copyright (c) 2011-2012 Turbulenz Limited


var namedCSSColor = {
    aliceblue : "#f0f8ff",
    antiquewhite : "#faebd7",
    aqua : "#00ffff",
    aquamarine : "#7fffd4",
    azure : "#f0ffff",
    beige : "#f5f5dc",
    bisque : "#ffe4c4",
    black : "#000000",
    blanchedalmond : "#ffebcd",
    blue : "#0000ff",
    blueviolet : "#8a2be2",
    brown : "#a52a2a",
    burlywood : "#deb887",
    cadetblue : "#5f9ea0",
    chartreuse : "#7fff00",
    chocolate : "#d2691e",
    coral : "#ff7f50",
    cornflowerblue : "#6495ed",
    cornsilk : "#fff8dc",
    crimson : "#dc143c",
    cyan : "#00ffff",
    darkblue : "#00008b",
    darkcyan : "#008b8b",
    darkgoldenrod : "#b8860b",
    darkgray : "#a9a9a9",
    darkgrey : "#a9a9a9",
    darkgreen : "#006400",
    darkkhaki : "#bdb76b",
    darkmagenta : "#8b008b",
    darkolivegreen : "#556b2f",
    darkorange : "#ff8c00",
    darkorchid : "#9932cc",
    darkred : "#8b0000",
    darksalmon : "#e9967a",
    darkseagreen : "#8fbc8f",
    darkslateblue : "#483d8b",
    darkslategray : "#2f4f4f",
    darkslategrey : "#2f4f4f",
    darkturquoise : "#00ced1",
    darkviolet : "#9400d3",
    deeppink : "#ff1493",
    deepskyblue : "#00bfff",
    dimgray : "#696969",
    dimgrey : "#696969",
    dodgerblue : "#1e90ff",
    firebrick : "#b22222",
    floralwhite : "#fffaf0",
    forestgreen : "#228b22",
    fuchsia : "#ff00ff",
    gainsboro : "#dcdcdc",
    ghostwhite : "#f8f8ff",
    gold : "#ffd700",
    goldenrod : "#daa520",
    gray : "#808080",
    grey : "#808080",
    green : "#008000",
    greenyellow : "#adff2f",
    honeydew : "#f0fff0",
    hotpink : "#ff69b4",
    indianred : "#cd5c5c",
    indigo : "#4b0082",
    ivory : "#fffff0",
    khaki : "#f0e68c",
    lavender : "#e6e6fa",
    lavenderblush : "#fff0f5",
    lawngreen : "#7cfc00",
    lemonchiffon : "#fffacd",
    lightblue : "#add8e6",
    lightcoral : "#f08080",
    lightcyan : "#e0ffff",
    lightgoldenrodyellow : "#fafad2",
    lightgray : "#d3d3d3",
    lightgrey : "#d3d3d3",
    lightgreen : "#90ee90",
    lightpink : "#ffb6c1",
    lightsalmon : "#ffa07a",
    lightseagreen : "#20b2aa",
    lightskyblue : "#87cefa",
    lightslategray : "#778899",
    lightslategrey : "#778899",
    lightsteelblue : "#b0c4de",
    lightyellow : "#ffffe0",
    lime : "#00ff00",
    limegreen : "#32cd32",
    linen : "#faf0e6",
    magenta : "#ff00ff",
    maroon : "#800000",
    mediumaquamarine : "#66cdaa",
    mediumblue : "#0000cd",
    mediumorchid : "#ba55d3",
    mediumpurple : "#9370d8",
    mediumseagreen : "#3cb371",
    mediumslateblue : "#7b68ee",
    mediumspringgreen : "#00fa9a",
    mediumturquoise : "#48d1cc",
    mediumvioletred : "#c71585",
    midnightblue : "#191970",
    mintcream : "#f5fffa",
    mistyrose : "#ffe4e1",
    moccasin : "#ffe4b5",
    navajowhite : "#ffdead",
    navy : "#000080",
    oldlace : "#fdf5e6",
    olive : "#808000",
    olivedrab : "#6b8e23",
    orange : "#ffa500",
    orangered : "#ff4500",
    orchid : "#da70d6",
    palegoldenrod : "#eee8aa",
    palegreen : "#98fb98",
    paleturquoise : "#afeeee",
    palevioletred : "#d87093",
    papayawhip : "#ffefd5",
    peachpuff : "#ffdab9",
    peru : "#cd853f",
    pink : "#ffc0cb",
    plum : "#dda0dd",
    powderblue : "#b0e0e6",
    purple : "#800080",
    red : "#ff0000",
    rosybrown : "#bc8f8f",
    royalblue : "#4169e1",
    saddlebrown : "#8b4513",
    salmon : "#fa8072",
    sandybrown : "#f4a460",
    seagreen : "#2e8b57",
    seashell : "#fff5ee",
    sienna : "#a0522d",
    silver : "#c0c0c0",
    skyblue : "#87ceeb",
    slateblue : "#6a5acd",
    slategray : "#708090",
    slategrey : "#708090",
    snow : "#fffafa",
    springgreen : "#00ff7f",
    steelblue : "#4682b4",
    tan : "#d2b48c",
    teal : "#008080",
    thistle : "#d8bfd8",
    tomato : "#ff6347",
    turquoise : "#40e0d0",
    violet : "#ee82ee",
    wheat : "#f5deb3",
    white : "#ffffff",
    whitesmoke : "#f5f5f5",
    yellow : "#ffff00",
    yellowgreen : "#9acd32"
};

function parseCSSColor(text, color)
{
    var readInt = parseInt;
    var components;

    text = text.replace(/ /g, '').toLowerCase();

    text = (namedCSSColor[text] || text);

    if (text[0] === '#')
    {
        text = text.substr(1, 6);

        var numChars = text.length;
        if (numChars === 6)
        {
            components = /^(\w{2})(\w{2})(\w{2})$/.exec(text);
            if (components)
            {
                color[0] = (readInt(components[1], 16) / 255);
                color[1] = (readInt(components[2], 16) / 255);
                color[2] = (readInt(components[3], 16) / 255);
                color[3] = 1.0;
                return color;
            }
        }
        else if (numChars === 3)
        {
            components = /^(\w{1})(\w{1})(\w{1})$/.exec(text);
            if (components)
            {
                color[0] = (readInt(components[1], 16) / 15);
                color[1] = (readInt(components[2], 16) / 15);
                color[2] = (readInt(components[3], 16) / 15);
                color[3] = 1.0;
                return color;
            }
        }
    }
    else
    {
        var color_type = text.substr(0, 4);
        if (color_type === 'rgba')
        {
            components = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.?\d+)\)$/.exec(text);
            if (components)
            {
                color[0] = readInt(components[1], 10) / 255;
                color[1] = readInt(components[2], 10) / 255;
                color[2] = readInt(components[3], 10) / 255;
                color[3] = parseFloat(components[4]);
                return color;
            }
        }
        else if (color_type === 'rgb(')
        {
            components = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/.exec(text);
            if (components)
            {
                color[0] = readInt(components[1], 10) / 255;
                color[1] = readInt(components[2], 10) / 255;
                color[2] = readInt(components[3], 10) / 255;
                color[3] = 1.0;
                return color;
            }
        }
        else
        {
            if (color_type === 'hsla')
            {
                components = /^hsla\((\d{1,3}),\s*(\d{1,3})\%,\s*(\d{1,3})\%,\s*(\d*\.?\d+)\)$/.exec(text);
                if (components)
                {
                    color[3] = parseFloat(components[4]);
                }
            }
            else if (color_type === 'hsl(')
            {
                components = /^hsl\((\d{1,3}),\s*(\d{1,3})\%,\s*(\d{1,3})\%\)$/.exec(text);
                if (components)
                {
                    color[3] = 1.0;
                }
            }

            if (components)
            {
                var hue = readInt(components[1], 10) / 360;
                var saturation = readInt(components[2], 10) / 100;
                var lightness = readInt(components[3], 10) / 100;
                if (saturation === 0)
                {
                    color[0] = lightness;
                    color[1] = lightness;
                    color[2] = lightness;
                }
                else
                {
                    var m1, m2;
                    if (lightness < 0.5)
                    {
                        m2 = (lightness * (saturation + 1));
                    }
                    else
                    {
                        m2 = ((lightness + saturation) - (lightness * saturation));
                    }
                    m1 = ((lightness * 2) - m2);

                    var hueToRgb = function hueToRgbFn(m1, m2, hue)
                    {
                        if (hue < 0)
                        {
                            hue += 1;
                        }
                        else if (hue > 1)
                        {
                            hue -= 1;
                        }

                        if ((6 * hue) < 1)
                        {
                            return (m1 + ((m2 - m1) * (hue * 6)));
                        }
                        else if ((2 * hue) < 1)
                        {
                            return m2;
                        }
                        else if ((3 * hue) < 2)
                        {
                            return (m1 + ((m2 - m1) * ((2 / 3) - hue) * 6));
                        }
                        else
                        {
                            return m1;
                        }
                    };

                    color[0] = hueToRgb(m1, m2, (hue + (1 / 3)));
                    color[1] = hueToRgb(m1, m2, hue);
                    color[2] = hueToRgb(m1, m2, (hue - (1 / 3)));
                }
                return color;
            }
        }
    }

    return undefined;
}

//
// CanvasLinearGradient
//
function CanvasLinearGradient() {}
CanvasLinearGradient.prototype =
{
    version : 1,

    // Public API
    addColorStop : function addLinearColorStopFn(offset, color)
    {
        if (offset < 0 || offset > 1)
        {
            throw 'INDEX_SIZE_ERR';
        }

        function sortfunction(a, b)
        {
            return (a[0] - b[0]);
        }

        var stops = this.stops;
        var numStops = stops.length;

        var parsedColor = parseCSSColor(color, []);

        if (parsedColor[3] < 1.0)
        {
            this.opaque = false;
        }

        parsedColor[0] = parseInt((parsedColor[0] * 255), 10);
        parsedColor[1] = parseInt((parsedColor[1] * 255), 10);
        parsedColor[2] = parseInt((parsedColor[2] * 255), 10);
        parsedColor[3] = parseInt((parsedColor[3] * 255), 10);
        stops[numStops] = [offset, parsedColor];
        numStops += 1;
        if (numStops > 1)
        {
            stops.sort(sortfunction);
        }
    },

    // Private API
    updateTexture : function updateLinearTextureFn(gd)
    {
        var texture = this.texture;
        var stops = this.stops;
        var numStops = stops.length;
        if (this.numTextureStops !== numStops)
        {
            this.numTextureStops = numStops;

            var width = this.width;
            var height = this.height;

            if (!texture)
            {
                this.texture = texture = gd.createTexture({
                    name    : ('linear:' + width + 'x' + height),
                    width   : width,
                    height  : height,
                    depth   : 1,
                    format  : gd.PIXELFORMAT_R8G8B8A8,
                    cubemap : false,
                    mipmaps : false
                });
            }

            var opaque = this.opaque;

            var lx = (this.x1 - this.x0);
            var ly = (this.y1 - this.y0);
            var ln = ((lx * lx) + (ly * ly));
            if (ln === 0)
            {
                ln = 1;
            }
            else
            {
                ln = (1.0 / Math.sqrt(ln));
            }

            lx *= ln;
            ly *= ln;

            var dx = (lx / (width > 1 ? (width - 1) : 1));
            var dy = (ly / (height > 1 ? (height - 1) : 1));

            var numValues = (width * height * 4);
            var pixelData = new Array(numValues);
            var p = 0;
            var vy = 0;
            for (var y = 0; y < height; y += 1, vy += dy)
            {
                var vyly = (vy * ly);
                var vx = 0;

                for (var x = 0; x < width; x += 1, p += 4, vx += dx)
                {
                    var s = ((vx * lx) + vyly);

                    var currentStop = stops[0];
                    var currentOffset = currentStop[0];
                    var currentColor = currentStop[1];
                    var lastOffset = currentOffset;
                    var lastColor = currentColor;

                    if (s > currentOffset)
                    {
                        for (var ns = 1; ns < numStops; ns += 1)
                        {
                            currentStop = stops[ns];
                            currentOffset = currentStop[0];
                            currentColor = currentStop[1];
                            if (s <= currentOffset)
                            {
                                break;
                            }
                            lastOffset = currentOffset;
                            lastColor = currentColor;
                        }
                    }

                    var da = (currentOffset - lastOffset);
                    if (da <= 0 || s === currentOffset)
                    {
                        pixelData[p] = currentColor[0];
                        pixelData[p + 1] = currentColor[1];
                        pixelData[p + 2] = currentColor[2];
                        if (opaque)
                        {
                            pixelData[p + 3] = 255;
                        }
                        else
                        {
                            pixelData[p + 3] = currentColor[3];
                        }
                    }
                    else
                    {
                        var a = (s - lastOffset) / da;
                        if (a < 0.996)
                        {
                            var inva = (1.0 - a);
                            pixelData[p] = ((currentColor[0] * a) + (lastColor[0] * inva));
                            pixelData[p + 1] = ((currentColor[1] * a) + (lastColor[1] * inva));
                            pixelData[p + 2] = ((currentColor[2] * a) + (lastColor[2] * inva));
                            if (opaque)
                            {
                                pixelData[p + 3] = 255;
                            }
                            else
                            {
                                pixelData[p + 3] = ((currentColor[3] * a) + (lastColor[3] * inva));
                            }
                        }
                        else
                        {
                            pixelData[p] = currentColor[0];
                            pixelData[p + 1] = currentColor[1];
                            pixelData[p + 2] = currentColor[2];
                            if (opaque)
                            {
                                pixelData[p + 3] = 255;
                            }
                            else
                            {
                                pixelData[p + 3] = currentColor[3];
                            }
                        }
                    }
                }
            }

            texture.setData(pixelData);
        }
        return texture;
    }
};

// Constructor function
CanvasLinearGradient.create = function canvasLinearGradientCreateFn(x0, y0, x1, y1)
{
    var dx = (x1 - x0);
    var dy = (y1 - y0);
    var width = Math.abs(dx);
    var height = Math.abs(dy);
    if (width === 0 && height === 0)
    {
        return null;
    }

    // We need minimmal dimensions for minimal quality
    while (width < 16 && height < 16)
    {
        width *= 16;
        height *= 16;
    }

    if (width < 1)
    {
        width = 1;
    }
    else
    {
        width = Math.floor(width);
    }

    if (height < 1)
    {
        height = 1;
    }
    else
    {
        height = Math.floor(height);
    }

    var c = new CanvasLinearGradient();
    c.x0 = x0;
    c.y0 = y0;
    c.x1 = x1;
    c.y1 = y1;
    c.width = width;
    c.height = height;
    c.stops = [];

    var idx = (1.0 / dx);
    var idy = (1.0 / dy);
    c.matrix = [idx, 0, -x0 * idx,
                0, idy, -y0 * idy];

    c.numTextureStops = 0;
    c.texture = null;

    c.opaque = true;

    return c;
};

//
// CanvasRadialGradient
//
function CanvasRadialGradient() {}
CanvasRadialGradient.prototype =
{
    version : 1,

    // Public API
    addColorStop : function addRadialColorStopFn(offset, color)
    {
        if (offset < 0 || offset > 1)
        {
            throw 'INDEX_SIZE_ERR';
        }

        function sortfunction(a, b)
        {
            return (a[0] - b[0]);
        }

        var stops = this.stops;
        var numStops = stops.length;
        var parsedColor = parseCSSColor(color, []);

        if (parsedColor[3] < 1.0)
        {
            this.opaque = false;
        }

        parsedColor[0] = parseInt((parsedColor[0] * 255), 10);
        parsedColor[1] = parseInt((parsedColor[1] * 255), 10);
        parsedColor[2] = parseInt((parsedColor[2] * 255), 10);
        parsedColor[3] = parseInt((parsedColor[3] * 255), 10);
        stops[numStops] = [offset, parsedColor];
        numStops += 1;
        if (numStops > 1)
        {
            stops.sort(sortfunction);
        }
    },

    // Private API
    updateTexture : function updateRadialTextureFn(gd)
    {
        var texture = this.texture;
        var stops = this.stops;
        var numStops = stops.length;
        if (this.numTextureStops !== numStops)
        {
            this.numTextureStops = numStops;

            var width = this.width;
            if (width < numStops)
            {
                this.width = width = numStops;
            }

            var height = this.height;
            if (height < numStops)
            {
                this.height = height = numStops;
            }

            if (!texture ||
                texture.width !== width ||
                texture.height !== height)
            {
                this.texture = texture = gd.createTexture({
                    name    : ('radial:' + width + 'x' + height),
                    width   : width,
                    height  : height,
                    depth   : 1,
                    format  : gd.PIXELFORMAT_R8G8B8A8,
                    cubemap : false,
                    mipmaps : false
                });
            }

            var x0 = (this.x0 - this.minX);
            var x1 = (this.x1 - this.minX);
            var dx = (x1 - x0);

            var y0 = (this.y0 - this.minY);
            var y1 = (this.y1 - this.minY);
            var dy = (y1 - y0);

            var r0 = this.r0;
            var r1 = this.r1;
            var dr = (r1 - r0);

            var numValues = (width * height * 4);
            var pixelData = new Array(numValues);

            var cos = Math.cos;
            var sin = Math.sin;
            var abs = Math.abs;
            var pi2 = (Math.PI * 2);

            /*jshint bitwise: false*/
            var numSteps = Math.max(abs(dx | 0), abs(dy | 0), abs(dr | 0));
            /*jshint bitwise: true*/

            var dw = (1.0 / numSteps);
            var c0, c1, c2, c3;
            for (var w = 0.0; w <= 1.0; w += dw)
            {
                var currentStop = stops[0];
                var currentOffset = currentStop[0];
                var currentColor = currentStop[1];
                var lastOffset = currentOffset;
                var lastColor = currentColor;

                if (w > currentOffset)
                {
                    for (var ns = 1; ns < numStops; ns += 1)
                    {
                        currentStop = stops[ns];
                        currentOffset = currentStop[0];
                        currentColor = currentStop[1];
                        if (w <= currentOffset)
                        {
                            break;
                        }
                        lastOffset = currentOffset;
                        lastColor = currentColor;
                    }
                }

                var da = (currentOffset - lastOffset);
                if (da <= 0 || w === currentOffset)
                {
                    c0 = currentColor[0];
                    c1 = currentColor[1];
                    c2 = currentColor[2];
                    c3 = currentColor[3];
                }
                else
                {
                    var a = (w - lastOffset) / da;
                    var inva = (1.0 - a);
                    c0 = ((currentColor[0] * a) + (lastColor[0] * inva));
                    c1 = ((currentColor[1] * a) + (lastColor[1] * inva));
                    c2 = ((currentColor[2] * a) + (lastColor[2] * inva));
                    c3 = ((currentColor[3] * a) + (lastColor[3] * inva));
                }

                var x = (x0 + (w * dx));
                var y = (y0 + (w * dy));
                var r = (r0 + (w * dr));

                var angle, dangle, cx, cy, p;
                for (var cr = 1; cr < r; cr += 1)
                {
                    dangle = (1.0 / cr);
                    for (angle = 0; angle < pi2; angle += dangle)
                    {
                        /*jshint bitwise: false*/
                        cx = ((x + (cr * cos(angle))) | 0);
                        cy = ((y + (cr * sin(angle))) | 0);
                        p = ((cx + (cy * width)) << 2);
                        /*jshint bitwise: true*/
                        if (pixelData[p + 3] === undefined)
                        {
                            pixelData[p] = c0;
                            pixelData[p + 1] = c1;
                            pixelData[p + 2] = c2;
                            pixelData[p + 3] = c3;
                        }
                    }
                }

                dangle = (1.0 / r);
                for (angle = 0; angle < pi2; angle += dangle)
                {
                    /*jshint bitwise: false*/
                    cx = ((x + (r * cos(angle))) | 0);
                    cy = ((y + (r * sin(angle))) | 0);
                    p = ((cx + (cy * width)) << 2);
                    /*jshint bitwise: true*/
                    if (pixelData[p + 3] === undefined)
                    {
                        pixelData[p] = c0;
                        pixelData[p + 1] = c1;
                        pixelData[p + 2] = c2;
                        pixelData[p + 3] = c3;
                    }
                }
            }

            var outColor = stops[numStops - 1][1];
            var out0 = outColor[0];
            var out1 = outColor[1];
            var out2 = outColor[2];
            var out3 = outColor[3];
            for (var n = 0; n < numValues; n += 4)
            {
                if (pixelData[n + 3] === undefined)
                {
                    pixelData[n] = out0;
                    pixelData[n + 1] = out1;
                    pixelData[n + 2] = out2;
                    pixelData[n + 3] = out3;
                }
            }

            texture.setData(pixelData);
        }
        return texture;
    }
};

// Constructor function
CanvasRadialGradient.create = function canvasRadialGradientCreateFn(x0, y0, r0, x1, y1, r1)
{
    if (r0 < 0 || r1 < 0)
    {
        throw 'INDEX_SIZE_ERR';
    }

    var c = new CanvasRadialGradient();
    c.x0 = x0;
    c.y0 = y0;
    c.r0 = r0;
    c.x1 = x1;
    c.y1 = y1;
    c.r1 = r1;

    var minX = (Math.min((x0 - r0), (x1 - r1)) - 1);
    var maxX = (Math.max((x0 + r0), (x1 + r1)) + 1);
    var minY = (Math.min((y0 - r0), (y1 - r1)) - 1);
    var maxY = (Math.max((y0 + r0), (y1 + r1)) + 1);

    c.minX = minX;
    c.minY = minY;
    c.stops = [];

    var width = Math.ceil(maxX - minX);
    var height = Math.ceil(maxY - minY);
    if (!width || !height)
    {
        return null;
    }
    c.width = width;
    c.height = height;

    var idx = (1.0 / width);
    var idy = (1.0 / height);

    c.matrix = [idx, 0, -minX * idx,
                0, idy, -minY * idy];

    c.numTextureStops = 0;
    c.texture = null;

    c.opaque = true;

    return c;
};

//
// CanvasContext
//
function CanvasContext() {}
CanvasContext.prototype =
{
    version : 1,

    compositeOperations :
    {
        'source-atop' : 1,
        'source-in' : 1,
        'source-out' : 1,
        'source-over' : 1,
        'destination-atop' : 1,
        'destination-in' : 1,
        'destination-out' : 1,
        'destination-over' : 1,
        'lighter' : 1,
        'copy' : 1,
        'xor' : 1
    },

    capStyles :
    {
        'butt' : 1,
        'round' : 1,
        'square' : 1
    },

    joinStyles :
    {
        'bevel' : 1,
        'round' : 1,
        'miter' : 1
    },

    //
    // Public canvas 2D context API
    //
    save : function saveFn()
    {
        var statesStack = this.statesStack;
        var numStatesInStack = this.numStatesInStack;
        var states = statesStack[numStatesInStack];
        if (!states)
        {
            statesStack[numStatesInStack] = states = this.createStatesObject();
        }
        this.numStatesInStack = (numStatesInStack + 1);
        this.setStates(states, this);
    },

    restore : function restoreFn()
    {
        var numStatesInStack = this.numStatesInStack;
        if (0 < numStatesInStack)
        {
            numStatesInStack -= 1;
            this.numStatesInStack = numStatesInStack;
            var states = this.statesStack[numStatesInStack];
            this.setStates(this, states);
        }
    },


    scale : function scaleFn(x, y)
    {
        var m = this.matrix;
        m[0] *= x;
        m[1] *= y;
        m[3] *= x;
        m[4] *= y;
    },

    rotate : function rotateFn(angle)
    {
        if (angle)
        {
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            this.transform(c, s, -s, c, 0, 0);
        }
    },

    translate : function translateFn(x, y)
    {
        var m = this.matrix;
        m[2] += (m[0] * x + m[1] * y);
        m[5] += (m[3] * x + m[4] * y);
    },

    transform : function transformFn(a, b, c, d, e, f)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        m[0] = (m0 * a + m1 * b);
        m[3] = (m3 * a + m4 * b);
        m[1] = (m0 * c + m1 * d);
        m[4] = (m3 * c + m4 * d);
        m[2] = (m0 * e + m1 * f + m2);
        m[5] = (m3 * e + m4 * f + m5);
    },

    setTransform : function setTransformFn(a, b, c, d, e, f)
    {
        var m = this.matrix;
        m[0] = a;
        m[1] = c;
        m[2] = e;
        m[3] = b;
        m[4] = d;
        m[5] = f;
    },


    createLinearGradient : function createLinearGradientFn(x0, y0, x1, y1)
    {
        return CanvasLinearGradient.create(x0, y0, x1, y1);
    },

    createRadialGradient : function createRadialGradientFn(x0, y0, r0, x1, y1, r1)
    {
        return CanvasRadialGradient.create(x0, y0, r0, x1, y1, r1);
    },

    createPattern : function createPatternFn(image, repetition)
    {
        if (!image)
        {
            throw 'INVALID_STATE_ERR';
        }

        if (image.width === 0 ||
            image.height === 0)
        {
            return null;
        }

        return image;
    },


    clearRect : function clearRectFn(x, y, w, h)
    {
        if (w > 0 && h > 0)
        {
            var gd = this.gd;
            var clipExtents = this.clipExtents;
            var minClipX = clipExtents[0];
            var minClipY = clipExtents[1];
            var maxClipX = clipExtents[2];
            var maxClipY = clipExtents[3];

            var rect = this.transformRect(x, y, w, h, this.tempRect);

            if (rect[0] <= minClipX &&
                rect[1] >= maxClipY &&
                rect[2] >= maxClipX &&
                rect[3] >= maxClipY &&
                rect[4] <= minClipX &&
                rect[5] <= minClipY &&
                rect[6] >= maxClipX &&
                rect[7] <= minClipY)
            {
                gd.clear(this.v4Zero);
            }
            else
            {
                this.fillFlatBuffer(rect, 4);

                var technique = this.flatTechniques.copy;

                gd.setTechnique(technique);

                technique.screen = this.screen;
                technique.color = this.v4Zero;

                gd.draw(this.triangleStripPrimitive, 4);
            }
        }
    },

    fillRect : function fillRectFn(x, y, w, h)
    {
        if (w > 0 && h > 0)
        {
            var rect = this.transformRect(x, y, w, h, this.tempRect);
            this.fillFlatBuffer(rect, 4);

            var primitive = this.triangleStripPrimitive;
            var style = this.fillStyle;
            var gd = this.gd;

            if (this.setShadowStyle(style))
            {
                gd.draw(primitive, 4);
            }

            this.setStyle(style);

            gd.draw(primitive, 4);
        }
    },

    strokeRect : function strokeRectFn(x, y, w, h)
    {
        if (w > 0 || h > 0)
        {
            var rect = this.transformRect(x, y, w, h, this.tempRect);

            var style = this.strokeStyle;
            var lineWidth = this.lineWidth;
            var thinLines = (lineWidth < 2 && !this.forceFatLines);

            var primitive;
            var numVertices;
            var bufferData;

            if (thinLines)
            {
                primitive = this.lineStripPrimitive;
                numVertices = 5;
                bufferData = this.getFlatBuffer(5);
                if (bufferData)
                {
                    bufferData[0] = rect[4];
                    bufferData[1] = rect[5];
                    bufferData[2] = rect[6];
                    bufferData[3] = rect[7];
                    bufferData[4] = rect[2];
                    bufferData[5] = rect[3];
                    bufferData[6] = rect[0];
                    bufferData[7] = rect[1];
                    bufferData[8] = rect[4];
                    bufferData[9] = rect[5];
                    this.fillFlatBuffer(bufferData, 5);
                }
            }
            else
            {
                var p0 = [rect[0], rect[1]];
                var p1 = [rect[2], rect[3]];
                var p2 = [rect[4], rect[5]];
                var p3 = [rect[6], rect[7]];
                var points = [p2, p3, p1, p0, p2];

                primitive = this.triangleStripPrimitive;
                numVertices = this.fillFatStrip(points, 5, lineWidth);
            }

            var gd = this.gd;

            if (this.setShadowStyle(style))
            {
                gd.draw(primitive, numVertices);
            }

            this.setStyle(style);

            gd.draw(primitive, numVertices);
        }
    },


    beginPath : function beginPathFn()
    {
        this.subPaths.length = 0;
        this.currentSubPath.length = 0;
    },

    closePath : function closePathFn()
    {
        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements > 1)
        {
            var firstPoint = currentSubPath[0];

            // Close current subpath if not just a single segment
            if (numCurrentSubPathElements > 2)
            {
                var lastPoint = currentSubPath[numCurrentSubPathElements - 1];
                var abs = Math.abs;
                if (abs(firstPoint[0] - lastPoint[0]) >= 1.0 ||
                    abs(firstPoint[1] - lastPoint[1]) >= 1.0)
                {
                    currentSubPath[numCurrentSubPathElements] = firstPoint;
                }
            }

            var subPaths = this.subPaths;
            subPaths[subPaths.length] = currentSubPath;

            this.currentSubPath = [firstPoint];
        }
    },

    moveTo : function moveToFn(x, y)
    {
        var currentSubPath = this.currentSubPath;
        if (currentSubPath.length > 1)
        {
            var subPaths = this.subPaths;
            subPaths[subPaths.length] = currentSubPath;

            this.currentSubPath = [this.transformPoint(x, y)];
        }
        else
        {
            currentSubPath[0] = this.transformPoint(x, y);
        }
    },

    lineTo : function lineToFn(x, y)
    {
        var currentSubPath = this.currentSubPath;
        currentSubPath[currentSubPath.length] = this.transformPoint(x, y);
    },

    quadraticCurveTo : function quadraticCurveToFn(cpx, cpy, x, y)
    {
        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements === 0)
        {
            throw 'Needs starting point!';
        }

        var p1 = currentSubPath[numCurrentSubPathElements - 1];
        var x1 = p1[0];
        var y1 = p1[1];

        var q = this.transformPoint(cpx, cpy);
        var xq = q[0];
        var yq = q[1];

        var p2 = this.transformPoint(x, y);
        var x2 = p2[0];
        var y2 = p2[1];

        var abs = Math.abs;
        /*jshint bitwise: false*/
        var numSteps = ((0.5 * (abs(x2 - x1) + abs(y2 - y1))) | 0);
        /*jshint bitwise: true*/
        var dt = (1.0 / numSteps);
        for (var t = dt; 1 < numSteps; t += dt, numSteps -= 1)
        {
            var invt = (1.0 - t);
            var invt2 = (invt * invt);
            var t2 = (t * t);
            var tinvt = (2 * t * invt);
            currentSubPath[numCurrentSubPathElements] = [((invt2 * x1) + (tinvt * xq) + (t2 * x2)),
                                                         ((invt2 * y1) + (tinvt * yq) + (t2 * y2))];
            numCurrentSubPathElements += 1;
        }

        currentSubPath[numCurrentSubPathElements] = [x2, y2];
    },

    bezierCurveTo : function bezierCurveToFn(cp1x, cp1y, cp2x, cp2y, x, y)
    {
        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements === 0)
        {
            throw 'Needs starting point!';
        }

        var p1 = currentSubPath[numCurrentSubPathElements - 1];
        var x1 = p1[0];
        var y1 = p1[1];

        var q1 = this.transformPoint(cp1x, cp1y);
        var xq1 = q1[0];
        var yq1 = q1[1];

        var q2 = this.transformPoint(cp2x, cp2y);
        var xq2 = q2[0];
        var yq2 = q2[1];

        var p2 = this.transformPoint(x, y);
        var x2 = p2[0];
        var y2 = p2[1];

        var abs = Math.abs;
        /*jshint bitwise: false*/
        var numSteps = ((0.5 * (abs(x2 - x1) + abs(y2 - y1))) | 0);
        /*jshint bitwise: true*/
        var dt = (1.0 / numSteps);
        for (var t = dt; 1 < numSteps; t += dt, numSteps -= 1)
        {
            var invt = (1.0 - t);
            var invt2 = (invt * invt);
            var invt3 = (invt2 * invt);
            var t2 = (t * t);
            var t3 = (t2 * t);
            var tinvt = (3 * t * invt2);
            var invtt = (3 * t2 * invt);
            currentSubPath[numCurrentSubPathElements] = [((invt3 * x1) + (tinvt * xq1) + (invtt * xq2) + (t3 * x2)),
                                                         ((invt3 * y1) + (tinvt * yq1) + (invtt * yq2) + (t3 * y2))];
            numCurrentSubPathElements += 1;
        }

        currentSubPath[numCurrentSubPathElements] = [x2, y2];
    },

    arcTo : function arcToFn(x1, y1, x2, y2, radius)
    {
        if (radius < 0)
        {
            throw 'INDEX_SIZE_ERR';
        }

        var x0, y0;

        var currentSubPath = this.currentSubPath;
        var numCurrentSubPathElements = currentSubPath.length;
        if (numCurrentSubPathElements === 0)
        {
            currentSubPath[0] = this.transformPoint(x1, y1);
            numCurrentSubPathElements = 1;

            x0 = x1;
            y0 = y1;
        }
        else
        {
            var p0 = this.untransformPoint(currentSubPath[numCurrentSubPathElements - 1]);
            x0 = p0[0];
            y0 = p0[1];
        }

        var dx0 = (x0 - x1);
        var dy0 = (y0 - y1);
        var ln0 = ((dx0 * dx0) + (dy0 * dy0));

        var dx2 = (x2 - x1);
        var dy2 = (y2 - y1);
        var ln2 = ((dx2 * dx2) + (dy2 * dy2));

        if (radius < 2 ||
            ln0 < 2 ||
            ln2 < 2)
        {
            currentSubPath.push(this.transformPoint(x1, y1));
        }
        else
        {
            var sqrt = Math.sqrt;
            var acos = Math.acos;
            var pi = Math.PI;

            ln0 = 1.0 / sqrt(ln0);
            dx0 *= ln0;
            dy0 *= ln0;

            ln2 = 1.0 / sqrt(ln2);
            dx2 *= ln2;
            dy2 *= ln2;

            // Calculate unit vector from x1 to center
            var dxc = (dx0 + dx2);
            var dyc = (dy0 + dy2);
            var lnc = (1.0 / sqrt((dxc * dxc) + (dyc * dyc)));
            dxc *= lnc;
            dyc *= lnc;

            // Calculate angle from vector to center with the vector to x2 using dot product
            // Use it to calculate distance to center
            var dot = ((dxc * dx2) + (dyc * dy2));
            var h = (radius / dot); // dot = Math.cos(angle)

            var cp = this.transformPoint((x1 + (h * dxc)),
                                         (y1 + (h * dyc)));
            var cx = cp[0];
            var cy = cp[1];

            var anticlockwise = (((dx0 * dy2) - (dx2 * dy0)) > 0);

            var da = acos(-dxc);
            if (dyc < 0)
            {
                da = -da;
            }
            da = ((0.5 * pi) - da);

            var angle = acos(dot);
            var startAngle = (pi + angle + da);
            var endAngle = ((2 * pi) - angle + da);
            if (anticlockwise)
            {
                this.interpolateArc(cx, cy, radius, endAngle, startAngle, true);
            }
            else
            {
                this.interpolateArc(cx, cy, radius, startAngle, endAngle);
            }
        }
    },

    arc : function arcFn(x, y, radius, startAngle, endAngle, anticlockwise)
    {
        if (radius < 0)
        {
            throw 'INDEX_SIZE_ERR';
        }

        var cp = this.transformPoint(x, y);

        var currentSubPath = this.currentSubPath;

        if (radius < 2.0)
        {
            currentSubPath.push(cp);
        }
        else
        {
            this.interpolateArc(cp[0], cp[1], radius, startAngle, endAngle, anticlockwise);
        }
    },

    rect : function rectFn(x, y, w, h)
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        var currentSubPath = this.currentSubPath;
        if (currentSubPath.length > 1)
        {
            subPaths[numSubPaths] = currentSubPath;
            numSubPaths += 1;
        }

        var rect = this.transformRect(x, y, w, h, this.tempRect);
        var p0 = [rect[0], rect[1]];
        var p1 = [rect[2], rect[3]];
        var p2 = [rect[4], rect[5]];
        var p3 = [rect[6], rect[7]];

        subPaths[numSubPaths] = [p2, p3, p1, p0, p2];

        this.currentSubPath = [p0];
    },

    path : function pathFn(path)
    {
        var end = path.length;
        var currentCommand = -1, previousCommand = -1;
        var i = 0;

        function skipWhiteSpace()
        {
            var c = path.charCodeAt(i);
            while (c <= 32 || c === 44) // whitespace or ,
            {
                i += 1;
                if (i >= end)
                {
                    return -1;
                }
                c = path.charCodeAt(i);
            }
            return c;
        }

        function readNumber()
        {
            var c = path.charCodeAt(i);
            while (c <= 32 || c === 44) // whitespace or ,
            {
                i += 1;
                if (i >= end)
                {
                    throw "Reached end of string without required coordinate.";
                }
                c = path.charCodeAt(i);
            }

            var start = i;

            if (c === 45 || //-
                c === 43) //+
            {
                i += 1;
                if (i >= end)
                {
                    return 0;
                }
                c = path.charCodeAt(i);
            }

            while (c >= 48 && c <= 57) //0-9
            {
                i += 1;
                if (i >= end)
                {
                    break;
                }
                c = path.charCodeAt(i);
            }

            if (c === 46 || //.
                c === 101 || //e
                c === 101) //E
            {
                if (c === 46) //.
                {
                    do
                    {
                        i += 1;
                        if (i >= end)
                        {
                            break;
                        }
                        c = path.charCodeAt(i);
                    }
                    while (c >= 48 && c <= 57); //0-9
                }

                if (c === 101 || //e
                    c === 101) //E
                {
                    i += 1;
                    if (i < end)
                    {
                        c = path.charCodeAt(i);

                        if (c === 45 || //-
                            c === 43) //+
                        {
                            i += 1;
                            if (i < end)
                            {
                                c = path.charCodeAt(i);
                            }
                        }

                        while (c >= 48 && c <= 57) //0-9
                        {
                            i += 1;
                            if (i >= end)
                            {
                                break;
                            }
                            c = path.charCodeAt(i);
                        }
                    }
                }

                return parseFloat(path.slice(start, i));
            }
            else
            {
                return parseInt(path.slice(start, i), 10);
            }
        }

        function readFlag()
        {
            var c = skipWhiteSpace();
            if (c < -1)
            {
                throw "Reached end of string without required flag.";
            }

            if (c === 48) //0
            {
                i += 1;
                return false;
            }
            else if (c === 49) //1
            {
                i += 1;
                return true;
            }
            else
            {
                throw "Unknown flag: " + path.slice(i);
            }
        }

        function getRatio(u, v)
        {
            var u0 = u[0];
            var u1 = u[1];
            var v0 = v[0];
            var v1 = v[1];
            return ((u0 * v0) + (u1 * v1)) / Math.sqrt(((u0 * u0) + (u1 * u1)) * ((v0 * v0) + (v1 * v1)));
        }

        function getAngle(u, v)
        {
            return ((u[0] * v[1]) < (u[1] * v[0]) ? -1 : 1) * Math.acos(getRatio(u, v));
        }

        var lx = 0;
        var ly = 0;

        var x, y, x1, y1, x2, y2;
        var rx, ry, angle, largeArcFlag, sweepFlag;

        while (i < end)
        {
            // Skip whitespace
            var c = skipWhiteSpace();
            if (c < 0)
            {
                // end of string
                return;
            }

            // Same command, new arguments?
            if (c === 43 || //+
                c === 45 || //-
                c === 46 || //.
                (c >= 48 && c <= 57)) //0-9
            {
                if (currentCommand < 0)
                {
                    throw "Coordinates without a command: " + path.slice(i);
                }
                else
                {
                    // Implicit lineTo after moveTo?
                    if (currentCommand === 77) //M
                    {
                        currentCommand = 76; //L
                    }
                    else if (currentCommand === 109) //m
                    {
                        currentCommand = 108; //l
                    }
                }
            }
            else
            {
                previousCommand = currentCommand;
                currentCommand = c;
                i += 1;
            }

            switch (currentCommand)
            {
            case 77: //M
            case 109: //m
                x = readNumber();
                y = readNumber();
                if (currentCommand === 109) //m
                {
                    x += lx;
                    y += ly;
                }
                this.moveTo(x, y);
                break;

            case 76: //L
            case 108: //l
                x = readNumber();
                y = readNumber();
                if (currentCommand === 108) //l
                {
                    x += lx;
                    y += ly;
                }
                this.lineTo(x, y);
                break;

            case 72: //H
            case 104: //h
                x = readNumber();
                if (currentCommand === 104) //h
                {
                    x += lx;
                }
                y = ly;
                this.lineTo(x, y);
                break;

            case 86: //V
            case 118: //v
                x = lx;
                y = readNumber();
                if (currentCommand === 118) //v
                {
                    y += ly;
                }
                this.lineTo(x, y);
                break;

            case 67: //C
            case 99: //c
                x1 = readNumber();
                y1 = readNumber();
                x2 = readNumber();
                y2 = readNumber();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 99) //c
                {
                    x1 += lx;
                    y1 += ly;
                    x2 += lx;
                    y2 += ly;
                    x += lx;
                    y += ly;
                }
                this.bezierCurveTo(x1, y1, x2, y2, x, y);
                break;

            case 83: //S
            case 115: //s
                if (previousCommand === 67 || //C
                    previousCommand === 99 || //c
                    previousCommand === 83 || //S
                    previousCommand === 115) //s
                {
                    x1 = ((2 * lx) - x2);
                    y1 = ((2 * ly) - y2);
                }
                else
                {
                    x1 = lx;
                    y1 = ly;
                }
                x2 = readNumber();
                y2 = readNumber();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 115) //s
                {
                    x2 += lx;
                    y2 += ly;
                    x += lx;
                    y += ly;
                }
                this.bezierCurveTo(x1, y1, x2, y2, x, y);
                break;

            case 81: //Q
            case 113: //q
                x1 = readNumber();
                y1 = readNumber();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 113) //q
                {
                    x1 += lx;
                    y1 += ly;
                    x += lx;
                    y += ly;
                }
                this.quadraticCurveTo(x1, y1, x, y);
                break;

            case 84: //T
            case 116: //t
                if (previousCommand === 81 || //Q
                    previousCommand === 113 || //q
                    previousCommand === 84 || //T
                    previousCommand === 116) //t
                {
                    x1 = ((2 * lx) - x1);
                    y1 = ((2 * ly) - y1);
                }
                else
                {
                    x1 = lx;
                    y1 = ly;
                }
                x = readNumber();
                y = readNumber();
                if (currentCommand === 116) //t
                {
                    x += lx;
                    y += ly;
                }
                this.quadraticCurveTo(x1, y1, x, y);
                break;

            case 65: //A
            case 97: //a
                var pi = Math.PI;
                x1 = lx;
                y1 = ly;
                rx = readNumber();
                ry = readNumber();
                angle = (readNumber() * (pi / 180.0));
                largeArcFlag = readFlag();
                sweepFlag = readFlag();
                x = readNumber();
                y = readNumber();
                if (currentCommand === 97) //a
                {
                    x += lx;
                    y += ly;
                }

                var sqrt = Math.sqrt;
                var ca = Math.cos(angle);
                var sa = Math.sin(angle);

                var hdx = (x1 - x) * 0.5;
                var hdy = (y1 - y) * 0.5;
                var x1b = ca * hdx + sa * hdy;
                var x1b2 = (x1b * x1b);
                var y1b = -sa * hdx + ca * hdy;
                var y1b2 = (y1b * y1b);

                // adjust radii
                var l = x1b2 / (rx * rx) + y1b2 / (ry * ry);
                if (l > 1)
                {
                    var lsq = sqrt(l);
                    rx *= lsq;
                    ry *= lsq;
                }

                var rx2 = (rx * rx);
                var invrx = (1 / rx);
                var ry2 = (ry * ry);
                var invry = (1 / ry);

                // cx', cy'
                var s = (largeArcFlag === sweepFlag ? -1 : 1) * sqrt(
                        ((rx2 * ry2) - (rx2 * y1b2) - (ry2 * x1b2)) / (rx2 * y1b2 + ry2 * x1b2));
                if (isNaN(s))
                {
                    s = 0;
                }
                var cxb = s * rx * y1b * invry;
                var cyb = s * -ry * x1b * invrx;

                var cx = (x1 + x) * 0.5 + ca * cxb - sa * cyb;
                var cy = (y1 + y) * 0.5 + sa * cxb + ca * cyb;

                var u = [(x1b - cxb) * invrx, (y1b - cyb) * invry];
                var v = [(-x1b - cxb) * invrx, (-y1b - cyb) * invry];

                // initial angle
                var a1 = getAngle([1, 0], u);

                // angle delta
                var ad;
                var ratio = getRatio(u, v);
                if (ratio <= -1)
                {
                    ad = pi;
                }
                else if (ratio >= 1)
                {
                    ad = 0;
                }
                else
                {
                    ad = getAngle(u, v);
                }

                if (!sweepFlag)
                {
                    if (ad > 0)
                    {
                        ad = ad - (2 * pi);
                    }
                }
                else //if (sweepFlag)
                {
                    if (ad < 0)
                    {
                        ad = ad + (2 * pi);
                    }
                }

                var radius, sx, sy;
                if (rx === ry)
                {
                    radius = rx;
                    sx = 1;
                    sy = 1;
                }
                else if (rx > ry)
                {
                    radius = rx;
                    sx = 1;
                    sy = ry * invrx;
                }
                else //if (rx < ry)
                {
                    radius = ry;
                    sx = rx * invry;
                    sy = 1;
                }

                if (angle !== 0 || sx !== 1 || sy !== 1)
                {
                    this.translate(cx, cy);
                    if (angle !== 0)
                    {
                        this.rotate(angle);
                    }
                    if (sx !== 1 || sy !== 1)
                    {
                        this.scale(sx, sy);
                    }

                    this.arc(0, 0, radius, a1, (a1 + ad), (true - sweepFlag));

                    if (sx !== 1 || sy !== 1)
                    {
                        this.scale((1 / sx), (1 / sy));
                    }
                    if (angle !== 0)
                    {
                        this.rotate(-angle);
                    }
                    this.translate(-cx, -cy);
                }
                else
                {
                    this.arc(cx, cy, radius, a1, (a1 + ad), (true - sweepFlag));
                }
                break;

            case 90: //Z
            case 122: //z
                var firstPoint = this.currentSubPath[0];
                x = firstPoint[0];
                y = firstPoint[1];
                this.closePath();
                break;

            default:
                throw "Unknown command: " + path.slice(i);
            }

            lx = x;
            ly = y;
        }
    },

    fill : function fillFn()
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        var currentSubPath = this.currentSubPath;
        if (numSubPaths > 0 ||
            currentSubPath.length > 2)
        {
            var autoClose = this.autoClose;
            var isConvex = this.isConvex;
            var points, numPoints, numSegments;

            var style = this.fillStyle;

            var primitive;
            var vertices;
            var numVertices = 0;

            if (numSubPaths > 1 ||
                (numSubPaths === 1 &&
                 currentSubPath.length > 2))
            {
                primitive = this.trianglePrimitive;
                vertices = this.tempVertices;

                for (var i = 0; i < numSubPaths; i += 1)
                {
                    points = subPaths[i];
                    numPoints = points.length;
                    if (numPoints > 2)
                    {
                        numPoints = autoClose(points, numPoints);
                        numSegments = (numPoints - 1);
                        if (isConvex(points, numSegments))
                        {
                            numVertices = this.triangulateConvex(points, numSegments, vertices, numVertices);
                        }
                        else
                        {
                            numVertices = this.triangulateConcave(points, numSegments, vertices, numVertices);
                        }
                    }
                }

                points = currentSubPath;
                numPoints = points.length;
                if (numPoints > 2)
                {
                    numPoints = autoClose(points, numPoints);
                    numSegments = (numPoints - 1);
                    if (isConvex(points, numSegments))
                    {
                        numVertices = this.triangulateConvex(points, numSegments, vertices, numVertices);
                    }
                    else
                    {
                        numVertices = this.triangulateConcave(points, numSegments, vertices, numVertices);
                    }
                }
            }
            else
            {
                if (numSubPaths > 0)
                {
                    points = subPaths[0];
                }
                else
                {
                    points = currentSubPath;
                }

                numPoints = points.length;
                if (numPoints > 2)
                {
                    numPoints = autoClose(points, numPoints);
                    numSegments = (numPoints - 1);

                    if (isConvex(points, numSegments))
                    {
                        primitive = this.triangleFanPrimitive;
                        vertices = points;
                        numVertices = numSegments;
                    }
                    else
                    {
                        primitive = this.trianglePrimitive;
                        vertices = this.tempVertices;
                        numVertices = this.triangulateConcave(points, numSegments, vertices, 0);
                    }
                }
            }

            if (numVertices > 0)
            {
                this.fillFlatVertices(vertices, numVertices);

                var gd = this.gd;

                if (this.setShadowStyle(style))
                {
                    gd.draw(primitive, numVertices);
                }

                this.setStyle(style);

                gd.draw(primitive, numVertices);
            }
        }
    },

    stroke : function strokeFn()
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        var currentSubPath = this.currentSubPath;
        if (numSubPaths > 0 ||
            currentSubPath.length > 0)
        {
            var gd = this.gd;
            var style = this.strokeStyle;
            var lineWidth = this.lineWidth;
            var thinLines = (lineWidth < 2 && !this.forceFatLines);

            var points, numPoints, primitive, numVertices;

            for (var i = 0; i < numSubPaths; i += 1)
            {
                points = subPaths[i];
                numPoints = points.length;
                if (thinLines)
                {
                    primitive = this.lineStripPrimitive;
                    numVertices = numPoints;
                    this.fillFlatVertices(points, numPoints);
                }
                else if (numPoints > 1)
                {
                    primitive = this.triangleStripPrimitive;
                    numVertices = this.fillFatStrip(points, numPoints, lineWidth);
                }
                else
                {
                    continue;
                }

                if (this.setShadowStyle(style))
                {
                    gd.draw(primitive, numVertices);
                }

                this.setStyle(style);

                gd.draw(primitive, numVertices);
            }

            points = currentSubPath;
            numPoints = points.length;
            if (numPoints > 0)
            {
                if (thinLines)
                {
                    primitive = this.lineStripPrimitive;
                    numVertices = numPoints;
                    this.fillFlatVertices(points, numPoints);
                }
                else if (numPoints > 1)
                {
                    primitive = this.triangleStripPrimitive;
                    numVertices = this.fillFatStrip(points, numPoints, lineWidth);
                }
                else
                {
                    return;
                }

                if (this.setShadowStyle(style))
                {
                    gd.draw(primitive, numVertices);
                }

                this.setStyle(style);

                gd.draw(primitive, numVertices);
            }
        }
    },


    drawSystemFocusRing : function drawSystemFocusRingFn(element)
    {
        // TODO
    },

    drawCustomFocusRing : function drawCustomFocusRingFn(element)
    {
        // TODO
        return false;
    },

    scrollPathIntoView : function scrollPathIntoViewFn()
    {
        // TODO
    },

    clip : function clipFn()
    {
        // Get copy of sub paths
        var points, numPoints, i, j, point, x, y;
        var numClipSubPaths = 0;
        var clipSubPaths = [];

        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        if (numSubPaths > 0)
        {
            clipSubPaths.length = numSubPaths;
            i = 0;
            do
            {
                points = subPaths[i];
                if (points.length > 2)
                {
                    clipSubPaths[numClipSubPaths] = points.slice();
                    numClipSubPaths += 1;
                }

                i += 1;
            }
            while (i < numSubPaths);
        }

        var currentSubPath = this.currentSubPath;
        if (currentSubPath.length > 2)
        {
            clipSubPaths[numClipSubPaths] = currentSubPath.slice();
            numClipSubPaths += 1;
        }

        if (numClipSubPaths === 0)
        {
            return;
        }

        var autoClose = this.autoClose;

        // Calculate bounding box of current path
        var minX, minY, maxX, maxY;
        i = 0;
        do
        {
            points = clipSubPaths[i];
            numPoints = autoClose(points, points.length);

            j = 0;

            if (minX === undefined)
            {
                point = points[0];
                minX = maxX = point[0];
                minY = maxY = point[1];
                j = 1;
            }

            do
            {
                point = points[j];
                x = point[0];
                y = point[1];

                if (minX > x)
                {
                    minX = x;
                }
                else if (maxX < x)
                {
                    maxX = x;
                }

                if (minY > y)
                {
                    minY = y;
                }
                else if (maxY < y)
                {
                    maxY = y;
                }

                j += 1;
            }
            while (j < numPoints);

            i += 1;
        }
        while (i < numClipSubPaths);

        // Intersect current clipExtents with bounding boxes of current paths
        var clipExtents = this.clipExtents;
        var minClipX = clipExtents[0];
        var minClipY = clipExtents[1];
        var maxClipX = clipExtents[2];
        var maxClipY = clipExtents[3];
        minClipX = (minClipX > minX ? minClipX : minX);
        minClipY = (minClipY > minY ? minClipY : minY);
        maxClipX = (maxClipX < maxX ? maxClipX : maxX);
        maxClipY = (maxClipY < maxY ? maxClipY : maxY);
        clipExtents[0] = minClipX;
        clipExtents[1] = minClipY;
        clipExtents[2] = maxClipX;
        clipExtents[3] = maxClipY;

        // Update scissor rectangle to at least have rectangular clipping
        this.updateScissor();

        // TODO: non rectangular clipping
    },

    isPointInPath : function isPointInPathFn(x, y)
    {
        var subPaths = this.subPaths;
        var numSubPaths = subPaths.length;
        if (numSubPaths > 0)
        {
            for (var i = 0; i < numSubPaths; i += 1)
            {
                if (this.isPointInSubPath(x, y, subPaths[i]))
                {
                    return true;
                }
            }
        }

        var currentSubPath = this.currentSubPath;
        if (this.isPointInSubPath(x, y, currentSubPath))
        {
            return true;
        }

        return false;
    },


    fillText : function fillTextFn(text, x, y, maxWidth)
    {
        if (maxWidth !== undefined && maxWidth <= 0)
        {
            return;
        }

        var fm = this.fm;
        if (!fm)
        {
            return;
        }

        var fontName = this.buildFontName();
        if (!fontName)
        {
            return;
        }

        var font = fm.load(fontName);
        if (!font)
        {
            return;
        }

        if (!maxWidth)
        {
            maxWidth = this.width;
        }

        var color;

        var style = this.fillStyle;
        if (typeof style === 'string') // CSS Color
        {
            color = this.parseColor(style);
        }
        else
        {
            // TODO
            color = this.v4One;
        }

        // No need to pre-multiply RGB by alpha for texture shaders
        var globalAlpha = this.globalAlpha;
        if (globalAlpha < 1.0)
        {
            color = this.md.v4Build(color[0], color[1], color[2], (color[3] * globalAlpha), this.tempColor);
        }

        var technique = this.textureTechniques[this.globalCompositeOperation];
        if (!technique)
        {
            throw "Unknown composite operation: " + this.globalCompositeOperation;
        }

        var gd = this.gd;

        gd.setTechnique(technique);

        technique.color = color;

        var rect = this.transformRect(x, y, maxWidth, maxWidth, this.tempRect);
        x = rect[4];
        y = rect[5];
        var w = (rect[2] - x);
        var h = (rect[3] - y);

        var scale = this.calculateFontScale(font);

        if (this.textBaseline === 'alphabetic')
        {
            y -= (font.baseline * scale);
        }
        else if (this.textBaseline === 'middle')
        {
            y -= ((font.baseline * 0.5) * scale);
        }
        else if (this.textBaseline === 'bottom' ||
                 this.textBaseline === 'ideographic')
        {
            y -= (font.lineHeight * scale);
        }

        var params = {
            rect : [x, y, w, h],
            scale : scale,
            spacing : 0
        };

        if (this.textAlign === "left" ||
            this.textAlign === "start")
        {
            params.alignment = 0;
        }
        else if (this.textAlign === "right" ||
                 this.textAlign === "end")
        {
            params.alignment = 2;
        }
        else
        {
            params.alignment = 1;
        }

        font.drawTextRect(text, params);
    },

    strokeText : function strokeTextFn(text, x, y, maxWidth)
    {
        // TODO
    },

    measureText : function measureTextFn(text)
    {
        var fm = this.fm;
        if (fm)
        {
            var fontName = this.buildFontName();
            if (fontName)
            {
                var font = fm.load(fontName);
                if (font)
                {
                    var scale = this.calculateFontScale(font);
                    return {
                            width : font.calculateTextDimensions(text, scale, 0).width
                        };
                }
            }
        }

        return {
                width : 0
            };
    },


    drawImage : function drawImageFn(image)
    {
        var dx, dy, dw, dh, u0, v0, u1, v1;

        if (arguments.length >= 7)
        {
            var sx = arguments[1];
            var sy = arguments[2];
            var sw = arguments[3];
            var sh = arguments[4];

            dx = arguments[5];
            dy = arguments[6];

            if (arguments.length >= 9)
            {
                dw = arguments[7];
                dh = arguments[8];
            }
            else
            {
                dw = sw;
                dh = sh;
            }

            var invImageWidth  = (1.0 / image.width);
            var invImageHeight = (1.0 / image.height);
            u0 = (sx * invImageWidth);
            v0 = (sy * invImageHeight);
            u1 = ((sx + sw) * invImageWidth);
            v1 = ((sy + sh) * invImageHeight);
        }
        else
        {
            dx = arguments[1];
            dy = arguments[2];

            if (arguments.length >= 5)
            {
                dw = arguments[3];
                dh = arguments[4];
            }
            else
            {
                dw = image.width;
                dh = image.height;
            }

            u0 = 0;
            v0 = 0;
            u1 = 1;
            v1 = 1;
        }

        if (dw > 0 && dh > 0)
        {
            var bufferData = this.getTextureBuffer(4);
            if (bufferData)
            {
                var rect = this.transformRect(dx, dy, dw, dh, this.tempRect);

                bufferData[0] = rect[0];
                bufferData[1] = rect[1];
                bufferData[2] = u0;
                bufferData[3] = v1;
                bufferData[4] = rect[2];
                bufferData[5] = rect[3];
                bufferData[6] = u1;
                bufferData[7] = v1;
                bufferData[8] = rect[4];
                bufferData[9] = rect[5];
                bufferData[10] = u0;
                bufferData[11] = v0;
                bufferData[12] = rect[6];
                bufferData[13] = rect[7];
                bufferData[14] = u1;
                bufferData[15] = v0;

                this.fillTextureBuffer(bufferData, 4);

                var primitive = this.triangleStripPrimitive;
                var gd = this.gd;

                if (this.setShadowStyle(image, true))
                {
                    gd.draw(primitive, 4);
                }

                var technique = this.textureTechniques[this.globalCompositeOperation];
                if (!technique)
                {
                    throw "Unknown composite operation: " + this.globalCompositeOperation;
                }

                gd.setTechnique(technique);

                technique.texture = image;

                var globalAlpha = this.globalAlpha;
                if (globalAlpha < 1.0)
                {
                    technique.color = this.md.v4Build(1.0, 1.0, 1.0, globalAlpha, this.tempColor);
                }
                else
                {
                    technique.color = this.v4One;
                }

                gd.draw(primitive, 4);
            }
        }
    },


    createImageData : function createImageDataFn()
    {
        var sw, sh;
        if (arguments.length === 2)
        {
            sw = arguments[0];
            sh = arguments[1];
        }
        else if (arguments.length === 1)
        {
            var imagedata = arguments[0];
            sw = imagedata.width;
            sh = imagedata.height;
        }
        else
        {
            throw "Wrong arguments";
        }

        var numValues = (sw * sh * 4);
        var pixelData = new Array(numValues);
        for (var i = 0; i < numValues; i += 1)
        {
            pixelData[i] = 0;
        }

        return {
            width : sw,
            height : sh,
            data : pixelData
        };
    },

    getImageData : function getImageDataFn(sx, sy, sw, sh)
    {
        var gd = this.gd;

        // Convert from top-left to bottom-left
        sy = (this.height - (sy + sh));

        var pixelData = gd.getScreenshot(false, sx, sy, sw, sh);

        return {
            width : sw,
            height : sh,
            data : pixelData
        };
    },

    putImageData : function putImageDataFn(imagedata, dx, dy)
    {
        if (!imagedata || !imagedata.data)
        {
            throw 'TYPE_MISMATCH_ERR';
        }

        var imageWidth  = imagedata.width;
        var imageHeight = imagedata.height;

        var dirtyX, dirtyY, dirtyWidth, dirtyHeight;
        if (arguments.length >= 7)
        {
            dirtyX = arguments[3];
            dirtyY = arguments[4];
            dirtyWidth = arguments[5];
            dirtyHeight = arguments[6];
        }
        else
        {
            dirtyX = 0;
            dirtyY = 0;
            dirtyWidth = imageWidth;
            dirtyHeight = imageHeight;
        }

        if (dirtyWidth && dirtyHeight)
        {
            var gd = this.gd;

            var tempImage = this.tempImage;
            if (tempImage === null ||
                tempImage.width !== dirtyWidth ||
                tempImage.height !== dirtyHeight)
            {
                this.tempImage = tempImage = gd.createTexture({
                        name    : ('imageData:' + dirtyWidth + 'x' + dirtyHeight),
                        width   : dirtyWidth,
                        height  : dirtyHeight,
                        depth   : 1,
                        format  : gd.PIXELFORMAT_R8G8B8A8,
                        cubemap : false,
                        mipmaps : false
                    });
            }

            tempImage.setData(imagedata.data);

            var viewport = this.viewport;
            gd.setScissor(viewport[0], viewport[1], viewport[2], viewport[3]);

            var bufferData = this.getTextureBuffer(4);
            if (bufferData)
            {
                var invCanvasWidth  = 2.0 / this.width;
                var invCanvasHeight = 2.0 / this.height;
                var x0 = ((dx * invCanvasWidth)  - 1);
                var y0 = (1 - (dy * invCanvasHeight));
                var x1 = (((dx + dirtyWidth)  * invCanvasWidth)  - 1);
                var y1 = (1 - ((dy + dirtyHeight) * invCanvasHeight));

                var invImageWidth  = 1.0 / imageWidth;
                var invImageHeight = 1.0 / imageHeight;
                var u0 = (dirtyX * invImageWidth);
                var v0 = (dirtyY * invImageHeight);
                var u1 = ((dirtyX + dirtyWidth)  * invImageWidth);
                var v1 = ((dirtyY + dirtyHeight) * invImageHeight);

                bufferData[0] = x0;
                bufferData[1] = y1;
                bufferData[2] = u0;
                bufferData[3] = v1;
                bufferData[4] = x1;
                bufferData[5] = y1;
                bufferData[6] = u1;
                bufferData[7] = v1;
                bufferData[8] = x0;
                bufferData[9] = y0;
                bufferData[10] = u0;
                bufferData[11] = v0;
                bufferData[12] = x1;
                bufferData[13] = y0;
                bufferData[14] = u1;
                bufferData[15] = v0;

                this.fillTextureBuffer(bufferData, 4);

                var technique = this.imageTechnique;

                gd.setTechnique(technique);

                technique.image = tempImage;

                gd.draw(this.triangleStripPrimitive, 4);
            }

            this.updateScissor();
        }
    },

    //
    // Public Turbulenz Canvas Context API
    //
    beginFrame : function beginFrameFn(target, viewportRect)
    {
        if (this.target)
        {
            throw '"endFrame" was never called!';
        }

        var gd = this.gd;

        if (!target)
        {
            target = gd;
        }

        this.target = target;

        var viewport = this.viewport;

        if (viewportRect)
        {
            viewport[0] =  viewportRect[0];
            viewport[1] =  viewportRect[1];
            viewport[2] =  viewportRect[2];
            viewport[3] =  viewportRect[3];
        }
        else
        {
            viewport[0] =  0;
            viewport[1] =  0;
            viewport[2] =  target.width;
            viewport[3] =  target.height;
        }

        gd.setViewport(viewport[0], viewport[1], viewport[2], viewport[3]);

        /* This code is required if Object.defineProperty does not work */
        var canvas = this.canvas;
        var width = canvas.width;
        var height = canvas.height;
        if (width !== this.width ||
            height !== this.height)
        {
            this.width = width;
            this.height = height;

            this.screen[0] = (2 / width);
            this.screen[1] = (-2 / height);

            this.resetState();

            this.clearRect(0, 0, width, height);
        }

        this.forceFatLines = ((2 * width) <= viewport[2] ||
                              (2 * height) <= viewport[3]);

        this.updateScissor();

        return true;
    },

    endFrame : function endFrameFn()
    {
        if (!this.target)
        {
            throw '"beginFrame" was never called!';
        }

        this.target = null;

        var viewport = this.viewport;
        var v0 = viewport[0];
        var v1 = viewport[1];
        var v2 = viewport[2];
        var v3 = viewport[3];

        var gd = this.gd;

        gd.setViewport(v0, v1, v2, v3);
        gd.setScissor(v0, v1, v2, v3);
    },

    //
    // Private API
    //
    setWidth : function setWidthFn(width)
    {
        this.width = width;
        this.screen[0] = (2 / width);

        this.resetState();

        if (this.target)
        {
            this.clearRect(0, 0, width, this.height);
        }
    },

    setHeight : function setHeightFn(height)
    {
        this.height = height;
        this.screen[1] = (-2 / height);

        this.resetState();

        if (this.target)
        {
            this.clearRect(0, 0, this.width, height);
        }
    },

    createStatesObject : function createStatesObjectFn()
    {
        return {
            globalAlpha : 0.0,
            globalCompositeOperation : null,
            strokeStyle : null,
            fillStyle : null,
            lineWidth : 0.0,
            lineCap : null,
            lineJoin : null,
            miterLimit : 0,
            shadowOffsetX : 0,
            shadowOffsetY : 0,
            shadowBlur : 0,
            shadowColor : null,
            font : null,
            textAlign : null,
            textBaseline : null,
            matrix : new this.arrayConstructor(6),
            scale : null,
            translate : null,
            transform : null,
            setTransform : null,
            transformPoint : null,
            transformRect : null,
            clipExtents : new this.arrayConstructor(4)
        };
    },

    setStates : function setStatesFn(dest, src)
    {
        dest.globalAlpha = src.globalAlpha;
        dest.globalCompositeOperation = src.globalCompositeOperation;
        dest.strokeStyle = src.strokeStyle;
        dest.fillStyle = src.fillStyle;
        dest.lineWidth = src.lineWidth;
        dest.lineCap = src.lineCap;
        dest.lineJoin = src.lineJoin;
        dest.miterLimit = src.miterLimit;
        dest.shadowOffsetX = src.shadowOffsetX;
        dest.shadowOffsetY = src.shadowOffsetY;
        dest.shadowBlur = src.shadowBlur;
        dest.shadowColor = src.shadowColor;
        dest.font = src.font;
        dest.textAlign = src.textAlign;
        dest.textBaseline = src.textBaseline;

        // Have to copy array elements because if we keep a reference we modify the default ones
        var destMatrix = dest.matrix;
        var srcMatrix = src.matrix;
        destMatrix[0] = srcMatrix[0];
        destMatrix[1] = srcMatrix[1];
        destMatrix[2] = srcMatrix[2];
        destMatrix[3] = srcMatrix[3];
        destMatrix[4] = srcMatrix[4];
        destMatrix[5] = srcMatrix[5];

        dest.scale = src.scale;
        dest.translate = src.translate;
        dest.transform = src.transform;
        dest.setTransform = src.setTransform;
        dest.transformPoint = src.transformPoint;
        dest.transformRect = src.transformRect;

        var destExtents = dest.clipExtents;
        var srcExtents = src.clipExtents;
        destExtents[0] = srcExtents[0];
        destExtents[1] = srcExtents[1];
        destExtents[2] = srcExtents[2];
        destExtents[3] = srcExtents[3];

        return dest;
    },

    resetState : function resetStateFn()
    {
        this.numStatesInStack = 0;

        this.beginPath();

        this.setStates(this, this.defaultStates);

        var clipExtents = this.clipExtents;
        clipExtents[0] = 0;
        clipExtents[1] = 0;
        clipExtents[2] = this.width;
        clipExtents[3] = this.height;

        this.resetTechniqueParameters();
    },

    resetTechniqueParameters : function resetTechniqueParametersFn()
    {
        // The screen value of texture techniques is updated here
        var screen = this.screen;
        var textureTechniques = this.textureTechniques;
        for (var p in textureTechniques)
        {
            if (textureTechniques.hasOwnProperty(p))
            {
                textureTechniques[p].screen = screen;
            }
        }
    },

    updateScissor : function updateScissorFn()
    {
        // Set scissor rectangle to intersection of viewport with clipExtents,
        // in OpengGL screen coordinates (0, 0) at bottom
        var viewport = this.viewport;
        var viewportX = viewport[0];
        var viewportY = viewport[1];
        var viewportWidth = viewport[2];
        var viewportHeight = viewport[3];

        var deviceScaleX = (viewportWidth / this.width);
        var deviceScaleY = (viewportHeight / this.height);

        var clipExtents = this.clipExtents;
        var minClipX = (clipExtents[0] * deviceScaleX);
        var minClipY = (clipExtents[1] * deviceScaleY);
        var maxClipX = (clipExtents[2] * deviceScaleX);
        var maxClipY = (clipExtents[3] * deviceScaleY);

        this.gd.setScissor((viewportX + minClipX),
                           (viewportY + (viewportHeight - maxClipY)),
                           (maxClipX - minClipX),
                           (maxClipY - minClipY));
    },


    setFontManager : function setFontManagerFn(fm)
    {
        this.fm = fm;
    },

    buildFontName : function buildFontNameFn()
    {
        var fontName;
        var font = this.font;
        var lastSpace = font.lastIndexOf(" ");
        if (lastSpace !== -1)
        {
            fontName = ('fonts/' + font.substr(lastSpace + 1) + '.fnt');
        }
        return fontName;
    },

    calculateFontScale : function calculateFontScaleFn(font)
    {
        var requiredHeight = parseInt(this.font, 10);
        if (isNaN(requiredHeight))
        {
            return 1;
        }
        else
        {
            return (requiredHeight / font.lineHeight);
        }
    },

    transformPoint : function transformPointFn(x, y)
    {
        var m = this.matrix;
        return [((x * m[0]) + (y * m[1]) + m[2]),
                ((x * m[3]) + (y * m[4]) + m[5])];
    },

    transformRect : function transformRectFn(x, y, w, h, rect)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        var bx = ((x * m0) + (y * m1) + m2);
        var by = ((x * m3) + (y * m4) + m5);
        var dx0 = (w * m0);
        var dy0 = (h * m1);
        var dx1 = (w * m3);
        var dy1 = (h * m4);

        rect[0] = (bx + dy0);
        rect[1] = (by + dy1);
        rect[2] = (bx + dx0 + dy0);
        rect[3] = (by + dx1 + dy1);
        rect[4] = bx;
        rect[5] = by;
        rect[6] = (bx + dx0);
        rect[7] = (by + dx1);

        return rect;
    },

    untransformPoint : function untransformPointFn(p)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        var x = p[0];
        var y = p[1];

        // invert matrix
        var r0, r1, r2, r3, r4, r5;

        var det = (m0 * m4 - m1 * m3);
        if (det === 0.0)
        {
            return [x, y];
        }

        r0 = m4;
        r3 = -m3;
        r1 = -m1;
        r4 = m0;
        r2 = (m1 * m5 - m4 * m2);
        r5 = (m2 * m3 - m0 * m5);

        if (det !== 1.0)
        {
            var detrecp = (1.0 / det);
            r0 *= detrecp;
            r3 *= detrecp;
            r1 *= detrecp;
            r4 *= detrecp;
            r2 *= detrecp;
            r5 *= detrecp;
        }

        return [((x * r0) + (y * r1) + r2),
                ((x * r3) + (y * r4) + r5)];
    },

    calculateGradientUVtransform : function calculateGradientUVtransformFn(gradientMatrix)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        var g0 = gradientMatrix[0];
        var g1 = gradientMatrix[1];
        var g2 = gradientMatrix[2];
        var g3 = gradientMatrix[3];
        var g4 = gradientMatrix[4];
        var g5 = gradientMatrix[5];

        // invert matrix
        var r0, r1, r2, r3, r4, r5;

        var det = (m0 * m4 - m1 * m3);
        if (det === 0.0)
        {
            r0 = 1.0;
            r3 = 0.0;
            r1 = 0.0;
            r4 = 1.0;
            r2 = 0.0;
            r5 = 0.0;
        }
        else
        {
            r0 = m4;
            r3 = -m3;
            r1 = -m1;
            r4 = m0;
            r2 = (m1 * m5 - m4 * m2);
            r5 = (m2 * m3 - m0 * m5);

            if (det !== 1.0)
            {
                var detrecp = (1.0 / det);
                r0 *= detrecp;
                r3 *= detrecp;
                r1 *= detrecp;
                r4 *= detrecp;
                r2 *= detrecp;
                r5 *= detrecp;
            }
        }

        var uvtransform = this.uvtransform;
        uvtransform[0] = (g0 * r0 + g1 * r3);
        uvtransform[1] = (g0 * r1 + g1 * r4);
        uvtransform[2] = (g0 * r2 + g1 * r5 + g2);
        uvtransform[3] = (g3 * r0 + g4 * r3);
        uvtransform[4] = (g3 * r1 + g4 * r4);
        uvtransform[5] = (g3 * r2 + g4 * r5 + g5);
        return uvtransform;
    },

    calculatePatternUVtransform : function calculatePatternUVtransformFn(imageWidth, imageHeight)
    {
        var m = this.matrix;
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];

        var invWidth = (1.0 / imageWidth);
        var invHeight = (1.0 / imageHeight);

        // invert matrix
        var r0, r1, r2, r3, r4, r5;

        var det = (m0 * m4 - m1 * m3);
        if (det === 0.0)
        {
            r0 = 1.0;
            r3 = 0.0;
            r1 = 0.0;
            r4 = 1.0;
            r2 = 0.0;
            r5 = 0.0;
        }
        else
        {
            r0 = m4;
            r3 = -m3;
            r1 = -m1;
            r4 = m0;
            r2 = (m1 * m5 - m4 * m2);
            r5 = (m2 * m3 - m0 * m5);

            if (det !== 1.0)
            {
                var detrecp = (1.0 / det);
                r0 *= detrecp;
                r3 *= detrecp;
                r1 *= detrecp;
                r4 *= detrecp;
                r2 *= detrecp;
                r5 *= detrecp;
            }
        }

        var uvtransform = this.uvtransform;
        uvtransform[0] = (invWidth * r0);
        uvtransform[1] = (invWidth * r1);
        uvtransform[2] = (invWidth * r2);
        uvtransform[3] = (invHeight * r3);
        uvtransform[4] = (invHeight * r4);
        uvtransform[5] = (invHeight * r5);
        return uvtransform;
    },


    setShadowStyle : function setShadowStyleFn(style, onlyTexture)
    {
        var shadowOffsetX = this.shadowOffsetX;
        var shadowOffsetY = this.shadowOffsetY;
        if (shadowOffsetX < 1 && shadowOffsetY < 1)
        {
            return false;
        }

        if (this.globalCompositeOperation !== 'source-over')
        {
            return false;
        }

        var color = this.parseColor(this.shadowColor);

        var alpha = (color[3] * this.globalAlpha);

        if (this.shadowBlur > 0)
        {
            alpha *= 0.5;
        }

        if (alpha < 0.004)
        {
            return false;
        }

        if (alpha < 1.0)
        {
            color = this.md.v4Build((color[0] * alpha),
                                    (color[1] * alpha),
                                    (color[2] * alpha),
                                    alpha,
                                    this.tempColor);
        }

        var screen = this.screen;
        var screenScaleX = screen[0];
        var screenScaleY = screen[1];
        screen = this.md.v4Build(screenScaleX, screenScaleY,
                                (screen[2] + (shadowOffsetX * screenScaleX)),
                                (screen[3] + (shadowOffsetY * screenScaleY)),
                                this.tempScreen);

        var gd = this.gd;

        var technique;

        if (typeof style !== 'string' &&
            !style.opaque)
        {
            if (onlyTexture) // drawImage
            {
                technique = this.textureShadowTechnique;

                gd.setTechnique(technique);

                technique.texture = style;
            }
            else if (style.stops) // Gradient
            {
                var texture = style.updateTexture(gd);
                var gradientWidth = texture.width;
                var gradientHeight = texture.height;

                if (!gradientWidth || !gradientHeight)
                {
                    throw 'INVALID_STATE_ERR';
                }

                technique = this.gradientShadowTechnique;

                gd.setTechnique(technique);

                technique.uvtransform = this.calculateGradientUVtransform(style.matrix);
                technique.gradient = texture;
            }
            else // Pattern
            {
                var imageWidth = style.width;
                var imageHeight = style.height;

                if (!imageWidth || !imageHeight)
                {
                    throw 'INVALID_STATE_ERR';
                }

                technique = this.patternShadowTechnique;

                gd.setTechnique(technique);

                technique.uvtransform = this.calculatePatternUVtransform(imageWidth, imageHeight);
                technique.pattern = style;
            }
        }
        else
        {
            if (alpha < 1.0)
            {
                technique = this.flatTechniques['source-over'];
            }
            else
            {
                technique = this.flatTechniques.copy;
            }

            gd.setTechnique(technique);
        }

        technique.screen = screen;

        technique.color = color;

        return true;
    },


    setStyle : function setStyleFn(style)
    {
        if (!style)
        {
            throw 'INVALID_STATE_ERR';
        }

        var globalCompositeOperation = this.globalCompositeOperation;
        var screen = this.screen;
        var gd = this.gd;

        var technique;

        if (typeof style === 'string') // CSS Color
        {
            var color = this.parseColor(style);

            var alpha = (color[3] * this.globalAlpha);
            if (alpha < 1.0)
            {
                color = this.md.v4Build((color[0] * alpha),
                                        (color[1] * alpha),
                                        (color[2] * alpha),
                                        alpha,
                                        this.tempColor);
            }

            if (globalCompositeOperation !== 'source-over' ||
                alpha < 1.0)
            {
                technique = this.flatTechniques[globalCompositeOperation];
                if (!technique)
                {
                    throw "Unknown composite operation: " + globalCompositeOperation;
                }
            }
            else
            {
                technique = this.flatTechniques.copy;
            }

            gd.setTechnique(technique);

            technique.screen = screen;

            technique.color = color;
        }
        else if (style.stops) // Gradient
        {
            var texture = style.updateTexture(gd);
            var gradientWidth = texture.width;
            var gradientHeight = texture.height;

            if (!gradientWidth || !gradientHeight)
            {
                throw 'INVALID_STATE_ERR';
            }

            var globalAlpha = this.globalAlpha;
            if (globalCompositeOperation !== 'source-over' ||
                globalAlpha < 1.0 ||
                !style.opaque)
            {
                technique = this.gradientTechniques[globalCompositeOperation];
                if (!technique)
                {
                    throw "Unknown composite operation: " + globalCompositeOperation;
                }
            }
            else
            {
                technique = this.gradientTechniques.copy;
            }

            gd.setTechnique(technique);

            technique.screen = screen;

            technique.uvtransform = this.calculateGradientUVtransform(style.matrix);

            technique.gradient = texture;
            technique.alpha = globalAlpha;
        }
        else // Pattern
        {
            var imageWidth = style.width;
            var imageHeight = style.height;

            if (!imageWidth || !imageHeight)
            {
                throw 'INVALID_STATE_ERR';
            }

            technique = this.patternTechniques[globalCompositeOperation];
            if (!technique)
            {
                throw "Unknown composite operation: " + globalCompositeOperation;
            }

            gd.setTechnique(technique);

            technique.screen = screen;

            technique.uvtransform = this.calculatePatternUVtransform(imageWidth, imageHeight);
            technique.pattern = style;
            technique.alpha = this.globalAlpha;
        }
    },

    parseColor : function parseColorFn(colorText)
    {
        var color = this.cachedColors[colorText];
        if (color !== undefined)
        {
            return color;
        }

        if (this.numCachedColors > 1024)
        {
            this.cachedColors = {};
            this.numCachedColors = 0;
        }

        color = parseCSSColor(colorText, this.md.v4BuildZero());
        if (color)
        {
            this.cachedColors[colorText] = color;
            this.numCachedColors += 1;
            return color;
        }
        else
        {
            throw "Unknown color: " + colorText;
        }
    },

    interpolateArc : function interpolateArcFn(x, y, radius, startAngle, endAngle, anticlockwise)
    {
        var cos = Math.cos;
        var sin = Math.sin;
        var pi2 = (Math.PI * 2);

        var points = this.currentSubPath;
        var numPoints = points.length;
        var angle, angleDiff, i, j;

        var angleStep = (2.0 / radius);

        var m = this.matrix;
        var m0 = (m[0] * radius);
        var m1 = (m[1] * radius);
        var m3 = (m[3] * radius);
        var m4 = (m[4] * radius);

        if (anticlockwise)
        {
            while (endAngle >= startAngle)
            {
                endAngle -= pi2;
            }

            angleDiff = (startAngle - endAngle);
            if (angleDiff >= angleStep)
            {
                for (angle = startAngle; angle > endAngle; angle -= angleStep)
                {
                    i = cos(angle);
                    j = sin(angle);
                    points[numPoints] = [((i * m0) + (j * m1) + x),
                                         ((i * m3) + (j * m4) + y)];
                    numPoints += 1;
                }
            }
        }
        else
        {
            while (endAngle <= startAngle)
            {
                endAngle += pi2;
            }

            angleDiff = (endAngle - startAngle);
            if (angleDiff >= angleStep)
            {
                for (angle = startAngle; angle < endAngle; angle += angleStep)
                {
                    i = cos(angle);
                    j = sin(angle);
                    points[numPoints] = [((i * m0) + (j * m1) + x),
                                         ((i * m3) + (j * m4) + y)];
                    numPoints += 1;
                }
            }
        }

        i = cos(endAngle);
        j = sin(endAngle);
        points[numPoints] = [((i * m0) + (j * m1) + x),
                             ((i * m3) + (j * m4) + y)];
    },


    getFlatBuffer : function getFlatBufferFn(numVertices)
    {
        var bufferData = this.bufferData;

        if (bufferData.length < (numVertices * 2))
        {
            this.bufferData = bufferData = new this.arrayConstructor(numVertices * 2);
        }

        return bufferData;
    },

    fillFlatBuffer : function fillFlatBufferFn(bufferData, numVertices)
    {
        var flatVertexBuffer = this.flatVertexBuffer;

        if (flatVertexBuffer.numVertices < numVertices)
        {
            flatVertexBuffer.destroy();
            this.flatVertexBuffer = flatVertexBuffer = null;
            this.flatVertexBuffer = flatVertexBuffer = this.gd.createVertexBuffer({
                numVertices: numVertices,
                attributes: this.flatVertexFormats,
                dynamic: true,
                'transient': true
            });
        }

        flatVertexBuffer.setData(bufferData, 0, numVertices);

        this.gd.setStream(flatVertexBuffer, this.flatSemantics);
    },


    getTextureBuffer : function getTextureBufferFn(numVertices)
    {
        var bufferData = this.bufferData;

        if (bufferData.length < (numVertices * 4))
        {
            this.bufferData = bufferData = new this.arrayConstructor(numVertices * 4);
        }

        return bufferData;
    },

    fillTextureBuffer : function fillTextureBufferFn(bufferData, numVertices)
    {
        var textureVertexBuffer = this.textureVertexBuffer;

        if (textureVertexBuffer.numVertices < numVertices)
        {
            textureVertexBuffer.destroy();
            this.textureVertexBuffer = textureVertexBuffer = null;
            this.textureVertexBuffer = textureVertexBuffer = this.gd.createVertexBuffer({
                numVertices: numVertices,
                attributes: this.textureVertexFormats,
                dynamic: true,
                'transient': true
            });
        }

        textureVertexBuffer.setData(bufferData, 0, numVertices);

        this.gd.setStream(textureVertexBuffer, this.textureSemantics);
    },


    fillFatStrip : function fillFatStripFn(points, numPoints, lineWidth)
    {
        var numVertices = 0;

        var bufferData = this.getFlatBuffer(numPoints * 2);
        if (bufferData)
        {
            var p, point, xB, yB, xC, yC, xAB, yAB, xBC, yBC, ln, dx, dy, n;
            var sqrt = Math.sqrt;
            var abs = Math.abs;

            lineWidth *= 0.5;

            point = points[0];
            xB = point[0];
            yB = point[1];

            var lastPoint = points[numPoints - 1];
            var isClosed = (abs(xB - lastPoint[0]) < 1.0 &&
                            abs(yB - lastPoint[1]) < 1.0);
            if (isClosed)
            {
                if (numPoints < 3)
                {
                    return 0;
                }

                point = points[numPoints - 2];
                xAB = (xB - point[0]);
                yAB = (yB - point[1]);
                ln = ((xAB * xAB) + (yAB * yAB));
                if (ln > 0.0)
                {
                    ln = (1.0 / sqrt(ln));
                    xAB *= ln;
                    yAB *= ln;
                }
            }
            else
            {
                xAB = 0;
                yAB = 0;
            }

            p = 0;
            n = 0;
            do
            {
                p += 1;
                if (p < numPoints)
                {
                    point = points[p];
                    xC = point[0];
                    yC = point[1];
                }
                else if (isClosed)
                {
                    point = points[1];
                    xC = point[0];
                    yC = point[1];
                }
                else
                {
                    // use perpendicular vector to (xAB, yAB) -> (yAB, -xAB)
                    xAB *= lineWidth;
                    yAB *= lineWidth;
                    bufferData[n + 0] = xB - yAB;
                    bufferData[n + 1] = yB + xAB;
                    bufferData[n + 2] = xB + yAB;
                    bufferData[n + 3] = yB - xAB;

                    n += 4;
                    numVertices += 2;
                    break;
                }
                xBC = (xC - xB);
                yBC = (yC - yB);
                ln = ((xBC * xBC) + (yBC * yBC));
                if (ln >= 1.0)
                {
                    ln = (1.0 / sqrt(ln));
                    xBC *= ln;
                    yBC *= ln;

                    dx = (xAB + xBC);
                    dy = (yAB + yBC);
                    ln = ((dx * dx) + (dy * dy));
                    if (ln > 0.0)
                    {
                        ln = (lineWidth / sqrt(ln));
                        dx *= ln;
                        dy *= ln;

                        // use perpendicular vector to (dx, dy) -> (dy, -dx)
                        bufferData[n + 0] = xB - dy;
                        bufferData[n + 1] = yB + dx;
                        bufferData[n + 2] = xB + dy;
                        bufferData[n + 3] = yB - dx;

                        n += 4;
                        numVertices += 2;
                    }

                    xB = xC;
                    yB = yC;
                    xAB = xBC;
                    yAB = yBC;
                }
            }
            while (p < numPoints);

            this.fillFlatBuffer(bufferData, numVertices);
        }

        return numVertices;
    },

    autoClose : function autoCloseFn(points, numPoints)
    {
        var firstPoint = points[0];
        var lastPoint = points[numPoints - 1];

        if (firstPoint === lastPoint)
        {
            return numPoints;
        }

        var abs = Math.abs;
        if (abs(firstPoint[0] - lastPoint[0]) < 1.0 &&
            abs(firstPoint[1] - lastPoint[1]) < 1.0)
        {
            return numPoints;
        }

        points[numPoints] = firstPoint;

        return (numPoints + 1);
    },

    isClosed : function isClosedFn(firstPoint, lastPoint)
    {
        if (firstPoint === lastPoint)
        {
            return true;
        }

        var abs = Math.abs;
        if (abs(firstPoint[0] - lastPoint[0]) < 1.0 &&
            abs(firstPoint[1] - lastPoint[1]) < 1.0)
        {
            return true;
        }

        return false;
    },

    isConvex : function isConvexFn(points, numSegments)
    {
        if (numSegments < 4)
        {
            return true;
        }

        var flag = 0;

        /*jshint bitwise: false*/
        var p0 = points[numSegments - 2];
        var p1 = points[numSegments - 1];
        var p0x = p0[0];
        var p0y = p0[1];
        var p1x = p1[0];
        var p1y = p1[1];
        var n = 0;
        do
        {
            var p2 = points[n];
            var p2x = p2[0];
            var p2y = p2[1];

            var z = (((p1x - p0x) * (p2y - p1y)) - ((p1y - p0y) * (p2x - p1x)));
            if (z < 0)
            {
                flag |= 1;
            }
            else if (z > 0)
            {
                flag |= 2;
            }

            if (flag === 3)
            {
                return false;
            }

            p0x = p1x;
            p0y = p1y;
            p1x = p2x;
            p1y = p2y;

            n += 1;
        }
        while (n < numSegments);
        /*jshint bitwise: true*/

        if (flag !== 0)
        {
            return true;
        }

        return false;
    },

    calculateArea : function calculateArea(points, numPoints)
    {
        // Dan Sunday, "Fast Polygon Area and Newell Normal Computation"
        var area = 0;
        var p0 = points[numPoints - 2];
        var p1 = points[numPoints - 1];
        var p = 0;
        do
        {
            var p2 = points[p];
            area += p1[0] * (p2[1] - p0[1]);
            p0 = p1;
            p1 = p2;

            p += 1;
        }
        while (p < numPoints);
        return (area * 0.5);
    },

    triangulateConvex : function triangulateConvexFn(points, numSegments, vertices, numVertices)
    {
        var p0 = points[0];
        var p1 = points[1];
        var p = 2;
        do
        {
            var p2 = points[p];
            vertices[numVertices] = p0;
            vertices[numVertices + 1] = p1;
            vertices[numVertices + 2] = p2;
            numVertices += 3;
            p1 = p2;
            p += 1;
        }
        while (p < numSegments);

        return numVertices;
    },

    triangulateConcave : function triangulateConcaveFn(points, numSegments, vertices, numVertices, ownPoints)
    {
        var isConvex = this.isConvex;

        var totalArea = this.calculateArea(points, numSegments);
        if (totalArea === 0)
        {
            return numVertices;
        }

        if (ownPoints)
        {
            points.length = numSegments;
        }
        else
        {
            // Need to get a copy because this is a destructive algorithm
            points = points.slice(0, numSegments); // no need to copy the duplicated last point
        }

        // Ear cutting algorithm
        var i0, i1, i2, p0, p1, p2, j, tarea;
        var ax, ay, bx, by, cx, cy;
        var v0x, v0y, v1x, v1y;
        var minX, maxX, minY, maxY;
        var valid, deletePoint;
        do
        {
            i0 = (numSegments - 2);
            i1 = (numSegments - 1);
            i2 = 0;

            p0 = points[i0];
            ax = p0[0];
            ay = p0[1];

            p1 = points[i1];
            bx = p1[0];
            by = p1[1];
            v1x = (bx - ax);
            v1y = (by - ay);

            valid = false;
            do
            {
                deletePoint = false;

                p2 = points[i2];
                cx = p2[0];
                cy = p2[1];
                v0x = (cx - ax);
                v0y = (cy - ay);

                // Calculate triangle area
                tarea = ((v1x * v0y) - (v0x * v1y)); // * 0.5);

                if ((totalArea * tarea) >= 0) // same winding order
                {
                    // Calculate triangle extents
                    minX = (ax < bx ? ax : bx);
                    minX = (minX < cx ? minX : cx);

                    maxX = (ax > bx ? ax : bx);
                    maxX = (maxX > cx ? maxX : cx);

                    minY = (ay < by ? ay : by);
                    minY = (minY < cy ? minY : cy);

                    maxY = (ay > by ? ay : by);
                    maxY = (maxY > cy ? maxY : cy);

                    // Compute dot products
                    var dot00 = ((v0x * v0x) + (v0y * v0y));
                    var dot01 = ((v0x * v1x) + (v0y * v1y));
                    var dot11 = ((v1x * v1x) + (v1y * v1y));
                    var denom = ((dot00 * dot11) - (dot01 * dot01));
                    if (denom !== 0)
                    {
                        var invDenom = (1.0 / denom);
                        dot00 *= invDenom;
                        dot01 *= invDenom;
                        dot11 *= invDenom;

                        var overlappingPointArea = 0;
                        var overlappingPoint = -1;

                        // Check if triangle overlaps any other point
                        j = 0;
                        do
                        {
                            if (j !== i0 &&
                                j !== i1 &&
                                j !== i2)
                            {
                                var p = points[j];
                                var px = p[0];
                                if (minX <= px && px <= maxX)
                                {
                                    var py = p[1];
                                    if (minY <= py && py <= maxY)
                                    {
                                        var v2x = (px - ax);
                                        var v2y = (py - ay);
                                        var dot02 = ((v0x * v2x) + (v0y * v2y));
                                        var dot12 = ((v1x * v2x) + (v1y * v2y));

                                        // Barycentric coordinates
                                        var u = ((dot11 * dot02) - (dot01 * dot12));
                                        if (u > 0)
                                        {
                                            var v = ((dot00 * dot12) - (dot01 * dot02));
                                            if (v > 0 && (u + v) < 1)
                                            {
                                                // There is at least one vertex inside the triangle, if there are more
                                                // find the one closer to i1 vertically by finding the one that has the
                                                // biggest triangle area with i0 and i2
                                                var parea = ((v0y * v2x) - (v0x * v2y));
                                                parea *= parea; // Make sure is a positive value
                                                if (overlappingPointArea < parea)
                                                {
                                                    overlappingPointArea = parea;
                                                    overlappingPoint = j;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            j += 1;
                        }
                        while (j < numSegments);

                        if (overlappingPoint < 0)
                        {
                            vertices[numVertices] = p0;
                            vertices[numVertices + 1] = p1;
                            vertices[numVertices + 2] = p2;
                            numVertices += 3;

                            deletePoint = true;
                        }
                        else if (overlappingPoint === ((i1 + 2) % numSegments))
                        {
                            // The diagonal is only splitting the next triangle
                            // Remove the point an keep going
                            i0 = i1;
                            i1 = i2;
                            i2 = overlappingPoint;

                            p0 = p1;
                            ax = bx;
                            ay = by;

                            p1 = p2;

                            p2 = points[i2];
                            cx = p2[0];
                            cy = p2[1];
                            v0x = (cx - ax);
                            v0y = (cy - ay);

                            vertices[numVertices] = p0;
                            vertices[numVertices + 1] = p1;
                            vertices[numVertices + 2] = p2;
                            numVertices += 3;

                            deletePoint = true;
                        }
                        else if (i1 === ((overlappingPoint + 2) % numSegments))
                        {
                            // The diagonal is only splitting the previous triangle
                            // Remove the point an keep going
                            i2 = i1;
                            i1 = i0;
                            i0 = overlappingPoint;

                            p2 = p1;
                            cx = bx;
                            cy = by;

                            p1 = p0;

                            p0 = points[i0];
                            ax = p0[0];
                            ay = p0[1];

                            v0x = (cx - ax);
                            v0y = (cy - ay);

                            vertices[numVertices] = p0;
                            vertices[numVertices + 1] = p1;
                            vertices[numVertices + 2] = p2;
                            numVertices += 3;

                            deletePoint = true;
                        }
                        else
                        {
                             // Found a diagonal
                            var d0 = i1;
                            var d1 = overlappingPoint;

                            var pointsA, pointsB;
                            if (d0 < d1)
                            {
                                pointsA = points.splice(d0, (d1 - d0 + 1), points[d0], points[d1]);
                                pointsB = points;
                            }
                            else
                            {
                                pointsB = points.splice(d1, (d0 - d1 + 1), points[d1], points[d0]);
                                pointsA = points;
                            }
                            points = null;

                            var numSegmentsA = pointsA.length;
                            if (numSegmentsA === 3)
                            {
                                vertices[numVertices] = pointsA[0];
                                vertices[numVertices + 1] = pointsA[1];
                                vertices[numVertices + 2] = pointsA[2];
                                numVertices += 3;
                            }
                            else
                            {
                                pointsA[numSegmentsA] = pointsA[0];

                                if (isConvex(pointsA, numSegmentsA))
                                {
                                    numVertices = this.triangulateConvex(pointsA, numSegmentsA, vertices, numVertices);
                                }
                                else
                                {
                                    numVertices = this.triangulateConcave(pointsA, numSegmentsA, vertices, numVertices, true);
                                }
                            }
                            pointsA = null;

                            var numSegmentsB = pointsB.length;
                            if (numSegmentsB === 3)
                            {
                                vertices[numVertices] = pointsB[0];
                                vertices[numVertices + 1] = pointsB[1];
                                vertices[numVertices + 2] = pointsB[2];
                                numVertices += 3;
                                return numVertices;
                            }
                            else
                            {
                                pointsB[numSegmentsB] = pointsB[0];

                                // Avoid recursion by restarting the loop
                                points = pointsB;
                                numSegments = numSegmentsB;
                                pointsB = null;

                                totalArea = this.calculateArea(points, numSegments);
                                if (totalArea === 0)
                                {
                                    return numVertices;
                                }

                                points.length = numSegments;

                                valid = true;
                                break;
                            }
                        }
                    }
                    else // Zero-area triangle
                    {
                        deletePoint = true;
                    }
                }

                if (deletePoint)
                {
                    valid = true;

                    points.splice(i1, 1);

                    numSegments -= 1;
                    if (numSegments < 4)
                    {
                        break;
                    }

                    if (i2 < numSegments)
                    {
                        if (i1 === 0)
                        {
                            i0 = (numSegments - 1);
                        }
                        else
                        {
                            i0 = (i1 - 1);

                            if (i1 === numSegments)
                            {
                                i1 = 0;
                            }
                        }

                        i2 = (i1 + 1);

                        p1 = p2;
                        bx = cx;
                        by = cy;
                        v1x = v0x;
                        v1y = v0y;

                        continue;
                    }
                    else
                    {
                        break;
                    }
                }

                i0 = i1;
                i1 = i2;
                i2 = (i2 + 1);

                p0 = p1;
                ax = bx;
                ay = by;

                p1 = p2;
                bx = cx;
                by = cy;
                v1x = (bx - ax);
                v1y = (by - ay);
            }
            while (i2 < numSegments);
        }
        while (valid && !isConvex(points, numSegments));

        if (!valid)
        {
            return numVertices;
        }

        // convex
        p0 = points[0];
        ax = p0[0];
        ay = p0[1];

        p1 = points[1];
        bx = p1[0];
        by = p1[1];
        v1x = (bx - ax);
        v1y = (by - ay);

        j = 2;
        do
        {
            p2 = points[j];
            cx = p2[0];
            cy = p2[1];
            v0x = (cx - ax);
            v0y = (cy - ay);

            // Calculate triangle area
            tarea = (((v1x * v0y) - (v0x * v1y)) * 0.5);

            if ((totalArea * tarea) > 0) // same winding order
            {
                vertices[numVertices] = p0;
                vertices[numVertices + 1] = p1;
                vertices[numVertices + 2] = p2;
                numVertices += 3;
            }

            p1 = p2;
            bx = cx;
            by = cy;
            v1x = v0x;
            v1y = v0y;

            j += 1;
        }
        while (j < numSegments);

        return numVertices;
    },

    fillFlatVertices : function fillFlatVerticesFn(vertices, numVertices)
    {
        var bufferData = this.getFlatBuffer(numVertices);
        if (bufferData)
        {
            var p = 0, d = 0;
            do
            {
                var vertex = vertices[p];
                bufferData[d] = vertex[0];
                d += 1;
                bufferData[d] = vertex[1];
                d += 1;
                p += 1;
            }
            while (p < numVertices);

            this.fillFlatBuffer(bufferData, numVertices);
        }
    },

    isPointInPolygon : function isPointInPolygonFn(tx, ty, points, numPoints)
    {
        var yflag0, yflag1, inside;
        var vtx0, vtx1, vtxn;

        vtx0 = points[numPoints - 1];
        yflag0 = (vtx0[1] >= ty);

        inside = false;

        for (vtxn = 0; vtxn < numPoints; vtxn += 1)
        {
            vtx1 = points[vtxn];
            yflag1 = (vtx1[1] >= ty);

            if (yflag0 !== yflag1)
            {
                if (((vtx1[1] - ty) * (vtx0[0] - vtx1[0]) >= (vtx1[0] - tx) * (vtx0[1] - vtx1[1])) === yflag1)
                {
                    inside = !inside;
                }
            }

            vtx0 = vtx1;
            yflag0 = yflag1;
        }

        return inside;
    },

    isPointInSubPath : function isPointInSubPathFn(tx, ty, points)
    {
        var numPoints = points.length;
        if (numPoints > 2)
        {
            if (this.isClosed(points[0], points[numPoints - 1]))
            {
                numPoints -= 1; // Skip duplicated last point

                return this.isPointInPolygon(tx, ty, points, numPoints);
            }
        }

        return false;
    },

/*jshint white: false*/
    shaderDefinition : {
 "version": 1,
 "name": "canvas.cgfx",
 "samplers":
 {
  "texture":
  {
   "MinFilter": 9985,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  },
  "pattern":
  {
   "MinFilter": 9728,
   "MagFilter": 9729,
   "WrapS": 10497,
   "WrapT": 10497
  },
  "gradient":
  {
   "MinFilter": 9728,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  },
  "image":
  {
   "MinFilter": 9728,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  }
 },
 "parameters":
 {
  "screen":
  {
   "type": "float",
   "columns": 4
  },
  "uvtransform":
  {
   "type": "float",
   "rows": 2,
   "columns": 3
  },
  "color":
  {
   "type": "float",
   "columns": 4
  },
  "alpha":
  {
   "type": "float"
  },
  "texture":
  {
   "type": "sampler2D"
  },
  "pattern":
  {
   "type": "sampler2D"
  },
  "gradient":
  {
   "type": "sampler2D"
  },
  "image":
  {
   "type": "sampler2D"
  }
 },
 "techniques":
 {
  "flat_source_atop":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_source_in":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_source_out":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_source_over":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_atop":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_in":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_out":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_destination_over":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_lighter":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_copy":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "flat_xor":
  [
   {
    "parameters": ["screen","color"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_flat","fp_flat"]
   }
  ],
  "texture_source_atop":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_source_in":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_source_out":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_source_over":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_atop":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_in":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_out":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_destination_over":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_lighter":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_copy":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "texture_xor":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_texture","fp_texture"]
   }
  ],
  "pattern_source_atop":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_source_in":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_source_out":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_source_over":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_destination_atop":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_destination_in":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_destination_out":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_destination_over":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_lighter":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_copy":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "pattern_xor":
  [
   {
    "parameters": ["screen","uvtransform","alpha","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern"]
   }
  ],
  "gradient_source_atop":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,771]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_source_in":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [772,0]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_source_out":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,0]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_source_over":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_destination_atop":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,770]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_destination_in":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,770]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_destination_out":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [0,771]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_destination_over":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,1]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_lighter":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,1]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_copy":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "gradient_xor":
  [
   {
    "parameters": ["screen","uvtransform","alpha","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [773,771]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient"]
   }
  ],
  "texture_shadow":
  [
   {
    "parameters": ["screen","color","texture"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture","fp_texture_shadow"]
   }
  ],
  "pattern_shadow":
  [
   {
    "parameters": ["screen","uvtransform","color","pattern"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture_uvtransform","fp_pattern_shadow"]
   }
  ],
  "gradient_shadow":
  [
   {
    "parameters": ["screen","uvtransform","color","gradient"],
    "semantics": ["POSITION"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [1,771]
    },
    "programs": ["vp_texture_uvtransform","fp_gradient_shadow"]
   }
  ],
  "image":
  [
   {
    "parameters": ["image"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_image","fp_image"]
   }
  ]
 },
 "programs":
 {
  "fp_image":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform sampler2D image;void main()\n{gl_FragColor=texture2D(image,tz_TexCoord[0].xy);}"
  },
  "vp_image":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR8;attribute vec4 ATTR0;\nvoid main()\n{vec4 tmpvar_1;tmpvar_1.zw=vec2(0.0,1.0);tmpvar_1.x=ATTR0.x;tmpvar_1.y=ATTR0.y;tz_TexCoord[0].xy=ATTR8.xy;gl_Position=tmpvar_1;}"
  },
  "fp_gradient_shadow":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform sampler2D gradient;uniform vec4 color;void main()\n{gl_FragColor=(color*texture2D(gradient,tz_TexCoord[0].xy).w);}"
  },
  "vp_texture_uvtransform":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR0;\nuniform vec3 uvtransform[2];uniform vec4 screen;void main()\n{vec2 tmpvar_1;vec2 tmpvar_2;tmpvar_2=((ATTR0.xy*screen.xy)+screen.zw);vec4 tmpvar_3;tmpvar_3.zw=vec2(0.0,1.0);tmpvar_3.x=tmpvar_2.x;tmpvar_3.y=tmpvar_2.y;vec3 tmpvar_4;tmpvar_4.z=1.0;tmpvar_4.x=ATTR0.x;tmpvar_4.y=ATTR0.y;tmpvar_1.x=dot(tmpvar_4,uvtransform[0]);tmpvar_1.y=dot(tmpvar_4,uvtransform[1]);tz_TexCoord[0].xy=tmpvar_1;gl_Position=tmpvar_3;}"
  },
  "fp_pattern_shadow":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform sampler2D pattern;uniform vec4 color;void main()\n{gl_FragColor=(color*texture2D(pattern,tz_TexCoord[0].xy).w);}"
  },
  "fp_texture_shadow":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform sampler2D texture;uniform vec4 color;void main()\n{gl_FragColor=(color*texture2D(texture,tz_TexCoord[0].xy).w);}"
  },
  "vp_texture":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR8;attribute vec4 ATTR0;\nuniform vec4 screen;void main()\n{vec2 tmpvar_1;tmpvar_1=((ATTR0.xy*screen.xy)+screen.zw);vec4 tmpvar_2;tmpvar_2.zw=vec2(0.0,1.0);tmpvar_2.x=tmpvar_1.x;tmpvar_2.y=tmpvar_1.y;tz_TexCoord[0].xy=ATTR8.xy;gl_Position=tmpvar_2;}"
  },
  "fp_gradient":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform sampler2D gradient;uniform float alpha;void main()\n{vec4 _fg;vec4 tmpvar_1;tmpvar_1=texture2D(gradient,tz_TexCoord[0].xy);_fg=tmpvar_1;_fg.w=(tmpvar_1.w*alpha);_fg.xyz=(tmpvar_1.xyz*_fg.w);gl_FragColor=_fg;}"
  },
  "fp_pattern":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform sampler2D pattern;uniform float alpha;void main()\n{vec4 _fg;vec4 tmpvar_1;tmpvar_1=texture2D(pattern,tz_TexCoord[0].xy);_fg=tmpvar_1;_fg.w=(tmpvar_1.w*alpha);_fg.xyz=(tmpvar_1.xyz*_fg.w);gl_FragColor=_fg;}"
  },
  "fp_texture":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nuniform sampler2D texture;uniform vec4 color;void main()\n{vec4 _fg;vec4 tmpvar_1;tmpvar_1=(texture2D(texture,tz_TexCoord[0].xy)*color);_fg=tmpvar_1;_fg.xyz=(tmpvar_1.xyz*tmpvar_1.w);gl_FragColor=_fg;}"
  },
  "fp_flat":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nuniform vec4 color;void main()\n{gl_FragColor=color;}"
  },
  "vp_flat":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nattribute vec4 ATTR0;\nuniform vec4 screen;void main()\n{vec2 tmpvar_1;tmpvar_1=((ATTR0.xy*screen.xy)+screen.zw);vec4 tmpvar_2;tmpvar_2.zw=vec2(0.0,1.0);tmpvar_2.x=tmpvar_1.x;tmpvar_2.y=tmpvar_1.y;gl_Position=tmpvar_2;}"
  }
 }
}
/*jshint white: true*/
};

// Constructor function
CanvasContext.create = function canvasCreateFn(canvas, gd, md, width, height)
{
    var c = new CanvasContext();

    // public variables
    c.canvas = canvas;
    c.globalAlpha = 1.0;
    c.globalCompositeOperation = 'source-over';
    c.strokeStyle = '#000000';
    c.fillStyle = '#000000';
    c.lineWidth = 1;
    c.lineCap = 'butt';
    c.lineJoin = 'miter';
    c.miterLimit = 10;
    c.shadowOffsetX = 0;
    c.shadowOffsetY = 0;
    c.shadowBlur = 0;
    c.shadowColor = 'rgba(0,0,0,0)';
    c.font = '10px sans-serif';
    c.textAlign = 'start';
    c.textBaseline = 'alphabetic';

    // private variables
    c.gd = gd;
    c.md = md;

    c.fm = null;

    c.target = null;
    c.viewport = [0, 0, width, height];

    c.forceFatLines = false;

    c.width = width;
    c.height = height;

    c.screen = md.v4Build((2 / width), (-2 / height), -1, 1);

    c.statesStack = [c.createStatesObject()]; // Preallocate one state objet
    c.numStatesInStack = 0;

    c.subPaths = [];
    c.currentSubPath = [];

    var shader = gd.createShader(c.shaderDefinition);
    c.shader = shader;

    c.triangleStripPrimitive = gd.PRIMITIVE_TRIANGLE_STRIP;
    c.triangleFanPrimitive = gd.PRIMITIVE_TRIANGLE_FAN;
    c.trianglePrimitive = gd.PRIMITIVE_TRIANGLES;
    c.lineStripPrimitive = gd.PRIMITIVE_LINE_STRIP;
    c.linePrimitive = gd.PRIMITIVE_LINES;

    c.textureVertexFormats = [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT2];
    c.textureSemantics = gd.createSemantics(['POSITION', 'TEXCOORD0']);

    c.textureVertexBuffer = gd.createVertexBuffer({
        numVertices: 4,
        attributes: c.textureVertexFormats,
        dynamic: true,
        'transient': true
    });

    c.flatVertexFormats = [gd.VERTEXFORMAT_FLOAT2];
    c.flatSemantics = gd.createSemantics(['POSITION']);

    c.flatVertexBuffer = gd.createVertexBuffer({
        numVertices: 256,
        attributes: c.flatVertexFormats,
        dynamic: true,
        'transient': true
    });

    var arrayConstructor = c.arrayConstructor;

    c.bufferData = new arrayConstructor(512);

    c.tempRect = new arrayConstructor(8);

    c.tempVertices = [];

    c.v4Zero = md.v4BuildZero();
    c.v4One = md.v4BuildOne();

    c.cachedColors = {};
    c.numCachedColors = 0;

    c.uvtransform = new arrayConstructor(6);
    c.uvtransform[0] = 1;
    c.uvtransform[1] = 0;
    c.uvtransform[2] = 0;
    c.uvtransform[3] = 0;
    c.uvtransform[4] = 1;
    c.uvtransform[5] = 0;

    c.tempColor = md.v4BuildZero();
    c.tempScreen = md.v4BuildZero();

    c.tempImage = null;
    c.imageTechnique = shader.getTechnique('image');

    var compositeOperations = c.compositeOperations;
    var flatTechniques = {};
    var textureTechniques = {};
    var patternTechniques = {};
    var gradientTechniques = {};
    c.flatTechniques = flatTechniques;
    c.textureTechniques = textureTechniques;
    c.patternTechniques = patternTechniques;
    c.gradientTechniques = gradientTechniques;
    for (var p in compositeOperations)
    {
        if (compositeOperations.hasOwnProperty(p))
        {
            var sp = p.replace('-', '_');
            flatTechniques[p] = shader.getTechnique('flat_' + sp);
            textureTechniques[p] = shader.getTechnique('texture_' + sp);
            patternTechniques[p] = shader.getTechnique('pattern_' + sp);
            gradientTechniques[p] = shader.getTechnique('gradient_' + sp);
        }
    }

    c.textureShadowTechnique = shader.getTechnique('texture_shadow');
    c.patternShadowTechnique = shader.getTechnique('pattern_shadow');
    c.gradientShadowTechnique = shader.getTechnique('gradient_shadow');

    c.resetTechniqueParameters();

/*
    c.renderTexture = gd.createTexture({
        name       : "canvas.backbuffer",
        width      : width,
        height     : height,
        depth      : 1,
        format     : gd.PIXELFORMAT_R8G8B8A8,
        cubemap    : false,
        mipmaps    : false,
        renderable : true
    });

    c.renderTarget = gd.createRenderTarget({
        colorTexture0 : c.renderTexture
    });
*/

    //
    // Transformation matrix and related operations
    //
    c.matrix = new arrayConstructor(6);
    c.matrix[0] = 1;
    c.matrix[1] = 0;
    c.matrix[2] = 0;
    c.matrix[3] = 0;
    c.matrix[4] = 1;
    c.matrix[5] = 0;

    var CanvasPrototype = CanvasContext.prototype;
    var scale = CanvasPrototype.scale;
    var translate = CanvasPrototype.translate;
    var transform = CanvasPrototype.transform;
    var setTransform = CanvasPrototype.setTransform;
    var transformPoint = CanvasPrototype.transformPoint;
    var transformRect = CanvasPrototype.transformRect;

    function resetTransformMethods()
    {
        c.scale = scale;
        c.translate = translate;
        c.transform = transform;
        c.setTransform = setTransform;
        c.transformPoint = transformPoint;
        c.transformRect = transformRect;
    }

    function transformTranslate(a, b, c, d, e, f)
    {
        var m = this.matrix;
        m[0] = a;
        m[3] = b;
        m[1] = c;
        m[4] = d;
        m[2] = (e + m[2]);
        m[5] = (f + m[5]);

        resetTransformMethods();
    }

    function transformPointTranslate(x, y)
    {
        var m = this.matrix;
        return [(x + m[2]), (y + m[5])];
    }

    function transformRectTranslate(x, y, w, h, rect)
    {
        var m = this.matrix;
        var x0 = (x + m[2]);
        var y0 = (y + m[5]);
        var x1 = (x0 + w);
        var y1 = (y0 + h);

        rect[0] = x0;
        rect[1] = y1;
        rect[2] = x1;
        rect[3] = y1;
        rect[4] = x0;
        rect[5] = y0;
        rect[6] = x1;
        rect[7] = y0;

        return rect;
    }

    function scaleIdentity(x, y)
    {
        if (x !== 1 || y !== 1)
        {
            var m = this.matrix;
            m[0] = x;
            m[4] = y;

            resetTransformMethods();
        }
    }

    function translateIdentity(x, y)
    {
        if (x !== 0 || y !== 0)
        {
            var m = this.matrix;
            m[2] = x;
            m[5] = y;

            this.translate = translate;
            this.transform = transformTranslate;
            this.transformPoint = transformPointTranslate;
            this.transformRect = transformRectTranslate;
        }
    }

    function setTransformIdentity(a, b, c, d, e, f)
    {
        var m = this.matrix;
        m[0] = a;
        m[1] = c;
        m[2] = e;
        m[3] = b;
        m[4] = d;
        m[5] = f;

        resetTransformMethods();
    }

    function transformPointIdentity(x, y)
    {
        return [x, y];
    }

    function transformRectIdentity(x, y, w, h, rect)
    {
        var x1 = (x + w);
        var y1 = (y + h);

        rect[0] = x;
        rect[1] = y1;
        rect[2] = x1;
        rect[3] = y1;
        rect[4] = x;
        rect[5] = y;
        rect[6] = x1;
        rect[7] = y;

        return rect;
    }

    c.scale = scaleIdentity;
    c.translate = translateIdentity;
    c.transform = setTransformIdentity;
    c.setTransform = setTransformIdentity;
    c.transformPoint = transformPointIdentity;
    c.transformRect = transformRectIdentity;

    //
    // Clipping
    //
    c.clipExtents = new arrayConstructor(4);
    c.clipExtents[0] = 0;
    c.clipExtents[1] = 0;
    c.clipExtents[2] = width;
    c.clipExtents[3] = height;

    //
    c.defaultStates = c.setStates(c.createStatesObject(), c);

    return c;
};

//
// Canvas
//
function Canvas() {}
Canvas.prototype =
{
    version : 1,

    // Standard API
    getContext : function getContextFn(contextId)
    {
        if (contextId.toLowerCase() === '2d')
        {
            return this.context;
        }
        else
        {
            return null;
        }
    },

    toDataURL : function toDataURLFn(type)
    {
        if (this.width === 0 ||
            this.height === 0)
        {
            return "data:,";
        }

        //if (type.toLowerCase() === 'image/jpeg')
        var pixelData = this.gd.getScreenshot(true, 0, 0, this.width, this.height);
        if (pixelData)
        {
            return "data:image/jpeg;base64," + pixelData.toBase64();
        }

        return null;
    },

    toBlob : function toBlobFn(fileCallback, type)
    {
        if (fileCallback)
        {
            //if (type.toLowerCase() === 'image/jpeg')
            var pixelData = this.gd.getScreenshot(true, 0, 0, this.width, this.height);
            fileCallback(pixelData);
        }
    },

    setAttribute : function setAttributeFn(attr, value)
    {
        if (value.substr(-2, 2) === "px")
        {
            value = value.substr(0, value.lengh - 2);
        }
        value = parseInt(value, 10);

        if (attr === "width")
        {
            this.width = value;
        }
        else if (attr === "height")
        {
            this.height = value;
        }
        else
        {
            throw 'UNSUPPORTED ATTRIBUTE!';
        }
    },

    // Turbulenz API
    setFontManager : function setFontManagerFn(fm)
    {
        this.context.setFontManager(fm);
    }
};

// Constructor function
Canvas.create = function canvasCreateFn(gd, md)
{
    var width = gd.width;
    var height = gd.height;

    var c = new Canvas();

    c.context = CanvasContext.create(c, gd, md, width, height);

    if (Object.defineProperty)
    {
        Object.defineProperty(c, "width", {
                get : function getWidth() {
                    return width;
                },
                set : function setWidth(newValue) {
                    width = newValue;

                    this.context.setWidth(newValue);

                    this.clientWidth = newValue;
                },
                enumerable : true,
                configurable : false
            });

        Object.defineProperty(c, "height", {
                get : function getHeight() {
                    return height;
                },
                set : function setHeight(newValue) {
                    height = newValue;

                    this.context.setHeight(newValue);

                    this.clientHeight = newValue;
                },
                enumerable : true,
                configurable : false
            });
    }
    else
    {
        c.width = width;
        c.height = height;
    }

    c.clientWidth = width;
    c.clientHeight = height;

    return c;
};

// Detect correct typed arrays
(function () {
    CanvasContext.prototype.arrayConstructor = Array;
    if (typeof Float32Array !== "undefined")
    {
        var testArray = new Float32Array(4);
        var textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            CanvasContext.prototype.arrayConstructor = Float32Array;
        }
    }
}());


/*jslint browser: true*/
/*global TurbulenzEngine,Canvas*/
TurbulenzEngine.onload = function onload() {
    
    var graphicsDevice = TurbulenzEngine.createGraphicsDevice({}),
		mathsDevice = TurbulenzEngine.createMathDevice({}),
		canvas = Canvas.create(graphicsDevice, mathsDevice),
		context = canvas.getContext('2d'),
		gridWidth = 10,
		cellwidth = 10,
		grid = new Grid(new RandomSeedGenerator(new CellDrawing(context)).generate(), new NeighbourhoodWatch(gridWidth));

    function update() {
		var deviceWidth, deviceHeight;

		if (graphicsDevice.beginFrame()) {
			deviceWidth = graphicsDevice.width;
			deviceHeight = graphicsDevice.height;

			if (canvas.width !== deviceWidth) {
				canvas.width = deviceWidth;
			}

			if (canvas.height !== deviceHeight) {
				canvas.height = deviceHeight;
			}

			context.beginFrame();			

			context.endFrame();
			graphicsDevice.endFrame();
		}
    }

    TurbulenzEngine.onunload = function gameOnunload() {
		graphicsDevice = null;
		mathsDevice = null;
		canvas = null;
		context = null;
	};

    TurbulenzEngine.setInterval(update, 1000 / 60);
};
function LiveCell (cellFactory, rule, drawService) {
    
    var neighbourCount = 0;

    function checkRule() {
        if (rule.isAlive(neighbourCount)) {
            return cellFactory.createLiveCell();
        } else {
            return cellFactory.createDeadCell();
        }
    }

    function notify() {
        neighbourCount += 1;
    }

    function notifyNeighbours(neighbours) {
        neighbours.forEach(function (neighbour) {
            neighbour.notify();
        });
    }

    function draw(index) {
        drawService.draw(true, index);
    }

    return {
        checkRule : checkRule,
        notify : notify,
        notifyNeighbours : notifyNeighbours,
        draw : draw
    };
}

function DeadCell(cellFactory, rule, drawService) {
    
    var neighbourCount = 0;

    function checkRule() {
        if (rule.isAlive(neighbourCount)) {
            return cellFactory.createLiveCell();
        } else {
            return cellFactory.createDeadCell();
        }
    }

    function notify() {
        neighbourCount += 1;
    }

    // don't notify neighbours, I'm dead
    // dead code??
    function notifyNeighbours(neighbours) { }

    function draw(index) {
        drawService.draw(false, index);
    }

    return {
        checkRule : checkRule,
        notify : notify,
        notifyNeighbours : notifyNeighbours,
        draw : draw
    };
}
function CellDrawing(context, gridWidth, cellWidth) {
    

    if(cellWidth == undefined) {
        cellWidth = 1;
    }

    function getCellColour(isAlive) {
        return isAlive ? '#FFFFFF' : '#000000';
    }

    function draw(isAlive, index) {
        var xCoordinate = (index % gridWidth) * cellWidth,
            yCoordinate = (Math.round(index / gridWidth)) * cellWidth;

        context.fillStyle = getCellColour(isAlive);
        context.fillRect(xCoordinate, yCoordinate, 10, 10);
    }

    return { draw : draw };
}
function CellFactory(liveCellRule, deadCellRule, drawService) {    
    
    function createLiveCell() {
        return new LiveCell(this, liveCellRule, drawService);
    }

    function createDeadCell() {
        return new DeadCell(this, deadCellRule, drawService);
    }

    return {
        createLiveCell : createLiveCell,
        createDeadCell : createDeadCell
    };
}
function Grid(seed, neighbourhoodWatch) {
    
    var cells = seed;

    function notifyNeighbours() {
        cells.forEach(function (cell, index) {
            cell.notifyNeighbours(neighbourhoodWatch.getNeighbours(cells, index));
        });
    }

    function checkRules() {
        var newCells = [];
        cells.forEach(function (cell, index) {
            cell.draw(index);
            newCells.push(cell.checkRule());
        });

        cells = newCells;
    }

    function update() {
        notifyNeighbours(cells);
        checkRules();
    }   

    function draw() {
        cells.forEach(function (cell, index) { 
            cell.draw(index);
        });
    }

    return {
        update : update,
        notifyNeighbours : notifyNeighbours,
        draw : draw
    };
}
function NeighbourhoodWatch(gridWidth) {
    

    function getStartIndex(cellIndex) {
        var startIndex = cellIndex - gridWidth - 1;

        if (startIndex < 0) {
            startIndex = 0;
        }

        return startIndex;
    }

    function getEndIndex(cellIndex, maxIndex) {
        var endIndex = cellIndex + gridWidth + 1;

        if (endIndex >= maxIndex) {
            endIndex = maxIndex - 1;
        }

        return endIndex;
    }

    function isCellWithinBounds(cellIndex, currentIndex) {
        var cellX = cellIndex % gridWidth,
            cellY = Math.floor(cellIndex / gridWidth),
            currX = currentIndex % gridWidth,
            currY = Math.floor(currentIndex / gridWidth),
            x = cellX - currX,
            y = cellY - currY;

        return (x >= -1 && x <= 1) && (y >= -1 && y <= 1) && (cellIndex !== currentIndex);
    }

    function getNeighbours(cells, cellIndex) {
        var neighbours = [],
            startIndex = getStartIndex(cellIndex),
            endIndex = getEndIndex(cellIndex, cells.length),
            currentIndex = startIndex;

        for (currentIndex; currentIndex <= endIndex; currentIndex += 1) {
            if (isCellWithinBounds(cellIndex, currentIndex)) {
                neighbours.push(cells[currentIndex]);
            }
        }

        return neighbours;
    }

    return {
        getNeighbours : getNeighbours
    };
}
/*global CellFactory,LiveCellRule, DeadCellRule*/
function RandomSeedGenerator(cellDrawing, gridWidth) {
    
    var gridSize = gridWidth * gridWidth;
    
    function generate(gridSize) {
        var cellFactory = new CellFactory(new LiveCellRule(), new DeadCellRule(), cellDrawing),
            cells = [],
            liveCell,
            i = 0;

        for (i; i < gridSize; i += 1) {
            liveCell = Math.floor((Math.random() * 100) + 1);

            if (liveCell > 50) {
                cells.push(cellFactory.createLiveCell());
            } else {
                cells.push(cellFactory.createDeadCell());
            }
        }

        return cells;
    }

    return {
        generate : generate
    };
}
function LiveCellRule() {
    
    function isAlive(noNeighbours) {
        return noNeighbours > 1 && noNeighbours < 4;
    }

    return {
        isAlive : isAlive
    };
}

function DeadCellRule() {
    
    function isAlive(noNeighbours) {
        return noNeighbours === 3;
    }

    return {
        isAlive : isAlive
    };
}

    if (!TurbulenzEngine.onload)
    {
        window.alert("Entry point 'TurbulenzEngine.onload' must be defined for Engine 0.19.0 onwards.");
        return;
    }
    TurbulenzEngine.onload.call(this);
}());