(function () {
// Copyright (c) 2009-2012 Turbulenz Limited
/*global Float32Array: false*/
/*global TurbulenzEngine: false*/

//
// Vector math library
//
var VMathArrayConstructor = [].constructor;

// Ensure there is a slice function available for Float32Arrays

if ((typeof Float32Array !== "undefined") &&
    (Float32Array.prototype !== undefined) &&
    (Float32Array.prototype.slice === undefined))
{
    Float32Array.prototype.slice = function Float32ArraySlice(s, e)
    {
        var length = this.length;
        if (s === undefined)
        {
            s = 0;
        }
        else if (s < 0)
        {
            s += length;
        }
        if (e === undefined)
        {
            e = length;
        }
        else if (e < 0)
        {
            e += length;
        }

        length = (e - s);
        if (0 < length)
        {
            var dst = new Float32Array(length);
            var n = 0;
            do
            {
                dst[n] = this[s];
                n += 1;
                s += 1;
            }
            while (s < e);
            return dst;
        }
        else
        {
            return new Float32Array();
        }
    };
}

var VMath =
{
    version : 1,

    // Default precision for equality comparations
    precision : 1e-6,

    FLOAT_MAX : Number.MAX_VALUE,

    select : function selectFn(m, a, b)
    {
        if (m)
        {
            return a;
        }
        else
        {
            return b;
        }
    },

    reciprocal : function reciprocalFn(a)
    {
        if (a !== 0.0)
        {
            return (1.0 / a);
        }
        else
        {
            throw "Division by zero";
        }
    },

    /*jshint bitwise: false*/
    truncate : function truncateFn(value)
    {
        return (value | 0);
    },
    /*jshint bitwise: true*/

    //
    // Vector2
    //
    v2BuildZero : function v2BuildZeroFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        return dst;
    },

    v2BuildOne : function v2BuildOneFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        return dst;
    },

    v2BuildXAxis : function v2BuildXAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        return dst;
    },

    v2BuildYAxis : function v2BuildYAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = 0.0;
        dst[1] = 1.0;
        return dst;
    },

    v2Build : function v2Fn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a;
        dst[1] = b;
        return dst;
    },

    v2Copy : function v2CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        return dst;
    },

    v2Set : function v2SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
    },

    v2Neg : function v2NegFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = -a[0];
        dst[1] = -a[1];
        return dst;
    },

    v2Add : function v2AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0];
        dst[1] = a[1] + b[1];
        return dst;
    },

    v2Add3 : function v2Add3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0] + c[0];
        dst[1] = a[1] + b[1] + c[1];
        return dst;
    },

    v2Add4 : function v2Add4Fn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0] + c[0] + d[0];
        dst[1] = a[1] + b[1] + c[1] + d[1];
        return dst;
    },

    v2Sub : function v2SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        return dst;
    },

    v2Mul : function v2MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        return dst;
    },

    v2MulAdd : function v2MulAddFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] * b[0]) + c[0];
        dst[1] = (a[1] * b[1]) + c[1];
        return dst;
    },

    v2Dot : function v2DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]));
    },

    v2PerpDot : function v2PerpDot(a, b)
    {
        return ((a[0] * b[1]) - (a[1] * b[0]));
    },

    v2LengthSq : function v2LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        return ((a0 * a0) + (a1 * a1));
    },

    v2Length : function v2LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        return Math.sqrt((a0 * a0) + (a1 * a1));
    },

    v2Reciprocal : function v2ReciprocalFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        var rcp = VMath.reciprocal;
        dst[0] = rcp(a[0]);
        dst[1] = rcp(a[1]);
        return dst;
    },

    v2Normalize : function v2NormalizeFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var a0 = a[0];
        var a1 = a[1];
        var lsq = ((a0 * a0) + (a1 * a1));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            dst[0] = (a0 * lr);
            dst[1] = (a1 * lr);
        }
        else
        {
            dst[0] = 0;
            dst[1] = 0;
        }
        return dst;
    },

    v2Abs : function v2AbsFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var abs = Math.abs;
        dst[0] = abs(a[0]);
        dst[1] = abs(a[1]);
        return dst;
    },

    v2Max : function v2MaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var max = Math.max;
        dst[0] = max(a[0], b[0]);
        dst[1] = max(a[1], b[1]);
        return dst;
    },

    v2Min : function v2MinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        var min = Math.min;
        dst[0] = min(a[0], b[0]);
        dst[1] = min(a[1], b[1]);
        return dst;
    },

    v2Equal : function v2EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision);
    },

    // Vector2 'masks'
    v2MaskEqual : function v2MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision)];
    },

    v2MaskLess : function v2MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1])];
    },

    v2MaskGreater : function v2MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1])];
    },

    v2MaskGreaterEq : function v2MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1])];
    },

    v2MaskNot : function v2MaskNotFn(a)
    {
        return [!a[0],
                !a[1]];
    },

    v2MaskOr : function v2MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1])];
    },

    v2MaskAnd : function v2MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1])];
    },

    v2Select : function v2SelectFn(m, a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = m[0] ? a[0] : b[0];
        dst[1] = m[1] ? a[1] : b[1];
        return dst;
    },

    // Vector2 operations with scalar
    v2ScalarBuild : function v2ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        dst[0] = a;
        dst[1] = a;

        return dst;
    },

    v2ScalarMax : function v2ScalarMaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        var max = Math.max;
        dst[0] = max(a[0], b);
        dst[1] = max(a[1], b);

        return dst;
    },

    v2ScalarMin : function v2ScalarMinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        var min = Math.min;
        dst[0] = min(a[0], b);
        dst[1] = min(a[1], b);

        return dst;
    },

    v2ScalarAdd : function v2ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);

        return dst;
    },

    v2ScalarSub : function v2ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);

        return dst;
    },

    v2ScalarMul : function v2ScalarMulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        if (b === 0)
        {
            dst[0] = 0;
            dst[1] = 0;
        }
        else
        {
            dst[0] = a[0] * b;
            dst[1] = a[1] * b;
        }
        return dst;
    },

    v2AddScalarMul : function v2AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        return dst;
    },

    // Vector2 'masks' with scalars
    v2EqualScalarMask : function v2EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision)];
    },

    v2LessScalarMask : function v2LessScalarMaskFn(a, b)
    {
        return [(a[0] < b),
                (a[1] < b)];
    },

    v2GreaterScalarMask : function v2GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b)];
    },

    v2GreaterEqScalarMask : function v2GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b)];
    },

    v2Lerp : function v2LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(2);
        }
        dst[0] = (a[0] + ((b[0] - a[0]) * t));
        dst[1] = (a[1] + ((b[1] - a[1]) * t));
        return dst;
    },

    //
    // Vector3
    //
    v3BuildZero : function v3BuildZeroFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildOne  : function v3BuildOneFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        dst[2] = 1.0;
        return dst;
    },

    v3BuildXAxis : function v3BuildXAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildYAxis : function v3BuildYAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 1.0;
        dst[2] = 0.0;
        return dst;
    },

    v3BuildZAxis : function v3BuildZAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 1.0;
        return dst;
    },

    v3Build : function v3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = a;
        dst[1] = b;
        dst[2] = c;
        return dst;
    },

    v3Copy : function v3CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        return dst;
    },

    v3Set : function v3SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
        v[2] = a[2];
    },

    v3Neg : function v3NegFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = -a[0];
        dst[1] = -a[1];
        dst[2] = -a[2];
        return dst;
    },

    v3Add : function v3AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] + b[0]);
        dst[1] = (a[1] + b[1]);
        dst[2] = (a[2] + b[2]);
        return dst;
    },

    v3Add3 : function v3Add3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = a[0] + b[0] + c[0];
        dst[1] = a[1] + b[1] + c[1];
        dst[2] = a[2] + b[2] + c[2];
        return dst;
    },

    v3Add4 : function v3Add4Fn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = a[0] + b[0] + c[0] + d[0];
        dst[1] = a[1] + b[1] + c[1] + d[1];
        dst[2] = a[2] + b[2] + c[2] + d[2];
        return dst;
    },

    v3Sub : function v3SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        dst[2] = (a[2] - b[2]);
        return dst;
    },

    v3Mul : function v3MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        dst[2] = (a[2] * b[2]);
        return dst;
    },

    v3MulAdd : function v3MulAddFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = (a[0] * b[0]) + c[0];
        dst[1] = (a[1] * b[1]) + c[1];
        dst[2] = (a[2] * b[2]) + c[2];
        return dst;
    },

    v3Dot : function v3DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]));
    },

    v3Cross : function v3CrossFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        dst[0] = ((a1 * b2) - (a2 * b1));
        dst[1] = ((a2 * b0) - (a0 * b2));
        dst[2] = ((a0 * b1) - (a1 * b0));
        return dst;
    },

    v3LengthSq : function v3LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        return ((a0 * a0) + (a1 * a1) + (a2 * a2));
    },

    v3Length : function v3LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        return Math.sqrt((a0 * a0) + (a1 * a1) + (a2 * a2));
    },

    v3Reciprocal : function v3ReciprocalFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var rcp = VMath.reciprocal;
        dst[0] = rcp(a[0]);
        dst[1] = rcp(a[1]);
        dst[2] = rcp(a[2]);
        return dst;
    },

    v3Normalize : function v3NormalizeFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var lsq = ((a0 * a0) + (a1 * a1) + (a2 * a2));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            dst[0] = (a0 * lr);
            dst[1] = (a1 * lr);
            dst[2] = (a2 * lr);
        }
        else
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
        }
        return dst;
    },

    v3Abs : function v3AbsFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var abs = Math.abs;
        dst[0] = abs(a[0]);
        dst[1] = abs(a[1]);
        dst[2] = abs(a[2]);
        return dst;
    },

    v3Max : function v3MaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var max = Math.max;
        dst[0] = max(a[0], b[0]);
        dst[1] = max(a[1], b[1]);
        dst[2] = max(a[2], b[2]);
        return dst;
    },

    v3Min : function v3MinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var min = Math.min;
        dst[0] = min(a[0], b[0]);
        dst[1] = min(a[1], b[1]);
        dst[2] = min(a[2], b[2]);
        return dst;
    },

    v3Equal : function v3EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision);
    },

    // Vector3 'masks'
    v3MaskEqual : function v3MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision),
                (abs(a[2] - b[2]) <= precision)];
    },

    v3MaskLess : function v3MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1]),
                (a[2] < b[2])];
    },

    v3MaskGreater : function v3MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1]),
                (a[2] > b[2])];
    },

    v3MaskGreaterEq : function v3MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1]),
                (a[2] >= b[2])];
    },

    v3MaskNot : function v3MaskNotFn(a)
    {
        return [!a[0],
                !a[1],
                !a[2]];
    },

    v3MaskOr : function v3MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1]),
                (a[2] || b[2])];
    },

    v3MaskAnd : function v3MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1]),
                (a[2] && b[2])];
    },

    v3Select : function v3SelectFn(m, a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[0] ? a[0] : b[0];
        dst[1] = m[1] ? a[1] : b[1];
        dst[2] = m[2] ? a[2] : b[2];
        return dst;
    },

    // Vector3 operations with scalar
    v3ScalarBuild : function v3ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = a;
        dst[1] = a;
        dst[2] = a;

        return dst;
    },

    v3ScalarMax : function v3ScalarMaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var max = Math.max;
        dst[0] = max(a[0], b);
        dst[1] = max(a[1], b);
        dst[2] = max(a[2], b);

        return dst;
    },

    v3ScalarMin : function v3ScalarMinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        var min = Math.min;
        dst[0] = min(a[0], b);
        dst[1] = min(a[1], b);
        dst[2] = min(a[2], b);

        return dst;
    },

    v3ScalarAdd : function v3ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);
        dst[2] = (a[2] + b);

        return dst;
    },

    v3ScalarSub : function v3ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);
        dst[2] = (a[2] - b);

        return dst;
    },

    v3ScalarMul : function v3ScalarMulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        if (b === 0)
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
        }
        else
        {
            dst[0] = (a[0] * b);
            dst[1] = (a[1] * b);
            dst[2] = (a[2] * b);
        }
        return dst;
    },

    v3AddScalarMul : function v3AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        dst[2] = a[2] + b[2] * c;

        return dst;
    },

    // Vector3 'masks' with scalars
    v3EqualScalarMask : function v3EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision),
                (abs(a[2] - b) <= precision)];
    },

    v3LessScalarMask : function v3LessScalarMaskFn(a, b)
    {
        return [(a[0] < b),
                (a[1] < b),
                (a[2] < b)];
    },

    v3GreaterScalarMask : function v3GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b),
                (a[2] > b)];
    },

    v3GreaterEqScalarMask : function v3GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b),
                (a[2] >= b)];
    },

    v3Lerp : function v3LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }

        dst[0] =  (a[0] + ((b[0] - a[0]) * t));
        dst[1] =  (a[1] + ((b[1] - a[1]) * t));
        dst[2] =  (a[2] + ((b[2] - a[2]) * t));

        return dst;
    },

    //
    // Vector4
    //
    v4BuildZero : function v4BuildZeroFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = 0.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        return dst;
    },

    v4BuildOne  : function v4BuildOneFn(dst) {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = 1.0;
        dst[1] = 1.0;
        dst[2] = 1.0;
        dst[3] = 1.0;
        return dst;
    },

    v4Build : function v4BuildFn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = a;
        dst[1] = b;
        dst[2] = c;
        dst[3] = d;
        return dst;
    },

    v4Copy : function v4CopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        return dst;
    },

    v4Set : function v4SetFn(v, a)
    {
        v[0] = a[0];
        v[1] = a[1];
        v[2] = a[2];
        v[3] = a[3];
    },

    v4Neg : function v4NegFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = -a[0];
        dst[1] = -a[1];
        dst[2] = -a[2];
        dst[3] = -a[3];

        return dst;
    },

    v4Add : function v4AddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] + b[0]);
        dst[1] = (a[1] + b[1]);
        dst[2] = (a[2] + b[2]);
        dst[3] = (a[3] + b[3]);
        return dst;
    },

    v4Add3 : function v4Add3Fn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a[0] + b[0] + c[0];
        dst[1] = a[1] + b[1] + c[1];
        dst[2] = a[2] + b[2] + c[2];
        dst[3] = a[3] + b[3] + c[3];

        return dst;
    },

    v4Add4 : function v4Add4Fn(a, b, c, d, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a[0] + b[0] + c[0] + d[0];
        dst[1] = a[1] + b[1] + c[1] + d[1];
        dst[2] = a[2] + b[2] + c[2] + d[2];
        dst[3] = a[3] + b[3] + c[3] + d[3];

        return dst;
    },

    v4Sub : function v4SubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] - b[0]);
        dst[1] = (a[1] - b[1]);
        dst[2] = (a[2] - b[2]);
        dst[3] = (a[3] - b[3]);
        return dst;
    },

    v4Mul : function v4MulFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] * b[0]);
        dst[1] = (a[1] * b[1]);
        dst[2] = (a[2] * b[2]);
        dst[3] = (a[3] * b[3]);
        return dst;
    },

    v4MulAdd : function v4MulAddFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] * b[0]) + c[0];
        dst[1] = (a[1] * b[1]) + c[1];
        dst[2] = (a[2] * b[2]) + c[2];
        dst[3] = (a[3] * b[3]) + c[3];

        return dst;
    },

    v4Dot : function v4DotFn(a, b)
    {
        return ((a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]));
    },

    v4LengthSq : function v4LengthSqFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        return ((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
    },

    v4Length : function v4LengthFn(a)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        return Math.sqrt((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
    },

    v4Reciprocal : function v4ReciprocalFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var rcp = VMath.reciprocal;
        dst[0] = rcp(a[0]);
        dst[1] = rcp(a[1]);
        dst[2] = rcp(a[2]);
        dst[3] = rcp(a[3]);

        return dst;
    },

    v4Normalize : function v4NormalizeFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];

        var lsq = ((a0 * a0) + (a1 * a1) + (a2 * a2) + (a3 * a3));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            dst[0] = a0 * lr;
            dst[1] = a1 * lr;
            dst[2] = a2 * lr;
            dst[3] = a3 * lr;
        }
        else
        {
            dst[0] = 0;
            dst[1] = 0;
            dst[2] = 0;
            dst[3] = 0;
        }
        return dst;
    },

    v4Abs : function v4AbsFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var abs = Math.abs;
        dst[0] = abs(a[0]);
        dst[1] = abs(a[1]);
        dst[2] = abs(a[2]);
        dst[3] = abs(a[3]);

        return dst;
    },

    v4Max : function v4MaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var max = Math.max;
        dst[0] = max(a[0], b[0]);
        dst[1] = max(a[1], b[1]);
        dst[2] = max(a[2], b[2]);
        dst[3] = max(a[3], b[3]);

        return dst;
    },

    v4Min : function v4MinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var min = Math.min;
        dst[0] = min(a[0], b[0]);
        dst[1] = min(a[1], b[1]);
        dst[2] = min(a[2], b[2]);
        dst[3] = min(a[3], b[3]);

        return dst;
    },

    v4Equal : function v4EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision &&
                abs(a[3] - b[3]) <= precision);
    },

    // Vector3 'masks'
    v4MaskEqual : function v4MaskEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b[0]) <= precision),
                (abs(a[1] - b[1]) <= precision),
                (abs(a[2] - b[2]) <= precision),
                (abs(a[3] - b[3]) <= precision)];
    },

    v4MaskLess : function v4MaskLessFn(a, b)
    {
        return [(a[0] < b[0]),
                (a[1] < b[1]),
                (a[2] < b[2]),
                (a[3] < b[3])];
    },

    v4MaskGreater : function v4MaskGreaterFn(a, b)
    {
        return [(a[0] > b[0]),
                (a[1] > b[1]),
                (a[2] > b[2]),
                (a[3] > b[3])];
    },

    v4MaskGreaterEq : function v4MaskGreaterEqFn(a, b)
    {
        return [(a[0] >= b[0]),
                (a[1] >= b[1]),
                (a[2] >= b[2]),
                (a[3] >= b[3])];
    },

    v4MaskNot : function v4MaskNotFn(a)
    {
        return [!a[0],
                !a[1],
                !a[2],
                !a[3]];
    },

    v4MaskOr : function v4MaskOrFn(a, b)
    {
        return [(a[0] || b[0]),
                (a[1] || b[1]),
                (a[2] || b[2]),
                (a[3] || b[3])];
    },

    v4MaskAnd : function v4MaskAndFn(a, b)
    {
        return [(a[0] && b[0]),
                (a[1] && b[1]),
                (a[2] && b[2]),
                (a[3] && b[3])];
    },

    v4Many : function v4ManyFn(m)
    {
        return (m[0] || m[1] || m[2] || m[3]);
    },

    v4MaskAll : function v4MaskAllFn(m)
    {
        return (m[0] && m[1] && m[2] && m[3]);
    },

    v4Select : function v4SelectFn(m, a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = m[0] ? a[0] : b[0];
        dst[1] = m[1] ? a[1] : b[1];
        dst[2] = m[2] ? a[2] : b[2];
        dst[3] = m[3] ? a[3] : b[3];

        return dst;
    },

    // Vector4 operations with scalar
    v4ScalarBuild : function v4ScalarBuildFn(a, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a;
        dst[1] = a;
        dst[2] = a;
        dst[3] = a;

        return dst;
    },

    v4ScalarMax : function v4ScalarMaxFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var max = Math.max;
        dst[0] = max(a[0], b);
        dst[1] = max(a[1], b);
        dst[2] = max(a[2], b);
        dst[3] = max(a[3], b);

        return dst;
    },

    v4ScalarMin : function v4ScalarMinFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var min = Math.min;
        dst[0] = min(a[0], b);
        dst[1] = min(a[1], b);
        dst[2] = min(a[2], b);
        dst[3] = min(a[3], b);

        return dst;
    },

    v4ScalarAdd : function v4ScalarAddFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] + b);
        dst[1] = (a[1] + b);
        dst[2] = (a[2] + b);
        dst[3] = (a[3] + b);

        return dst;
    },

    v4ScalarSub : function v4ScalarSubFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = (a[0] - b);
        dst[1] = (a[1] - b);
        dst[2] = (a[2] - b);
        dst[3] = (a[3] - b);

        return dst;
    },

    v4ScalarMul : function v4ScalarMulFn(a, b, dst)
    {
        if (b === 0)
        {
            return VMath.v4BuildZero(dst);
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(4);
            }

            dst[0] = (a[0] * b);
            dst[1] = (a[1] * b);
            dst[2] = (a[2] * b);
            dst[3] = (a[3] * b);

            return dst;
        }
    },

    v4AddScalarMul : function v4AddScalarMulFn(a, b, c, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = a[0] + b[0] * c;
        dst[1] = a[1] + b[1] * c;
        dst[2] = a[2] + b[2] * c;
        dst[3] = a[3] + b[3] * c;

        return dst;
    },

    v4ScalarEqual : function v4ScalarEqualFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return (abs(a[0] - b) <= precision &&
                abs(a[1] - b) <= precision &&
                abs(a[2] - b) <= precision &&
                abs(a[3] - b) <= precision);
    },

    // Vector3 'masks' with scalars
    v4EqualScalarMask : function v4EqualScalarMaskFn(a, b)
    {
        var abs = Math.abs;
        var precision = VMath.precision;
        return [(abs(a[0] - b) <= precision),
                (abs(a[1] - b) <= precision),
                (abs(a[2] - b) <= precision),
                (abs(a[3] - b) <= precision)];
    },

    v4LessScalarMask : function v4LessScalarMaskFn(a, b)
    {
        return [(a[0] < b),
                (a[1] < b),
                (a[2] < b),
                (a[3] < b)];
    },

    v4GreaterScalarMask : function v4GreaterScalarMaskFn(a, b)
    {
        return [(a[0] > b),
                (a[1] > b),
                (a[2] > b),
                (a[3] > b)];
    },

    v4GreaterEqScalarMask : function v4GreaterEqScalarMaskFn(a, b)
    {
        return [(a[0] >= b),
                (a[1] >= b),
                (a[2] >= b),
                (a[3] >= b)];
    },

    v4Lerp : function v4LerpFn(a, b, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = (a[0] + ((b[0] - a[0]) * t));
        dst[1] = (a[1] + ((b[1] - a[1]) * t));
        dst[2] = (a[2] + ((b[2] - a[2]) * t));
        dst[3] = (a[3] + ((b[3] - a[3]) * t));
        return dst;
    },

    //
    // AABB
    //

    aabbBuild : function aabbBuildFn(a0, a1, a2, a3, a4, a5, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = a0;
        dst[1] = a1;
        dst[2] = a2;
        dst[3] = a3;
        dst[4] = a4;
        dst[5] = a5;

        return dst;
    },

    aabbBuildEmpty : function aabbBuildEmptyFn(dst)
    {
        var float_max = this.FLOAT_MAX;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = float_max;
        dst[1] = float_max;
        dst[2] = float_max;
        dst[3] = -float_max;
        dst[4] = -float_max;
        dst[5] = -float_max;

        return dst;
    },

    aabbCopy : function aabbCopyFn(aabb, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = aabb[0];
        dst[1] = aabb[1];
        dst[2] = aabb[2];
        dst[3] = aabb[3];
        dst[4] = aabb[4];
        dst[5] = aabb[5];

        return dst;
    },

    aabbSet : function aabbSet(dst, src)
    {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        dst[4] = src[4];
        dst[5] = src[5];
    },

    aabbIsEmpty : function aabbIsEmptyFn(aabb)
    {
        return aabb[0] > aabb[3];
    },

    aabbMin : function aabbMinFn(aabb, dst)
    {
        if (dst === undefined)
        {
            return aabb.slice(0, 3);
        }
        dst[0] = aabb[0];
        dst[1] = aabb[1];
        dst[2] = aabb[2];
        return dst;
    },

    aabbMax : function aabbMaxFn(aabb, dst)
    {
        if (dst === undefined)
        {
            return aabb.slice(3, 6);
        }
        dst[0] = aabb[3];
        dst[1] = aabb[4];
        dst[2] = aabb[5];
        return dst;
    },

    aabbGetCenterAndHalf : function aabbGetCenterAndHalfFn(aabb, center, half)
    {
        var cX = (aabb[0] + aabb[3]) * 0.5;
        var cY = (aabb[1] + aabb[4]) * 0.5;
        var cZ = (aabb[2] + aabb[5]) * 0.5;

        center[0] = cX;
        center[1] = cY;
        center[2] = cZ;

        half[0] = aabb[3] - cX;
        half[1] = aabb[4] - cY;
        half[2] = aabb[5] - cZ;
    },

    aabbIsInsidePlanes : function aabbIsInsidePlanesFn(aabb, planes)
    {
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? aabb[0] : aabb[3]) + d1 * (d1 < 0 ? aabb[1] : aabb[4]) + d2 * (d2 < 0 ? aabb[2] : aabb[5])) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    aabbIsFullyInsidePlanes : function aabbIsFullyInsidePlanesFn(aabb, planes)
    {
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? aabb[0] : aabb[3]) + d1 * (d1 > 0 ? aabb[1] : aabb[4]) + d2 * (d2 > 0 ? aabb[2] : aabb[5])) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    aabbUnion : function aabbUnionFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = a[0] < b[0] ? a[0] : b[0];
        dst[1] = a[1] < b[1] ? a[1] : b[1];
        dst[2] = a[2] < b[2] ? a[2] : b[2];
        dst[3] = a[3] > b[3] ? a[3] : b[3];
        dst[4] = a[4] > b[4] ? a[4] : b[4];
        dst[5] = a[5] > b[5] ? a[5] : b[5];

        return dst;
    },

    aabbUnionArray : function aabbUnionArrayFn(aabbArray, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }
        VMath.aabbCopy(aabbArray[0], dst);

        var numAABBs = aabbArray.length;
        for (var i = 0; i < numAABBs; i += 1)
        {
            var aabb = aabbArray[i];
            dst[0] = (dst[0] < aabb[0] ? dst[0] : aabb[0]);
            dst[1] = (dst[1] < aabb[1] ? dst[1] : aabb[1]);
            dst[2] = (dst[2] < aabb[2] ? dst[2] : aabb[2]);
            dst[3] = (dst[3] > aabb[3] ? dst[3] : aabb[3]);
            dst[4] = (dst[4] > aabb[4] ? dst[4] : aabb[4]);
            dst[5] = (dst[5] > aabb[5] ? dst[5] : aabb[5]);
        }

        return dst;
    },

    aabbAddPoints : function aabbAddPointFn(aabb, ps)
    {
        var i;
        var numPoints = ps.length;

        var r0 = aabb[0];
        var r1 = aabb[1];
        var r2 = aabb[2];
        var r3 = aabb[3];
        var r4 = aabb[4];
        var r5 = aabb[5];

        var p0, p1, p2;

        for (i = 0; i < numPoints; i += 1)
        {
            p0 = ps[i][0];
            p1 = ps[i][1];
            p2 = ps[i][2];

            r0 = (r0 < p0 ? r0 : p0);
            r1 = (r1 < p1 ? r1 : p1);
            r2 = (r2 < p2 ? r2 : p2);
            r3 = (r3 > p0 ? r3 : p0);
            r4 = (r4 > p1 ? r4 : p1);
            r5 = (r5 > p2 ? r5 : p2);
        }

        aabb[0] = r0;
        aabb[1] = r1;
        aabb[2] = r2;
        aabb[3] = r3;
        aabb[4] = r4;
        aabb[5] = r5;

    },

    aabbTransform : function aabbTransformFn(aabb, matrix, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        var cX = (aabb[0] + aabb[3]) * 0.5;
        var cY = (aabb[1] + aabb[4]) * 0.5;
        var cZ = (aabb[2] + aabb[5]) * 0.5;

        var hX = aabb[3] - cX;
        var hY = aabb[4] - cY;
        var hZ = aabb[5] - cZ;

        var m0 = matrix[0];
        var m1 = matrix[1];
        var m2 = matrix[2];
        var m3 = matrix[3];
        var m4 = matrix[4];
        var m5 = matrix[5];
        var m6 = matrix[6];
        var m7 = matrix[7];
        var m8 = matrix[8];

        var ctX = matrix[9] +  (m0 * cX + m3 * cY + m6 * cZ);
        var ctY = matrix[10] + (m1 * cX + m4 * cY + m7 * cZ);
        var ctZ = matrix[11] + (m2 * cX + m5 * cY + m8 * cZ);

        var abs = Math.abs;

        var htX = (abs(m0) * hX + abs(m3) * hY + abs(m6) * hZ);
        var htY = (abs(m1) * hX + abs(m4) * hY + abs(m7) * hZ);
        var htZ = (abs(m2) * hX + abs(m5) * hY + abs(m8) * hZ);

        dst[0] = ctX - htX;
        dst[1] = ctY - htY;
        dst[2] = ctZ - htZ;
        dst[3] = ctX + htX;
        dst[4] = ctY + htY;
        dst[5] = ctZ + htZ;

        return dst;
    },

    aabbIntercept : function aabbInterceptFn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(6);
        }

        dst[0] = a[0] > b[0] ? a[0] : b[0];
        dst[1] = a[1] > b[1] ? a[1] : b[1];
        dst[2] = a[2] > b[2] ? a[2] : b[2];
        dst[3] = a[3] < b[3] ? a[3] : b[3];
        dst[4] = a[4] < b[4] ? a[4] : b[4];
        dst[5] = a[5] < b[5] ? a[5] : b[5];

        return dst;
    },

    aabbOverlaps : function aabbOverlapsFn(a, b)
    {
        return ((a[0] <= b[3]) &&
                (a[1] <= b[4]) &&
                (a[2] <= b[5]) &&
                (a[3] >= b[0]) &&
                (a[4] >= b[1]) &&
                (a[5] >= b[2]));
    },

    aabbSphereOverlaps : function aabbSphereOverlapsFn(aabb, center, radius)
    {
        var centerX = center[0];
        var centerY = center[1];
        var centerZ = center[2];
        var radiusSquared = radius * radius;

        var minX = aabb[0];
        var minY = aabb[1];
        var minZ = aabb[2];
        var maxX = aabb[3];
        var maxY = aabb[4];
        var maxZ = aabb[5];
        var totalDistance = 0, sideDistance;

        if (centerX < minX)
        {
            sideDistance = (minX - centerX);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerX > maxX)
        {
            sideDistance = (centerX - maxX);
            totalDistance += (sideDistance * sideDistance);
        }
        if (centerY < minY)
        {
            sideDistance = (minY - centerY);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerY > maxY)
        {
            sideDistance = (centerY - maxY);
            totalDistance += (sideDistance * sideDistance);
        }
        if (centerZ < minZ)
        {
            sideDistance = (minZ - centerZ);
            totalDistance += (sideDistance * sideDistance);
        }
        else if (centerZ > maxZ)
        {
            sideDistance = (centerZ - maxZ);
            totalDistance += (sideDistance * sideDistance);
        }
        return (totalDistance <= radiusSquared);
    },

    aabbIsInside : function aabbIsInsideFn(a, b)
    {
        return ((a[0] >= b[0]) &&
                (a[1] >= b[1]) &&
                (a[2] >= b[2]) &&
                (a[3] <= b[3]) &&
                (a[4] <= b[4]) &&
                (a[5] <= b[5]));
    },

    aabbTestInside : function aabbTestInsideFn(a, b)
    {
        if ((a[0] <= b[3]) &&
            (a[1] <= b[4]) &&
            (a[2] <= b[5]) &&
            (a[3] >= b[0]) &&
            (a[4] >= b[1]) &&
            (a[5] >= b[2]))
        {

            if ((a[0] >= b[0]) &&
                (a[1] >= b[1]) &&
                (a[2] >= b[2]) &&
                (a[3] <= b[3]) &&
                (a[4] <= b[4]) &&
                (a[5] <= b[5]))
            {
                return 2;
            }
            return 1;
        }

        return 0;
    },

    //
    // Matrix
    //
    m33BuildIdentity : function m33BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        dst[4] = 1.0;
        dst[5] = 0.0;
        dst[6] = 0.0;
        dst[7] = 0.0;
        dst[8] = 1.0;

        return dst;
    },

    // Matrix33
    m33Build : function m33BuildFn(r, u, a, dst)
    {
        var length = arguments.length;
        if (length >= 9)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 9)
            {
                res = arguments[9];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(9);
                }
            }
            else
            {
                res = new VMathArrayConstructor(9);
            }

            res[0] = arguments[0];
            res[1] = arguments[1];
            res[2] = arguments[2];
            res[3] = arguments[3];
            res[4] = arguments[4];
            res[5] = arguments[5];
            res[6] = arguments[6];
            res[7] = arguments[7];
            res[8] = arguments[8];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(9);
            }

            dst[0] = r[0];
            dst[1] = r[1];
            dst[2] = r[2];
            dst[3] = u[0];
            dst[4] = u[1];
            dst[5] = u[2];
            dst[6] = a[0];
            dst[7] = a[1];
            dst[8] = a[2];

            return dst;
        }
    },

    m33Copy : function m33CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];

        return dst;
    },

    m33FromAxisRotation : function m33FromAxisRotationFn(axis, angle, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;

        dst[0] = tx * axisX + c;
        dst[1] = tx * axisY - sz;
        dst[2] = tx * axisZ + sy;
        dst[3] = ty * axisX + sz;
        dst[4] = ty * axisY + c;
        dst[5] = ty * axisZ - sx;
        dst[6] = tz * axisX - sy;
        dst[7] = tz * axisY + sx;
        dst[8] = tz * axisZ + c;

        return dst;
    },

    m33FromQuat: function m33FromQuatFn(q, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var qx = q[0];
        var qy = q[1];
        var qz = q[2];
        var qw = q[3];

        var xx = 2.0 * qx * qx;
        var yy = 2.0 * qy * qy;
        var zz = 2.0 * qz * qz;
        var xy = 2.0 * qx * qy;
        var zw = 2.0 * qz * qw;
        var xz = 2.0 * qx * qz;
        var yw = 2.0 * qy * qw;
        var yz = 2.0 * qy * qz;
        var xw = 2.0 * qx * qw;

        dst[0] = 1.0 - yy - zz;
        dst[1] = xy - zw;
        dst[2] = xz + yw;
        dst[3] = xy + zw;
        dst[4] = 1.0 - xx - zz;
        dst[5] = yz - xw;
        dst[6] = xz - yw;
        dst[7] = yz + xw;
        dst[8] = 1.0 - xx - yy;

        return dst;
    },

    m33Right : function m33RightFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        return dst;
    },

    m33Up : function m33UpFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[3];
        dst[1] = m[4];
        dst[2] = m[5];
        return dst;
    },

    m33At : function m33AtFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[6];
        dst[1] = m[7];
        dst[2] = m[8];
        return dst;
    },

    m33SetRight : function m33SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
    },

    m33SetUp : function m33SetUpFn(m, v)
    {
        m[3] = v[0];
        m[4] = v[1];
        m[5] = v[2];
    },

    m33SetAt : function m33SetAtFn(m, v)
    {
        m[6] = v[0];
        m[7] = v[1];
        m[8] = v[2];
    },

    m33Transpose : function m33TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        dst[0] = m0;
        dst[1] = m3;
        dst[2] = m6;
        dst[3] = m1;
        dst[4] = m4;
        dst[5] = m7;
        dst[6] = m2;
        dst[7] = m5;
        dst[8] = m8;
        return dst;
    },

    m33Determinant : function m33DeterminantFn(m)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        return (m0 * (m4 * m8 - m5 * m7) +
                m1 * (m5 * m6 - m3 * m8) +
                m2 * (m3 * m7 - m4 * m6));
    },

    m33Inverse : function m33InverseFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var det = VMath.m33Determinant(m);
        if (det === 0.0)
        {
            dst[0] = dst[1] = dst[2] = 0.0;
            dst[3] = dst[4] = dst[5] = 0.0;
            dst[6] = dst[7] = dst[8] = 0.0;
            return dst;
        }
        else
        {
            var m0 = m[0];
            var m1 = m[1];
            var m2 = m[2];
            var m3 = m[3];
            var m4 = m[4];
            var m5 = m[5];
            var m6 = m[6];
            var m7 = m[7];
            var m8 = m[8];

            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[1] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[2] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[3] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[5] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[6] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[7] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            return dst;
        }
    },

    m33InverseTranspose : function m33InverseTransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var det = (m0 * (m4 * m8 - m5 * m7) +
                   m1 * (m5 * m6 - m3 * m8) +
                   m2 * (m3 * m7 - m4 * m6));
        if (det === 0.0)
        {
            dst[0] = dst[1] = dst[2] = 0.0;
            dst[3] = dst[4] = dst[5] = 0.0;
            dst[6] = dst[7] = dst[8] = 0.0;
            return dst;
        }
        else
        {
            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[3] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[6] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[1] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[7] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[2] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[5] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            return dst;
        }
    },

    m33Mul : function m33MulFn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        dst[0] = (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] = (b1 * a0 + b4 * a1 + b7 * a2);
        dst[2] = (b2 * a0 + b5 * a1 + b8 * a2);

        dst[3] = (b0 * a3 + b3 * a4 + b6 * a5);
        dst[4] = (b1 * a3 + b4 * a4 + b7 * a5);
        dst[5] = (b2 * a3 + b5 * a4 + b8 * a5);

        dst[6] = (b0 * a6 + b3 * a7 + b6 * a8);
        dst[7] = (b1 * a6 + b4 * a7 + b7 * a8);
        dst[8] = (b2 * a6 + b5 * a7 + b8 * a8);

        return dst;
    },

    m33Transform : function m33TransformFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2);
        return dst;
    },

    m33Equal : function m33EqualFn(a, b, precision)
    {
        var abs = Math.abs;
        if (precision === undefined)
        {
            precision = this.precision;
        }
        return (abs(a[0] - b[0]) <= precision &&
                abs(a[1] - b[1]) <= precision &&
                abs(a[2] - b[2]) <= precision &&
                abs(a[3] - b[3]) <= precision &&
                abs(a[4] - b[4]) <= precision &&
                abs(a[5] - b[5]) <= precision &&
                abs(a[6] - b[6]) <= precision &&
                abs(a[7] - b[7]) <= precision &&
                abs(a[8] - b[8]) <= precision);
    },

    m33MulM43 : function m33MulM43Fn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];

        dst[0] = b0 * a0 + b3 * a1 + b6 * a2;
        dst[1] = b1 * a0 + b4 * a1 + b7 * a2;
        dst[2] = b2 * a0 + b5 * a1 + b8 * a2;

        dst[3] = b0 * a3 + b3 * a4 + b6 * a5;
        dst[4] = b1 * a3 + b4 * a4 + b7 * a5;
        dst[5] = b2 * a3 + b5 * a4 + b8 * a5;

        dst[6] = b0 * a6 + b3 * a7 + b6 * a8;
        dst[7] = b1 * a6 + b4 * a7 + b7 * a8;
        dst[8] = b2 * a6 + b5 * a7 + b8 * a8;

        dst[9] = b[9];
        dst[10] = b[10];
        dst[11] = b[11];

        return dst;
    },

    m33MulM44 : function m33MulM44Fn(a, b, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];
        var b9  = b[9];
        var b10 = b[10];
        var b11 = b[11];


        dst[0] = b0 * a0 + b4 * a1 + b8  * a2;
        dst[1] = b1 * a0 + b5 * a1 + b9  * a2;
        dst[2] = b2 * a0 + b6 * a1 + b10 * a2;
        dst[3] = b3 * a0 + b7 * a1 + b11 * a2;

        dst[4] = b0 * a3 + b4 * a4 + b8  * a5;
        dst[5] = b1 * a3 + b5 * a4 + b9  * a5;
        dst[6] = b2 * a3 + b6 * a4 + b10 * a5;
        dst[7] = b3 * a3 + b7 * a4 + b11 * a5;

        dst[8] = b0 * a6 + b4 * a7 + b8  * a8;
        dst[9] = b1 * a6 + b5 * a7 + b9  * a8;
        dst[10] = b2 * a6 + b6 * a7 + b10 * a8;
        dst[11] = b3 * a6 + b7 * a7 + b11 * a8;

        dst[12] = b[12];
        dst[13] = b[13];
        dst[14] = b[14];
        dst[15] = b[15];

        return dst;
    },

    // Matrix3 operations with scalar
    m33ScalarAdd : function m33ScalarAddFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }
        for (var n = 0; n < 9; n += 1)
        {
            dst[n] = (m[n] + s);
        }
        return dst;
    },

    m33ScalarSub : function m33ScalarSubFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }
        for (var n = 0; n < 9; n += 1)
        {
            dst[n] = (m[n] - s);
        }
        return dst;
    },

    m33ScalarMul : function m33ScalarMulFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(9);
        }

        for (var n = 0; n < 9; n += 1)
        {
            dst[n] = (m[n] * s);
        }

        return dst;
    },

    // Matrix34
    m34BuildIdentity : function m34BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        dst[0] = 1.0;
        dst[5] = 1.0;
        dst[10] = 1.0;
        return dst;
    },

    m34Pos : function m34PosFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[3];
        dst[1] = m[7];
        dst[2] = m[11];
        return dst;
    },

    m34Scale : function m34ScaleFn(m, scale, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        dst[0] = m[0] * sx;
        dst[1] = m[1] * sx;
        dst[2] = m[2] * sx;
        dst[3] = m[3];

        dst[4] = m[4] * sy;
        dst[5] = m[5] * sy;
        dst[6] = m[6] * sy;
        dst[7] = m[7];

        dst[8] = m[8] * sz;
        dst[9] = m[9] * sz;
        dst[10] = m[10] * sz;
        dst[11] = m[11];

        return dst;
    },

    // Matrix43
    m43BuildIdentity : function m43BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        dst[0] = 1.0;
        dst[1] = 0.0;
        dst[2] = 0.0;
        dst[3] = 0.0;
        dst[4] = 1.0;
        dst[5] = 0.0;
        dst[6] = 0.0;
        dst[7] = 0.0;
        dst[8] = 1.0;
        dst[9] = 0.0;
        dst[10] = 0.0;
        dst[11] = 0.0;
        return dst;
    },

    m43Build : function m43BuildFn(r, u, a, p, dst)
    {
        var length = arguments.length;
        if (length >= 12)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 12)
            {
                res = arguments[12];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(12);
                }
            }
            else
            {
                res = new VMathArrayConstructor(12);
            }

            res[0] = arguments[0];
            res[1] = arguments[1];
            res[2] = arguments[2];
            res[3] = arguments[3];
            res[4] = arguments[4];
            res[5] = arguments[5];
            res[6] = arguments[6];
            res[7] = arguments[7];
            res[8] = arguments[8];
            res[9] = arguments[9];
            res[10] = arguments[10];
            res[11] = arguments[11];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(12);
            }

            dst[0] = r[0];
            dst[1] = r[1];
            dst[2] = r[2];
            dst[3] = u[0];
            dst[4] = u[1];
            dst[5] = u[2];
            dst[6] = a[0];
            dst[7] = a[1];
            dst[8] = a[2];
            dst[9] = p[0];
            dst[10] = p[1];
            dst[11] = p[2];

            return dst;
        }
    },

    m43BuildTranslation : function m43BuildTranslationFn(p, dst)
    {
        // Can NOT use p or dst because it will overwrite the input value...
        var res, a;

        var length = arguments.length;
        if (length >= 3)
        {
            a = arguments;
            if (length === 4)
            {
                res = arguments[3];
            }
        }
        else
        {
            a = p;
            res = dst;
        }

        if (res === undefined)
        {
            res = new VMathArrayConstructor(12);
        }

        res[0] = 1;
        res[1] = 0;
        res[2] = 0;
        res[3] = 0;
        res[4] = 1;
        res[5] = 0;
        res[6] = 0;
        res[7] = 0;
        res[8] = 1;
        res[9] = a[0];
        res[10] = a[1];
        res[11] = a[2];

        return res;
    },

    m43Copy : function m43CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];
        dst[9] = m[9];
        dst[10] = m[10];
        dst[11] = m[11];

        return dst;
    },

    m43FromM33V3: function m43FromM33V3Fn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        dst[4] = m[4];
        dst[5] = m[5];
        dst[6] = m[6];
        dst[7] = m[7];
        dst[8] = m[8];
        dst[9] = v[0];
        dst[10] = v[1];
        dst[11] = v[2];

        return dst;
    },

    m43FromAxisRotation : function m43FromAxisRotationFn(axis, angle, dst)
    {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = tx * axisX + c;
        dst[1] = tx * axisY - sz;
        dst[2] = tx * axisZ + sy;

        dst[3] = ty * axisX + sz;
        dst[4] = ty * axisY + c;
        dst[5] = ty * axisZ - sx;

        dst[6] = tz * axisX - sy;
        dst[7] = tz * axisY + sx;
        dst[8] = tz * axisZ + c;

        dst[9] = 0.0;
        dst[10] = 0.0;
        dst[11] = 0.0;

        return dst;
    },

    m43FromQuatPos : function m43FromQuatPosFn(qp, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var qx = qp[0];
        var qy = qp[1];
        var qz = qp[2];
        var qw = qp[3];
        var px = qp[4];
        var py = qp[5];
        var pz = qp[6];

        var xx = 2.0 * qx * qx;
        var yy = 2.0 * qy * qy;
        var zz = 2.0 * qz * qz;
        var xy = 2.0 * qx * qy;
        var zw = 2.0 * qz * qw;
        var xz = 2.0 * qx * qz;
        var yw = 2.0 * qy * qw;
        var yz = 2.0 * qy * qz;
        var xw = 2.0 * qx * qw;

        dst[0] = 1.0 - yy - zz;
        dst[1] = xy - zw;
        dst[2] = xz + yw;

        dst[3] = xy + zw;
        dst[4] = 1.0 - xx - zz;
        dst[5] = yz - xw;

        dst[6] = xz - yw;
        dst[7] = yz + xw;
        dst[8] = 1.0 - xx - yy;

        dst[9] = px;
        dst[10] = py;
        dst[11] = pz;

        return dst;
    },

    m43FromRTS : function m43FromRTSFn(quat, pos, scale, dst)
    {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];

        var xx = (2.0 * qx * qx);
        var yy = (2.0 * qy * qy);
        var zz = (2.0 * qz * qz);
        var xy = (2.0 * qx * qy);
        var zw = (2.0 * qz * qw);
        var xz = (2.0 * qx * qz);
        var yw = (2.0 * qy * qw);
        var yz = (2.0 * qy * qz);
        var xw = (2.0 * qx * qw);

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = sx * (1.0 - yy - zz);
        dst[1] = sx * (xy - zw);
        dst[2] = sx * (xz + yw);
        dst[3] = sy * (xy + zw);
        dst[4] = sy * (1.0 - xx - zz);
        dst[5] = sy * (yz - xw);
        dst[6] = sz * (xz - yw);
        dst[7] = sz * (yz + xw);
        dst[8] = sz * (1.0 - xx - yy);
        dst[9]  = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43FromRT : function m43FromRTFn(quat, pos, dst)
    {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];

        var xx = (2.0 * qx * qx);
        var yy = (2.0 * qy * qy);
        var zz = (2.0 * qz * qz);
        var xy = (2.0 * qx * qy);
        var zw = (2.0 * qz * qw);
        var xz = (2.0 * qx * qz);
        var yw = (2.0 * qy * qw);
        var yz = (2.0 * qy * qz);
        var xw = (2.0 * qx * qw);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  1.0 - yy - zz;
        dst[1] =  xy - zw;
        dst[2] =  xz + yw;
        dst[3] =  xy + zw;
        dst[4] =  1.0 - xx - zz;
        dst[5] =  yz - xw;
        dst[6] =  xz - yw;
        dst[7] =  yz + xw;
        dst[8] =  1.0 - xx - yy;
        dst[9]  = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43Right : function m43RightFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        return dst;
    },

    m43Up : function m43UpFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[3];
        dst[1] = m[4];
        dst[2] = m[5];
        return dst;
    },

    m43At : function m43AtFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[6];
        dst[1] = m[7];
        dst[2] = m[8];
        return dst;
    },

    m43Pos : function m43PosFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = m[9];
        dst[1] = m[10];
        dst[2] = m[11];
        return dst;
    },

    m43SetRight : function m43SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
    },

    m43SetUp : function m43SetUpFn(m, v)
    {
        m[3] = v[0];
        m[4] = v[1];
        m[5] = v[2];
    },

    m43SetAt : function m43SetAtFn(m, v)
    {
        m[6] = v[0];
        m[7] = v[1];
        m[8] = v[2];
    },

    m43SetPos : function m43SetPosFn(m, v)
    {
        m[9] = v[0];
        m[10] = v[1];
        m[11] = v[2];
    },

    m43SetAxisRotation : function m43SetAxisRotationFn(m, axis, angle)
    {
        var s = Math.sin(angle);
        var c = Math.cos(angle);
        var t = 1.0 - c;
        var axisX = axis[0];
        var axisY = axis[1];
        var axisZ = axis[2];
        var tx = t * axisX;
        var ty = t * axisY;
        var tz = t * axisZ;
        var sx = s * axisX;
        var sy = s * axisY;
        var sz = s * axisZ;
        m[0] = tx * axisX + c;
        m[1] = tx * axisY - sz;
        m[2] = tx * axisZ + sy;
        m[3] = ty * axisX + sz;
        m[4] = ty * axisY + c;
        m[5] = ty * axisZ - sx;
        m[6] = tz * axisX - sy;
        m[7] = tz * axisY + sx;
        m[8] = tz * axisZ + c;
    },

    m43InverseOrthonormal : function m43InverseOrthonormalFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var px = m[9];
        var py = m[10];
        var pz = m[11];
        dst[0] = m0;
        dst[1] = m3;
        dst[2] = m6;
        dst[3] = m1;
        dst[4] = m4;
        dst[5] = m7;
        dst[6] = m2;
        dst[7] = m5;
        dst[8] = m8;
        dst[9]  = -((px * m0) + (py * m1) + (pz * m2));
        dst[10] = -((px * m3) + (py * m4) + (pz * m5));
        dst[11] = -((px * m6) + (py * m7) + (pz * m8));
        return dst;
    },

    m43Orthonormalize : function m43OrthonormalizeFn(m, dst)
    {
        var normalize = VMath.v3Normalize;
        var length    = VMath.v3Length;
        var dot       = VMath.v3Dot;
        var cross     = VMath.v3Cross;
        var abs       = Math.abs;

        var right = VMath.m43Right(m);
        var up    = VMath.m43Up(m);
        var at    = VMath.m43At(m);
        var pos   = VMath.m43Pos(m);

        var innerX = length(right);
        var innerY = length(up);
        var innerZ = length(at);

        normalize(right, right);
        normalize(up, up);
        normalize(at, at);

        var vpU, vpV, vpW;
        if (innerX > 0.0)
        {
            if (innerY > 0.0)
            {
                if (innerZ > 0.0)
                {
                    var outerX = abs(dot(up, at));
                    var outerY = abs(dot(at, right));
                    var outerZ = abs(dot(right, up));
                    if (outerX < outerY)
                    {
                        if (outerX < outerZ)
                        {
                            vpU = up;
                            vpV = at;
                            vpW = right;
                        }
                        else
                        {
                            vpU = right;
                            vpV = up;
                            vpW = at;
                        }
                    }
                    else
                    {
                        if (outerY < outerZ)
                        {
                            vpU = at;
                            vpV = right;
                            vpW = up;
                        }
                        else
                        {
                            vpU = right;
                            vpV = up;
                            vpW = at;
                        }
                    }
                }
                else
                {
                    vpU = right;
                    vpV = up;
                    vpW = at;
                }
            }
            else
            {
                vpU = at;
                vpV = right;
                vpW = up;
            }
        }
        else
        {
            vpU = up;
            vpV = at;
            vpW = right;
        }

        cross(vpU, vpV, vpW);
        normalize(vpW, vpW);

        cross(vpW, vpU, vpV);
        normalize(vpV, vpV);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] = right[0];
        dst[1] = right[1];
        dst[2] = right[2];
        dst[3] = up[0];
        dst[4] = up[1];
        dst[5] = up[2];
        dst[6] = at[0];
        dst[7] = at[1];
        dst[8] = at[2];
        dst[9] = pos[0];
        dst[10] = pos[1];
        dst[11] = pos[2];

        return dst;
    },

    m43Determinant : function m43DeterminantFn(m)
    {
        return (m[0] * (m[4] * m[8] - m[5] * m[7]) +
                m[1] * (m[5] * m[6] - m[3] * m[8]) +
                m[2] * (m[3] * m[7] - m[4] * m[6]));
    },

    m43Inverse : function m43InverseFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var det = (m0 * (m4 * m8 - m5 * m7) +
                   m1 * (m5 * m6 - m3 * m8) +
                   m2 * (m3 * m7 - m4 * m6));
        if (det === 0.0)
        {
            return dst;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(12);
            }
            var detrecp = 1.0 / det;
            dst[0] = ((m4 * m8 + m5 * (-m7)) * detrecp);
            dst[1] = ((m7 * m2 + m8 * (-m1)) * detrecp);
            dst[2] = ((m1 * m5 - m2 *   m4)  * detrecp);
            dst[3] = ((m5 * m6 + m3 * (-m8)) * detrecp);
            dst[4] = ((m8 * m0 + m6 * (-m2)) * detrecp);
            dst[5] = ((m3 * m2 - m0 *   m5)  * detrecp);
            dst[6] = ((m3 * m7 + m4 * (-m6)) * detrecp);
            dst[7] = ((m6 * m1 + m7 * (-m0)) * detrecp);
            dst[8] = ((m0 * m4 - m3 *   m1)  * detrecp);
            dst[9]  = ((m3 * (m10 * m8  - m7 * m11) + m4  * (m6 * m11 - m9 * m8) + m5  * (m9 * m7 - m6 * m10)) * detrecp);
            dst[10] = ((m6 * (m2  * m10 - m1 * m11) + m7  * (m0 * m11 - m9 * m2) + m8  * (m9 * m1 - m0 * m10)) * detrecp);
            dst[11] = ((m9 * (m2  * m4  - m1 * m5)  + m10 * (m0 * m5  - m3 * m2) + m11 * (m3 * m1 - m0 * m4))  * detrecp);
            return dst;
        }
    },

    m43Translate : function m43TranslateFn(matrix, pos)
    {
        matrix[9]  += pos[0];
        matrix[10] += pos[1];
        matrix[11] += pos[2];
    },

    m43Scale : function m43ScaleFn(m, scale, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var sx = scale[0];
        var sy = scale[1];
        var sz = scale[2];

        dst[0] = m[0] * sx;
        dst[1] = m[1] * sx;
        dst[2] = m[2] * sx;
        dst[3] = m[3] * sy;
        dst[4] = m[4] * sy;
        dst[5] = m[5] * sy;
        dst[6] = m[6] * sz;
        dst[7] = m[7] * sz;
        dst[8] = m[8] * sz;
        dst[9] = m[9];
        dst[10] = m[10];
        dst[11] = m[11];

        return dst;
    },

    m43TransformVector : function m43TransformVectorFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2);
        return dst;
    },

    m43TransformPoint : function m43TransformPointFn(m, v, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        dst[0] = (m[0] * v0 + m[3] * v1 + m[6] * v2 + m[9]);
        dst[1] = (m[1] * v0 + m[4] * v1 + m[7] * v2 + m[10]);
        dst[2] = (m[2] * v0 + m[5] * v1 + m[8] * v2 + m[11]);
        return dst;
    },

    m43Mul : function m43MulFn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];
        var a9  = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] =  (b1 * a0 + b4 * a1 + b7 * a2);
        dst[2] =  (b2 * a0 + b5 * a1 + b8 * a2);
        dst[3] =  (b0 * a3 + b3 * a4 + b6 * a5);
        dst[4] =  (b1 * a3 + b4 * a4 + b7 * a5);
        dst[5] =  (b2 * a3 + b5 * a4 + b8 * a5);
        dst[6] =  (b0 * a6 + b3 * a7 + b6 * a8);
        dst[7] =  (b1 * a6 + b4 * a7 + b7 * a8);
        dst[8] =  (b2 * a6 + b5 * a7 + b8 * a8);
        dst[9]  = (b0 * a9 + b3 * a10 + b6 * a11 + b[9]);
        dst[10] = (b1 * a9 + b4 * a10 + b7 * a11 + b[10]);
        dst[11] = (b2 * a9 + b5 * a10 + b8 * a11 + b[11]);

        return dst;
    },

    m43MulM44 : function m43MulM44Fn(a, b, dst)
    {
        var a0  = a[0];
        var a1  = a[1];
        var a2  = a[2];
        var a3  = a[3];
        var a4  = a[4];
        var a5  = a[5];
        var a6  = a[6];
        var a7  = a[7];
        var a8  = a[8];
        var a9  = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0  = b[0];
        var b1  = b[1];
        var b2  = b[2];
        var b3  = b[3];
        var b4  = b[4];
        var b5  = b[5];
        var b6  = b[6];
        var b7  = b[7];
        var b8  = b[8];
        var b9  = b[9];
        var b10 = b[10];
        var b11 = b[11];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  (b0 * a0 + b4 * a1 + b8  * a2);
        dst[1] =  (b1 * a0 + b5 * a1 + b9  * a2);
        dst[2] =  (b2 * a0 + b6 * a1 + b10 * a2);
        dst[3] =  (b3 * a0 + b7 * a1 + b11 * a2);
        dst[4] =  (b0 * a3 + b4 * a4 + b8  * a5);
        dst[5] =  (b1 * a3 + b5 * a4 + b9  * a5);
        dst[6] =  (b2 * a3 + b6 * a4 + b10 * a5);
        dst[7] =  (b3 * a3 + b7 * a4 + b11 * a5);
        dst[8] =  (b0 * a6 + b4 * a7 + b8  * a8);
        dst[9]  = (b1 * a6 + b5 * a7 + b9  * a8);
        dst[10] = (b2 * a6 + b6 * a7 + b10 * a8);
        dst[11] = (b3 * a6 + b7 * a7 + b11 * a8);
        dst[12] = (b0 * a9 + b4 * a10 + b8  * a11 + b[12]);
        dst[13] = (b1 * a9 + b5 * a10 + b9  * a11 + b[13]);
        dst[14] = (b2 * a9 + b6 * a10 + b10 * a11 + b[14]);
        dst[15] = (b3 * a9 + b7 * a10 + b11 * a11 + b[15]);

        return dst;
    },

    m43Transpose : function m43TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        dst[0] =  m0;
        dst[1] =  m3;
        dst[2] =  m6;
        dst[3] =  m9;
        dst[4] =  m1;
        dst[5] =  m4;
        dst[6] =  m7;
        dst[7] =  m10;
        dst[8] =  m2;
        dst[9]  = m5;
        dst[10] = m8;
        dst[11] = m11;

        return dst;
    },

    m43MulTranspose: function m43MulTransposeFn(a, b, dst)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];
        var a9 = a[9];
        var a10 = a[10];
        var a11 = a[11];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];
        var b9 = b[9];
        var b10 = b[10];
        var b11 = b[11];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        dst[0] =  (b0 * a0 + b3 * a1 + b6 * a2);
        dst[1] =  (b0 * a3 + b3 * a4 + b6 * a5);
        dst[2] =  (b0 * a6 + b3 * a7 + b6 * a8);
        dst[3] =  (b0 * a9 + b3 * a10 + b6 * a11 + b9);
        dst[4] =  (b1 * a0 + b4 * a1 + b7 * a2);
        dst[5] =  (b1 * a3 + b4 * a4 + b7 * a5);
        dst[6] =  (b1 * a6 + b4 * a7 + b7 * a8);
        dst[7] =  (b1 * a9 + b4 * a10 + b7 * a11 + b10);
        dst[8] =  (b2 * a0 + b5 * a1 + b8 * a2);
        dst[9]  = (b2 * a3 + b5 * a4 + b8 * a5);
        dst[10] = (b2 * a6 + b5 * a7 + b8 * a8);
        dst[11] = (b2 * a9 + b5 * a10 + b8 * a11 + b11);

        return dst;
    },

    m43Offset: function m43OffsetFn(m, o, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var o0 = o[0];
        var o1 = o[1];
        var o2 = o[2];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  m3;
        dst[4] =  m4;
        dst[5] =  m5;
        dst[6] =  m6;
        dst[7] =  m7;
        dst[8] =  m8;
        dst[9]  = (m0 * o0 + m3 * o1 + m6 * o2 + m9);
        dst[10] = (m1 * o0 + m4 * o1 + m7 * o2 + m10);
        dst[11] = (m2 * o0 + m5 * o1 + m8 * o2 + m11);

        return dst;
    },

    m43NegOffset: function m43NegOffsetFn(m, o, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];

        var o0 = -o[0];
        var o1 = -o[1];
        var o2 = -o[2];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  m3;
        dst[4] =  m4;
        dst[5] =  m5;
        dst[6] =  m6;
        dst[7] =  m7;
        dst[8] =  m8;
        dst[9]  = (m0 * o0 + m3 * o1 + m6 * o2 + m9);
        dst[10] = (m1 * o0 + m4 * o1 + m7 * o2 + m10);
        dst[11] = (m2 * o0 + m5 * o1 + m8 * o2 + m11);

        return dst;
    },

    m43InverseTransposeProjection: function m43InverseTransposeProjectionFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }

        var xf = (0.5 / s[0]);
        var yf = (0.5 / s[1]);
        var zf = (0.5 / s[2]);
        var m0 = (m[0] * xf);
        var m1 = (m[1] * xf);
        var m2 = (m[2] * xf);
        var m3 = (m[3] * yf);
        var m4 = (m[4] * yf);
        var m5 = (m[5] * yf);
        var m6 = (m[6] * zf);
        var m7 = (m[7] * zf);
        var m8 = (m[8] * zf);
        var px = m[9];
        var py = m[10];
        var pz = m[11];

        dst[0] =  m0;
        dst[1] =  m1;
        dst[2] =  m2;
        dst[3] =  (0.5 - ((px * m0) + (py * m1) + (pz * m2)));
        dst[4] =  m3;
        dst[5] =  m4;
        dst[6] =  m5;
        dst[7] =  (0.5 - ((px * m3) + (py * m4) + (pz * m5)));
        dst[8] =  m6;
        dst[9]  = m7;
        dst[10] = m8;
        dst[11] = (0.5 - ((px * m6) + (py * m7) + (pz * m8)));

        return dst;
    },

    // Matrix 43 opeations with scalar
    m43ScalarAdd : function m43ScalarAddFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        for (var n = 0; n < 12; n += 1)
        {
            dst[n] = (m[n] + s);
        }
        return dst;
    },

    m43ScalarSub : function m43ScalarSubFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        for (var n = 0; n < 12; n += 1)
        {
            dst[n] = (m[n] - s);
        }
        return dst;
    },

    m43ScalarMul : function m43ScalarMulFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(12);
        }
        for (var n = 0; n < 12; n += 1)
        {
            dst[n] = (m[n] * s);
        }
        return dst;
    },

    // Matrix44
    m44BuildIdentity : function m44BuildIdentityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  1.0;
        dst[1] =  0.0;
        dst[2] =  0.0;
        dst[3] =  0.0;
        dst[4] =  0.0;
        dst[5] =  1.0;
        dst[6] =  0.0;
        dst[7] =  0.0;
        dst[8] =  0.0;
        dst[9] =  0.0;
        dst[10] = 1.0;
        dst[11] = 0.0;
        dst[12] = 0.0;
        dst[13] = 0.0;
        dst[14] = 0.0;
        dst[15] = 1.0;

        return dst;
    },

    m44Build : function m44BuildFn(r, u, a, p, dst)
    {
        var length = arguments.length;
        if (length >= 16)
        {
            // Can NOT use dst because it will overwrite the input value...
            var res;

            if (length > 16)
            {
                res = arguments[16];
                if (res === undefined)
                {
                    res = new VMathArrayConstructor(16);
                }
            }
            else
            {
                res = new VMathArrayConstructor(16);
            }

            res[0] =  arguments[0];
            res[1] =  arguments[1];
            res[2] =  arguments[2];
            res[3] =  arguments[3];
            res[4] =  arguments[4];
            res[5] =  arguments[5];
            res[6] =  arguments[6];
            res[7] =  arguments[7];
            res[8] =  arguments[8];
            res[9] =  arguments[9];
            res[10] = arguments[10];
            res[11] = arguments[11];
            res[12] = arguments[12];
            res[13] = arguments[13];
            res[14] = arguments[14];
            res[15] = arguments[15];

            return res;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(16);
            }

            dst[0] =  r[0];
            dst[1] =  r[1];
            dst[2] =  r[2];
            dst[3] =  r[3];
            dst[4] =  u[0];
            dst[5] =  u[1];
            dst[6] =  u[2];
            dst[7] =  u[3];
            dst[8] =  a[0];
            dst[9] =  a[1];
            dst[10] = a[2];
            dst[11] = a[3];
            dst[12] = p[0];
            dst[13] = p[1];
            dst[14] = p[2];
            dst[15] = p[3];

            return dst;
        }
    },

    m44Copy : function m44CopyFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] =  m[0];
        dst[1] =  m[1];
        dst[2] =  m[2];
        dst[3] =  m[3];
        dst[4] =  m[4];
        dst[5] =  m[5];
        dst[6] =  m[6];
        dst[7] =  m[7];
        dst[8] =  m[8];
        dst[9] =  m[9];
        dst[10] = m[10];
        dst[11] = m[11];
        dst[12] = m[12];
        dst[13] = m[13];
        dst[14] = m[14];
        dst[15] = m[15];

        return dst;
    },

    m44Right : function m44RightFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(0, 4);
        }

        dst[0] = m[0];
        dst[1] = m[1];
        dst[2] = m[2];
        dst[3] = m[3];
        return dst;
    },

    m44Up : function m44UpFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(4, 8);
        }

        dst[0] = m[4];
        dst[1] = m[5];
        dst[2] = m[6];
        dst[3] = m[7];
        return dst;
    },

    m44At : function m44AtFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(8, 12);
        }

        dst[0] = m[8];
        dst[1] = m[9];
        dst[2] = m[10];
        dst[3] = m[11];
        return dst;
    },

    m44Pos : function m44PosFn(m, dst)
    {
        if (dst === undefined)
        {
            return m.slice(12);
        }

        dst[0] = m[12];
        dst[1] = m[13];
        dst[2] = m[14];
        dst[3] = m[15];
        return dst;
    },

    m44SetRight : function m44SetRightFn(m, v)
    {
        m[0] = v[0];
        m[1] = v[1];
        m[2] = v[2];
        m[3] = v[3];
    },

    m44SetUp : function m44SetUpFn(m, v)
    {
        m[4] = v[0];
        m[5] = v[1];
        m[6] = v[2];
        m[7] = v[3];
    },

    m44SetAt : function m44SetAtFn(m, v)
    {
        m[8] = v[0];
        m[9] = v[1];
        m[10] = v[2];
        m[11] = v[3];
    },

    m44SetPos : function m44SetPosFn(m, v)
    {
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];
        m[15] = v[3];
    },

    m44Translate : function m44TranslateFn(m, v)
    {
        m[12] += v[0];
        m[13] += v[1];
        m[14] += v[2];
        m[15] += v[3];
    },

    m44Scale : function m44ScaleFn(m, scale, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        /*jshint white: false */
        dst[0] =  m[0]  * scale[0];
        dst[1] =  m[1]  * scale[0];
        dst[2] =  m[2]  * scale[0];
        dst[3] =  m[3];
        dst[4] =  m[4]  * scale[1];
        dst[5] =  m[5]  * scale[1];
        dst[6] =  m[6]  * scale[1];
        dst[7] =  m[7];
        dst[8] =  m[8]  * scale[2];
        dst[9] =  m[9]  * scale[2];
        dst[10] = m[10] * scale[2];
        dst[11] = m[11];
        dst[12] = m[12];
        dst[13] = m[13];
        dst[14] = m[14];
        dst[15] = m[15];
        /*jshint white: true */

        return dst;
    },

    m44Transform : function m44TransformFn(m, v, dst)
    {
        var v0 = v[0];
        var v1 = v[1];
        var v2 = v[2];
        var v3 = v[3];
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        if (v3 !== 1.0)
        {
            dst[0] = ((m[0] * v0) + (m[4] * v1) + (m[8]  * v2) + (m[12] * v3));
            dst[1] = ((m[1] * v0) + (m[5] * v1) + (m[9]  * v2) + (m[13] * v3));
            dst[2] = ((m[2] * v0) + (m[6] * v1) + (m[10] * v2) + (m[14] * v3));
            dst[3] = ((m[3] * v0) + (m[7] * v1) + (m[11] * v2) + (m[15] * v3));
        }
        else
        {
            dst[0] = ((m[0] * v0) + (m[4] * v1) + (m[8]  * v2) + m[12]);
            dst[1] = ((m[1] * v0) + (m[5] * v1) + (m[9]  * v2) + m[13]);
            dst[2] = ((m[2] * v0) + (m[6] * v1) + (m[10] * v2) + m[14]);
            dst[3] = ((m[3] * v0) + (m[7] * v1) + (m[11] * v2) + m[15]);
        }
        return dst;
    },

    m44Mul : function m44MulFn(a, b, dst)
    {
        var a0 = a[0];
        var a1 = a[1];
        var a2 = a[2];
        var a3 = a[3];
        var a4 = a[4];
        var a5 = a[5];
        var a6 = a[6];
        var a7 = a[7];
        var a8 = a[8];
        var a9 = a[9];
        var a10 = a[10];
        var a11 = a[11];
        var a12 = a[12];
        var a13 = a[13];
        var a14 = a[14];
        var a15 = a[15];

        var b0 = b[0];
        var b1 = b[1];
        var b2 = b[2];
        var b3 = b[3];
        var b4 = b[4];
        var b5 = b[5];
        var b6 = b[6];
        var b7 = b[7];
        var b8 = b[8];
        var b9 = b[9];
        var b10 = b[10];
        var b11 = b[11];
        var b12 = b[12];
        var b13 = b[13];
        var b14 = b[14];
        var b15 = b[15];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] = (b0 * a0  + b4 * a1  + b8  * a2  + b12 * a3);
        dst[1] = (b1 * a0  + b5 * a1  + b9  * a2  + b13 * a3);
        dst[2] = (b2 * a0  + b6 * a1  + b10 * a2  + b14 * a3);
        dst[3] = (b3 * a0  + b7 * a1  + b11 * a2  + b15 * a3);
        dst[4] = (b0 * a4  + b4 * a5  + b8  * a6  + b12 * a7);
        dst[5] = (b1 * a4  + b5 * a5  + b9  * a6  + b13 * a7);
        dst[6] = (b2 * a4  + b6 * a5  + b10 * a6  + b14 * a7);
        dst[7] = (b3 * a4  + b7 * a5  + b11 * a6  + b15 * a7);
        dst[8] = (b0 * a8  + b4 * a9  + b8  * a10 + b12 * a11);
        dst[9] = (b1 * a8  + b5 * a9  + b9  * a10 + b13 * a11);
        dst[10] = (b2 * a8  + b6 * a9  + b10 * a10 + b14 * a11);
        dst[11] = (b3 * a8  + b7 * a9  + b11 * a10 + b15 * a11);
        dst[12] = (b0 * a12 + b4 * a13 + b8  * a14 + b12 * a15);
        dst[13] = (b1 * a12 + b5 * a13 + b9  * a14 + b13 * a15);
        dst[14] = (b2 * a12 + b6 * a13 + b10 * a14 + b14 * a15);
        dst[15] = (b3 * a12 + b7 * a13 + b11 * a14 + b15 * a15);

        return dst;
    },

    m44Inverse : function m44InverseFn(m, dst)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];
        var m9 = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        /*jshint white: false */
        var A0 = (( m0 *  m5) - ( m1 *  m4));
        var A1 = (( m0 *  m6) - ( m2 *  m4));
        var A2 = (( m0 *  m7) - ( m3 *  m4));
        var A3 = (( m1 *  m6) - ( m2 *  m5));
        var A4 = (( m1 *  m7) - ( m3 *  m5));
        var A5 = (( m2 *  m7) - ( m3 *  m6));
        var B0 = (( m8 * m13) - ( m9 * m12));
        var B1 = (( m8 * m14) - (m10 * m12));
        var B2 = (( m8 * m15) - (m11 * m12));
        var B3 = (( m9 * m14) - (m10 * m13));
        var B4 = (( m9 * m15) - (m11 * m13));
        var B5 = ((m10 * m15) - (m11 * m14));
        /*jshint white: true */

        var det = ((A0 * B5) - (A1 * B4) + (A2 * B3) + (A3 * B2) - (A4 * B1) + (A5 * B0));
        if (det === 0.0)
        {
            /*jshint white: false */
            dst[ 0] = 0.0;
            dst[ 1] = 0.0;
            dst[ 2] = 0.0;
            dst[ 3] = 0.0;
            dst[ 4] = 0.0;
            dst[ 5] = 0.0;
            dst[ 6] = 0.0;
            dst[ 7] = 0.0;
            dst[ 8] = 0.0;
            dst[ 9] = 0.0;
            dst[10] = 0.0;
            dst[11] = 0.0;
            dst[12] = 0.0;
            dst[13] = 0.0;
            dst[14] = 0.0;
            dst[15] = 0.0;
            /*jshint white: true */
        }
        else
        {
            var detrecp = 1.0 / det;
            /*jshint white: false */
            dst[ 0] = (+ ( m5 * B5) - ( m6 * B4) + ( m7 * B3)) * detrecp;
            dst[ 4] = (- ( m4 * B5) + ( m6 * B2) - ( m7 * B1)) * detrecp;
            dst[ 8] = (+ ( m4 * B4) - ( m5 * B2) + ( m7 * B0)) * detrecp;
            dst[12] = (- ( m4 * B3) + ( m5 * B1) - ( m6 * B0)) * detrecp;
            dst[ 1] = (- ( m1 * B5) + ( m2 * B4) - ( m3 * B3)) * detrecp;
            dst[ 5] = (+ ( m0 * B5) - ( m2 * B2) + ( m3 * B1)) * detrecp;
            dst[ 9] = (- ( m0 * B4) + ( m1 * B2) - ( m3 * B0)) * detrecp;
            dst[13] = (+ ( m0 * B3) - ( m1 * B1) + ( m2 * B0)) * detrecp;
            dst[ 2] = (+ (m13 * A5) - (m14 * A4) + (m15 * A3)) * detrecp;
            dst[ 6] = (- (m12 * A5) + (m14 * A2) - (m15 * A1)) * detrecp;
            dst[10] = (+ (m12 * A4) - (m13 * A2) + (m15 * A0)) * detrecp;
            dst[14] = (- (m12 * A3) + (m13 * A1) - (m14 * A0)) * detrecp;
            dst[ 3] = (- ( m9 * A5) + (m10 * A4) - (m11 * A3)) * detrecp;
            dst[ 7] = (+ ( m8 * A5) - (m10 * A2) + (m11 * A1)) * detrecp;
            dst[11] = (- ( m8 * A4) + ( m9 * A2) - (m11 * A0)) * detrecp;
            dst[15] = (+ ( m8 * A3) - ( m9 * A1) + (m10 * A0)) * detrecp;
            /*jsline white: true */
        }

        return dst;
    },

    m44Transpose : function m44TransposeFn(m, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }

        dst[0] = m[0];
        dst[1] = m[4];
        dst[2] = m[8];
        dst[3] = m[12];
        dst[4] = m[1];
        dst[5] = m[5];
        dst[6] = m[9];
        dst[7] = m[13];
        dst[8] = m[2];
        dst[9] = m[6];
        dst[10] = m[10];
        dst[11] = m[14];
        dst[12] = m[3];
        dst[13] = m[7];
        dst[14] = m[11];
        dst[15] = m[15];

        return dst;
    },

    // Matrix44 operations with scalars
    m44ScalarAdd : function m44ScalarAddFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }
        for (var n = 0; n < 16; n += 1)
        {
            dst[n] = (m[n] + s);
        }
        return dst;
    },

    m44ScalarSub : function m44ScalarSubFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }
        for (var n = 0; n < 16; n += 1)
        {
            dst[n] = (m[n] - s);
        }
        return dst;
    },

    m44ScalarMul : function m44ScalarMulFn(m, s, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(16);
        }
        for (var n = 0; n < 16; n += 1)
        {
            dst[n] = (m[n] * s);
        }
        return dst;
    },

    // Quaternion
    quatBuild : function quatBuildFn(x, y, z, w, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = x;
        dst[1] = y;
        dst[2] = z;
        dst[3] = w;
        return dst;
    },

    quatCopy : function quatCopyFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
        dst[3] = src[3];
        return dst;
    },

    quatIsSimilar : function quatIsSimilarFn(q1, q2, precision)
    {
        if (precision === undefined)
        {
            precision = this.precision;
        }
        // this compares for similar rotations not raw data
        var q1temp = q1;

        if (q1[3] * q2[3] < 0.0)
        {
            // quaternions in opposing hemispheres, negate one
            q1temp = VMath.v4Neg(q1);
        }

        var mag_sqrd = VMath.v4LengthSq(VMath.v4Sub(q1temp, q2));
        var epsilon_sqrd = (precision * precision);
        return mag_sqrd < epsilon_sqrd;
    },

    quatLength : function quatLengthFn(q)
    {
        return VMath.v4Length(q);
    },

    quatDot : function quatDotFn(q1, q2)
    {
        return VMath.v4Dot(q1, q2);
    },

    quatMul : function quatMulFn(q1, q2, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        // Note quaternion multiplication is the opposite way around from our matrix multiplication
        //var v1 = q1; // use full quats to avoid copy
        //var v2 = q2;

        /*
        // Calculate the imaginary part
        var quat = VMath.v3Add3(VMath.v3ScalarMul(v2, q1[3]), VMath.v3ScalarMul(v1, q2[3]), VMath.v3Cross(v1, v2));
        // And extend with the real part
        quat[3] = (q1[3] * q2[3]) - VMath.v3Dot(v1, v2);
        */

        // Inlined from above
        var q2x = q1[0];
        var q2y = q1[1];
        var q2z = q1[2];
        var q2w = q1[3];
        var q1x = q2[0];
        var q1y = q2[1];
        var q1z = q2[2];
        var q1w = q2[3];

        var cx = (q1z * q2y) - (q1y * q2z);
        var cy = (q1x * q2z) - (q1z * q2x);
        var cz = (q1y * q2x) - (q1x * q2y);

        dst[0] = (q2x * q1w) + (q1x * q2w) + cx;
        dst[1] = (q2y * q1w) + (q1y * q2w) + cy;
        dst[2] = (q2z * q1w) + (q1z * q2w) + cz;
        dst[3] = (q1w * q2w) - (q1x * q2x + q1y * q2y + q1z * q2z);

        return dst;
    },

    quatMulTranslate : function quatMulTranslateFn(qa, va, qb, vb, qr, vr)
    {
        var qax = qa[0];
        var qay = qa[1];
        var qaz = qa[2];
        var qaw = qa[3];
        var qbx = qb[0];
        var qby = qb[1];
        var qbz = qb[2];
        var qbw = qb[3];

        // Multiply together the two quaternions
        var cx = (qaz * qby) - (qay * qbz);
        var cy = (qax * qbz) - (qaz * qbx);
        var cz = (qay * qbx) - (qax * qby);

        qr[0] = (qbx * qaw) + (qax * qbw) + cx;
        qr[1] = (qby * qaw) + (qay * qbw) + cy;
        qr[2] = (qbz * qaw) + (qaz * qbw) + cz;
        qr[3] = (qaw * qbw) - (qax * qbx + qay * qby + qaz * qbz);

        // Transform the 2nd vector by the first quaternion and add in the first position
        var vax = va[0];
        var vay = va[1];
        var vaz = va[2];
        var vbx = vb[0];
        var vby = vb[1];
        var vbz = vb[2];

        var s = (qaw * qaw) - (qax * qax + qay * qay + qaz * qaz);
        var rx = vbx * s;
        var ry = vby * s;
        var rz = vbz * s;

        s = qax * vbx + qay * vby + qaz * vbz;

        var twoS = s + s;
        rx += qax * twoS;
        ry += qay * twoS;
        rz += qaz * twoS;

        cx = (qaz * vby) - (qay * vbz);
        cy = (qax * vbz) - (qaz * vbx);
        cz = (qay * vbx) - (qax * vby);
        var twoQw = qaw + qaw;
        rx += cx * twoQw;
        ry += cy * twoQw;
        rz += cz * twoQw;

        vr[0] = rx + vax;
        vr[1] = ry + vay;
        vr[2] = rz + vaz;
    },

    quatNormalize : function quatNormalizeFn(q, dst)
    {
        var norme = VMath.quatDot(q, q);
        if (norme === 0.0)
        {
            return VMath.v4BuildZero(dst);
        }
        else
        {
            var recip = 1.0 / Math.sqrt(norme);
            return VMath.v4ScalarMul(q, recip, dst);
        }
    },

    quatConjugate : function quatConjugateFn(q, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = -q[0];
        dst[1] = -q[1];
        dst[2] = -q[2];
        dst[3] =  q[3];

        return dst;
    },

    quatLerp : function quatLerpFn(q1, q2, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var q1x = q1[0];
        var q1y = q1[1];
        var q1z = q1[2];
        var q1w = q1[3];
        var q2x = q2[0];
        var q2y = q2[1];
        var q2z = q2[2];
        var q2w = q2[3];

        dst[0] = ((q2x - q1x) * t) + q1x;
        dst[1] = ((q2y - q1y) * t) + q1y;
        dst[2] = ((q2z - q1z) * t) + q1z;
        dst[3] = ((q2w - q1w) * t) + q1w;

        return dst;
    },

    cosMinSlerpAngle : Math.cos(Math.PI / 40.0), // use a lerp for angles <= 4.5 degrees

    quatSlerp : function quatSlerpFn(q1, q2, t, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var q1x = q1[0];
        var q1y = q1[1];
        var q1z = q1[2];
        var q1w = q1[3];
        var q2x = q2[0];
        var q2y = q2[1];
        var q2z = q2[2];
        var q2w = q2[3];
        var dotq1q2 = (q1x * q2x) + (q1y * q2y) + (q1z * q2z) + (q1w * q2w);

        var cosom = dotq1q2;
        if (cosom < 0.0)
        {
            q1x = -q1x;
            q1y = -q1y;
            q1z = -q1z;
            q1w = -q1w;
            cosom = -cosom;
        }

        if (cosom > VMath.cosMinSlerpAngle)
        {
            var delta = t;
            if (dotq1q2 <= 0.0)
            {
                delta = -t;
            }

            var qrx = ((q2x - q1x) * delta) + q1x;
            var qry = ((q2y - q1y) * delta) + q1y;
            var qrz = ((q2z - q1z) * delta) + q1z;
            var qrw = ((q2w - q1w) * delta) + q1w;

            var mag = Math.sqrt((qrx * qrx) + (qry * qry) + (qrz * qrz) + (qrw * qrw));
            var recip = 1.0 / mag;

            dst[0] =  qrx * recip;
            dst[1] =  qry * recip;
            dst[2] =  qrz * recip;
            dst[3] =  qrw * recip;

            return dst;
        }

        var sinFn = Math.sin;
        var omega = Math.acos(cosom);
        var inv_sin_omega = 1.0 / sinFn(omega);

        var scalar = sinFn((1.0 - t) * omega) * inv_sin_omega;
        q1x = q1x * scalar;
        q1y = q1y * scalar;
        q1z = q1z * scalar;
        q1w = q1w * scalar;

        scalar = sinFn(t * omega) * inv_sin_omega;
        q2x = q2x * scalar;
        q2y = q2y * scalar;
        q2z = q2z * scalar;
        q2w = q2w * scalar;

        dst[0] =  q1x + q2x;
        dst[1] =  q1y + q2y;
        dst[2] =  q1z + q2z;
        dst[3] =  q1w + q2w;

        return dst;
    },

    quatFromM43 : function quatFromM43Fn(m, dst)
    {
        var m0 = m[0];
        var m1 = m[1];
        var m2 = m[2];
        var m3 = m[3];
        var m4 = m[4];
        var m5 = m[5];
        var m6 = m[6];
        var m7 = m[7];
        var m8 = m[8];

        var x, y, z, w, s;
        var trace = m0 + m4 + m8 + 1;
        if (trace > VMath.precision)
        {
            w = Math.sqrt(trace) / 2;
            x = (m5 - m7) / (4 * w);
            y = (m6 - m2) / (4 * w);
            z = (m1 - m3) / (4 * w);
        }
        else
        {
            if ((m0 > m4) && (m0 > m8))
            {
                s = Math.sqrt(1.0 + m0 - m4 - m8) * 2; // S=4*qx
                w = (m5 - m7) / s;
                x = 0.25 * s;
                y = (m3 + m1) / s;
                z = (m6 + m2) / s;
            }
            else if (m4 > m8)
            {
                s = Math.sqrt(1.0 + m4 - m0 - m8) * 2; // S=4*qy
                w = (m6 - m2) / s;
                x = (m3 + m1) / s;
                y = 0.25 * s;
                z = (m7 + m5) / s;
            }
            else
            {
                s = Math.sqrt(1.0 + m8 - m0 - m4) * 2; // S=4*qz
                w = (m1 - m3) / s;
                x = (m6 + m2) / s;
                y = (m7 + m5) / s;
                z = 0.25 * s;
            }
        }

        var q = VMath.quatNormalize([x, y, z, w], dst);

        return VMath.quatConjugate(q, dst);
    },

    quatFromAxisRotation : function quatFromAxisRotationFn(axis, angle, dst)
    {
        var omega = 0.5 * angle;
        var s = Math.sin(omega);
        var c = Math.cos(omega);

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        dst[0] = axis[0] * s;
        dst[1] = axis[1] * s;
        dst[2] = axis[2] * s;
        dst[3] = c;

        return VMath.quatNormalize(dst, dst);
    },

    quatToAxisRotation : function quatToAxisRotation(q, dst)
    {
        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(4);
        }

        var q3 = q[3];
        var angle = Math.acos(q3) * 2.0;
        var sin_sqrd = 1.0 - q3 * q3;

        if (sin_sqrd < VMath.precision)
        {
            // we can return any axis
            dst[0] = 1.0;
            dst[1] = 0.0;
            dst[2] = 0.0;
            dst[3] = angle;
        }
        else
        {
            var scale = 1.0 / Math.sqrt(sin_sqrd);
            dst[0] = q[0] * scale;
            dst[1] = q[1] * scale;
            dst[2] = q[2] * scale;
            dst[3] = angle;
        }
        return dst;
    },

    quatTransformVector : function quatTransformVectorFn(q, v, dst)
    {
        /*
        var qimaginary = q; // Use full quat directly to avoid copy
        var qw = q[3];

        var s = (qw * qw) - VMath.v3Dot(qimaginary, qimaginary);

        var r = VMath.v3ScalarMul(v, s);

        s = VMath.v3Dot(qimaginary, v);
        r = VMath.v3Add(r, VMath.v3ScalarMul(qimaginary, s + s));
        r = VMath.v3Add(r, VMath.v3ScalarMul(VMath.v3Cross(qimaginary, v), qw + qw));
        */

        // Inlined from above
        var qx = q[0];
        var qy = q[1];
        var qz = q[2];
        var qw = q[3];

        var vx = v[0];
        var vy = v[1];
        var vz = v[2];

        //var s = (qw * qw) - VMath.v3Dot(qimaginary, qimaginary);
        var s = (qw * qw) - (qx * qx + qy * qy + qz * qz);

        //var r = VMath.v3ScalarMul(v, s);
        var rx = vx * s;
        var ry = vy * s;
        var rz = vz * s;

        //s = VMath.v3Dot(qimaginary, v);
        s = qx * vx + qy * vy + qz * vz;

        //r = VMath.v3Add(r, VMath.v3ScalarMul(qimaginary, s + s));
        var twoS = s + s;
        rx += qx * twoS;
        ry += qy * twoS;
        rz += qz * twoS;

        //r = VMath.v3Add(r, VMath.v3ScalarMul(VMath.v3Cross(VMath.v3Neg(qimaginary), v), qw + qw));
        var cx = (qz * vy) - (qy * vz);
        var cy = (qx * vz) - (qz * vx);
        var cz = (qy * vx) - (qx * vy);
        var twoQw = qw + qw;
        rx += cx * twoQw;
        ry += cy * twoQw;
        rz += cz * twoQw;

        if (dst === undefined)
        {
            dst = new VMathArrayConstructor(3);
        }
        dst[0] = rx;
        dst[1] = ry;
        dst[2] = rz;

        return dst;
    },

    quatEqual : function quatEqual(q1, q2, precision)
    {
        if (precision === undefined)
        {
            precision = this.precision;
        }
        var abs = Math.abs;
        return (abs(q1[0] - q2[0]) <= precision &&
                abs(q1[1] - q2[1]) <= precision &&
                abs(q1[2] - q2[2]) <= precision &&
                abs(q1[3] - q2[3]) <= precision);
    },

    // quatPos
    quatPosBuild : function quatPosBuildFn(x, y, z, w, px, py, pz, dst)
    {
        if (arguments.length < 7)
        {
            if (z === undefined)
            {
                z = new VMathArrayConstructor(7);
            }
            z[0] = x[0];
            z[1] = x[1];
            z[2] = x[2];
            z[3] = x[3];
            z[4] = y[0];
            z[5] = y[1];
            z[6] = y[2];
            return z;
        }
        else
        {
            if (dst === undefined)
            {
                dst = new VMathArrayConstructor(7);
            }
            dst[0] = x;
            dst[1] = y;
            dst[2] = z;
            dst[3] = w;
            dst[4] = px;
            dst[5] = py;
            dst[6] = pz;
            return dst;
        }
    },

    quatPosTransformVector : function quatPosTransformVectorFn(qp, n, dst)
    {
        return VMath.quatTransformVector(qp, n, dst);
    },

    quatPosTransformPoint : function quatPosTransformPointFn(qp, p)
    {
        var offset = qp.slice(4, 7);

        var rotatedp = VMath.quatTransformVector(qp, p);
        return VMath.v3Add(rotatedp, offset);
    },

    quatPosMul : function quatPosMulFn(qp1, qp2)
    {
        var v2 = qp2.slice(4, 7);

        var qr = VMath.quatMul(qp1, qp2);
        var pr = VMath.quatPosTransformPoint(qp1, v2);
        qr[4] = pr[0];
        qr[5] = pr[1];
        qr[6] = pr[2];

        return qr;
    },

    //
    // Visibility queries
    //
    isVisibleBox : function isVisibleBoxFn(center, halfDimensions, vpm)
    {
        var abs = Math.abs;

        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];

        var h0 = halfDimensions[0];
        var h1 = halfDimensions[1];
        var h2 = halfDimensions[2];

        var m0  = vpm[0];
        var m1  = vpm[1];
        var m2  = vpm[2];
        var m3  = vpm[3];
        var m4  = vpm[4];
        var m5  = vpm[5];
        var m6  = vpm[6];
        var m7  = vpm[7];
        var m8  = vpm[8];
        var m9  = vpm[9];
        var m10 = vpm[10];
        var m11 = vpm[11];

        var I0 = (m0  * h0);
        var I1 = (m1  * h0);
        var I2 = (m2  * h0);
        var I3 = (m3  * h0);
        var J0 = (m4  * h1);
        var J1 = (m5  * h1);
        var J2 = (m6  * h1);
        var J3 = (m7  * h1);
        var K0 = (m8  * h2);
        var K1 = (m9  * h2);
        var K2 = (m10 * h2);
        var K3 = (m11 * h2);

        var T0 = (m0 * c0 + m4 * c1 + m8  * c2 + vpm[12]);
        var T1 = (m1 * c0 + m5 * c1 + m9  * c2 + vpm[13]);
        var T2 = (m2 * c0 + m6 * c1 + m10 * c2 + vpm[14]);
        var T3 = (m3 * c0 + m7 * c1 + m11 * c2 + vpm[15]);

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleBoxOrigin : function isVisibleBoxOriginFn(halfDimensions, vpm)
    {
        var abs = Math.abs;

        var h0 = halfDimensions[0];
        var h1 = halfDimensions[1];
        var h2 = halfDimensions[2];

        var I0 = (vpm[0]  * h0);
        var I1 = (vpm[1]  * h0);
        var I2 = (vpm[2]  * h0);
        var I3 = (vpm[3]  * h0);
        var J0 = (vpm[4]  * h1);
        var J1 = (vpm[5]  * h1);
        var J2 = (vpm[6]  * h1);
        var J3 = (vpm[7]  * h1);
        var K0 = (vpm[8]  * h2);
        var K1 = (vpm[9]  * h2);
        var K2 = (vpm[10] * h2);
        var K3 = (vpm[11] * h2);
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphere : function isVisibleSphereFn(center, radius, vpm)
    {
        var abs = Math.abs;

        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];

        var m0  = vpm[0];
        var m1  = vpm[1];
        var m2  = vpm[2];
        var m3  = vpm[3];
        var m4  = vpm[4];
        var m5  = vpm[5];
        var m6  = vpm[6];
        var m7  = vpm[7];
        var m8  = vpm[8];
        var m9  = vpm[9];
        var m10 = vpm[10];
        var m11 = vpm[11];

        var I0 = m0;
        var I1 = m1;
        var I2 = m2;
        var I3 = m3;
        var J0 = m4;
        var J1 = m5;
        var J2 = m6;
        var J3 = m7;
        var K0 = m8;
        var K1 = m9;
        var K2 = m10;
        var K3 = m11;

        var T0 = (m0 * c0 + m4 * c1 + m8  * c2 + vpm[12]);
        var T1 = (m1 * c0 + m5 * c1 + m9  * c2 + vpm[13]);
        var T2 = (m2 * c0 + m6 * c1 + m10 * c2 + vpm[14]);
        var T3 = (m3 * c0 + m7 * c1 + m11 * c2 + vpm[15]);

        var nradius = -radius;

        return !(((T0 - T3) >  radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  radius * (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphereOrigin : function isVisibleSphereOriginFn(radius, vpm)
    {
        var abs = Math.abs;

        var I0 = vpm[0];
        var I1 = vpm[1];
        var I2 = vpm[2];
        var I3 = vpm[3];
        var J0 = vpm[4];
        var J1 = vpm[5];
        var J2 = vpm[6];
        var J3 = vpm[7];
        var K0 = vpm[8];
        var K1 = vpm[9];
        var K2 = vpm[10];
        var K3 = vpm[11];
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        var nradius = -radius;

        return !(((T0 - T3) >  radius * (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < nradius * (abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  radius * (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < nradius * (abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  radius * (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < nradius * (abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  radius * (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < nradius * (abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    isVisibleSphereUnit : function isVisibleSphereUnitFn(vpm)
    {
        var abs = Math.abs;

        var I0 = vpm[0];
        var I1 = vpm[1];
        var I2 = vpm[2];
        var I3 = vpm[3];
        var J0 = vpm[4];
        var J1 = vpm[5];
        var J2 = vpm[6];
        var J3 = vpm[7];
        var K0 = vpm[8];
        var K1 = vpm[9];
        var K2 = vpm[10];
        var K3 = vpm[11];
        var T0 = vpm[12];
        var T1 = vpm[13];
        var T2 = vpm[14];
        var T3 = vpm[15];

        return !(((T0 - T3) >  (abs(I0 - I3) + abs(J0 - J3) + abs(K0 - K3))) ||
                 ((T0 + T3) < -(abs(I0 + I3) + abs(J0 + J3) + abs(K0 + K3))) ||
                 ((T1 - T3) >  (abs(I1 - I3) + abs(J1 - J3) + abs(K1 - K3))) ||
                 ((T1 + T3) < -(abs(I1 + I3) + abs(J1 + J3) + abs(K1 + K3))) ||
                 ((T2 - T3) >  (abs(I2 - I3) + abs(J2 - J3) + abs(K2 - K3))) ||
                 ((T2 + T3) < -(abs(I2 + I3) + abs(J2 + J3) + abs(K2 + K3))) ||
               //((T3 - T3) >  (abs(I3 - I3) + abs(J3 - J3) + abs(K3 - K3))) ||
                 ((T3 + T3) < -(abs(I3 + I3) + abs(J3 + J3) + abs(K3 + K3))));
    },

    transformBox : function transformBoxFn(center, halfExtents, matrix)
    {
        var abs = Math.abs;
        var m0  = matrix[0];
        var m1  = matrix[1];
        var m2  = matrix[2];
        var m3  = matrix[3];
        var m4  = matrix[4];
        var m5  = matrix[5];
        var m6  = matrix[6];
        var m7  = matrix[7];
        var m8  = matrix[8];
        var c0 = center[0];
        var c1 = center[1];
        var c2 = center[2];
        var h0 = halfExtents[0];
        var h1 = halfExtents[1];
        var h2 = halfExtents[2];

        var out_center = new VMathArrayConstructor(3);
        out_center[0] = m0 * c0 + m3 * c1 + m6 * c2 + matrix[9];
        out_center[1] = m1 * c0 + m4 * c1 + m7 * c2 + matrix[10];
        out_center[2] = m2 * c0 + m5 * c1 + m8 * c2 + matrix[11];

        var out_halfext = new VMathArrayConstructor(3);
        out_halfext[0] = abs(m0) * h0 + abs(m3) * h1 + abs(m6) * h2;
        out_halfext[1] = abs(m1) * h0 + abs(m4) * h1 + abs(m7) * h2;
        out_halfext[2] = abs(m2) * h0 + abs(m5) * h1 + abs(m8) * h2;

        return {
            center : out_center,
            halfExtents : out_center
        };
    },

    //
    // Planes
    //
    planeNormalize : function planeNormalizeFn(plane, output)
    {
        if (output === undefined)
        {
            output = new VMathArrayConstructor(4);
        }

        var a = plane[0];
        var b = plane[1];
        var c = plane[2];
        var lsq = ((a * a) + (b * b) + (c * c));
        if (lsq > 0.0)
        {
            var lr = 1.0 / Math.sqrt(lsq);
            output[0] = (a * lr);
            output[1] = (b * lr);
            output[2] = (c * lr);
            output[3] = (plane[3] * lr);
        }
        else
        {
            output[0] = 0;
            output[1] = 0;
            output[2] = 0;
            output[3] = 0;
        }

        return output;
    },

    extractFrustumPlanes : function extractFrustumPlanesFn(m, p)
    {
        var planeNormalize = VMath.planeNormalize;
        var m0  = m[0];
        var m1  = m[1];
        var m2  = m[2];
        var m3  = m[3];
        var m4  = m[4];
        var m5  = m[5];
        var m6  = m[6];
        var m7  = m[7];
        var m8  = m[8];
        var m9  = m[9];
        var m10 = m[10];
        var m11 = m[11];
        var m12 = m[12];
        var m13 = m[13];
        var m14 = m[14];
        var m15 = m[15];
        var planes = (p || []);

        // Negate 'd' here to avoid doing it on the isVisible functions
        planes[0] = planeNormalize([(m3  + m0), (m7  + m4), (m11 + m8),
                                    -(m15 + m12)], planes[0]); // left
        planes[1] = planeNormalize([(m3  - m0), (m7  - m4), (m11 - m8),
                                    -(m15 - m12)], planes[1]); // right
        planes[2] = planeNormalize([(m3  - m1), (m7  - m5), (m11 - m9),
                                    -(m15 - m13)], planes[2]); // top
        planes[3] = planeNormalize([(m3  + m1), (m7  + m5), (m11 + m9),
                                    -(m15 + m13)], planes[3]); // bottom
        planes[4] = planeNormalize([(m3  + m2), (m7  + m6), (m11 + m10),
                                    -(m15 + m14)], planes[4]);  // near
        planes[5] = planeNormalize([(m3  - m2), (m7  - m6), (m11 - m10),
                                    -(m15 - m14)], planes[5]); // far

        return planes;
    },

    isInsidePlanesPoint : function isInsidePlanesPointFn(p, planes)
    {
        var p0 = p[0];
        var p1 = p[1];
        var p2 = p[2];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            if ((plane[0] * p0 + plane[1] * p1 + plane[2] * p2) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isInsidePlanesSphere : function isInsidePlanesSphereFn(c, r, planes)
    {
        var c0 = c[0];
        var c1 = c[1];
        var c2 = c[2];
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            if ((plane[0] * c0 + plane[1] * c1 + plane[2] * c2) < (plane[3] - r))
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },

    isInsidePlanesBox : function isInsidePlanesBoxFn(c, h, planes)
    {
        var c0 = c[0];
        var c1 = c[1];
        var c2 = c[2];
        var h0 = h[0];
        var h1 = h[1];
        var h2 = h[2];
        var p0 = (c0 + h0);
        var p1 = (c1 + h1);
        var p2 = (c2 + h2);
        var n0 = (c0 - h0);
        var n1 = (c1 - h1);
        var n2 = (c2 - h2);
        var numPlanes = planes.length;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1) + d2 * (d2 < 0 ? n2 : p2)) < plane[3])
            {
                return false;
            }
            n += 1;
        }
        while (n < numPlanes);
        return true;
    },


    extractIntersectingPlanes : function extractIntersectingPlanesFn(extents, planes)
    {
        var n0 = extents[0];
        var n1 = extents[1];
        var n2 = extents[2];
        var p0 = extents[3];
        var p1 = extents[4];
        var p2 = extents[5];
        var numPlanes = planes.length;
        var p = [];
        var np = 0;
        var n = 0;
        do
        {
            var plane = planes[n];
            var d0 = plane[0];
            var d1 = plane[1];
            var d2 = plane[2];
            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1) + d2 * (d2 > 0 ? n2 : p2)) < plane[3])
            {
                p[np] = plane;
                np += 1;
            }
            n += 1;
        }
        while (n < numPlanes);
        return p;
    }
};

if (typeof Float32Array !== "undefined")
{
    var testVector = new Float32Array([1, 2, 3]);

    // Clamp FLOAT_MAX
    testVector[0] = VMath.FLOAT_MAX;

    VMath.FLOAT_MAX = testVector[0];
    VMathArrayConstructor = Float32Array;
}

// If the plugin has a 'getNativeMathDevice' method then VMath should
// replace the standard MathDevice.

if (TurbulenzEngine.hasOwnProperty('VMath'))
{
    TurbulenzEngine.VMath = VMath;
}



// Copyright (c) 2011-2012 Turbulenz Limited

/*global TurbulenzEngine*/
/*global Observer*/

function RequestHandler() {}
RequestHandler.prototype =
{
    reasonConnectionLost: 0,
    reasonServiceBusy: 1,

    retryExponential: function requestHandlerExponentialRetryFn(callContext, requestFn, status)
    {
        if (!this.notifiedConnectionLost &&
            TurbulenzEngine.time - this.connectionLostTime > (this.notifyTime * 0.001))
        {
            this.notifiedConnectionLost = true;

            var reason;
            if (status === 0)
            {
                reason = this.reasonConnectionLost;
            }
            else
            {
                reason = this.reasonServiceBusy;
            }
            callContext.reason = reason;
            this.onRequestTimeout(reason, callContext);
        }

        // only the first request with a lost connection continues
        // all following requests wait for a reconnection
        if (this.connected)
        {
            this.connectionLostTime = TurbulenzEngine.time;
            this.notifiedConnectionLost = false;
            this.connected = false;
            this.reconnectTest = callContext;

            callContext.status = status;
        }
        else if (this.reconnectTest !== callContext)
        {
            var reconnectedObserver = this.reconnectedObserver;
            reconnectedObserver.subscribe(function onReconnected()
                {
                    reconnectedObserver.unsubscribe(onReconnected);
                    requestFn();
                });
            return;
        }

        if (callContext.expTime)
        {
            callContext.expTime = 2 * callContext.expTime;
            if (callContext.expTime > this.maxRetryTime)
            {
                callContext.expTime = this.maxRetryTime;
            }
        }
        else
        {
            callContext.expTime = this.initialRetryTime;
        }

        if (callContext.retries)
        {
            callContext.retries += 1;
        }
        else
        {
            callContext.retries = 1;
        }
        TurbulenzEngine.setTimeout(requestFn, callContext.expTime);
    },

    retryAfter: function requestHandlerRetryAfterFn(callContext, retryAfter, requestFn, status)
    {
        if (callContext.retries)
        {
            callContext.retries += 1;
        }
        else
        {
            callContext.firstRetry = TurbulenzEngine.time;
            callContext.retries = 1;
        }

        if (!callContext.notifiedMaxRetries &&
            TurbulenzEngine.time - callContext.firstRetry + retryAfter > this.notifyTime)
        {
            callContext.notifiedMaxRetries = true;

            var reason = this.reasonServiceBusy;
            callContext.reason = reason;
            this.onRequestTimeout(reason, callContext);
        }

        TurbulenzEngine.setTimeout(requestFn, retryAfter * 1000);
    },

    request: function requestHandlerRequestFn(callContext)
    {
        var makeRequest;
        var that = this;

        var responseCallback = function responseCallbackFn(responseAsset, status)
        {
            var xhr = callContext.xhr;
            var sendEventToHandlers = that.sendEventToHandlers;
            var handlers = that.handlers;

            if (xhr)
            {
                var retryAfterHeader = xhr.getResponseHeader("Retry-After");
                if (retryAfterHeader)
                {
                    var retryAfter = parseInt(retryAfterHeader, 10);
                    if (retryAfter > 0)
                    {
                        that.retryAfter(callContext, retryAfter, makeRequest, status);
                        return;
                    }
                }
            }

            // 0 Connection Lost
            // 408 Request Timeout
            // 429 Too Many Requests
            // 480 Temporarily Unavailable
            if (status === 0 || status === 408 || status === 429 || status === 480)
            {
                that.retryExponential(callContext, makeRequest, status);
                return;
            }

            if (!that.connected)
            {
                // Reconnected!
                that.connected = true;
                if (that.reconnectTest === callContext && that.notifiedConnectionLost)
                {
                    that.onReconnected(that.reconnectTest.reason, that.reconnectTest);
                }
                that.reconnectTest = null;
                that.reconnectedObserver.notify();
            }

            if (callContext.customErrorHandler &&
                !callContext.customErrorHandler.call(this, callContext, makeRequest, responseAsset, status))
            {
                return;
            }

            if (that.customErrorHandler &&
                !that.customErrorHandler(callContext, makeRequest, responseAsset, status))
            {
                return;
            }

            if (callContext.onload)
            {
                var nameStr;
                if (responseAsset && responseAsset.name)
                {
                    nameStr = responseAsset.name;
                }
                else
                {
                    nameStr = callContext.src;
                }

                sendEventToHandlers(handlers.eventOnload, {eventType: "eventOnload", name: nameStr});

                callContext.onload(responseAsset, status, callContext);
                callContext.onload = null;
            }
            callContext = null;
        };

        makeRequest = function makeRequestFn()
        {
            if (callContext.requestFn)
            {
                if (callContext.requestOwner)
                {
                    callContext.requestFn.call(callContext.requestOwner, callContext.src, responseCallback, callContext);
                }
                else
                {
                    callContext.requestFn(callContext.src, responseCallback, callContext);
                }
            }
            else if (callContext.requestOwner)
            {
                callContext.requestOwner.request(callContext.src, responseCallback, callContext);
            }
            else
            {
                TurbulenzEngine.request(callContext.src, responseCallback, callContext);
            }
        };

        makeRequest();
    },

    addEventListener : function addEventListenerFn(eventType, eventListener)
    {
        var i;
        var length;
        var eventHandlers;

        if (this.handlers.hasOwnProperty(eventType))
        {
            eventHandlers = this.handlers[eventType];

            if (eventListener)
            {
                // Check handler is not already stored
                length = eventHandlers.length;
                for (i = 0; i < length; i += 1)
                {
                    if (eventHandlers[i] === eventListener)
                    {
                        // Event handler has already been added
                        return;
                    }
                }

                eventHandlers.push(eventListener);
            }
        }
    },

    removeEventListener : function removeEventListenerFn(eventType, eventListener)
    {
        var i;
        var length;
        var eventHandlers;

        if (this.handlers.hasOwnProperty(eventType))
        {
            eventHandlers = this.handlers[eventType];

            if (eventListener)
            {
                length = eventHandlers.length;
                for (i = 0; i < length; i += 1)
                {
                    if (eventHandlers[i] === eventListener)
                    {
                        eventHandlers.splice(i, 1);
                        break;
                    }
                }
            }
        }
    },

    sendEventToHandlers : function sendEventToHandlersFn(eventHandlers, arg0)
    {
        var i;
        var length = eventHandlers.length;

        if (length)
        {
            for (i = 0; i < length; i += 1)
            {
                eventHandlers[i](arg0);
            }
        }
    }
};

RequestHandler.create = function requestHandlerCreateFn(params)
{
    var rh = new RequestHandler();

    rh.initialRetryTime = params.initialRetryTime || 0.5 * 1000;
    rh.notifyTime = params.notifyTime || 4 * 1000;
    rh.maxRetryTime = params.maxRetryTime || 8 * 1000;

    rh.notifiedConnectionLost = false;
    rh.connected = true;
    rh.reconnectedObserver = Observer.create();
    rh.reconnectTest = null;

    rh.onReconnected = params.onReconnected || function onReconnectedFn() {};
    rh.onRequestTimeout = params.onRequestTimeout || function onRequestTimeoutFn(callContext) {};
    var handlers = {};
    rh.handlers = handlers;

    rh.handlers.eventOnload = [];

    return rh;
};

// Copyright (c) 2011 Turbulenz Limited

/*global TurbulenzServices: false*/

//
// API
//
function MappingTable() {}
MappingTable.prototype =
{
    version : 1,

    getURL: function mappingTableGetURL(assetPath, missingCallbackFn)
    {
        var url = this.urlMapping[assetPath];
        if (url)
        {
            return url;
        }
        else
        {
            if (missingCallbackFn)
            {
                missingCallbackFn(assetPath);
            }
            return (this.assetPrefix + assetPath);
        }
    },

    map: function mappingTableMap(logicalPath, physicalPath)
    {
        this.urlMapping[logicalPath] = physicalPath;
    },

    alias: function mappingTableAlias(alias, logicalPath)
    {
        var urlMapping = this.urlMapping;
        urlMapping[alias] = urlMapping[logicalPath];
    }
};

MappingTable.create = function MappingTableCreateFn(params)
{
    var mappingTable = new MappingTable();

    mappingTable.mappingTableURL = params.mappingTableURL;
    mappingTable.mappingTablePrefix = params.mappingTablePrefix;
    mappingTable.assetPrefix = params.assetPrefix;

    mappingTable.errorCallbackFn = params.errorCallback || TurbulenzServices.defaultErrorCallback;
    if (!mappingTable.mappingTableURL)
    {
        mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable no mapping table file given");
    }

    function createMappingTableCallbackFn(urlMappingData)
    {
        var urlMapping = urlMappingData.urnmapping || urlMappingData.urnremapping || {};
        mappingTable.urlMapping = urlMapping;

        // Prepend all the mapped physical paths with the asset server
        var mappingTablePrefix = mappingTable.mappingTablePrefix;
        if (mappingTablePrefix)
        {
            var source;
            for (source in urlMapping)
            {
                if (urlMapping.hasOwnProperty(source))
                {
                    urlMapping[source] = mappingTablePrefix + urlMapping[source];
                }
            }
        }

        params.onload(mappingTable);
    }

    params.requestHandler.request({
            src: mappingTable.mappingTableURL,
            onload: function jsonifyResponse(jsonResponse, status) {
                var obj = JSON.parse(jsonResponse);
                if (status === 200)
                {
                    createMappingTableCallbackFn(obj);
                }
                else
                {
                    mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable error with HTTP status " + status + ": " + jsonResponse.msg, status);
                }
            }
        });

    return mappingTable;
};

// Copyright (c) 2012 Turbulenz Limited

/*global
Global: false
Draw2D: false
Float32Array: false
TurbulenzEngine: false
*/

//
// Draw2DGroup. Wraps vertex buffer data with pairings of indices and textures
// representing subsets of buffer relating to a set of equal-texture quads.
//
// [ sprite1  sprite2  sprite3  sprite4  sprite5 ]
//  \---------------/  \------/ \--------------/
//       texture 1    texture 2     texture 3
//      12 indices    6 indices     12 indices
//
function Draw2DGroup() {}
Draw2DGroup.create = function draw2DGroupFn()
{
    var group = new Draw2DGroup();

    // pairs of index counts + associated texture for subset of group.
    group.indices = [];
    group.textures = [];
    group.numSets = 0;

    // vertex buffer for group.
    group.vertexBufferData = new Draw2D.prototype.floatArray(1024);
    group.numVertices = 0;

    return group;
};

function Draw2DSprite() {}
Draw2DSprite.prototype = {

    version : 1,

    //
    // Assumption is that user will not be performing these actions frequently.
    // To that end, we provide a function which performs the ssary side effects
    // on call, to prevent an overhead for lazy evaluation.
    //
    getTextureRectangle : function getTextureRectangleFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Draw2D.prototype.floatArray(4);
        }
        var data = this.data;
        var texture = this._texture;
        if (texture)
        {
            dst[0] = data[12] * texture.width;
            dst[1] = data[13] * texture.height;
            dst[2] = data[14] * texture.width;
            dst[3] = data[15] * texture.height;
        }
        else
        {
            dst[0] = data[12];
            dst[1] = data[13];
            dst[2] = data[14];
            dst[3] = data[15];
        }
        return dst;
    },
    setTextureRectangle : function setTextureRectangleFn(uvRect)
    {
        var data = this.data;
        var texture = this._texture;
        if (texture)
        {
            var iwidth  = 1 / texture.width;
            var iheight = 1 / texture.height;
            data[12] = uvRect[0] * iwidth;
            data[13] = uvRect[1] * iheight;
            data[14] = uvRect[2] * iwidth;
            data[15] = uvRect[3] * iheight;
        }
        else
        {
            data[12] = uvRect[0];
            data[13] = uvRect[1];
            data[14] = uvRect[2];
            data[15] = uvRect[3];
        }
    },

    getColor : function getColorFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Draw2D.prototype.floatArray(4);
        }
        var data = this.data;
        dst[0] = data[8];
        dst[1] = data[9];
        dst[2] = data[10];
        dst[3] = data[11];
        return dst;
    },
    setColor : function setColorFn(color)
    {
        var data = this.data;
        data[8]  = color[0];
        data[9]  = color[1];
        data[10] = color[2];
        data[11] = color[3];
    },

    getTexture : function getTextureFn()
    {
        return this._texture;
    },
    setTexture : function setTextureFn(texture)
    {
        if (this._texture !== texture)
        {
            var su = (this._texture ? this._texture.width  : 1.0) / (texture ? texture.width  : 1.0);
            var sv = (this._texture ? this._texture.height : 1.0) / (texture ? texture.height : 1.0);
            this._texture = texture || null;

            // re-normalise texture coordinates.
            var data = this.data;
            data[12] *= su;
            data[13] *= sv;
            data[14] *= su;
            data[15] *= sv;
        }
    },

    getWidth : function getWidthFn()
    {
        return this.data[17] * 2;
    },
    setWidth : function setWidthFn(width)
    {
        width *= 0.5;
        var data = this.data;
        if (data[17] !== width)
        {
            data[17] = width;
            this._invalidate();
        }
    },

    getHeight : function getHeightFn()
    {
        return this.data[18] * 2;
    },
    setHeight : function setHeightFn(height)
    {
        height *= 0.5;
        var data = this.data;
        if (data[18] !== height)
        {
            data[18] = height;
            this._invalidate();
        }
    },

    getScale : function getScaleFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Draw2D.prototype.floatArray(2);
        }
        var data = this.data;
        dst[0] = data[19];
        dst[1] = data[20];
        return dst;
    },
    setScale : function setScaleFn(scale)
    {
        var scaleX = scale[0];
        var scaleY = scale[1];
        var data = this.data;
        if (data[19] !== scaleX || data[20] !== scaleY)
        {
            data[19] = scaleX;
            data[20] = scaleY;
            this._invalidate();
        }
    },

    getShear : function getShearFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Draw2D.prototype.floatArray(2);
        }
        var data = this.data;
        dst[0] = data[21];
        dst[1] = data[22];
        return dst;
    },
    setShear : function setShearFn(shear)
    {
        var shearX = shear[0];
        var shearY = shear[1];
        var data = this.data;
        if (data[21] !== shearX || data[22] !== shearY)
        {
            data[21] = shearX;
            data[22] = shearY;
            this._invalidate();
        }
    },

    getOrigin : function getOriginFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Draw2D.prototype.floatArray(2);
        }
        var data = this.data;
        dst[0] = data[23];
        dst[1] = data[24];
        return dst;
    },
    setOrigin : function setOriginFn(origin)
    {
        var originX = origin[0];
        var originY = origin[1];
        var data = this.data;
        if (data[23] !== originX || data[24] !== originY)
        {
            data[23] = originX;
            data[24] = originY;
            this._invalidate();
        }
    },

    // Method for internal use only.
    //
    // Recompute locally defined vectors.
    _invalidate : function invalidateFn()
    {
        var data = this.data;
        // [ T1 T2 ] = [ scaleX 0 ] [ 1 shearX ]
        // [ T3 T4 ]   [ 0 scaleY ] [ shearY 1 ]
        var T1 = data[19];
        var T2 = data[19] * data[21];
        var T3 = data[20] * data[22];
        var T4 = data[20];

        // Recompute locally defined position of true center of sprite.
        var x = data[17] - data[23];  // x = width/2 - originX
        var y = data[18] - data[24];  // y = height/2 - originY
        var cx = data[25] = (T1 * x + T2 * y); // (cx) = T (x)
        var cy = data[26] = (T3 * x + T4 * y); // (cy)     (y)

        // Recompute locally defined position of top-left vertex relative to center of sprite.
        x = -data[17]; // x = -width/2
        y = -data[18]; // y = -height/2
        var ux = data[27] = (T1 * x + T2 * y); // (ux) = T (x)
        var uy = data[28] = (T3 * x + T4 * y); // (uy)     (y)

        // Recompute locally defined position of top-right vertex relative to center of sprite.
        x = -x; // x = width / 2
        var vx = data[29] = (T1 * x + T2 * y); // (vx) = T (x)
        var vy = data[30] = (T3 * x + T4 * y); // (vy)     (y)

        // Rotate vectors to screen space so that in the case that rotation is not performed
        // These vectors are still valid.
        var rotation = data[16] = this.rotation;
        var cos = Math.cos(rotation);
        var sin = Math.sin(rotation);

        data[31] = ((cos * cx) - (sin * cy));
        data[32] = ((sin * cx) + (cos * cy));
        data[33] = ((cos * ux) - (sin * uy));
        data[34] = ((sin * ux) + (cos * uy));
        data[35] = ((cos * vx) - (sin * vy));
        data[36] = ((sin * vx) + (cos * vy));

        // Compute suitable epsilon to consider rotations equals.
        // We do this by finding the vertex furthest from defined center of rotation.
        // And using its distance to compute what rotation constitutes a 'visible' rotation.
        //
        // Positions of vertices relative to origin are given by:
        // v1 = c + u, v2 = c + v, v3 = c - v, v4 = c - u.
        // |v1|^2 = |c|^2 + |u|^2 + 2c.u
        // |v4|^2 = |c|^2 + |u|^2 - 2c.u
        // |v2|^2 = |c|^2 + |v|^2 + 2c.v
        // |v3|^2 = |c|^2 + |v|^2 - 2c.v
        //
        // Compute r1 = |u|^2 + abs(2c.u)
        // Compute r2 = |v|^2 + abs(2c.v)
        //
        // Finally max(|vi|^2) = |c|^2 + max(r1, r2)
        //
        var dot = 2 * ((cx * ux) + (cy * uy));
        if (dot < 0)
        {
            dot = -dot;
        }
        var r1 = (ux * ux) + (uy * uy) + dot;

        dot = 2 * ((cx * vx) + (cy * vy));
        if (dot < 0)
        {
            dot = -dot;
        }
        var r2 = (vx * vx) + (vy * vy) + dot;

        if (r2 > r1)
        {
            r1 = r2;
        }

        r1 += ((cx * cx) + (cy * cy));
        // r1 is the squared distance to furthest vertex.
        //
        // We permit a half pixel movement to be considered a 'true' movement.
        // Squared rotation required to impart this movement on furthest vertex is
        data[37] = (0.25 / r1); // squared epsilon
    },

    // Method for internal use only.
    //
    // Recompute draw2d coordinate space vertices and vectors.
    _update : function _updateFn(angleScaleFactor)
    {
        var data = this.data;
        var x, y, u, v;

        // Check if rotation has been modified
        x = this.rotation;
        y = x - data[16]; // y = rotation - previousRotation
        if ((y * y) > (data[37] * angleScaleFactor)) // if |y| > epsilon
        {
            data[16] = x; //previousRotation = rotation
            u = Math.cos(x);
            v = Math.sin(x);

            // rotate locally defined vectors.
            x = data[25];
            y = data[26];
            data[31] = (u * x - v * y); // (px) = [cos -sin] (cx)
            data[32] = (v * x + u * y); // (py) = [sin  cos] (cy)

            x = data[27];
            y = data[28];
            data[33] = (u * x - v * y); // (x1) = [cos -sin] (ux)
            data[34] = (v * x + u * y); // (y1) = [sin  cos] (uy)

            x = data[29];
            y = data[30];
            data[35] = (u * x - v * y); // (x2) = [cos -sin] (vx)
            data[36] = (v * x + u * y); // (y2) = [sin  cos] (vy)
        }

        // Compute center of this sprite in screen space.
        u = this.x + data[31]; // u = centerX = positionX + px
        v = this.y + data[32]; // v = centerY = positionY + py

        // Compute vertex positions in screen space.
        x = data[33];
        y = data[34];
        data[0] = u + x; // v1x = centerX + x1
        data[1] = v + y; // v1y = centerY + y1
        data[6] = u - x; // v4x = centerX - x1
        data[7] = v - y; // v4y = centerY - y1

        x = data[35];
        y = data[36];
        data[2] = u + x; // v2x = centerX + x2
        data[3] = v + y; // v2y = centerY + y2
        data[4] = u - x; // v3x = centerX - x2
        data[5] = v - y; // v3y = centerY - y2
    }
};

Draw2DSprite.create = function draw2DSpriteCreateFn(params)
{
    if ((params.width === undefined || params.height === undefined) && !params.texture)
    {
        return null;
    }

    // data:
    // ---
    // First 16 values reserved for Draw2DSpriteData.
    //   includes colour and texture coordinates.
    //
    // 16    : old_rotation (for lazy evaluation)
    // 17,18 : width/2, height/2 (changed by user via function)
    // 19,20 : scaleX, scaleY    (changed by user via function)
    // 21,22 : shearX, shearY    (changed by user via function)
    // 23,24 : originX, originY  (changed by user via function)
    // 25,26 : cx, cy // locally defined position of true center of sprite relative to origin
    //    (dependant on scale/shear/center/dimension)
    // 27,28 : u1, v1 // locally defined position of top-left vertex relative to center of sprite.
    //    (dependant on scale/shear/dimension)
    // 29,30 : u2, v2 // locally defined position of top-right vertex relative to center of sprite.
    //    (dependant on scale/shear/dimension)
    // 31,32 : px, py // relative defined position of true center of sprite relative to origin
    //    (dependant on rotation and cx,cy)
    // 33,34 : x1, y1 // relative defined position of top-left vertex relative to center of sprite.
    //    (dependant on rotation and u1,v1)
    // 35,36 : x2, y2 // relative defined position of top-right vertex relative to center of sprite.
    //    (dependant on rotation and u2,v2)
    // 37 : Squared epsilon to consider rotations equal based on dimensions.
    var s = new Draw2DSprite();
    var data = s.data = new Draw2D.prototype.floatArray(38);

    // texture (not optional)
    var texture = s._texture = params.texture || null;

    // position (optional, default 0,0)
    s.x = (params.x || 0.0);
    s.y = (params.y || 0.0);

    // rotation (optional, default 0)
    s.rotation = data[16] = (params.rotation || 0.0);

    // colour (optional, default [1,1,1,1])
    var color = params.color;
    data[8]  = (color ? color[0] : 1.0);
    data[9]  = (color ? color[1] : 1.0);
    data[10] = (color ? color[2] : 1.0);
    data[11] = (color ? color[3] : 1.0);

    // uvRect (optional, default texture rectangle)
    var uvRect = params.textureRectangle;
    var iwidth  = (texture ? 1 / texture.width  : 1);
    var iheight = (texture ? 1 / texture.height : 1);
    data[12] = (uvRect ? (uvRect[0] * iwidth)  : 0.0);
    data[13] = (uvRect ? (uvRect[1] * iheight) : 0.0);
    data[14] = (uvRect ? (uvRect[2] * iwidth)  : 1.0);
    data[15] = (uvRect ? (uvRect[3] * iheight) : 1.0);

    // dimensions / 2 (default texture dimensions)
    data[17] = ((params.width  !== undefined) ? params.width  : texture.width)  * 0.5;
    data[18] = ((params.height !== undefined) ? params.height : texture.height) * 0.5;

    // scale (default [1,1])
    var scale = params.scale;
    data[19] = (scale ? scale[0] : 1.0);
    data[20] = (scale ? scale[1] : 1.0);

    // shear (default [0,0])
    var shear = params.shear;
    data[21] = (shear ? shear[0] : 0.0);
    data[22] = (shear ? shear[1] : 0.0);

    // origin (default dimensions / 2)
    var origin = params.origin;
    data[23] = (origin ? origin[0] : data[17]);
    data[24] = (origin ? origin[1] : data[18]);

    s._invalidate();
    return s;
};

//
// Used in rectangle draw routines to compute data to be pushed into vertex buffers.
//
function Draw2DSpriteData() {}
Draw2DSpriteData.setFromRotatedRectangle = function setFromRotatedRectangleFn(sprite, texture, rect, uvrect, color, rotation, origin)
{
    var x1 = rect[0];
    var y1 = rect[1];
    var x2 = rect[2];
    var y2 = rect[3];

    if (!rotation)
    {
        sprite[0] = x1;
        sprite[1] = y1;
        sprite[2] = x2;
        sprite[3] = y1;
        sprite[4] = x1;
        sprite[5] = y2;
        sprite[6] = x2;
        sprite[7] = y2;
    }
    else
    {
        var cx, cy;
        if (origin)
        {
            cx = x1 + origin[0];
            cy = y1 + origin[1];
        }
        else
        {
            cx = 0.5 * (x1 + x2);
            cy = 0.5 * (y1 + y2);
        }

        var dx = x1 - cx;
        var dy = y1 - cy;

        var cos = Math.cos(rotation);
        var sin = Math.sin(rotation);
        var w = (x2 - x1);
        var h = (y2 - y1);

        sprite[0] = x1 = cx + (cos * dx - sin * dy);
        sprite[1] = y1 = cy + (sin * dx + cos * dy);
        sprite[2] = x1 + (cos * w);
        sprite[3] = y1 + (sin * w);
        sprite[4] = x1 - (sin * h);
        sprite[5] = y1 + (cos * h);
        sprite[6] = x1 + (cos * w - sin * h);
        sprite[7] = y1 + (sin * w + cos * h);
    }

    if (color)
    {
        sprite[8]  = color[0];
        sprite[9]  = color[1];
        sprite[10] = color[2];
        sprite[11] = color[3];
    }
    else
    {
        sprite[8] = sprite[9] = sprite[10] = sprite[11] = 1.0;
    }

    if (uvrect && texture)
    {
        var iwidth  = 1 / texture.width;
        var iheight = 1 / texture.height;
        sprite[12] = uvrect[0] * iwidth;
        sprite[13] = uvrect[1] * iheight;
        sprite[14] = uvrect[2] * iwidth;
        sprite[15] = uvrect[3] * iheight;
    }
    else
    {
        sprite[12] = sprite[13] = 0;
        sprite[14] = sprite[15] = 1;
    }
};

Draw2DSpriteData.create = function draw2DSpriteFn()
{
    // x1 y1 x2 y2 x3 y3 x4 y4 - vertices [0,8)
    // cr cg cb ca u1 v1 u2 v2 - normalized color + texture [8,16)
    return new Draw2D.prototype.floatArray(16);
};

function Draw2D() {}

Draw2D.prototype = {

    version : 7,

    forceUpdate : false,
    clearBackBuffer : false,

    // supported sort modes.
    sort : {
        deferred  : 'deferred',
        immediate : 'immediate',
        texture   : 'texture'
    },

    // supported scale modes.
    scale : {
        scale : 'scale',
        none  : 'none'
    },

    drawStates: {
        uninit: 0,
        ready : 1,
        draw  : 2
    },

    defaultClearColor: [0, 0, 0, 1],

    clear: function clearFn(clearColor)
    {
        if (this.state !== this.drawStates.ready)
        {
            return false;
        }

        var gd = this.graphicsDevice;
        if (this.currentRenderTarget)
        {
            if (!gd.beginRenderTarget(this.currentRenderTarget.renderTarget))
            {
                return false;
            }

            gd.clear(clearColor || this.defaultClearColor);
            gd.endRenderTarget();
        }
        else
        {
            gd.clear(clearColor || this.defaultClearColor);
        }

        return true;
    },

    clearBatch: function clearFn()
    {
        for (var name in this.texLists)
        {
            if (this.texLists.hasOwnProperty(name))
            {
                delete this.texLists[name];
            }
        }
        this.currentTextureGroup = undefined;
        this.numGroups = 0;
    },

    bufferSprite : function bufferSpriteFn(buffer, sprite, index)
    {
        sprite._update(0);
        /*jshint bitwise: false*/
        index <<= 4;
        /*jshint bitwise: true*/

        var data = sprite.data;
        buffer[index]      = data[0];
        buffer[index + 1]  = data[1];
        buffer[index + 2]  = data[2];
        buffer[index + 3]  = data[3];
        buffer[index + 4]  = data[4];
        buffer[index + 5]  = data[5];
        buffer[index + 6]  = data[6];
        buffer[index + 7]  = data[7];
        buffer[index + 8]  = data[8];
        buffer[index + 9]  = data[9];
        buffer[index + 10] = data[10];
        buffer[index + 11] = data[11];
        buffer[index + 12] = data[12];
        buffer[index + 13] = data[13];
        buffer[index + 14] = data[14];
        buffer[index + 15] = data[15];
    },

    update: function updateFn()
    {
        var graphicsDevice = this.graphicsDevice;
        var width = this.width;
        var height = this.height;

        var graphicsDeviceWidth = graphicsDevice.width;
        var graphicsDeviceHeight = graphicsDevice.height;

        if (width !== graphicsDeviceWidth || height !== graphicsDeviceHeight || this.forceUpdate)
        {
            var viewWidth, viewHeight, viewX, viewY;
            var viewportRectangle = this.viewportRectangle;

            if (viewportRectangle)
            {
                viewX = viewportRectangle[0];
                viewY = viewportRectangle[1];
                viewWidth  = viewportRectangle[2] - viewX;
                viewHeight = viewportRectangle[3] - viewY;
            }
            else
            {
                viewX = 0;
                viewY = 0;
                viewWidth = graphicsDeviceWidth;
                viewHeight = graphicsDeviceHeight;
            }

            if ((viewWidth === graphicsDeviceWidth) && (viewHeight === graphicsDeviceHeight))
            {
                this.clearBackBuffer = false;
            }
            else
            {
                this.clearBackBuffer = true;
            }

            var target = this.currentRenderTarget;

            if (this.scaleMode === 'scale')
            {
                var viewAspectRatio = viewWidth / viewHeight;
                var graphicsDeviceAspectRatio = graphicsDeviceWidth / graphicsDeviceHeight;
                var calcViewWidth, calcViewHeight, diffWidth, diffHeight, halfDiffWidth, halfDiffHeight;

                if (graphicsDeviceAspectRatio > viewAspectRatio)
                {
                    calcViewWidth = Math.ceil((graphicsDeviceHeight / viewHeight) * viewWidth);
                    diffWidth = graphicsDeviceWidth - calcViewWidth;
                    halfDiffWidth = Math.floor(diffWidth * 0.5);

                    this.scissorX = halfDiffWidth;
                    this.scissorY = 0;
                    this.scissorWidth = calcViewWidth;
                    this.scissorHeight = graphicsDeviceHeight;

                    this.viewScaleX = viewWidth / calcViewWidth;
                    this.viewScaleY = viewHeight / graphicsDeviceHeight;

                    if (!target)
                    {
                        this.clipOffsetX = (halfDiffWidth / graphicsDeviceWidth * 2.0) - 1.0;
                        this.clipOffsetY = 1;
                        this.clipScaleX = (calcViewWidth / graphicsDeviceWidth * 2.0) / viewWidth;
                        this.clipScaleY = -2.0 / viewHeight;
                    }
                }
                else
                {
                    calcViewHeight = Math.ceil((graphicsDeviceWidth / viewWidth) * viewHeight);
                    diffHeight = graphicsDeviceHeight - calcViewHeight;
                    halfDiffHeight = Math.floor(diffHeight * 0.5);

                    this.scissorX = 0;
                    this.scissorY = halfDiffHeight;
                    this.scissorWidth = graphicsDeviceWidth;
                    this.scissorHeight = calcViewHeight;

                    this.viewScaleX = viewWidth / graphicsDeviceWidth;
                    this.viewScaleY = viewHeight / calcViewHeight;

                    if (!target)
                    {
                        this.clipOffsetX = -1.0;
                        this.clipOffsetY = 1 - ((halfDiffHeight / graphicsDeviceHeight) * 2.0);
                        this.clipScaleX = 2.0 / viewWidth;
                        this.clipScaleY = ((calcViewHeight / graphicsDeviceHeight) * -2.0) / viewHeight;
                    }
                }
            }
            else
            {
                this.viewScaleX = 1;
                this.viewScaleY = 1;

                if (!target)
                {
                    this.clipOffsetX = -1.0;
                    this.clipOffsetY = 1.0;
                    this.clipScaleX = 2.0 / graphicsDeviceWidth;
                    this.clipScaleY = -2.0 / graphicsDeviceHeight;
                }

                this.scissorX = 0;
                this.scissorY = (graphicsDeviceHeight - viewHeight);
                this.scissorWidth = viewWidth;
                this.scissorHeight = viewHeight;
            }

            this.spriteAngleFactor = Math.min(this.viewScaleX, this.viewScaleY);
            this.spriteAngleFactor *= this.spriteAngleFactor;

            this.width = graphicsDeviceWidth;
            this.height = graphicsDeviceHeight;

            var i = 0;
            var renderTargets = this.renderTargetStructs;
            var limit = renderTargets.length;
            for (i = 0; i < limit; i += 1)
            {
                this.validateTarget(renderTargets[i], this.scissorWidth, this.scissorHeight);
            }

            if (target)
            {
                this.clipOffsetX = -1.0;
                this.clipOffsetY = -1.0;
                this.clipScaleX = 2.0 * target.actualWidth / target.texture.width / viewWidth;
                this.clipScaleY = 2.0 * target.actualHeight / target.texture.height / viewHeight;
            }

            // Deal with viewports that are not started at (0,0)
            this.clipOffsetX -= viewX * this.clipScaleX;
            this.clipOffsetY -= viewY * this.clipScaleY;

            var clipSpace = this.techniqueParameters.clipSpace;
            clipSpace[0] = this.clipScaleX;
            clipSpace[1] = this.clipScaleY;
            clipSpace[2] = this.clipOffsetX;
            clipSpace[3] = this.clipOffsetY;

            this.updateRenderTargetVbo(this.scissorX, this.scissorY, this.scissorWidth, this.scissorHeight);
            this.forceUpdate = false;
        }
    },

    getViewport: function getViewportFn(dst)
    {
        if (!dst)
        {
            dst = new Draw2D.prototype.floatArray(4);
        }
        var viewport = this.viewportRectangle;
        if (viewport)
        {
            dst[0] = viewport[0];
            dst[1] = viewport[1];
            dst[2] = viewport[2];
            dst[3] = viewport[3];
        }
        else
        {
            dst[0] = dst[1] = 0;
            dst[2] = this.graphicsDevice.width;
            dst[3] = this.graphicsDevice.height;
        }
        return dst;
    },
    getScreenSpaceViewport: function screenSpaceViewportFn(dst)
    {
        if (!dst)
        {
            dst = new Draw2D.prototype.floatArray(4);
        }
        // ensure mapping is correct.
        this.update();

        dst[0] = this.scissorX;
        dst[1] = this.height - (this.scissorY + this.scissorHeight);
        dst[2] = dst[0] + this.scissorWidth;
        dst[3] = dst[1] + this.scissorHeight;
        return dst;
    },

    viewportMap: function viewportMapFn(screenX, screenY, dst)
    {
        if (!dst)
        {
            dst = new Draw2D.prototype.floatArray(2);
        }
        // ensure mapping is correct.
        this.update();

        // webgl coordinates have flipped y.
        var scissorY = (this.height - this.scissorHeight - this.scissorY);

        dst[0] = (screenX - this.scissorX) * this.viewScaleX;
        dst[1] = (screenY - scissorY) * this.viewScaleY;

        var viewport = this.viewportRectangle;
        if (viewport)
        {
            dst[0] += viewport[0];
            dst[1] += viewport[1];
        }

        return dst;
    },
    viewportUnmap: function screenMapFn(x, y, dst)
    {
        if (!dst)
        {
            dst = new Draw2D.prototype.floatArray(2);
        }
        // ensure mapping is correct.
        this.update();

        var viewport = this.viewportRectangle;
        if (viewport)
        {
            x -= viewport[0];
            y -= viewport[1];
        }

        // webgl coordinates have flipped y.
        var scissorY = (this.height - this.scissorHeight - this.scissorY);

        dst[0] = (x / this.viewScaleX) + this.scissorX;
        dst[1] = (y / this.viewScaleY) + scissorY;
        return dst;
    },

    viewportClamp: function viewportClampFn(point)
    {
        if (point)
        {
            var x = point[0];
            var y = point[1];

            var minX, minY, maxX, maxY;
            var viewport = this.viewportRectangle;
            if (viewport)
            {
                minX = viewport[0];
                minY = viewport[1];
                maxX = viewport[2];
                maxY = viewport[3];
            }
            else
            {
                minX = 0;
                minY = 0;
                maxX = this.graphicsDevice.width;
                maxY = this.graphicsDevice.height;
            }

            if (x < minX)
            {
                x = minX;
            }
            else if (x > maxX)
            {
                x = maxX;
            }

            if (y < minY)
            {
                y = minY;
            }
            else if (y > maxY)
            {
                y = maxY;
            }

            point[0] = x;
            point[1] = y;
        }

        return point;
    },

    configure: function configureFn(params)
    {
        if (this.state !== this.drawStates.ready)
        {
            return false;
        }

        var viewportRectangle = ("viewportRectangle" in params) ? params.viewportRectangle : this.viewportRectangle;

        var scaleMode = params.scaleMode;
        if (scaleMode !== undefined)
        {
            // check scaleMode is supported.
            if (!(scaleMode in this.scale))
            {
                return false;
            }
            if (scaleMode === 'scale' && !viewportRectangle)
            {
                return false;
            }
            this.scaleMode = scaleMode;
        }

        this.viewportRectangle = viewportRectangle;

        this.forceUpdate = true;
        this.update();

        return true;
    },

    destroy: function destroyFn()
    {
        this.texLists = null;
        this.state = this.drawStates.uninit;

        delete this.graphicsDevice;

        if (this.vertexBuffer)
        {
            this.vertexBuffer.destroy();
        }
        if (this.indexBuffer)
        {
            this.indexBuffer.destroy();
        }

        this.copyVertexBuffer.destroy();

        var renderTargets = this.renderTargetStructs;
        while (renderTargets.length > 0)
        {
            var target = renderTargets.pop();
            target.texture.destroy();
            target.renderTarget.destroy();
            delete target.texture;
            delete target.renderTarget;
        }
    },

    begin: function beginFn(blendMode, sortMode)
    {
        // Check sort mode is well defined (or undefined signifying default)
        if (sortMode && !(sortMode in this.sort))
        {
            return false;
        }

        // Check blend mode is well defined (or undefined signifying default)
        if (blendMode && !(blendMode in this.blend))
        {
            return false;
        }

        //if there are render states left in the stack
        //and begin has been called without an end
        //draw previous data with current render state
        var firstTime = !this.sortMode;
        if (this.dispatch())
        {
            this.clearBatch();
        }

        if (firstTime)
        {
            if (this.state !== this.drawStates.ready)
            {
                return false;
            }

            // Check the buffers are correct before we render
            this.update();

            if (!this.currentRenderTarget)
            {
                this.graphicsDevice.setScissor(this.scissorX, this.scissorY, this.scissorWidth, this.scissorHeight);
            }
        }

        this.state = this.drawStates.draw;

        sortMode  = (sortMode)  ? sortMode  : (firstTime ? 'deferred' : this.sortMode);
        blendMode = (blendMode) ? blendMode : (firstTime ? 'opaque'   : this.blendMode);


        if (!firstTime)
        {
            this.sortModeStack.push(this.sortMode);
            this.blendModeStack.push(this.blendMode);
        }
        this.sortMode = sortMode;
        this.blendMode = blendMode;

        this.prepareSortMode(sortMode);
        this.graphicsDevice.setTechnique(this.blendModeTechniques[blendMode]);

        return true;
    },

    ///////////////////////////////////////////////////////////////////////////////////////////////

    // append sprite data to group buffer.
    _bufferSprite : function bufferSpriteFn(group, sprite)
    {
        var vertexData = group.vertexBufferData;
        var vertexBuffer = this.vertexBuffer;

        var index = group.numVertices * vertexBuffer.stride;
        var total = index + (4 * vertexBuffer.stride);
        if (total >= vertexData.length)
        {
            // allocate new vertex buffer data array.
            var size = this.bufferSizeAlgorithm(total, this.cpuStride);
            var newData = new Draw2D.prototype.floatArray(size);

            // copy data from existing buffer.
            var i;
            for (i = 0; i < index; i += 1)
            {
                newData[i] = vertexData[i];
            }

            group.vertexBufferData = vertexData = newData;
        }

        var c1 = sprite[8];
        var c2 = sprite[9];
        var c3 = sprite[10];
        var c4 = sprite[11];
        var u1 = sprite[12];
        var v1 = sprite[13];
        var u2 = sprite[14];
        var v2 = sprite[15];

        vertexData[index]      = sprite[0];
        vertexData[index + 1]  = sprite[1];
        vertexData[index + 2]  = c1;
        vertexData[index + 3]  = c2;
        vertexData[index + 4]  = c3;
        vertexData[index + 5]  = c4;
        vertexData[index + 6]  = u1;
        vertexData[index + 7]  = v1;

        vertexData[index + 8]  = sprite[2];
        vertexData[index + 9]  = sprite[3];
        vertexData[index + 10] = c1;
        vertexData[index + 11] = c2;
        vertexData[index + 12] = c3;
        vertexData[index + 13] = c4;
        vertexData[index + 14] = u2;
        vertexData[index + 15] = v1;

        vertexData[index + 16] = sprite[4];
        vertexData[index + 17] = sprite[5];
        vertexData[index + 18] = c1;
        vertexData[index + 19] = c2;
        vertexData[index + 20] = c3;
        vertexData[index + 21] = c4;
        vertexData[index + 22] = u1;
        vertexData[index + 23] = v2;

        vertexData[index + 24] = sprite[6];
        vertexData[index + 25] = sprite[7];
        vertexData[index + 26] = c1;
        vertexData[index + 27] = c2;
        vertexData[index + 28] = c3;
        vertexData[index + 29] = c4;
        vertexData[index + 30] = u2;
        vertexData[index + 31] = v2;

        group.numVertices += 4;

        // increment number of indices in present subset.
        group.indices[group.numSets - 1] += 6;
    },

    bufferMultiSprite : function bufferMultiSprite(group, buffer, count, offset)
    {
        var vertexData = group.vertexBufferData;
        var vertexBuffer = this.vertexBuffer;

        var numSprites = (count === undefined) ? Math.floor(buffer.length / 16) : count;
        count = numSprites * 16;

        offset = (offset !== undefined ? offset : 0) * 16;

        var i;
        var index = (group.numVertices * vertexBuffer.stride);
        var total = index + (numSprites * 4 * vertexBuffer.stride);
        if (total >= vertexData.length)
        {
            // allocate new vertex buffer data array.
            var size = this.bufferSizeAlgorithm(total, this.cpuStride);
            var newData = new Draw2D.prototype.floatArray(size);

            // copy data from existing buffer.
            for (i = 0; i < index; i += 1)
            {
                newData[i] = vertexData[i];
            }

            group.vertexBufferData = vertexData = newData;
        }

        var limit = offset + count;
        for (i = offset; i < limit; i += 16)
        {
            var c1 = buffer[i + 8];
            var c2 = buffer[i + 9];
            var c3 = buffer[i + 10];
            var c4 = buffer[i + 11];
            var u1 = buffer[i + 12];
            var v1 = buffer[i + 13];
            var u2 = buffer[i + 14];
            var v2 = buffer[i + 15];

            vertexData[index]      = buffer[i];
            vertexData[index + 1]  = buffer[i + 1];
            vertexData[index + 2]  = c1;
            vertexData[index + 3]  = c2;
            vertexData[index + 4]  = c3;
            vertexData[index + 5]  = c4;
            vertexData[index + 6]  = u1;
            vertexData[index + 7]  = v1;

            vertexData[index + 8]  = buffer[i + 2];
            vertexData[index + 9]  = buffer[i + 3];
            vertexData[index + 10] = c1;
            vertexData[index + 11] = c2;
            vertexData[index + 12] = c3;
            vertexData[index + 13] = c4;
            vertexData[index + 14] = u2;
            vertexData[index + 15] = v1;

            vertexData[index + 16] = buffer[i + 4];
            vertexData[index + 17] = buffer[i + 5];
            vertexData[index + 18] = c1;
            vertexData[index + 19] = c2;
            vertexData[index + 20] = c3;
            vertexData[index + 21] = c4;
            vertexData[index + 22] = u1;
            vertexData[index + 23] = v2;

            vertexData[index + 24] = buffer[i + 6];
            vertexData[index + 25] = buffer[i + 7];
            vertexData[index + 26] = c1;
            vertexData[index + 27] = c2;
            vertexData[index + 28] = c3;
            vertexData[index + 29] = c4;
            vertexData[index + 30] = u2;
            vertexData[index + 31] = v2;

            index += 32;
        }

        group.numVertices += (numSprites * 4);
        // increment number of indices in present subset.
        group.indices[group.numSets - 1] += (numSprites * 6);
    },

    ///////////////////////////////////////////////////////////////////////////////////////////////

    indexData : function indexDataFn(count)
    {
        var indexData = new Draw2D.prototype.uint16Array(count);
        var i;
        var vertexIndex = 0;
        for (i = 0; i < count; i += 6)
        {
            indexData[i]     = vertexIndex;
            indexData[i + 1] = vertexIndex + 1;
            indexData[i + 2] = vertexIndex + 2;
            indexData[i + 3] = vertexIndex + 1;
            indexData[i + 4] = vertexIndex + 2;
            indexData[i + 5] = vertexIndex + 3;
            vertexIndex += 4;
        }
        return indexData;
    },

    // upload group buffer to graphics device vertexBuffer.
    uploadBuffer : function uploadBufferFn(group, count, offset)
    {
        var vertexBuffer = this.vertexBuffer;
        var vertexBufferParameters = this.vertexBufferParameters;
        var graphicsDevice = this.graphicsDevice;
        var vertexData = group.vertexBufferData;

        var performanceData = this.performanceData;

        // Resize buffers.
        if (count > vertexBufferParameters.numVertices)
        {
            var newSize = this.bufferSizeAlgorithm(count, this.gpuStride);
            if (newSize > this.maxVertices)
            {
                newSize = this.maxVertices;
            }

            vertexBufferParameters.numVertices = newSize;
            this.vertexBuffer.destroy();
            this.vertexBuffer = vertexBuffer = graphicsDevice.createVertexBuffer(vertexBufferParameters);

            // 32 bytes per vertex.
            // 2 bytes per index, 1.5 indices per vertex.
            performanceData.gpuMemoryUsage = newSize * 35; // 32 + (1.5 * 2)

            newSize *= 1.5;

            // Set indices.
            var indexBufferParameters = this.indexBufferParameters;
            indexBufferParameters.data = this.indexData(newSize);
            indexBufferParameters.numIndices = newSize;
            this.indexBuffer.destroy();
            this.indexBuffer = graphicsDevice.createIndexBuffer(indexBufferParameters);
            graphicsDevice.setIndexBuffer(this.indexBuffer);
        }

        performanceData.dataTransfers += 1;

        // Upload data.
        if (offset === 0)
        {
            vertexBuffer.setData(vertexData, 0, count);
        }
        else
        {
            var stride = vertexBuffer.stride;
            vertexBuffer.setData(vertexData.subarray(offset * stride, (offset + count) * stride), 0, count);
        }
    },

    ///////////////////////////////////////////////////////////////////////////////////////////////

    drawRawImmediate : function drawRawImmediateFn(texture, multiSprite, count, offset)
    {
        var group = this.drawGroups[0];
        group.textures[0] = texture || this.defaultTexture;
        group.indices[0] = 0;
        group.numSets = 1;
        this.numGroups = 1;

        this.bufferMultiSprite(group, multiSprite, count, offset);

        // Draw render group immediately.
        this.dispatch();
    },

    drawSpriteImmediate : function drawSpriteImmediateFn(sprite)
    {
        var group = this.drawGroups[0];
        group.textures[0] = sprite._texture || this.defaultTexture;
        group.indices[0] = 0;
        group.numSets = 1;
        this.numGroups = 1;

        sprite._update(this.spriteAngleFactor);
        this._bufferSprite(group, sprite.data);

        // Draw render group immediately.
        this.dispatch();
    },

    drawImmediate : function drawImmediateFn(params)
    {
        var texture = params.texture || this.defaultTexture;
        var destRect = params.destinationRectangle;
        var srcRect = params.sourceRectangle;
        var color = params.color;
        var rotation = params.rotation;

        var group = this.drawGroups[0];
        group.textures[0] = texture;
        group.indices[0] = 0;
        group.numSets = 1;
        this.numGroups = 1;

        var drawSprite = this.drawSprite;
        Draw2DSpriteData.setFromRotatedRectangle(drawSprite, texture, destRect, srcRect, color, rotation, params.origin);
        this._bufferSprite(group, drawSprite);

        // Draw render group immediately.
        this.dispatch();
    },

    ///////////////////////////////////////////////////////////////////////////////////////////////

    drawRawDeferred : function drawRawDeferredFn(texture, multiSprite, count, offset)
    {
        texture = texture || this.defaultTexture;
        var group = this.drawGroups[0];
        this.numGroups = 1;
        // If present group draw list uses a different texture
        // We must start a new draw list.
        var numSets = group.numSets;
        if (numSets === 0 || group.textures[numSets - 1] !== texture)
        {
            group.textures[numSets] = texture;
            group.indices[numSets] = 0;
            group.numSets += 1;
        }

        this.bufferMultiSprite(group, multiSprite, count, offset);
    },

    drawSpriteDeferred : function drawSpriteDeferredFn(sprite)
    {
        var texture = sprite._texture || this.defaultTexture;

        var group = this.drawGroups[0];
        this.numGroups = 1;
        // If present group draw list uses a different texture
        // We must start a new draw list.
        var numSets = group.numSets;
        if (numSets === 0 || group.textures[numSets - 1] !== texture)
        {
            group.textures[numSets] = texture;
            group.indices[numSets] = 0;
            group.numSets += 1;
        }

        sprite._update(this.spriteAngleFactor);
        this._bufferSprite(group, sprite.data);
    },

    drawDeferred : function drawDeferredFn(params)
    {
        var texture = params.texture || this.defaultTexture;

        var group = this.drawGroups[0];
        this.numGroups = 1;
        // If present group draw list uses a different texture
        // We must start a new draw list.
        var numSets = group.numSets;
        if (numSets === 0 || group.textures[numSets - 1] !== texture)
        {
            group.textures[numSets] = texture;
            group.indices[numSets] = 0;
            group.numSets += 1;
        }

        var destRect = params.destinationRectangle;
        var srcRect = params.sourceRectangle;
        var color = params.color;
        var rotation = params.rotation;

        var drawSprite = this.drawSprite;
        Draw2DSpriteData.setFromRotatedRectangle(drawSprite, texture, destRect, srcRect, color, rotation, params.origin);

        this._bufferSprite(group, drawSprite);
    },

    ///////////////////////////////////////////////////////////////////////////////////////////////

    drawRawTextured : function drawRawTexturedFn(texture, multiSprite, count, offset)
    {
        texture = texture || this.defaultTexture;
        var group;
        // If last call to drawTextured used the same texture, then we need not look up render group.
        if (this.currentTextureGroup !== undefined && this.currentTextureGroup.textures[0] === texture)
        {
            group = this.currentTextureGroup;
        }
        else
        {
            // Look up render group in texLists.
            var name = texture.name;
            var texLists = this.texLists;
            group = texLists[name];
            if (!group)
            {
                // Create new render group.
                group = this.drawGroups[this.numGroups];
                if (!group)
                {
                    group = Draw2DGroup.create();
                }
                this.drawGroups[this.numGroups] = texLists[name] = group;
                group.textures[0] = texture;
                group.indices[0] = 0;
                group.numSets = 1;
                this.numGroups += 1;
            }
            this.currentTextureGroup = group;
        }

        this.bufferMultiSprite(group, multiSprite, count, offset);
    },

    drawSpriteTextured : function drawSpriteTexturedFn(sprite)
    {
        var texture = sprite._texture || this.defaultTexture;

        var group;
        // If last call to drawTextured used the same texture, then we need not look up render group.
        if (this.currentTextureGroup !== undefined && this.currentTextureGroup.textures[0] === texture)
        {
            group = this.currentTextureGroup;
        }
        else
        {
            // Look up render group in texLists.
            var name = texture.name;
            var texLists = this.texLists;
            group = texLists[name];
            if (!group)
            {
                // Create new render group.
                group = this.drawGroups[this.numGroups];
                if (!group)
                {
                    group = Draw2DGroup.create();
                }
                this.drawGroups[this.numGroups] = texLists[name] = group;
                group.textures[0] = texture;
                group.indices[0] = 0;
                group.numSets = 1;
                this.numGroups += 1;
            }
            this.currentTextureGroup = group;
        }

        sprite._update(this.spriteAngleFactor);
        this._bufferSprite(group, sprite.data);
    },

    drawTextured : function drawTexturedFn(params)
    {
        var texture = params.texture || this.defaultTexture;

        var group;
        // If last call to drawTextured used the same texture, then we need not look up render group.
        if (this.currentTextureGroup !== undefined && this.currentTextureGroup.textures[0] === texture)
        {
            group = this.currentTextureGroup;
        }
        else
        {
            // Look up render group in texLists.
            var name = texture.name;
            var texLists = this.texLists;
            group = texLists[name];
            if (!group)
            {
                // Create new render group.
                group = this.drawGroups[this.numGroups];
                if (!group)
                {
                    group = Draw2DGroup.create();
                }
                this.drawGroups[this.numGroups] = texLists[name] = group;
                group.textures[0] = texture;
                group.indices[0] = 0;
                group.numSets = 1;
                this.numGroups += 1;
            }
            this.currentTextureGroup = group;
        }

        var destRect = params.destinationRectangle;
        var srcRect = params.sourceRectangle;
        var color = params.color;
        var rotation = params.rotation;

        var drawSprite = this.drawSprite;
        Draw2DSpriteData.setFromRotatedRectangle(drawSprite, texture, destRect, srcRect, color, rotation, params.origin);

        this._bufferSprite(group, drawSprite);
    },

    ///////////////////////////////////////////////////////////////////////////////////////////////

    prepareSortMode : function refreshSortModeFn(sortMode)
    {
        if (sortMode === 'deferred')
        {
            this.draw = this.drawDeferred;
            this.drawSprite = this.drawSpriteDeferred;
            this.drawRaw = this.drawRawDeferred;
        }
        else if (sortMode === 'immediate')
        {
            this.draw = this.drawImmediate;
            this.drawSprite = this.drawSpriteImmediate;
            this.drawRaw = this.drawRawImmediate;
        }
        else
        {
            this.draw = this.drawTextured;
            this.drawSprite = this.drawSpriteTextured;
            this.drawRaw = this.drawRawTextured;
        }
    },

    ///////////////////////////////////////////////////////////////////////////////////////////////

    end: function endFn()
    {
        if (this.state !== this.drawStates.draw)
        {
            return false;
        }

        //dispatch objects to the graphics card
        if (this.dispatch())
        {
            this.clearBatch();
        }

        if (this.blendModeStack.length !== 0)
        {
            this.blendMode = this.blendModeStack.pop();
            this.sortMode = this.sortModeStack.pop();
            this.prepareSortMode(this.sortMode);
            this.graphicsDevice.setTechnique(this.blendModeTechniques[this.blendMode]);
        }
        else
        {
            this.blendMode = undefined;
            this.sortMode = undefined;
            this.state = this.drawStates.ready;
        }

        return true;
    },

    dispatch: function dispatchFn()
    {
        // Nothing to dispatch.
        var numGroups = this.numGroups;
        if (numGroups === 0)
        {
            return false;
        }

        var graphicsDevice = this.graphicsDevice;
        var techniqueParameters = this.techniqueParameters;
        graphicsDevice.setIndexBuffer(this.indexBuffer);

        var drawGroups = this.drawGroups;
        var renderTargetUsed = false;
        if (this.currentRenderTarget)
        {
            renderTargetUsed = graphicsDevice.beginRenderTarget(this.currentRenderTarget.renderTarget);
        }

        var performanceData = this.performanceData;

        var i;
        for (i = 0; i < numGroups; i += 1)
        {
            var group = drawGroups[i];

            var textures = group.textures;
            var indices = group.indices;
            var setIndex = 0;

            var vindex = 0;
            var vlimit = group.numVertices;
            while (vindex < vlimit)
            {
                // number of vertices remaining.
                var vcount = vlimit - vindex;
                if (vcount > this.maxVertices)
                {
                    vcount = this.maxVertices;
                }

                // Upload group vertex sub-buffer to graphics device.
                this.uploadBuffer(group, vcount, vindex);
                graphicsDevice.setStream(this.vertexBuffer, this.semantics);

                // sprite uses 4 vertices, and 6 indices
                // so for 'vcount' number of vertices, we have vcount * 1.5 indices
                var ilimit = vcount * 1.5;
                var iindex = 0;
                while (iindex < ilimit) {
                    techniqueParameters.texture = textures[setIndex];

                    // number of indices remaining to render.
                    var icount = ilimit - iindex;
                    if (icount >= indices[setIndex])
                    {
                        // finish rendering sub list.
                        icount = indices[setIndex];
                        setIndex += 1;
                    }
                    else
                    {
                        // sub list still has remaining indices to render.
                        indices[setIndex] -= icount;
                    }

                    var batchSize = icount / 6;
                    if (performanceData.batchCount === 0)
                    {
                        performanceData.minBatchSize = batchSize;
                        performanceData.maxBatchSize = batchSize;
                        performanceData.avgBatchSize = batchSize;
                        performanceData.batchCount = 1;
                    }
                    else
                    {
                        if (batchSize < performanceData.minBatchSize)
                        {
                            performanceData.minBatchSize = batchSize;
                        }
                        if (batchSize > performanceData.maxBatchSize)
                        {
                            performanceData.maxBatchSize = batchSize;
                        }
                        performanceData.avgBatchSize *= performanceData.batchCount;
                        performanceData.avgBatchSize += batchSize;
                        performanceData.batchCount += 1;
                        performanceData.avgBatchSize /= performanceData.batchCount;
                    }

                    graphicsDevice.setTechniqueParameters(techniqueParameters);
                    graphicsDevice.drawIndexed(graphicsDevice.PRIMITIVE_TRIANGLES, icount, iindex);

                    iindex += icount;
                }

                vindex += vcount;
            }

            group.numSets = 0;
            group.numVertices = 0;
        }

        if (this.currentRenderTarget && renderTargetUsed)
        {
            graphicsDevice.endRenderTarget();
        }

        return true;
    },

    bufferSizeAlgorithm : function bufferSizeAlgorithmFn(target, stride)
    {
        // scale factor of 2 is asymtopically optimal in terms of number of resizes
        // performed and copies performed, but we want to try and conserve memory
        // and so choose a less optimal 1.25 so that buffer will never be too much
        // larger than necessary.
        var factor = 1.25;

        // We size buffer to the next power of the factor which is >= target
        var logf = Math.ceil(Math.log(target) / Math.log(factor));
        var size = Math.floor(Math.pow(factor, logf));

        // Additionally ensure that we always take a multiple of of the stride
        // to avoid wasted bytes that could never be used.
        return (stride * Math.ceil(size / stride));
    },

    updateRenderTargetVbo : function updateRenderTargetVboFn(viewX, viewY, viewWidth, viewHeight)
    {
        var graphicsDevice = this.graphicsDevice;
        var halfGraphicsDeviceWidth = 0.5 * graphicsDevice.width;
        var halfGraphicsDeviceHeight = 0.5 * graphicsDevice.height;

        //
        // Update the VBO for the presentRenderTarget
        //
        var vertexBuffer = this.copyVertexBuffer;

        var left = (viewX - halfGraphicsDeviceWidth) / halfGraphicsDeviceWidth;
        var right = (viewX + viewWidth - halfGraphicsDeviceWidth) / halfGraphicsDeviceWidth;
        var topv = (viewY - halfGraphicsDeviceHeight) / halfGraphicsDeviceHeight;
        var bottom = (viewY + viewHeight - halfGraphicsDeviceHeight) / halfGraphicsDeviceHeight;

        var vertexData = this.vertexBufferData;
        vertexData[0] = left;
        vertexData[1] = bottom;
        vertexData[2] = 0.0;
        vertexData[3] = 1.0;

        vertexData[4] = left;
        vertexData[5] = topv;
        vertexData[6] = 0.0;
        vertexData[7] = 0.0;

        vertexData[8] = right;
        vertexData[9] = bottom;
        vertexData[10] = 1.0;
        vertexData[11] = 1.0;

        vertexData[12] = right;
        vertexData[13] = topv;
        vertexData[14] = 1.0;
        vertexData[15] = 0.0;

        vertexBuffer.setData(vertexData, 0, 4);
    },

    // always overallocate.
    makePow2 : function makePow2Fn(dim)
    {
        var index = Math.log(dim) / Math.log(2);
        return (1 << Math.ceil(index));
    },

    createRenderTarget : function createRenderTargetFn(params)
    {
        var gd = this.graphicsDevice;
        var renderTargets = this.renderTargetStructs;
        var index = renderTargets.length;

        var name = (params && params.name) ? params.name : ("RenderTarget#" + index);
        var backBuffer = (params && params.backBuffer !== undefined) ? params.backBuffer : true;
        var matchScreen = (params.width === undefined || params.height === undefined);

        var texParams = this.renderTargetTextureParameters;
        texParams.name = name;

        var width  = (matchScreen) ? gd.width  : params.width;
        var height = (matchScreen) ? gd.height : params.height;
        texParams.width  = this.makePow2(width);
        texParams.height = this.makePow2(height);

        var texture = gd.createTexture(texParams);
        var targetParams = this.renderTargetParams;
        targetParams.colorTexture0 = texture;
        var renderTarget = gd.createRenderTarget(targetParams);

        renderTargets.push({
            managed : matchScreen,
            renderTarget : renderTarget,
            texture : texture,
            backBuffer : backBuffer,
            actualWidth  : (backBuffer ? width  : texture.width),
            actualHeight : (backBuffer ? height : texture.height)
        });

        return index;
    },

    validateTarget : function validateTargetFn(target, viewWidth, viewHeight)
    {
        if (target.managed)
        {
            var tex = target.texture;
            if (target.backBuffer)
            {
                target.actualWidth = viewWidth;
                target.actualHeight = viewHeight;
            }
            viewWidth = this.makePow2(viewWidth);
            viewHeight = this.makePow2(viewHeight);
            if (!target.backBuffer)
            {
                target.actualWidth = viewWidth;
                target.actualHeight = viewHeight;
            }
            if (tex.width !== viewWidth || tex.height !== viewHeight)
            {
                var texParams = this.renderTargetTextureParameters;
                var targetParams = this.renderTargetParams;

                texParams.name = tex.name;
                texParams.width  = viewWidth;
                texParams.height = viewHeight;

                tex.destroy();
                target.renderTarget.destroy();

                var graphicsDevice = this.graphicsDevice;
                target.texture = graphicsDevice.createTexture(texParams);
                targetParams.colorTexture0 = target.texture;
                target.renderTarget = graphicsDevice.createRenderTarget(targetParams);
            }
        }
    },

    setBackBuffer : function setBackBufferFn()
    {
        if (this.state !== this.drawStates.ready)
        {
            return false;
        }

        this.currentRenderTarget = null;
        this.forceUpdate = true;

        return true;
    },

    getRenderTargetTexture : function getRenderTargetTextureFn(renderTargetIndex)
    {
        var renderTargets = this.renderTargetStructs;
        if (renderTargetIndex < 0 || renderTargetIndex >= renderTargets.length)
        {
            return null;
        }

        return renderTargets[renderTargetIndex].texture;
    },

    getRenderTarget : function getRenderTargetFn(renderTargetIndex)
    {
        var renderTargets = this.renderTargetStructs;
        if (renderTargetIndex < 0 || renderTargetIndex >= renderTargets.length)
        {
            return null;
        }

        return renderTargets[renderTargetIndex].renderTarget;
    },

    setRenderTarget : function setRenderTargetFn(renderTargetIndex)
    {
        var renderTargets = this.renderTargetStructs;
        if (renderTargetIndex < 0 || renderTargetIndex >= renderTargets.length)
        {
            return false;
        }

        if (this.state !== this.drawStates.ready)
        {
            return false;
        }

        this.currentRenderTarget = renderTargets[renderTargetIndex];
        this.forceUpdate = true;

        return true;
    },

    copyRenderTarget: function copyRenderTargetFn(renderTargetIndex)
    {
        if (this.state !== this.drawStates.ready)
        {
            return false;
        }

        var renderTargets = this.renderTargetStructs;
        if (renderTargetIndex < 0 || renderTargetIndex >= renderTargets.length)
        {
            return false;
        }

        // Check the buffers are correct before we render.
        this.update();

        if (!this.currentRenderTarget)
        {
            this.graphicsDevice.setScissor(this.scissorX, this.scissorY, this.scissorWidth, this.scissorHeight);
        }

        var graphicsDevice = this.graphicsDevice;
        var target = renderTargets[renderTargetIndex];
        var tex = target.texture;

        var technique = this.copyTechnique;
        var params = this.copyTechniqueParameters;
        var copyUVScale = params.copyUVScale;
        copyUVScale[0] = target.actualWidth / tex.width;
        copyUVScale[1] = target.actualHeight / tex.height;
        params.copyFlip = (!this.currentRenderTarget ? -1.0 : 1.0);
        params.inputTexture0 = tex;

        var renderTargetUsed = false;
        var currentTarget = this.currentRenderTarget;
        var vbo = this.copyVertexBuffer;
        if (currentTarget)
        {
            renderTargetUsed = graphicsDevice.beginRenderTarget(currentTarget.renderTarget);
        }

        graphicsDevice.setTechnique(technique);
        graphicsDevice.setTechniqueParameters(params);

        graphicsDevice.setStream(vbo, this.quadSemantics);
        graphicsDevice.draw(this.quadPrimitive, 4, 0);

        if (currentTarget && renderTargetUsed)
        {
            graphicsDevice.endRenderTarget();
        }

        return true;
    },

    resetPerformanceData : function resetPerformanceDataFn()
    {
        var data = this.performanceData;
        data.minBatchSize = data.maxBatchSize = data.avgBatchSize = undefined;
        data.batchCount = 0;
        data.dataTransfers = 0;
    }
};

// Constructor function
//
// params : {
//    graphicsDevice : gd,
//    blendModes : { // optional
//       name : Technique,
//       **repeated**
//    }
// }
Draw2D.create = function draw2DCreateFn(params)
{
    var o = new Draw2D();
    var gd = o.graphicsDevice = params.graphicsDevice;

    // Current sort and blend mode.
    o.sortMode  = undefined;
    o.blendMode = undefined;
    // Disjoint stack of modes for nested begins.
    o.sortModeStack  = [];
    o.blendModeStack = [];

    // Set of render groups to be dispatched.
    o.drawGroups = [Draw2DGroup.create()];
    o.numGroups = 0;

    // Set of render groups for texture sort mode.
    // dictionary on texture name.
    o.texLists = [];
    // Cached reference to last retrieved group to accelerate
    // texture sort mode draw calls.
    o.texGroup = undefined;

    // Sprite data instance used for rectangle draw calls.
    o.drawSprite = Draw2DSpriteData.create();

    // Solid fill texture for draw calls that do not specify a texture.
    o.defaultTexture = gd.createTexture({
        name : "DefaultDraw2DTexture",
        width : 1,
        height : 1,
        depth : 1,
        format : "L8",
        cubemap : false,
        mipmaps : true,
        renderable : false,
        dynamic : false,
        data : [0xff]
    });

    // Draw call methods.
    // These are set based on current sort mode.
    o.draw = undefined;
    o.drawSprite = undefined;
    o.drawRaw = undefined;

    // Load embedded default shader and techniques
    /*jshint white: false*/
    var shader = gd.createShader(
{
 "version": 1,
 "name": "draw2D.cgfx",
 "samplers":
 {
  "texture":
  {
   "MinFilter": 9985,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  },
  "inputTexture0":
  {
   "MinFilter": 9728,
   "MagFilter": 9729,
   "WrapS": 33071,
   "WrapT": 33071
  }
 },
 "parameters":
 {
  "clipSpace":
  {
   "type": "float",
   "columns": 4
  },
  "copyUVScale":
  {
   "type": "float",
   "columns": 2
  },
  "copyFlip":
  {
   "type": "float"
  },
  "texture":
  {
   "type": "sampler2D"
  },
  "inputTexture0":
  {
   "type": "sampler2D"
  }
 },
 "techniques":
 {
  "opaque":
  [
   {
    "parameters": ["clipSpace","texture"],
    "semantics": ["POSITION","COLOR","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_draw2D","fp_draw2D"]
   }
  ],
  "alpha":
  [
   {
    "parameters": ["clipSpace","texture"],
    "semantics": ["POSITION","COLOR","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [770,771]
    },
    "programs": ["vp_draw2D","fp_draw2D"]
   }
  ],
  "additive":
  [
   {
    "parameters": ["clipSpace","texture"],
    "semantics": ["POSITION","COLOR","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [770,1]
    },
    "programs": ["vp_draw2D","fp_draw2D"]
   }
  ],
  "copy":
  [
   {
    "parameters": ["copyUVScale","copyFlip","inputTexture0"],
    "semantics": ["POSITION","TEXCOORD0"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": false
    },
    "programs": ["vp_copy","fp_copy"]
   }
  ]
 },
 "programs":
 {
  "fp_copy":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];\nvec4 _ret_0;uniform sampler2D inputTexture0;void main()\n{_ret_0=texture2D(inputTexture0,tz_TexCoord[0].xy);gl_FragColor=_ret_0;}"
  },
  "vp_copy":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying vec4 tz_TexCoord[8];attribute vec4 ATTR8;attribute vec4 ATTR0;\nvec4 _OutPosition1;vec2 _OutUV1;uniform vec2 copyUVScale;uniform float copyFlip;void main()\n{_OutPosition1.x=ATTR0.x;_OutPosition1.y=ATTR0.y*copyFlip;_OutPosition1.zw=ATTR0.zw;_OutUV1=ATTR8.xy*copyUVScale;tz_TexCoord[0].xy=_OutUV1;gl_Position=_OutPosition1;}"
  },
  "fp_draw2D":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;varying vec4 tz_TexCoord[8];\nvec4 _ret_0;vec4 _TMP0;uniform sampler2D texture;void main()\n{_TMP0=texture2D(texture,tz_TexCoord[0].xy);_ret_0=tz_Color*_TMP0;gl_FragColor=_ret_0;}"
  },
  "vp_draw2D":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;varying vec4 tz_TexCoord[8];attribute vec4 ATTR8;attribute vec4 ATTR3;attribute vec4 ATTR0;\nvec4 _OUTPosition1;vec4 _OUTColor1;vec2 _OUTTexCoord01;uniform vec4 clipSpace;void main()\n{vec2 _position;_position=ATTR0.xy*clipSpace.xy+clipSpace.zw;_OUTPosition1.x=_position.x;_OUTPosition1.y=_position.y;_OUTPosition1.z=0.0;_OUTPosition1.w=1.0;_OUTColor1=ATTR3;_OUTTexCoord01=ATTR8.xy;tz_TexCoord[0].xy=ATTR8.xy;tz_Color=ATTR3;gl_Position=_OUTPosition1;}"
  }
 }
}
    );
    /*jshint white: true*/

    // supported blend modes.
    o.blend = {
        additive : 'additive',
        alpha    : 'alpha',
        opaque   : 'opaque'
    },

    // Mapping from blend mode name to Technique object.
    o.blendModeTechniques = {};
    o.blendModeTechniques.additive = shader.getTechnique("additive");
    o.blendModeTechniques.alpha    = shader.getTechnique("alpha");
    o.blendModeTechniques.opaque   = shader.getTechnique("opaque");

    // Append techniques and supported blend modes with user supplied techniques.
    if (params.blendModes)
    {
        for (var name in params.blendModes)
        {
            if (params.blendModes.hasOwnProperty(name))
            {
                o.blend[name] = name;
                o.blendModeTechniques[name] = params.blendModes[name];
            }
        }
    }

    // Blending techniques.
    o.techniqueParameters = gd.createTechniqueParameters({
        clipSpace: new Draw2D.prototype.floatArray(4),
        texture: null
    });

    // Current render target
    o.currentRenderTarget = null;
    o.renderTargetStructs = [];

    o.state = o.drawStates.ready;

    o.scaleMode = 'none';
    o.blendMode = 'opaque';

    // View port, back buffer and managed render target values.
    o.width = 0;
    o.height = 0;

    o.scissorX = 0;
    o.scissorY = 0;
    o.scissorWidth = o.graphicsDevice.width;
    o.scissorHeight = o.graphicsDevice.height;

    o.clipOffsetX = -1.0;
    o.clipOffsetY = 1;
    o.clipScaleX = 2.0 / o.graphicsDevice.width;
    o.clipScaleY = -2.0 / o.graphicsDevice.height;

    o.viewScaleX = 1;
    o.viewScaleY = 1;

    // GPU Memory.
    // -----------

    var initial = (params.initialGpuMemory ? params.initialGpuMemory : 0);
    if (initial < 140)
    {
        // 140 = minimum that can be used to draw a single sprite.
        initial = 140;
    }
    if (initial > 2293760)
    {
        // 2293760 = maximum that can ever be used in 16bit indices.
        initial = 2293760;
    }

    o.performanceData = {
        gpuMemoryUsage : initial,
        minBatchSize : 0,
        maxBatchSize : 0,
        avgBatchSize : 0,
        batchCount : 0,
        dataTransfers : 0
    };

    o.maxGpuMemory = (params.maxGpuMemory ? params.maxGpuMemory : 2293760);
    if (o.maxGpuMemory < initial)
    {
        o.maxGpuMemory = initial;
    }

    var initialVertices = Math.floor(initial / 140) * 4;
    o.maxVertices = Math.floor(o.maxGpuMemory / 140) * 4;
    if (o.maxVertices > 65536)
    {
        o.maxVertices = 65536;
    }

    // number of bytes used per-sprite on cpu vertex buffers.
    o.cpuStride = 64;

    // vertex buffer is in terms of number of vertices.
    // so we have a stride of 4 rather than 128.
    o.gpuStride = 4;

    // Index and vertex buffer setup.
    o.vertexBufferParameters = {
        numVertices: initialVertices,
        attributes: [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT4, gd.VERTEXFORMAT_FLOAT2],
        'transient': true
    };
    o.vertexBuffer = gd.createVertexBuffer(o.vertexBufferParameters);

    o.semantics = gd.createSemantics([gd.SEMANTIC_POSITION, gd.SEMANTIC_COLOR, gd.SEMANTIC_TEXCOORD0]);
    o.indexBufferParameters = {
        numIndices: (initialVertices * 1.5),
        format: gd.INDEXFORMAT_USHORT,
        dynamic: false,
        data : o.indexData((initialVertices * 1.5))
    };
    o.indexBuffer = gd.createIndexBuffer(o.indexBufferParameters);

    // Render Target API
    // -----------------

    // Objects and values used in render target management.
    o.renderTargetIndex = 0;
    o.renderTargetCount = 0;

    o.renderTargetTextureParameters = {
        name   : '',
        width  : 0,
        height : 0,
        depth  : 1,
        format     : "R8G8B8A8",
        cubemap    : false,
        mipmaps    : true,
        renderable : true,
        dynamic    : true
    };

    o.renderTargetParams = {
        colorTexture0 : null
    };

    // Render Target copying.
    // ----------------------

    // Copy technique for copyRenderTarget
    o.copyTechnique = shader.getTechnique("copy");
    o.copyTechniqueParameters = gd.createTechniqueParameters({
        inputTexture0 : null,
        copyFlip : 1,
        copyUVScale : new Draw2D.prototype.floatArray([1, 1])
    });

    // Objects used in copyRenderTarget method.
    o.quadSemantics = gd.createSemantics([gd.SEMANTIC_POSITION, gd.SEMANTIC_TEXCOORD0]);
    o.quadPrimitive = gd.PRIMITIVE_TRIANGLE_STRIP;

    o.copyVertexBufferParams = {
        numVertices: 4,
        attributes: [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT2],
        'transient': true
    };
    o.copyVertexBuffer = gd.createVertexBuffer(o.copyVertexBufferParams);

    // updateRenderTargetVBO
    // ---------------------

    /*jshint white: false*/
    o.vertexBufferData = new Draw2D.prototype.floatArray([-1.0, -1.0, 0.0, 0.0,
                                                           1.0, -1.0, 1.0, 0.0,
                                                          -1.0,  1.0, 0.0, 1.0,
                                                           1.0,  1.0, 1.0, 1.0]);
    /*jshint white: true*/

    return o;
};

// Detect correct typed arrays
(function () {
    Draw2D.prototype.uint16Array = function (arg) {
        if (arguments.length === 0)
        {
            return [];
        }

        var i, ret;
        if (typeof arg === "number")
        {
            ret = new Array(arg);
        }
        else
        {
            ret = [];
            for (i = 0; i < arg.length; i += 1)
            {
                ret[i] = arg[i];
            }
        }
        return ret;
    };

    var testArray;
    var textDescriptor;

    if (typeof Uint16Array !== "undefined")
    {
        testArray = new Uint16Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Uint16Array]')
        {
            Draw2D.prototype.uint16Array = Uint16Array;
        }
    }

    Draw2D.prototype.floatArray = function (arg) {
        if (arguments.length === 0)
        {
            return [];
        }

        var i, ret;
        if (typeof arg === "number")
        {
            ret = new Array(arg);
        }
        else
        {
            ret = [];
            for (i = 0; i < arg.length; i += 1)
            {
                ret[i] = arg[i];
            }
        }
        return ret;
    };

    if (typeof Float32Array !== "undefined")
    {
        testArray = new Float32Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            Draw2D.prototype.floatArray = Float32Array;
            Draw2D.prototype.defaultClearColor = new Float32Array(Draw2D.prototype.defaultClearColor);
        }
    }
}());

// Copyright (c) 2011-2012 Turbulenz Limited

/*global BadgeManager: false*/
/*global window: false*/
/*global GameSession: false*/
/*global Turbulenz*/
/*global TurbulenzBridge: false*/
/*global TurbulenzEngine: false*/
/*global Utilities: false*/
/*global MappingTable: false*/
/*global LeaderboardManager: false*/
/*global ServiceRequester: false*/
/*global Badges*/
/*global MultiPlayerSession: false*/
/*global MultiPlayerSessionManager: false*/
/*global Observer*/
/*global StoreManager: false*/
/*global JsLocalStore: false*/

var TurbulenzServices;

function ServiceRequester() {}
ServiceRequester.prototype =
{

    // make a request if the service is available. Same parameters as an
    // Utilities.ajax call with extra argument:
    //     neverDiscard - Never discard the request. Always queues the request
    //                    for when the service is again available. (Ignores
    //                    server preference)
    request: function requestFn(params)
    {
        var discardRequestFn = function discardRequestFn()
        {
            if (params.callback)
            {
                params.callback({'ok': false, 'msg': 'Service Unavailable. Discarding request'}, 503);
            }
        };

        var that = this;
        var serviceStatusObserver = this.serviceStatusObserver;

        var onServiceStatusChange;
        onServiceStatusChange = function onServiceStatusChangeFn(running, discardRequest)
        {
            if (discardRequest)
            {
                if (!params.neverDiscard)
                {
                    serviceStatusObserver.unsubscribe(onServiceStatusChange);
                    discardRequestFn();
                }
            }
            else if (running)
            {
                serviceStatusObserver.unsubscribe(onServiceStatusChange);
                that.request(params);
            }
        };

        if (!this.running)
        {
            if (this.discardRequests && !params.neverDiscard)
            {
                TurbulenzEngine.setTimeout(discardRequestFn, 0);
                return false;
            }

            // we check waiting so that we don't get into an infinite loop of callbacks
            // when a service goes down, then up and then down again before the subscribed
            // callbacks have all been called.
            if (!params.waiting)
            {
                params.waiting = true;
                serviceStatusObserver.subscribe(onServiceStatusChange);
            }
            return true;
        }

        var oldCustomErrorHandler = params.customErrorHandler;
        params.customErrorHandler = function checkServiceUnavailableFn(callContext, makeRequest, responseJSON, status)
        {
            if (status === 503)
            {
                var responseObj = JSON.parse(responseJSON);
                var statusObj = responseObj.data;
                var discardRequests = (statusObj ? statusObj.discardRequests : true);
                that.discardRequests = discardRequests;

                if (discardRequests && !params.neverDiscard)
                {
                    discardRequestFn();
                }
                else
                {
                    serviceStatusObserver.subscribe(onServiceStatusChange);
                }
                TurbulenzServices.serviceUnavailable(that, callContext);
                // An error occurred so return false to avoid calling the success callback
                return false;
            }
            else
            {
                // call the old custom error handler
                if (oldCustomErrorHandler)
                {
                    return oldCustomErrorHandler.call(params.requestHandler, callContext, makeRequest, responseJSON, status);
                }
                return true;
            }
        };

        Utilities.ajax(params);
        return true;
    }
};

ServiceRequester.create = function apiServiceCreateFn(serviceName, params)
{
    var serviceRequester = new ServiceRequester();

    if (!params)
    {
        params = {};
    }

    // we assume everything is working at first
    serviceRequester.running = true;
    serviceRequester.discardRequests = false;
    serviceRequester.serviceStatusObserver = Observer.create();

    serviceRequester.serviceName = serviceName;

    serviceRequester.onServiceUnavailable = params.onServiceUnavailable;
    serviceRequester.onServiceAvailable = params.onServiceAvailable;

    return serviceRequester;
};

//
// TurbulenzServices
//
TurbulenzServices = {

    multiplayerJoinRequestQueue: {
        // A FIFO queue that passes events through to the handler when un-paused and buffers up
        // events while paused
        argsQueue: [],
        handler: function nopFn() {},
        context: undefined,
        paused: true,
        onEvent: function onEventFn(handler, context) {
            this.handler = handler;
            this.context = context;
        },
        push: function pushFn(sessionId)
        {
            var args = [sessionId];
            if (this.paused)
            {
                this.argsQueue.push(args);
            }
            else
            {
                this.handler.apply(this.context, args);
            }
        },
        shift: function shiftFn()
        {
            var args = this.argsQueue.shift();
            return args ? args[0] : undefined;
        },
        clear: function clearFn()
        {
            this.argsQueue = [];
        },
        pause: function pauseFn()
        {
            this.paused = true;
        },
        resume: function resumeFn()
        {
            this.paused = false;
            while (this.argsQueue.length)
            {
                this.handler.apply(this.context, this.argsQueue.shift());
                if (this.paused)
                {
                    break;
                }
            }
        }
    },

    available: function turbulenzServicesAvailableFn()
    {
        return window.gameSlug !== undefined;
    },

    addBridgeEvents: function addBridgeEventsFn()
    {
        var turbulenz = window.top.Turbulenz;
        var turbulenzData = (turbulenz && turbulenz.Data) || {};
        var sessionToJoin = turbulenzData.joinMultiplayerSessionId;
        var that = this;

        var onJoinMultiplayerSession = function onJoinMultiplayerSessionFn(joinMultiplayerSessionId) {
            that.multiplayerJoinRequestQueue.push(joinMultiplayerSessionId);
        };

        var onReceiveConfig = function onReceiveConfigFn(configString) {
            var config = JSON.parse(configString);

            if (config.mode)
            {
                that.mode = config.mode;
            }

            if (config.joinMultiplayerSessionId)
            {
                that.multiplayerJoinRequestQueue.push(config.joinMultiplayerSessionId);
            }

            that.bridgeServices = !!config.bridgeServices;
        };

        // This should go once we have fully moved to the new system
        if (sessionToJoin)
        {
            this.multiplayerJoinRequestQueue.push(sessionToJoin);
        }

        TurbulenzBridge.setOnMultiplayerSessionToJoin(onJoinMultiplayerSession);
        TurbulenzBridge.setOnReceiveConfig(onReceiveConfig);
        TurbulenzBridge.triggerRequestConfig();

        // Setup framework for asynchronous function calls
        this.responseHandlers = [null];
        // 0 is reserved value for no registered callback
        this.responseIndex = 0;
        TurbulenzBridge.on("bridgeservices.response", function (jsondata) { that.routeResponse(jsondata); });
    },

    callOnBridge: function turbulenzServicesCallOnBridgeFn(event, data, callback)
    {
        var request = {
            data: data
        };
        if (callback)
        {
            this.responseIndex += 1;
            this.responseHandlers[this.responseIndex] = callback;
            request.key = this.responseIndex;
        }
        TurbulenzBridge.emit('bridgeservices.' + event, JSON.stringify(request));
    },

    addSignature: function turbulenzServicesAddSignatureFn(data, url)
    {
        var str;
        data.requestUrl = url;
        str = TurbulenzEngine.encrypt(JSON.stringify(data));
        data.str = str;
        data.signature = TurbulenzEngine.generateSignature(str);
        return data;
    },

    routeResponse: function routeResponseFn(jsondata)
    {
        var response = JSON.parse(jsondata);
        var index = response.key || 0;
        var callback = this.responseHandlers[index];
        if (callback)
        {
            this.responseHandlers[index] = null;
            callback(response.data);
        }
    },

    defaultErrorCallback: function turbulenzServicesDefaultErrorCallbackFn(errorMsg, httpStatus) {},

    onServiceUnavailable: function turbulenzServicesOnServiceUnavailableFn(serviceName, callContext) {},
    onServiceAvailable: function turbulenzServicesOnServiceAvailableFn(serviceName, callContext) {},

    createGameSession: function turbulenzServicesCreateGameSession(requestHandler, sessionCreatedFn, errorCallbackFn)
    {
        return GameSession.create(requestHandler, sessionCreatedFn, errorCallbackFn);
    },

    createMappingTable: function turbulenzServicesCreateMappingTable(requestHandler,
                                                                     gameSession,
                                                                     tableRecievedFn,
                                                                     defaultMappingSettings,
                                                                     errorCallbackFn)
    {
        var mappingTable = new MappingTable();
        var mappingTableSettings = gameSession && gameSession.mappingTable;
        if (mappingTableSettings)
        {
            mappingTable.mappingTableURL = mappingTableSettings.mappingTableURL;
            mappingTable.mappingTablePrefix = mappingTableSettings.mappingTablePrefix;
            mappingTable.assetPrefix = mappingTableSettings.assetPrefix;
        }
        else if (defaultMappingSettings)
        {
            mappingTable.mappingTableURL = defaultMappingSettings.mappingTableURL ||
                (defaultMappingSettings.mappingTableURL === "" ? "" : "mapping_table.json");
            mappingTable.mappingTablePrefix = defaultMappingSettings.mappingTablePrefix ||
                (defaultMappingSettings.mappingTablePrefix === "" ? "" : "staticmax/");
            mappingTable.assetPrefix = defaultMappingSettings.assetPrefix ||
                (defaultMappingSettings.assetPrefix === "" ? "" : "missing/");
        }
        else
        {
            mappingTable.mappingTableURL = "mapping_table.json";
            mappingTable.mappingTablePrefix = "staticmax/";
            mappingTable.assetPrefix = "missing/";
        }

        mappingTable.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
        if (!mappingTable.mappingTableURL)
        {
            mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable no mapping table file given");
        }

        function createMappingTableCallbackFn(urlMappingData)
        {
            var urlMapping = urlMappingData.urnmapping || urlMappingData.urnremapping || {};
            mappingTable.urlMapping = urlMapping;

            // Prepend all the mapped physical paths with the asset server
            var mappingTablePrefix = mappingTable.mappingTablePrefix;
            if (mappingTablePrefix)
            {
                var source;
                for (source in urlMapping)
                {
                    if (urlMapping.hasOwnProperty(source))
                    {
                        urlMapping[source] = mappingTablePrefix + urlMapping[source];
                    }
                }
            }

            tableRecievedFn(mappingTable);
        }

        requestHandler.request({
                src: mappingTable.mappingTableURL,
                onload: function jsonifyResponse(jsonResponse, status) {
                    if (status === 200)
                    {
                        var obj = JSON.parse(jsonResponse);
                        createMappingTableCallbackFn(obj);
                        return;
                    }

                    jsonResponse = jsonResponse || { msg: "(no response)"};
                    mappingTable.errorCallbackFn("TurbulenzServices.createMappingTable error with HTTP status " + status + ": " + jsonResponse.msg, status);

                    mappingTable.urlMapping = defaultMappingSettings && (defaultMappingSettings.urnMapping || {});
                    tableRecievedFn(mappingTable);
                }
            });

        return mappingTable;
    },

    createLeaderboardManager: function turbulenzServicesCreateLeaderboardManager(requestHandler,
                                                                                 gameSession,
                                                                                 leaderboardMetaRecieved,
                                                                                 errorCallbackFn)
    {
        return LeaderboardManager.create(requestHandler, gameSession, leaderboardMetaRecieved, errorCallbackFn);
    },

    createBadgeManager: function turbulenzServicesCreateBadgeManager(requestHandler, gameSession)
    {
        return BadgeManager.create(requestHandler, gameSession);
    },

    createStoreManager: function turbulenzServicesCreateStoreManager(requestHandler,
                                                                     gameSession,
                                                                     storeMetaRecieved,
                                                                     errorCallbackFn)
    {
        return StoreManager.create(requestHandler,
                                   gameSession,
                                   storeMetaRecieved,
                                   errorCallbackFn);
    },

    createMultiplayerSessionManager: function turbulenzServicescreateMultiplayerSessionManagerFn(requestHandler,
                                                                                                 gameSession)
    {
        return MultiPlayerSessionManager.create(requestHandler, gameSession);
    },

    createUserProfile: function turbulenzServicesCreateUserProfile(requestHandler,
                                                                   profileRecievedFn,
                                                                   errorCallbackFn)
    {
        var userProfile = {};

        if (!errorCallbackFn)
        {
            errorCallbackFn = TurbulenzServices.defaultErrorCallback;
        }

        function loadUserProfileCallbackFn(userProfileData)
        {
            if (userProfileData && userProfileData.ok)
            {
                userProfileData = userProfileData.data;
                var p;
                for (p in userProfileData)
                {
                    if (userProfileData.hasOwnProperty(p))
                    {
                        userProfile[p] = userProfileData[p];
                    }
                }
            }
        }

        var url = '/api/v1/profiles/user';
        // Can't request files from the hard disk using AJAX
        if (TurbulenzServices.available())
        {
            this.getService('profiles').request({
                url: url,
                method: 'GET',
                callback: function createUserProfileAjaxErrorCheck(jsonResponse, status)
                {
                    if (status === 200)
                    {
                        loadUserProfileCallbackFn(jsonResponse);
                    }
                    else if (errorCallbackFn)
                    {
                        errorCallbackFn("TurbulenzServices.createUserProfile error with HTTP status " + status + ": " + jsonResponse.msg, status);
                    }
                    profileRecievedFn(userProfile);
                },
                requestHandler: requestHandler
            });
        }

        return userProfile;
    },

    sendCustomMetricEvent: function turbulenzServicesSendCustomMetricEvent(eventKey,
                                                                           eventValue,
                                                                           requestHandler,
                                                                           gameSession,
                                                                           errorCallbackFn)
    {
        if (!errorCallbackFn)
        {
            errorCallbackFn = TurbulenzServices.defaultErrorCallback;
        }

        if (!TurbulenzServices.available())
        {
            if (errorCallbackFn)
            {
                errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Service not available",
                                0);
            }
            return;
        }

        // Validation

        if (('string' !== typeof eventKey) || (0 === eventKey.length))
        {
            if (errorCallbackFn)
            {
                errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Event key must be a non-empty string",
                                0);
            }
            return;
        }

        if (isNaN(parseFloat(eventValue)) || !isFinite(eventValue))
        {
            if ('[object Array]' !== Object.prototype.toString.call(eventValue))
            {
                if (errorCallbackFn)
                {
                    errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Event value must be a number or an array of numbers",
                                    0);
                }
                return;
            }

            var i, valuesLength = eventValue.length;
            for (i = 0; i < valuesLength; i += 1)
            {
                if (isNaN(parseFloat(eventValue[i])) || !isFinite(eventValue[i]))
                {
                    if (errorCallbackFn)
                    {
                        errorCallbackFn("TurbulenzServices.sendCustomMetricEvent failed: Event value array elements must be numbers",
                                        0);
                    }
                    return;
                }
            }
        }

        this.getService('customMetrics').request({
            url: '/api/v1/custommetrics/add-event/' + gameSession.gameSlug,
            method: 'POST',
            data: {'key': eventKey, 'value': eventValue, 'gameSessionId': gameSession.gameSessionId},
            callback: function sendCustomMetricEventAjaxErrorCheck(jsonResponse, status)
            {
                if (status !== 200 && errorCallbackFn)
                {
                    errorCallbackFn("TurbulenzServices.sendCustomMetricEvent error with HTTP status " + status + ": " + jsonResponse.msg, status);
                }
            },
            requestHandler: requestHandler,
            encrypt: true
        });
    },


    services: {},
    waitingServices: {},
    pollingServiceStatus: false,
    // milliseconds
    defaultPollInterval: 4000,

    getService: function getServiceFn(serviceName)
    {
        var services = this.services;
        if (services.hasOwnProperty(serviceName))
        {
            return services[serviceName];
        }
        else
        {
            var service = ServiceRequester.create(serviceName);
            services[serviceName] = service;
            return service;
        }
    },

    serviceUnavailable: function serviceUnavailableFn(service, callContext)
    {
        var waitingServices = this.waitingServices;
        var serviceName = service.serviceName;
        if (waitingServices.hasOwnProperty(serviceName))
        {
            return;
        }

        waitingServices[serviceName] = service;

        service.running = false;

        var onServiceUnavailableCallbacks = function onServiceUnavailableCallbacksFn(service)
        {
            var onServiceUnavailable = callContext.onServiceUnavailable;
            if (onServiceUnavailable)
            {
                onServiceUnavailable.call(service, callContext);
            }
            if (service.onServiceUnavailable)
            {
                service.onServiceUnavailable();
            }
            if (TurbulenzServices.onServiceUnavailable)
            {
                TurbulenzServices.onServiceUnavailable(service);
            }
        };

        if (service.discardRequests)
        {
            onServiceUnavailableCallbacks(service);
        }

        if (this.pollingServiceStatus)
        {
            return;
        }

        var that = this;
        var pollServiceStatus;

        var serviceUrl = '/api/v1/service-status/game/read/' + window.gameSlug;
        var servicesStatusCB = function servicesStatusCBFn(responseObj, status)
        {
            if (status === 200)
            {
                var statusObj = responseObj.data;
                var servicesObj = statusObj.services;

                var retry = false;
                var serviceName;
                for (serviceName in waitingServices)
                {
                    if (waitingServices.hasOwnProperty(serviceName))
                    {
                        var service = waitingServices[serviceName];
                        var serviceData = servicesObj[serviceName];
                        var serviceRunning = serviceData.running;

                        service.running = serviceRunning;
                        service.description = serviceData.description;

                        if (serviceRunning)
                        {
                            if (service.discardRequests)
                            {
                                var onServiceAvailable = callContext.onServiceAvailable;
                                if (onServiceAvailable)
                                {
                                    onServiceAvailable.call(service, callContext);
                                }
                                if (service.onServiceAvailable)
                                {
                                    service.onServiceAvailable();
                                }
                                if (TurbulenzServices.onServiceAvailable)
                                {
                                    TurbulenzServices.onServiceAvailable(service);
                                }
                            }

                            delete waitingServices[serviceName];
                            service.discardRequests = false;
                            service.serviceStatusObserver.notify(serviceRunning, service.discardRequests);

                        }
                        else
                        {
                            // if discardRequests has been set
                            if (serviceData.discardRequests && !service.discardRequests)
                            {
                                service.discardRequests = true;
                                onServiceUnavailableCallbacks(service);
                                // discard all waiting requests
                                service.serviceStatusObserver.notify(serviceRunning, service.discardRequests);
                            }
                            retry = true;
                        }
                    }
                }
                if (!retry)
                {
                    this.pollingServiceStatus = false;
                    return;
                }
                TurbulenzEngine.setTimeout(pollServiceStatus, statusObj.pollInterval * 1000);
            }
            else
            {
                TurbulenzEngine.setTimeout(pollServiceStatus, that.defaultPollInterval);
            }
        };

        pollServiceStatus = function pollServiceStatusFn()
        {
            Utilities.ajax({
                url: serviceUrl,
                method: 'GET',
                callback: servicesStatusCB
            });
        };

        pollServiceStatus();
    }

};

if (typeof TurbulenzBridge !== 'undefined')
{
    TurbulenzServices.addBridgeEvents();
}

// Copyright (c) 2011-2012 Turbulenz Limited
/*global window: false*/
/*global TurbulenzServices: false*/
/*jshint nomen: false*/

/*
 * An object that takes care of communication with the gamesite and, among
 * other things, replaces the deprecated 'osdlib' module.
 *
 * It wraps an EventEmitter instance that is stored on the page and provides
 * methods that manually display the 'loading'-flag, post certain events to
 * the page or request information about a player's settings.
 *
 */
var TurbulenzBridge = {
    _bridge: undefined,

    /**
     * Try to find an 'EventEmitter' object on the page and cache it.
     */
    _initInstance: function _initInstanceFn() {
        var Turbulenz = window.top.Turbulenz;

        if (Turbulenz && Turbulenz.Services)
        {
            var bridge = Turbulenz.Services.bridge;
            if (!bridge)
            {
                return;
            }

            this._bridge = bridge;

            this.emit = bridge.emit;
            // TODO can remove all of these or's after gamesite and hub updates
            this.on = bridge.gameListenerOn || bridge.addListener || bridge.setListener;

            // we cant use off yet becuase the function recieved on the other VM is re-wrapped each time
            //this.off = bridge.gameListenerOff;
            // Legacy functions addListener/setListener
            this.addListener = bridge.gameListenerOn || bridge.addListener || bridge.setListener;
            this.setListener = bridge.gameListenerOn || bridge.setListener;
        }

        if (typeof TurbulenzServices !== 'undefined')
        {
            TurbulenzServices.addBridgeEvents();
        }
    },

    isInitialised: function isInitialisedFn() {
        return this._bridge !== undefined;
    },

    emit: function emitFn() {},

    on: function onFn() {},

    //off: function offFn() {},

    addListener: function addListenerFn() {},

    setListener: function setListenerFn() {},

    /**
     * Message that passes game configuration information from the hosting site
     */
    setOnReceiveConfig: function setOnReceiveConfigFn(callback) {
        this.on('config.set', callback);
    },
    triggerRequestConfig: function triggerRequestConfigFn() {
        this.emit('config.request');
    },

    /**
     * Methods to signal the beginning and end of load/save processes.
     * This will display hints to the player and helps the page
     * to prioritize resources.
     */
    startLoading: function startLoadingFn() {
        this.emit('status.loading.start');
    },

    startSaving: function startSavingFn() {
        this.emit('status.saving.start');
    },

    stopLoading: function stopLoadingFn() {
        this.emit('status.loading.stop');
    },

    stopSaving: function stopSavingFn() {
        this.emit('status.saving.stop');
    },

    /**
     * These methods tell the gamesite the gameSession so it can
     * emit a heartbeat for the message server to detect.
     * gameSessionId - A string for identifying the current game session
     */
    createdGameSession: function createdGameSessionFn(gameSessionId) {
        this.emit('game.session.created', gameSessionId);
    },

    destroyedGameSession: function destroyedGameSessionFn(gameSessionId) {
        this.emit('game.session.destroyed', gameSessionId);
    },

    setGameSessionStatus: function setGameSessionStatusFn(gameSessionId, status) {
        this.emit('game.session.status', gameSessionId, status);
    },

    setGameSessionInfo: function setGameSessionInfoFn(info) {
        this.emit('game.session.info', info);
    },

    /**
     * Update a userbadge. Used by the BadgeManager
     */
    updateUserBadge: function updateUserBadgeFn(badge)
    {
        this.emit('userbadge.update', badge);
    },

    /**
     * Update a leaderboard. Used by the LeaderboardManager
     */
    updateLeaderBoard: function updateLeaderBoardFn(scoreData)
    {
        this.emit('leaderboards.update', scoreData);
    },


    /**
     * Handle multiplayer join events
     */
    setOnMultiplayerSessionToJoin: function setOnMultiplayerSessionToJoinFn(callback) {
        this.on('multiplayer.session.join', callback);
    },

    triggerJoinedMultiplayerSession: function triggerJoinedMultiplayerSessionFn(session) {
        this.emit('multiplayer.session.joined', session);
    },

    triggerLeaveMultiplayerSession: function triggerLeaveMultiplayerSessionFn(sessionId) {
        this.emit('multiplayer.session.leave', sessionId);
    },

    triggerMultiplayerSessionMakePublic: function triggerMultiplayerSessionMakePublicFn(sessionId) {
        this.emit('multiplayer.session.makepublic');
    },

    /**
     * Handle store basket events
     */
    setOnBasketUpdate: function setOnBasketUpdateFn(callback) {
        this.on('basket.site.update', callback);
    },

    triggerBasketUpdate: function triggerBasketUpdateFn(basket) {
        this.emit('basket.game.update', basket);
    },

    triggerUserStoreUpdate: function triggerUserStoreUpdateFn(items) {
        this.emit('store.user.update', items);
    },

    setOnPurchaseConfirmed: function setOnPurchaseConfirmedFn(callback) {
        this.on('purchase.confirmed', callback);
    },

    setOnPurchaseRejected: function setOnPurchaseRejectedFn(callback) {
        this.on('purchase.rejected', callback);
    },

    triggerShowConfirmPurchase: function triggerShowConfirmPurchaseFn() {
        this.emit('purchase.show.confirm');
    },

    triggerFetchStoreMeta: function triggerFetchStoreMetaFn() {
        this.emit('fetch.store.meta');
    },

    setOnStoreMeta: function setOnStoreMetaFn(callback) {
        this.on('store.meta.v2', callback);
    },

    /**
     * Methods to signal changes of the viewport's aspect ratio to the page.
     */
    changeAspectRatio: function changeAspectRatioFn(ratio) {
        this.emit('change.viewport.ratio', ratio);
    },

    /**
     * Methods to set callbacks to react to events happening on the page.
     */
    setOnViewportHide: function setOnViewportHideFn(callback) {
        this.on('change.viewport.hide', callback);
    },

    setOnViewportShow: function setOnViewportShowFn(callback) {
        this.on('change.viewport.show', callback);
    },

    setOnFullscreenOn: function setOnFullscreenOnFn(callback) {
        this.on('change.viewport.fullscreen.on', callback);
    },

    setOnFullscreenOff: function setOnFullscreenOffFn(callback) {
        this.on('change.viewport.fullscreen.off', callback);
    },

    setOnMenuStateChange: function setOnMenuStateChangeFn(callback) {
        this.on('change.menu.state', callback);
    },

    setOnUserStateChange: function setOnUserStateChangeFn(callback) {
        this.on('change.user.state', callback);
    },

    /**
     * Methods to send trigger event-emission on the page. These prompt the  page to trigger
     * the aforementioned corresponding onXXXX methods.
     */

    triggerOnFullscreen: function triggerOnFullscreenQueryFn() {
        this.emit('trigger.viewport.fullscreen');
    },

    triggerOnViewportVisibility: function triggerOnViewportVisibilityQueryFn() {
        this.emit('trigger.viewport.visibility');
    },

    triggerOnMenuStateChange: function triggerOnMenuStateQueryFn() {
        this.emit('trigger.menu.state');
    },

    triggerOnUserStateChange: function triggerOnUserStateQueryFn() {
        this.emit('trigger.user.state');
    },

    /**
     * Methods to send requests for information to the page. These methods can be used to send
     * state-queries. They take a callback function and prompt the page to call it.
     */

    /**
     * callback - a function that takes a single boolean value that will be set to 'true' if the
     * viewport is in fullscreen.
     */
    queryFullscreen: function queryFullscreenFn(callback) {
        this.emit('query.viewport.fullscreen', callback);
    },
    /**
     * callback - a function that takes a single boolean value that will be set to 'true' if the
     * viewport is visible.
     */
    queryViewportVisibility: function queryViewportVisibilityFn(callback) {
        this.emit('query.viewport.visibility', callback);
    },
    /**
     * callback - a function that takes an object-representation of the current menu-state.
     */
    queryMenuState: function queryMenuStateFn(callback) {
        this.emit('query.menu.state', callback);
    },
    /**
     * callback - a function that takes an object-representation of the current state of the user's settings.
     */
    queryUserState: function queryUserStateFn(callback) {
        this.emit('query.user.state', callback);
    }
};

if (!TurbulenzBridge.isInitialised())
{
    TurbulenzBridge._initInstance();
}

// Copyright (c) 2011-2012 Turbulenz Limited

/*global Utilities: false*/
/*global TurbulenzBridge: false*/
/*global TurbulenzEngine: false*/
/*global TurbulenzServices: false*/

//
// API
//
function GameSession() {}
GameSession.prototype =
{
    version : 1,
    post_delay: 1000,

    setStatus: function gameSessionSetStatusFn(status)
    {
        if (this.destroyed || this.status === status)
        {
            return;
        }

        this.status = status;
        TurbulenzBridge.setGameSessionStatus(this.gameSessionId, status);
    },

    // callbackFn is for testing only!
    // It will not be called if destroy is called in TurbulenzEngine.onUnload
    destroy: function gameSessionDestroyFn(callbackFn)
    {
        var dataSpec;
        if (this.pendingUpdate)
        {
            TurbulenzEngine.clearTimeout(this.pendingUpdate);
            this.pendingUpdate = null;
        }

        if (!this.destroyed && this.gameSessionId)
        {
            // we can't wait for the callback as the browser doesn't
            // call async callbacks after onbeforeunload has been called
            TurbulenzBridge.destroyedGameSession(this.gameSessionId);
            this.destroyed = true;

            dataSpec = {'gameSessionId': this.gameSessionId};

            if (TurbulenzServices.bridgeServices)
            {
                TurbulenzServices.callOnBridge('gamesession.destroy', dataSpec, callbackFn);
            }
            else
            {
                Utilities.ajax({
                    url: '/api/v1/games/destroy-session',
                    method: 'POST',
                    data: dataSpec,
                    callback: callbackFn,
                    requestHandler: this.requestHandler
                });
            }
        }
        else
        {
            if (callbackFn)
            {
                TurbulenzEngine.setTimeout(callbackFn, 0);
            }
        }
    },

    /**
     * Handle player metadata
     */
    setTeamInfo : function gameSessionSetTeamInfoFn(teamList)
    {
        var sessionData = this.info.sessionData;
        var oldTeamList = sessionData.teamList || [];
        if (teamList.join('#') !== oldTeamList.join('#'))
        {
            sessionData.teamList = teamList;
            this.update();
        }
    },

    setPlayerInfo : function gameSessionSetPlayerInfoFn(playerId, data)
    {
        var playerData = this.info.playerSessionData[playerId];
        var key;
        var dirty = false;

        if (!playerData)
        {
            playerData = {};
            this.info.playerSessionData[playerId] = playerData;
            dirty = true;
        }

        for (key in data)
        {
            if (data.hasOwnProperty(key))
            {
                if (!this.templatePlayerData.hasOwnProperty(key))
                {
                    throw "unknown session data property " + key;
                }
                if (playerData[key] !== data[key])
                {
                    playerData[key] = data[key];
                    dirty = true;
                }
            }
        }

        if (dirty)
        {
            this.update();
        }
    },

    removePlayerInfo : function gameSessionRemovePlayerInfoFn(playerId)
    {
        delete this.info.playerSessionData[playerId];
        this.update();
    },

    clearAllPlayerInfo : function clearAllPlayerInfoFn()
    {
        this.info.playerSessionData = {};
        this.update();
    },

    update: function updateFn()
    {
        if (!this.pendingUpdate)
        {
            // Debounce the update to pick up any other changes.
            this.pendingUpdate = TurbulenzEngine.setTimeout(this.postData, this.post_delay);
        }
    }
};

GameSession.create = function gameSessionCreateFn(requestHandler, sessionCreatedFn, errorCallbackFn)
{
    var gameSession = new GameSession();
    var gameSlug = window.gameSlug;
    var turbulenz = window.top.Turbulenz;
    var turbulenzData = (turbulenz && turbulenz.Data) || {};
    var mode = turbulenzData.mode || TurbulenzServices.mode;
    var createSessionURL = '/api/v1/games/create-session/' + gameSlug;
    var gameSessionRequestCallback = function gameSessionRequestCallbackFn(jsonResponse, status)
    {
        if (status === 200)
        {
            gameSession.mappingTable = jsonResponse.mappingTable;
            gameSession.gameSessionId = jsonResponse.gameSessionId;

            if (sessionCreatedFn)
            {
                sessionCreatedFn(gameSession);
            }

            TurbulenzBridge.createdGameSession(gameSession.gameSessionId);
        }
        else
        {
            gameSession.errorCallbackFn("TurbulenzServices.createGameSession error with HTTP status " + status + ": " + jsonResponse.msg, status);
        }
    };

    gameSession.info = {
        sessionData: {},
        playerSessionData: {}
    };

    gameSession.templatePlayerData = {
        team: null,
        color: null,
        status: null,
        rank: null,
        score: null,
        sortkey: null
    };

    gameSession.postData = function postDataFn()
    {
        TurbulenzBridge.setGameSessionInfo(JSON.stringify(gameSession.info));
        gameSession.pendingUpdate = null;
    };

    gameSession.pendingUpdate = null;

    gameSession.gameSlug = gameSlug;

    gameSession.requestHandler = requestHandler;
    gameSession.errorCallbackFn = errorCallbackFn || TurbulenzServices.defaultErrorCallback;
    gameSession.gameSessionId = null;
    gameSession.service = TurbulenzServices.getService('gameSessions');
    gameSession.status = null;

    if (!TurbulenzServices.available())
    {
        // Call sessionCreatedFn on a timeout to get the same behaviour as the AJAX call
        if (sessionCreatedFn)
        {
            TurbulenzEngine.setTimeout(function sessionCreatedCall()
            {
                sessionCreatedFn(gameSession);
            }, 0);
        }
        return gameSession;
    }

    if (mode)
    {
        createSessionURL += '/' + mode;
    }

    gameSession.service.request({
        url: createSessionURL,
        method: 'POST',
        callback: gameSessionRequestCallback,
        requestHandler: requestHandler,
        neverDiscard: true
    });

    return gameSession;
};

// Copyright (c) 2010-2011 Turbulenz Limited

//
// Observer
//
function Observer() {}

Observer.prototype = {
    subscribe: function observerSubscribeFn(subscriber)
    {
        //Check for duplicates
        var subscribers = this.subscribers;
        var length = subscribers.length;
        for (var index = 0; index < length; index += 1)
        {
            if (subscribers[index] === subscriber)
            {
                return;
            }
        }

        subscribers.push(subscriber);
    },

    unsubscribe: function observerUnsubscribeFn(subscriber)
    {
        var subscribers = this.subscribers;
        var length = subscribers.length;
        for (var index = 0; index < length; index += 1)
        {
            if (subscribers[index] === subscriber)
            {
                subscribers.splice(index, 1);
                break;
            }
        }
    },

    unsubscribeAll: function observerUnsubscribeAllFn(subscriber)
    {
        this.subscribers.length = 0;
    },

    // this function can take any number of arguments
    // they are passed on to the subscribers
    notify: function observerNotifyFn()
    {
        // Note that the callbacks might unsubscribe
        var subscribers = this.subscribers;
        var length = this.subscribers.length;
        var index = 0;

        while (index < length)
        {
            subscribers[index].apply(null, arguments);
            if (subscribers.length === length)
            {
                index += 1;
            }
            else
            {
                length = subscribers.length;
            }
        }
    }
};

Observer.create = function observerCreateFn()
{
    var observer = new Observer();
    observer.subscribers = [];
    return observer;
};

// Copyright (c) 2010-2012 Turbulenz Limited

/*global window: false*/
/*global Observer: false*/
/*global TurbulenzEngine: false*/

var Utilities = {};

//
// assert
//
Utilities.skipAsserts = false;
Utilities.assert = function assertFn(test, message)
{
    if (!test)
    {
        if (!this.skipAsserts)
        {
            this.breakInDebugger.doesNotExist(); //Use a function that does not exist. This is caught in the debuggers.
        }
    }
};

//
// beget
//
Utilities.beget = function begetFn(o)
{
    var F = function () { };
    F.prototype = o;
    return new F();
};

//
// log
//
Utilities.log = function logFn()
{
    var console = window.console;
    if (console)
    {
        // "console.log.apply" will crash when using the plugin on Chrome...
        switch (arguments.length)
        {
        case 1:
            console.log(arguments[0]);
            break;
        case 2:
            console.log(arguments[0], arguments[1]);
            break;
        case 3:
            console.log(arguments[0], arguments[1], arguments[2]);
            break;
        case 4:
            console.log(arguments[0], arguments[1], arguments[2], arguments[3]);
            break;
        default:
            // Note: this will fail if using printf-style string formatting
            var args = [].splice.call(arguments, 0);
            console.log(args.join(' '));
            break;
        }
    }
};

Utilities.nearestLowerPow2 = function UtilitiesNearestLowerPow2(num)
{
    /*jshint bitwise: false*/
    num = num | (num >>> 1);
    num = num | (num >>> 2);
    num = num | (num >>> 4);
    num = num | (num >>> 8);
    num = num | (num >>> 16);
    return (num - (num >>> 1));
};

Utilities.nearestUpperPow2 = function UtilitiesNearestUpperPow2(num)
{
    /*jshint bitwise: false*/
    num = num - 1;
    num = num | (num >>> 1);
    num = num | (num >>> 2);
    num = num | (num >>> 4);
    num = num | (num >>> 8);
    num = num | (num >>> 16);
    return (num + 1);
};

var MathDeviceConvert =
{
    v2ToArray : function v2ToJavaScriptArrayFn(v2)
    {
        return [v2[0], v2[1]];
    },

    arrayToV2 : function arrayToV2Fn(mathDevice, v2Array, v2Dest)
    {
        return mathDevice.v2Build(v2Array[0], v2Array[1], v2Dest);
    },

    v3ToArray : function v3ToJavaScriptArrayFn(v3)
    {
        return [v3[0], v3[1], v3[2]];
    },

    arrayToV3 : function arrayToV3Fn(mathDevice, v3Array, v3Dest)
    {
        return mathDevice.v3Build(v3Array[0], v3Array[1], v3Array[2], v3Dest);
    },

    v4ToArray : function v4ToJavaScriptArrayFn(v4)
    {
        return [v4[0], v4[1], v4[2], v4[3]];
    },

    arrayToV4 : function arrayToV4Fn(mathDevice, v4Array, v4Dest)
    {
        return mathDevice.v4Build(v4Array[0], v4Array[1], v4Array[2], v4Array[3], v4Dest);
    },

    quatToArray : function quatToJavaScriptArrayFn(quat)
    {
        return [quat[0], quat[1], quat[2], quat[3]];
    },

    arrayToQuat : function arrayToQuatFn(mathDevice, quatArray, quatDest)
    {
        return mathDevice.quatBuild(quatArray[0], quatArray[1], quatArray[2], quatArray[3], quatDest);
    },

    aabbToArray : function aabbToJavaScriptArrayFn(aabb)
    {
        return [aabb[0], aabb[1], aabb[2],
                aabb[3], aabb[4], aabb[5]];
    },

    arrayToAABB : function arrayToQuatFn(mathDevice, aabbArray, aabbDest)
    {
        return mathDevice.aabbBuild(aabbArray[0], aabbArray[1], aabbArray[2],
                                    aabbArray[3], aabbArray[4], aabbArray[5], aabbDest);
    },

    quatPosToArray : function quatPosToJavaScriptArrayFn(quatPos)
    {
        return [quatPos[0], quatPos[1], quatPos[2], quatPos[3],
                quatPos[4], quatPos[5], quatPos[6]];
    },

    arrayToQuatPos : function arrayToQuatPosFn(mathDevice, quatPosArray, quatPosDest)
    {
        return mathDevice.quatPosBuild(quatPosArray[0], quatPosArray[1], quatPosArray[2], quatPosArray[3],
                                       quatPosArray[4], quatPosArray[5], quatPosArray[6], quatPosDest);
    },

    m33ToArray : function m33ToJavaScriptArrayFn(m33)
    {
        return [m33[0], m33[1], m33[2],
                m33[3], m33[4], m33[5],
                m33[6], m33[7], m33[8]];
    },

    arrayToM33 : function arrayToM33Fn(mathDevice, m33Array, m33Dest)
    {
        return mathDevice.m33Build(m33Array[0], m33Array[1], m33Array[2],
                                   m33Array[3], m33Array[4], m33Array[5],
                                   m33Array[6], m33Array[7], m33Array[8], m33Dest);
    },

    /*jshint white: false*/
    m43ToArray : function m43ToJavaScriptArrayFn(m43)
    {
        return [m43[0], m43[ 1], m43[ 2],
                m43[3], m43[ 4], m43[ 5],
                m43[6], m43[ 7], m43[ 8],
                m43[9], m43[10], m43[11]];
    },

    arrayToM43 : function arrayToM43Fn(mathDevice, m43Array, m43Dest)
    {
        return mathDevice.m43Build(m43Array[0], m43Array[ 1], m43Array[ 2],
                                   m43Array[3], m43Array[ 4], m43Array[ 5],
                                   m43Array[6], m43Array[ 7], m43Array[ 8],
                                   m43Array[9], m43Array[10], m43Array[11], m43Dest);
    },

    m34ToArray : function m34ToJavaScriptArrayFn(m34)
    {
        return [m34[0], m34[1], m34[ 2], m34[ 3],
                m34[4], m34[5], m34[ 6], m34[ 7],
                m34[8], m34[9], m34[10], m34[11]];
    },

    m44ToArray : function m44ToJavaScriptArrayFn(m44)
    {
        return [m44[ 0], m44[ 1], m44[ 2], m44[ 3],
                m44[ 4], m44[ 5], m44[ 6], m44[ 7],
                m44[ 8], m44[ 9], m44[10], m44[11],
                m44[12], m44[13], m44[14], m44[15]];
    },

    arrayToM44 : function arrayToM44Fn(mathDevice, m44Array, m44Dest)
    {
        return mathDevice.m44Build(m44Array[ 0], m44Array[ 1], m44Array[ 2], m44Array[ 3],
                                   m44Array[ 4], m44Array[ 5], m44Array[ 6], m44Array[ 7],
                                   m44Array[ 8], m44Array[ 9], m44Array[10], m44Array[11],
                                   m44Array[12], m44Array[13], m44Array[14], m44Array[15], m44Dest);
    }
    /*jshint white: true*/
};

//
// ajax
//
Utilities.ajax = function utilitiesAjaxFn(params)
{
    // parameters
    var requestText = "";
    var method = params.method;
    var data = params.data || {};
    var encrypted = params.encrypt;
    var signature = null;
    var url = params.url;
    var requestHandler = params.requestHandler;
    var callbackFn = params.callback;

    if (encrypted)
    {
        data.requestUrl = url;

        var str = JSON.stringify(data);

        if (method === "POST")
        {
            str = TurbulenzEngine.encrypt(str);
        }

        requestText += "data=" + encodeURIComponent(str) + "&";

        requestText += "gameSessionId=" + encodeURIComponent(data.gameSessionId);

        signature = TurbulenzEngine.generateSignature(str);
    }
    else if (data)
    {
        var key;
        for (key in data)
        {
            if (data.hasOwnProperty(key))
            {
                if (requestText.length !== 0)
                {
                    requestText += "&";
                }
                if (method === "POST")
                {
                    requestText += key + "=" + data[key];
                }
                else
                {
                    requestText += encodeURIComponent(key) + "=" + encodeURIComponent(data[key]);
                }
            }
        }
    }

    var httpResponseCallback = function httpResponseCallbackFn(xhrResponseText, xhrStatus)
    {
        var sig = this.xhr.getResponseHeader("X-TZ-Signature");

        // break circular reference
        this.xhr.onreadystatechange = null;
        this.xhr = null;

        var response;

        response = JSON.parse(xhrResponseText);
        if (encrypted)
        {
            var validSignature = TurbulenzEngine.verifySignature(xhrResponseText, sig);
            xhrResponseText = null;

            TurbulenzEngine.setTimeout(function () {
                var receivedUrl = response.requestUrl;

                if (validSignature)
                {
                    if (!TurbulenzEngine.encryptionEnabled || receivedUrl === url)
                    {
                        callbackFn(response, xhrStatus);
                        callbackFn = null;
                        return;
                    }
                }

                // If it was a server-side verification fail then pass through the actual message
                if (xhrStatus === 400)
                {
                    callbackFn(response, xhrStatus, "Verification Failed");
                }
                else
                {
                    // Else drop reply
                    callbackFn({msg: "Verification failed", ok: false}, 400, "Verification Failed");
                }
                callbackFn = null;
            }, 0);
        }
        else
        {
            xhrResponseText = null;

            TurbulenzEngine.setTimeout(function () {
                callbackFn(response, xhrStatus);
                callbackFn = null;
            }, 0);
        }
    };

    var httpRequest = function httpRequestFn(url, onload, callContext)
    {
        var xhr;
        if (window.XMLHttpRequest)
        {
            xhr = new window.XMLHttpRequest();
        }
        else if (window.ActiveXObject)
        {
            xhr = new window.ActiveXObject("Microsoft.XMLHTTP");
        }
        else
        {
            if (params.error)
            {
                params.error("No XMLHTTPRequest object could be created");
            }
            return;
        }
        callContext.xhr = xhr;

        var httpCallback = function httpCallbackFn()
        {
            if (xhr.readyState === 4 && TurbulenzEngine && !TurbulenzEngine.isUnloading()) /* 4 == complete */
            {
                var xhrResponseText = xhr.responseText;
                var xhrStatus = xhr.status;
                // Checking xhrStatusText when xhrStatus is 0 causes a silent error!
                var xhrStatusText = (xhrStatus !== 0 && xhr.statusText) || "No connection or cross domain request";

                // Sometimes the browser sets status to 200 OK when the connection is closed
                // before the message is sent (weird!).
                // In order to address this we fail any completely empty responses.
                // Hopefully, nobody will get a valid response with no headers and no body!
                if (xhr.getAllResponseHeaders() === "" && xhrResponseText === "" && xhrStatus === 200 && xhrStatusText === 'OK')
                {
                    onload('', 0);
                    return;
                }

                onload.call(callContext, xhrResponseText, xhrStatus);
            }
        };

        // Send request
        xhr.open(method, ((requestText && (method !== "POST")) ? url + "?" + requestText : url), true);
        if (callbackFn)
        {
            xhr.onreadystatechange = httpCallback;
        }

        if (signature)
        {
            xhr.setRequestHeader("X-TZ-Signature", signature);
        }

        if (method === "POST")
        {
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
            xhr.send(requestText);
        }
        else // method === 'GET'
        {
            xhr.send();
        }
    };

    if (requestHandler)
    {
        requestHandler.request({
            src: url,
            requestFn: httpRequest,
            customErrorHandler: params.customErrorHandler,
            onload: httpResponseCallback
        });
    }
    else
    {
        var callContext = {
            src: url
        };
        httpRequest(url, httpResponseCallback, callContext);
    }
};


//
// ajaxStatusCodes
//

// http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
Utilities.ajaxStatusCodes = {
    0: "No Connection, Timeout Or Cross Domain Request",
    100: "Continue",
    101: "Switching Protocols",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Time-out",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Request Entity Too Large",
    414: "Request-URI Too Large",
    415: "Unsupported Media Type",
    416: "Requested range not satisfiable",
    417: "Expectation Failed",
    429: "Too Many Requests",
    480: "Temporarily Unavailable",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Time-out",
    505: "HTTP Version not supported"
};

//
//Reference
//

// Proxy reference class allowing weak reference to the object
function Reference() {}

Reference.prototype =
{
    version: 1,

    //
    // add
    //
    add: function referenceAddFn()
    {
        this.referenceCount += 1;
    },

    //
    // remove
    //
    remove: function referenceRemovefn()
    {
        this.referenceCount -= 1;
        if (this.referenceCount === 0)
        {
            if (this.destroyedObserver)
            {
                this.destroyedObserver.notify(this.object);
            }
            this.object.destroy();
            this.object = null;
        }
    },

    //
    //subscribeDestroyed
    //
    subscribeDestroyed: function referenceSubscribeDestroyedFn(observerFunction)
    {
        if (!this.destroyedObserver)
        {
            this.destroyedObserver = Observer.create();
        }
        this.destroyedObserver.subscribe(observerFunction);
    },

    //
    //unsubscribeDestroyed
    //
    unsubscribeDestroyed: function referenceDestroyedFn(observerFunction)
    {
        this.destroyedObserver.unsubscribe(observerFunction);
    }
};

//
// create
//
Reference.create = function referenceCreate(object)
{
    var result = new Reference();
    result.object = object;
    result.referenceCount = 0;
    return result;
};


//
// Profile
//
var Profile =
{
    profiles: [],

    sortMode: {alphabetical: 0, duration: 1, max: 2, min: 3, calls: 4},

    //
    // start
    //
    start: function profileStartFn(name)
    {
        var data = this.profiles[name];
        if (!data)
        {
            data = {name: name, calls: 0, duration: 0.0, min: Number.MAX_VALUE, max: 0.0, sumOfSquares: 0.0};
            this.profiles[name] = data;
        }
        data.start = TurbulenzEngine.time;
    },

    //
    // stop
    //
    stop: function profileStopFn(name)
    {
        var end = TurbulenzEngine.time;
        var data = this.profiles[name];
        if (data)
        {
            var duration = end - data.start;
            data.duration += duration;
            data.calls += 1;
            var delta = duration - data.duration / data.calls; // This is an approximation, it should use the mean of all samples (or N random ones) but thats requries samples to be stored
            data.sumOfSquares += delta * delta;

            if (duration > data.max)
            {
                data.max = duration;
            }

            if (duration < data.min)
            {
                data.min = duration;
            }
        }
    },

    //
    // reset
    //
    reset: function profileResetFn()
    {
        this.profiles = [];
    },

    //
    // getReport
    //
    getReport: function profileGetReportFn(sortMode, format)
    {
        var dataArray = [];
        var data;
        var maxDuration = 0.0;
        var name;
        for (name in this.profiles)
        {
            if (this.profiles.hasOwnProperty(name))
            {
                data = this.profiles[name];
                if (maxDuration < data.duration)
                {
                    maxDuration = data.duration;
                }
                dataArray.push(data);
            }
        }

        var compareFunction;

        if (sortMode === Profile.sortMode.alphabetical)
        {
            compareFunction = function compareName(left, right)
                            {
                                return (left.name < right.name) ? -1 : (left.name > right.name) ? 1 : 0;
                            };
        }
        else if (sortMode === Profile.sortMode.max)
        {
            compareFunction = function compareMax(left, right)
                            {
                                return right.max - left.max;
                            };
        }
        else if (sortMode === Profile.sortMode.min)
        {
            compareFunction = function compareMin(left, right)
                            {
                                return right.min - left.min;
                            };
        }
        else if (sortMode === Profile.sortMode.calls)
        {
            compareFunction = function compareCalls(left, right)
                            {
                                return right.calls - left.calls;
                            };
        }
        else // Profile.sortMode.duration or undefined
        {
            compareFunction = function compareDuration(left, right)
                            {
                                return right.duration - left.duration;
                            };
        }

        dataArray.sort(compareFunction);

        var line;
        var text = "";
        var precision = format ? format.precision : 8;
        var percentagePrecision = format ? format.percentagePrecision : 1;
        var seperator = format ? format.seperator : " ";
        var length = dataArray.length;
        var index;
        for (index = 0; index < length; index += 1)
        {
            data = dataArray[index];
            line = data.name;
            line += seperator + data.calls;
            line += seperator + data.duration.toFixed(precision);
            line += seperator + data.max.toFixed(precision);
            line += seperator + data.min.toFixed(precision);
            line += seperator + (data.duration / data.calls).toFixed(precision); // average
            line += seperator + Math.sqrt(data.sumOfSquares / data.calls).toFixed(precision); // approximate standard deviation
            line += seperator + (100 * data.duration / maxDuration).toFixed(percentagePrecision) + "%\n";
            text += line;
        }
        return text;
    }
};

//
// Utilities to use with TurbulenzEngine.stopProfiling() object.
//
var JSProfiling = {};

//
// createArray
//      Creates an array of nodes by merging all duplicate function references in the call profile tree together.
JSProfiling.createArray = function JSProfilingCreateArrayFn(rootNode)
{
    var map = {};
    var array = [];

    if (rootNode.head)
    {
        rootNode = rootNode.head; // Chrome native profiler.
    }

    var processNode = function processNodeFn(node)
    {
        var urlObject = map[node.url];
        if (!urlObject)
        {
            urlObject = {};
            map[node.url] = urlObject;
        }

        var functionName = node.functionName === "" ? "(anonymous)" : node.functionName;

        var functionObject = urlObject[functionName];
        if (!functionObject)
        {
            functionObject = {};
            urlObject[functionName] = functionObject;
        }

        var existingNode = functionObject[node.lineNumber];
        if (!existingNode)
        {
            var newNode = { functionName : functionName,
                            numberOfCalls : node.numberOfCalls,
                            totalTime : node.totalTime,
                            selfTime : node.selfTime,
                            url : node.url,
                            lineNumber : node.lineNumber
                           };

            array[array.length] = newNode;
            functionObject[node.lineNumber] = newNode;
        }
        else
        {
            existingNode.totalTime += node.totalTime;
            existingNode.selfTime += node.selfTime;
            existingNode.numberOfCalls += node.numberOfCalls;
        }

        var children = node.children;
        if (children)
        {
            var numberOfChildren = children.length;
            var childIndex;
            for (childIndex = 0; childIndex < numberOfChildren; childIndex += 1)
            {
                processNode(children[childIndex]);
            }
        }
    };

    processNode(rootNode);

    return array;
};

//
// sort
//
JSProfiling.sort = function JSProfilingSortFn(array, propertyName, descending)
{
    if (!propertyName)
    {
        propertyName = "totalTime";
    }

    var sorterAscending = function (left, right)
    {
        return left[propertyName] - right[propertyName];
    };

    var sorterDescending = function (left, right)
    {
        return right[propertyName] - left[propertyName];
    };

    if (descending === false)
    {
        array.sort(sorterAscending);
    }
    else
    {
        array.sort(sorterDescending);
    }
};

// Copyright (c) 2012 Turbulenz Limited

// Complains in various parts about use of (/*NAME*/value) constants.
/*jshint white: false*/

/*global
Float32Array: false
Uint16Array: false
BoxTree: false
*/


//
// Physics2D Configuration
//
var Physics2DConfig = {
    // (Contact Physics)
    // Amount of slop permitted in contact penetration
    CONTACT_SLOP : 0.01, // m
    EFF_MASS_EPSILON : 1e-10,
    ILL_THRESHOLD : 1e5,
    CLIP_EPSILON : 1.65e-10, // m

    // Configuration of bias coeffecient computation
    // for percentage of error to resolve per-frame.
    BIAS_COEF : 0.15,
    STATIC_BIAS_COEF : 0.75, // for static-dynamic
    CONT_BIAS_COEF : 0.5, // for continuous contacts.
    CONT_STATIC_BIAS_COEF : 0.6, // for continuous, static-dynamic contacts.

    // Bounce-target-velocity at contact below this value
    // will cause bouncing to be ignored.
    BOUNCE_VELOCITY_THRESHOLD : 0.25, // m/s


    // ================================================
    // (Constraint physics)
    // Point
    // -----------
    // Percentage of error solved per-iteration
    POINT_BIAS_COEF : 0.5,
    // Maximum error to be resolved per-iteration
    POINT_MAX_ERROR : 0.2, // m
    POINT_MAX_ERROR_SQ : (0.2 * 0.2),
    POINT_SLOP_SQ : 1e-6, // m^2
    // Squared error to consider error too large
    // to solve properly.
    POINT_LARGE_ERROR_SQ : 0.01, //m^2
    // Percentage of error solved per-iteration in large error case
    POINT_LARGE_ERROR_BIAS : 0.75,
    // Maximum error to be resolve per-iteration in large error case
    POINT_LARGE_ERROR_MAX : 0.4, // m

    // Weld
    // ----
    // Percentage of error solved per-iteration
    WELD_BIAS_COEF : 0.5,
    // Maximum error to be resolved per-iteration
    WELD_MAX_LINEAR_ERROR : 0.2, // m
    WELD_MAX_ANGULAR_ERROR : 0.5, // rad
    WELD_MAX_LINEAR_ERROR_SQ : (0.2 * 0.2),
    WELD_LINEAR_SLOP_SQ : 1e-6, // m^2
    WELD_ANGULAR_SLOP_SQ : 1e-6, // rad^2
    // Squared error to consider error too large
    // to solve properly.
    WELD_LARGE_ERROR_SQ : 0.01, //m^2
    // Percentage of linear error solved per-iteration in large error case
    WELD_LARGE_ERROR_BIAS : 0.75,
    // Maximum linear error to be resolve per-iteration in large error case
    WELD_LARGE_ERROR_MAX : 0.4, // m

    // Angle
    // -----
    // Percentage of error solved per-iteration
    ANGLE_BIAS_COEF : 0.5,
    ANGLE_SLOP_SQ : 1e-6, // rad^2

    // Distance
    // --------
    // Percentage of error solved per-iteration
    DIST_BIAS_COEF : 0.5,
    DIST_SLOP_SQ : 1e-6, // m^2
    // Squared error to consider error too large
    // to solve properly.
    DIST_LARGE_ERROR_SQ : 0.01, //m^2
    // Percentage of error to solve per-iteration in large error case
    DIST_LARGE_ERROR_BIAS : 0.75,


    // Line
    // ----
    // Percentage of error solved per-iteration
    LINE_BIAS_COEF : 0.8,
    LINE_SLOP_SQ : 1e-6, // m^2
    // Squared error to consider error too large
    // to solve properly.
    LINE_LARGE_ERROR_SQ : 0.01, // m^2
    // Percentage of error to solve per-iteration in large error case
    LINE_LARGE_ERROR_BIAS : 0.9,

    // Pulley
    // --------
    // Percentage of error solved per-iteration
    PULLEY_BIAS_COEF : 0.5,
    PULLEY_SLOP_SQ : 1e-6, // m^2
    // Squared error to consider error too large
    // to solve properly.
    PULLEY_LARGE_ERROR_SQ : 0.01, //m^2
    // Percentage of error to solve per-iteration in large error case
    PULLEY_LARGE_ERROR_BIAS : 0.75,

    // ================================================
    // (Continuous collisions)
    // Percentage of body radius body must move through.
    MIN_LINEAR_STATIC_SWEEP : 0.05,
    MIN_ANGULAR_STATIC_SWEEP : 0.005,
    MIN_LINEAR_BULLET_SWEEP : 0.5,
    MIN_ANGULAR_BULLET_SWEEP : 0.05,

    // Accuracy threshold for sweeps on distance.
    SWEEP_LIMIT : 0.0005, // m
    // Amount of slop permitted in a continuous collision.
    SWEEP_SLOP : 0.05, // m

    // Minimum fractional TOI-alpha advancement
    MINIMUM_SWEEP_ADVANCE : 1e-6,
    // Maximum sub-steps in sweep
    MAX_SWEEP_ITER : 50,

    // Squared relative velocity in dynamic sweeps to ignore pair
    EQUAL_SQ_VEL : 0.2, // (m/s)^2
    // Sum of angular-velocity * radius for pair of shapes to ignore pair in dynamic sweeps.
    ZERO_ANG_BIAS : 0.02, // (m.rad/s)

    // Scale factor for angular velocity when TOI has been permitted to slip.
    // This helps prevent an object getting 'stuck' for a few steps when in
    // a fast rotating continuous set of collisions at one point.
    TOI_SLIP_SCALE : 0.75,


    // ================================================
    // (Arbiter/Contact persistance)
    // Number of simulation steps before inactive arbiter is killed.
    DELAYED_DEATH : 30,

    // ================================================
    // (Body integration)
    DELTA_ROTATION_EPSILON : 1e-4, // rad^2

    // ================================================
    // (Sleeping)
    SLEEP_DELAY : 60,
    // squared linear velocity for sleeping
    SLEEP_LINEAR_SQ : 0.0006, // (m/s)^2
    // squared tangent velocity for sleeping (body radius taken into account)
    SLEEP_ANGULAR_SQ : 0.001, // (m/s)^2

    // ================================================
    // (Point containment)
    CONTAINS_EPSILON : 1e-6,
    CONTAINS_SQ_EPSILON : 1e-12,

    // ================================================
    // (General)
    COLLINEAR_EPSILON : 1e-5,
    COLLINEAR_SQ_EPSILON : (1e-5 * 1e-5),
    NORMALIZE_EPSILON : 1e-6,
    NORMALIZE_SQ_EPSILON : (1e-6 * 1e-6)
};


// ==============================================================

//
// Physics2D Material
//

//
// MATERIAL DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*MAT_ELASTICITY*/0
///*MAT_STATIC*/1
///*MAT_DYNAMIC*/2
///*MAT_ROLLING*/3
///*MAT_DENSITY*/4
//
///*MATERIAL_DATA_SIZE*/5
//
function Physics2DMaterial() {}
Physics2DMaterial.prototype = {

    version : 1,

    getElasticity : function getElasticityFn()
    {
        return this._data[(/*MAT_ELASTICITY*/0)];
    },

    getStaticFriction : function getStaticFrictionFn()
    {
        return this._data[(/*MAT_STATIC*/1)];
    },

    getDynamicFriction : function getDynamicFrictionFn()
    {
        return this._data[(/*MAT_DYNAMIC*/2)];
    },

    getRollingFriction : function getRollingFrictionFn()
    {
        return this._data[(/*MAT_ROLLING*/3)];
    },

    getDensity : function getDensityFn()
    {
        return this._data[(/*MAT_DENSITY*/4)];
    }
};

// params = {
//    elasticity : ## = 0,
//    staticFriction : ## = 2,
//    dynamicFriction : ## = 1,
//    rollingFriction : ## = 0.005,
//    density : ## = 1,
//    userData : null
// }
Physics2DMaterial.create = function materialFn(params)
{
    var m = new Physics2DMaterial();
    var elasticity      = (params && params.elasticity      !== undefined ? params.elasticity      : 0);
    var staticFriction  = (params && params.staticFriction  !== undefined ? params.staticFriction  : 2);
    var dynamicFriction = (params && params.dynamicFriction !== undefined ? params.dynamicFriction : 1);
    var rollingFriction = (params && params.rollingFriction !== undefined ? params.rollingFriction : 0.005);
    var density         = (params && params.density         !== undefined ? params.density         : 1);

    var data = m._data = new Physics2DDevice.prototype.floatArray((/*MATERIAL_DATA_SIZE*/5));

    data[(/*MAT_ELASTICITY*/0)] = elasticity;
    data[(/*MAT_STATIC*/1)]     = staticFriction;
    data[(/*MAT_DYNAMIC*/2)]    = dynamicFriction;
    data[(/*MAT_ROLLING*/3)]    = rollingFriction;
    data[(/*MAT_DENSITY*/4)]    = density;

    m.userData = (params && params.userData ? params.userData : null);

    return m;
};

// =========================================================================
//
// Common to all constraints
//

// CONSTRAINT DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*JOINT_FREQUENCY*/0   // Frequency when soft constraint enabled
///*JOINT_DAMPING*/1     // Damping when soft constraint enabled
///*JOINT_MAX_FORCE*/2   // Force clamping for soft/rigid constraints
///*JOINT_MAX_ERROR*/3   // Error clamping for soft constraints only.
///*JOINT_PRE_DT*/4      // Previous time step value for impulse scaling

function Physics2DConstraint() {}
Physics2DConstraint.prototype = {

    init : function initFn(con, params)
    {
        var data = con._data;
        data[(/*JOINT_FREQUENCY*/0)] = (params.frequency !== undefined ? params.frequency : 10.0);
        data[(/*JOINT_DAMPING*/1)]   = (params.damping   !== undefined ? params.damping   : 1.0);
        data[(/*JOINT_MAX_FORCE*/2)] = (params.maxForce  !== undefined ? params.maxForce  : Number.POSITIVE_INFINITY);
        data[(/*JOINT_MAX_ERROR*/3)] = (params.maxError  !== undefined ? params.maxError  : Number.POSITIVE_INFINITY);
        data[(/*JOINT_PRE_DT*/4)]    = -1;

        con._removeOnBreak      = (params.removeOnBreak      !== undefined ? params.removeOnBreak      : true);
        con._breakUnderError    = (params.breakUnderError    !== undefined ? params.breakUnderError    : false);
        con._breakUnderForce    = (params.breakUnderForce    !== undefined ? params.breakUnderForce    : false);
        con._stiff              = (params.stiff              !== undefined ? params.stiff              : true);
        con._ignoreInteractions = (params.ignoreInteractions !== undefined ? params.ignoreInteractions : false);
        con.sleeping            = (params.sleeping           !== undefined ? params.sleeping           : false);
        con._active             = (params.disabled           !== undefined ? (!params.disabled)        : true);

        con.world = null;
        con._islandRoot = null;
        con._islandRank = 0;
        con._island = null;

        con._wakeTime = 0;

        con._onBreak = [];
        con._onWake  = [];
        con._onSleep = [];

        con.userData = (params.userData || null);
    },

    configure : function configureFn(params)
    {
        var data = this._data;
        if (params.frequency !== undefined)
        {
            data[(/*JOINT_FREQUENCY*/0)] = params.frequency;
        }
        if (params.damping !== undefined)
        {
            data[(/*JOINT_DAMPING*/1)] = params.damping;
        }
        if (params.maxForce !== undefined)
        {
            data[(/*JOINT_MAX_FORCE*/2)] = params.maxForce;
        }
        if (params.maxError !== undefined)
        {
            data[(/*JOINT_MAX_ERROR*/3)] = params.maxError;
        }
        if (params.removeOnBreak !== undefined)
        {
            this._removeOnBreak = params.removeOnBreak;
        }
        if (params.breakUnderError !== undefined)
        {
            this._breakUnderError = params.breakUnderError;
        }
        if (params.breakUnderForce !== undefined)
        {
            this._breakUnderForce = params.breakUnderForce;
        }
        if (params.ignoreInteractions !== undefined)
        {
            this._ignoreInteractions = params.ignoreInteractions;
        }
        if (params.stiff !== undefined)
        {
            this._stiff = params.stiff;
        }
        this.wake(true);
    },

    // ===============================================

    addEventListener : function constraintAddEventListenerFn(eventType, callback)
    {
        var events = (eventType === 'wake'  ? this._onWake  :
                      eventType === 'sleep' ? this._onSleep :
                      eventType === 'break' ? this._onBreak :
                      null);

        if (events === null)
        {
            return false;
        }

        var index = events.indexOf(callback);
        if (index !== -1)
        {
            return false;
        }

        events.push(callback);

        this.wake();

        return true;
    },

    removeEventListener : function removeEventListenerFn(eventType, callback)
    {
        var events = (eventType === 'wake'  ? this._onWake  :
                      eventType === 'sleep' ? this._onSleep :
                      eventType === 'break' ? this._onBreak :
                      null);

        if (events === null)
        {
            return false;
        }

        var index = events.indexOf(callback);
        if (index === -1)
        {
            return false;
        }

        // Need to keep order, cannot use swap-pop
        events.splice(index, 1);

        this.wake();

        return true;
    },

    // ===============================================

    wake : function wakeFn(automated)
    {
        if (!this.world)
        {
            this.sleeping = false;
            return;
        }

        this.world._wakeConstraint(this, !automated);
    },
    sleep : function sleepFn()
    {
        if (!this.world)
        {
            this.sleeping = true;
            return;
        }

        this.world._forceSleepConstraint(this);
    },

    // ================================================

    isEnabled : function isEnabledFn()
    {
        return this._active;
    },
    isDisabled : function isDisabledFn()
    {
        return (!this._active);
    },

    enable : function enableFn()
    {
        if (!this._active)
        {
            this._active = true;
            if (this.world)
            {
                this.world._enabledConstraint(this);
                this.wake(true);
            }
        }
    },
    disable : function disableFn()
    {
        if (this._active)
        {
            if (this.world)
            {
                // Emulate a non-automated wake
                // to prevent wake callback.
                this.wake(false);
                this.world._disabledConstraint(this);
            }
            this._active = false;
        }
    },

    // ================================================

    getAnchorA : function getAnchorAFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var INDEX = this._ANCHOR_A;
        dst[0] = data[INDEX];
        dst[1] = data[INDEX + 1];
        return dst;
    },
    getAnchorB : function getAnchorBFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var INDEX = this._ANCHOR_B;
        dst[0] = data[INDEX];
        dst[1] = data[INDEX + 1];
        return dst;
    },

    setAnchorA : function setAnchorAFn(anchor)
    {
        var data = this._data;
        var INDEX = this._ANCHOR_A;
        var newX = anchor[0];
        var newY = anchor[1];
        if (newX !== data[INDEX] || newY !== data[INDEX + 1])
        {
            data[INDEX]     = newX;
            data[INDEX + 1] = newY;
            this.wake(true);
        }
    },
    setAnchorB : function setAnchorBFn(anchor)
    {
        var data = this._data;
        var INDEX = this._ANCHOR_B;
        var newX = anchor[0];
        var newY = anchor[1];
        if (newX !== data[INDEX] || newY !== data[INDEX + 1])
        {
            data[INDEX]     = newX;
            data[INDEX + 1] = newY;
            this.wake(true);
        }
    },

    rotateAnchor : function rotateAnchorFn(data, body, LOCAL, RELATIVE)
    {
        var x = data[LOCAL];
        var y = data[LOCAL + 1];
        var cos = body[(/*BODY_AXIS*/5)];
        var sin = body[(/*BODY_AXIS*/5) + 1];

        data[RELATIVE]     = ((cos * x) - (sin * y));
        data[RELATIVE + 1] = ((sin * x) + (cos * y));
    },

    // ================================================

    dtRatio : function dtRatioFn(data, deltaTime)
    {
        var preDt = data[(/*JOINT_PRE_DT*/4)];
        var dtRatio = (preDt === -1 ? 1.0 : (deltaTime / preDt));
        data[(/*JOINT_PRE_DT*/4)] = deltaTime;
        return dtRatio;
    },

    // ================================================

    twoBodyInWorld : function twoBodyInWorldFn()
    {
        this.bodyA.constraints.push(this);
        this.bodyB.constraints.push(this);
    },

    twoBodyOutWorld : function twoBodyOutWorldFn()
    {
        var constraints = this.bodyA.constraints;
        var index = constraints.indexOf(this);
        constraints[index] = constraints[constraints.length - 1];
        constraints.pop();

        constraints = this.bodyB.constraints;
        index = constraints.indexOf(this);
        constraints[index] = constraints[constraints.length - 1];
        constraints.pop();
    },

    twoBodyPairExists : function twoBodyPairExistsFn(b1, b2)
    {
        return ((b1 === this.bodyA && b2 === this.bodyB) ||
                (b2 === this.bodyA && b1 === this.bodyB));
    },

    twoBodyWakeConnected : function twoBodyWakeConnectedFn()
    {
        var body = this.bodyA;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            body.wake(true);
        }

        body = this.bodyB;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            body.wake(true);
        }
    },

    twoBodySleepComputation : function twoBodySleepComputationFn(union)
    {
        var body = this.bodyA;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            union(body, this);
        }

        body = this.bodyB;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            union(body, this);
        }
    },

    // ================================================

    clearCache : function clearCacheFn()
    {
        var data = this._data;
        data[this._JACC] = 0;
        data[(/*JOINT_PRE_DT*/4)] = -1;
    },
    clearCache2 : function clearCache2Fn()
    {
        var data = this._data;
        var INDEX = this._JACC;
        data[INDEX] = data[INDEX + 1] = 0;
        data[(/*JOINT_PRE_DT*/4)] = -1;
    },
    clearCache3 : function clearCache3Fn()
    {
        var data = this._data;
        var INDEX = this._JACC;
        data[INDEX] = data[INDEX + 1] = data[INDEX + 2] = 0;
        data[(/*JOINT_PRE_DT*/4)] = -1;
    },

    // ================================================

    // Soft constraint parameter logic.
    // storing gamma at index GAMMA
    // scaling effective mass at KMASS
    // scaling bias at BIAS
    // and returning true if constraint was broken.
    soft_params : function soft_paramsFn(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError)
    {
        var bias = data[BIAS];
        var bsq = (bias * bias);
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (breakUnderError && (bsq > (maxError * maxError)))
        {
            return true;
        }

        var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/0)]);
        var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/1)]) + (omega * deltaTime))));
        var iG = (1 / (1 + gamma));
        var biasCoef = (deltaTime * omega * omega * gamma);

        data[GAMMA] = (gamma * iG);
        data[KMASS] *= iG;

        bias *= biasCoef;
        bsq *= (biasCoef * biasCoef);
        if (bsq > (maxError * maxError))
        {
            bsq = (maxError / Math.sqrt(bsq));
            bias *= bsq;
        }
        data[BIAS] = bias;
        return false;
    },
    soft_params2 : function soft_params2Fn(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError)
    {
        var biasX = data[BIAS];
        var biasY = data[BIAS + 1];
        var bsq = ((biasX * biasX) + (biasY * biasY));
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (breakUnderError && (bsq > (maxError * maxError)))
        {
            return true;
        }

        var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/0)]);
        var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/1)]) + (omega * deltaTime))));
        var iG = (1 / (1 + gamma));
        var biasCoef = (deltaTime * omega * omega * gamma);

        data[GAMMA] = (gamma * iG);
        data[KMASS]     *= iG;
        data[KMASS + 1] *= iG;
        data[KMASS + 2] *= iG;

        biasX *= biasCoef;
        biasY *= biasCoef;
        bsq *= (biasCoef * biasCoef);
        if (bsq > (maxError * maxError))
        {
            bsq = (maxError / Math.sqrt(bsq));
            biasX *= bsq;
            biasY *= bsq;
        }
        data[BIAS]     = biasX;
        data[BIAS + 1] = biasY;
        return false;
    },
    soft_params3 : function soft_params3Fn(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError)
    {
        var biasX = data[BIAS];
        var biasY = data[BIAS + 1];
        var biasZ = data[BIAS + 2];
        var bsq = ((biasX * biasX) + (biasY * biasY) + (biasZ * biasZ));
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (breakUnderError && (bsq > (maxError * maxError)))
        {
            return true;
        }

        var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/0)]);
        var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/1)]) + (omega * deltaTime))));
        var iG = (1 / (1 + gamma));
        var biasCoef = (deltaTime * omega * omega * gamma);

        data[GAMMA] = (gamma * iG);
        data[KMASS]     *= iG;
        data[KMASS + 1] *= iG;
        data[KMASS + 2] *= iG;
        data[KMASS + 3] *= iG;
        data[KMASS + 4] *= iG;
        data[KMASS + 5] *= iG;

        biasX *= biasCoef;
        biasY *= biasCoef;
        biasZ *= biasCoef;
        bsq *= (biasCoef * biasCoef);
        if (bsq > (maxError * maxError))
        {
            bsq = (maxError / Math.sqrt(bsq));
            biasX *= bsq;
            biasY *= bsq;
            biasZ *= bsq;
        }
        data[BIAS]     = biasX;
        data[BIAS + 1] = biasY;
        data[BIAS + 2] = biasZ;
        return false;
    },

    // Solve K * j = err, permitting degeneracies in K
    // indices JMASS, ERR, IMP
    // ERR may be equal to IMP.
    safe_solve : function safe_solveFn(data, KMASS, ERR, IMP)
    {
        var err = data[ERR];
        var K = data[KMASS];
        data[IMP] = (K !== 0 ? (err / K) : 0);
    },
    safe_solve2 : function safe_solve2Fn(data, KMASS, ERR, IMP)
    {
        var errX = data[ERR];
        var errY = data[ERR + 1];

        var Ka = data[KMASS];
        var Kb = data[KMASS + 1];
        var Kc = data[KMASS + 2];
        var det = ((Ka * Kc) - (Kb * Kb));
        if (det === 0)
        {
            // Consider ranks seperately.
            data[IMP]     = (Ka !== 0 ? (errX / Ka) : 0);
            data[IMP + 1] = (Kc !== 0 ? (errY / Kc) : 0);
        }
        else
        {
            // Full matrix inversion.
            det = (1 / det);
            data[IMP]     = (det * ((Kc * errX) - (Kb * errY)));
            data[IMP + 1] = (det * ((Ka * errY) - (Kb * errX)));
        }
    },
    safe_solve3 : function safe_solve3Fn(data, KMASS, ERR, IMP)
    {
        var errX = data[ERR];
        var errY = data[ERR + 1];
        var errZ = data[ERR + 2];

        var Ka = data[KMASS];
        var Kb = data[KMASS + 1];
        var Kc = data[KMASS + 2];
        var Kd = data[KMASS + 3];
        var Ke = data[KMASS + 4];
        var Kf = data[KMASS + 5];

        var A = ((Kd * Kf) - (Ke * Ke));
        var B = ((Kc * Ke) - (Kb * Kf));
        var C = ((Kb * Ke) - (Kc * Kd));
        var det = ((Ka * A) + (Kb * B) + (Kc * C));
        if (det === 0)
        {
            det = ((Ka * Kd) - (Kb * Kb));
            if (det !== 0)
            {
                // Invert matrix ignoring bottom rank.
                // [Ka Kb #]
                // [Kb Kd #]
                // [#  #  #]
                det = (1 / det);
                data[IMP]     = (det * ((Kd * errX) - (Kb * errY)));
                data[IMP + 1] = (det * ((Ka * errY) - (Kb * errX)));
                data[IMP + 2] = (Kf !== 0 ? (errZ / Kf) : 0);
                return;
            }

            det = ((Ka * Kf) - (Kc * Kc));
            if (det !== 0)
            {
                // Invert matrix ignoring bottom rank.
                // [Ka # Kc]
                // [#  #  #]
                // [Kc # Kf]
                det = (1 / det);
                data[IMP]     = (det * ((Kf * errX) - (Kc * errZ)));
                data[IMP + 1] = (Kd !== 0 ? (errY / Kd) : 0);
                data[IMP + 2] = (det * ((Ka * errZ) - (Kc * errX)));
                return;
            }

            det = ((Kd * Kf) - (Ke * Ke));
            if (det !== 0)
            {
                // Invert matrix ignoring top rank
                // [#  #  #]
                // [# Kd Ke]
                // [# Ke Kf]
                det = (1 / det);
                data[IMP]     = (Ka !== 0 ? (errX / Ka) : 0);
                data[IMP + 1] = (det * ((Kf * errY) - (Ke * errZ)));
                data[IMP + 2] = (det * ((Kd * errZ) - (Ke * errY)));
                return;
            }

            // Consider all ranks seperately.
            data[IMP]     = (Ka !== 0 ? (errX / Ka) : 0);
            data[IMP + 1] = (Kd !== 0 ? (errY / Kd) : 0);
            data[IMP + 2] = (Kf !== 0 ? (errZ / Kf) : 0);
        }
        else
        {
            // Full matrix inversion.
            det = (1 / det);
            var D = ((Ka * Kf) - (Kc * Kc));
            var E = ((Kb * Kc) - (Ka * Ke));
            var F = ((Ka * Kd) - (Kb * Kb));
            data[IMP]     = (det * ((A * errX) + (B * errY) + (C * errZ)));
            data[IMP + 1] = (det * ((B * errX) + (D * errY) + (E * errZ)));
            data[IMP + 2] = (det * ((C * errX) + (E * errY) + (F * errZ)));
        }
    },

    // Invert matrix stored symmetrically in data at
    // indices KMASS
    // with accumulated impulse at indices JACC
    safe_invert : function safe_invertFn(data, KMASS, JACC)
    {
        // Invert [K != 0] into [1 / K]
        // And otherwise into [0] with zero-ed JACC
        var K = data[KMASS];
        if (K === 0)
        {
            data[JACC] = 0;
        }
        else
        {
            data[KMASS] = (1 / K);
        }
    },
    safe_invert2 : function safe_invert2Fn(data, KMASS, JACC)
    {
        var Ka = data[KMASS];
        var Kb = data[KMASS + 1];
        var Kc = data[KMASS + 2];

        var det = ((Ka * Kc) - (Kb * Kb));
        if (det === 0)
        {
            // Consider both ranks seperately.
            if (Ka !== 0)
            {
                data[KMASS] = (1 / Ka);
            }
            else
            {
                data[JACC] = 0.0;
            }

            if (Kc !== 0)
            {
                data[KMASS + 2] = (1 / Kc);
            }
            else
            {
                data[JACC + 1] = 0.0;
            }

            data[KMASS + 1] = 0.0;
        }
        else
        {
            // Full matrix inversion.
            det = (1 / det);
            data[KMASS]     = (det * Kc);
            data[KMASS + 1] = (det * -Kb);
            data[KMASS + 2] = (det * Ka);
        }
    },
    safe_invert3 : function safe_invert3Fn(data, KMASS, JACC)
    {
        var Ka = data[KMASS];
        var Kb = data[KMASS + 1];
        var Kc = data[KMASS + 2];
        var Kd = data[KMASS + 3];
        var Ke = data[KMASS + 4];
        var Kf = data[KMASS + 5];

        var A = ((Kd * Kf) - (Ke * Ke));
        var B = ((Kc * Ke) - (Kb * Kf));
        var C = ((Kb * Ke) - (Kc * Kd));
        var det = ((Ka * A) + (Kb * B) + (Kc * C));
        if (det === 0)
        {
            det = ((Ka * Kd) - (Kb * Kb));
            if (det !== 0)
            {
                // Invert matrix ignoring bottom rank
                // [Ka Kb #]
                // [Kb Kd #]
                // [#  #  #]
                det = (1 / det);
                data[KMASS]     = (det * Kd);
                data[KMASS + 1] = (det * -Kb);
                data[KMASS + 3] = (det * Ka);

                // Consider bottom rank seperately.
                if (Kf !== 0)
                {
                    data[KMASS + 5] = (1 / Kf);
                }
                else
                {
                    data[JACC + 2] = 0;
                }

                data[KMASS + 2] = data[KMASS + 4] = 0;
                return;
            }

            det = ((Ka * Kf) - (Kc * Kc));
            if (det !== 0)
            {
                // Invert matrix ignoring middle rank
                // [Ka # Kc]
                // [#  #  #]
                // [Kc # Kf]
                det = (1 / det);
                data[KMASS]     = (det * Kf);
                data[KMASS + 2] = (det * -Kc);
                data[KMASS + 5] = (det * Ka);

                // Consider middle rank seperately.
                if (Kd !== 0)
                {
                    data[KMASS + 3] = (1 / Kd);
                }
                else
                {
                    data[JACC + 1] = 0;
                }

                data[KMASS + 1] = data[KMASS + 4] = 0;
                return;
            }

            det = ((Kd * Kf) - (Ke * Ke));
            if (det !== 0)
            {
                // Invert matrix ignoring top rank
                // [#  #  #]
                // [# Kd Ke]
                // [# Ke Kf]
                det = (1 / det);
                data[KMASS + 3] = (det * Kf);
                data[KMASS + 4] = (det * -Ke);
                data[KMASS + 5] = (det * Kd);

                // Consider top rank seperately.
                if (Ka !== 0)
                {
                    data[KMASS] = (1 / Ka);
                }
                else
                {
                    data[JACC] = 0;
                }

                data[KMASS + 1] = data[KMASS + 2] = 0;
                return;
            }

            // Consider all ranks seperately
            if (Ka !== 0)
            {
                data[KMASS] = (1 / Ka);
            }
            else
            {
                data[JACC] = 0;
            }

            if (Kd !== 0)
            {
                data[KMASS + 3] = (1 / Kd);
            }
            else
            {
                data[JACC + 1] = 0;
            }

            if (Kf !== 0)
            {
                data[KMASS + 5] = (1 / Kf);
            }
            else
            {
                data[JACC + 2] = 0;
            }

            data[KMASS + 1] = data[KMASS + 2] = data[KMASS + 4] = 0;
        }
        else
        {
            // Full matrix inversion.
            det = (1 / det);
            data[KMASS]     = (det * A);
            data[KMASS + 1] = (det * B);
            data[KMASS + 2] = (det * C);
            data[KMASS + 3] = (det * ((Ka * Kf) - (Kc * Kc)));
            data[KMASS + 4] = (det * ((Kb * Kc) - (Ka * Ke)));
            data[KMASS + 5] = (det * ((Ka * Kd) - (Kb * Kb)));
        }
    }

};


// =========================================================================
//
// Custom Constraint
//

// CUSTOM DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*CUSTOM_JMAX*/5
///*CUSTOM_GAMMA*/6

function Physics2DCustomConstraint() {}
Physics2DCustomConstraint.prototype = {

    type : "CUSTOM",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    _inWorld : function _inWorldFn()
    {
        var bodies = this.bodies;
        var limit = bodies.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            bodies[i].constraints.push(this);
        }
    },

    _outWorld : function _inactiveOurOutWorldFn()
    {
        var bodies = this.bodies;
        var limit = bodies.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var constraints = bodies[i].constraints;
            var index = constraints.indexOf(this);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();
        }
    },

    _pairExists : function _pairExistsFn(b1, b2)
    {
        var bodies = this.bodies;
        var limit = bodies.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var bodyA = bodies[i];
            if (bodyA === b1 || bodyA === b2)
            {
                var j;
                for (j = (i + 1); j < limit; j += 1)
                {
                    var bodyB = bodies[j];
                    if ((bodyA === b1 && bodyB === b2) ||
                        (bodyA === b2 && bodyB === b1))
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    },

    _wakeConnected : function wakeConnectedFn()
    {
        var bodies = this.bodies;
        var limit = bodies.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var body = bodies[i];
            if (body._type === (/*TYPE_DYNAMIC*/0))
            {
                body.wake(true);
            }
        }
    },

    _sleepComputation : function sleepComputationFn(union)
    {
        var bodies = this.bodies;
        var limit = bodies.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var body = bodies[i];
            if (body._type === (/*TYPE_DYNAMIC*/0))
            {
                union(body, this);
            }
        }
    },

    // =====================================================

    _clearCache : function _clearCacheFn()
    {
        var data = this._data;

        var J_ACC = this._J_ACC;
        var limit = (J_ACC + this.dimension);
        var i;
        for (i = J_ACC; i < limit; i += 1)
        {
            data[i] = 0;
        }

        data[(/*JOINT_PRE_DT*/4)] = -1;
    },

    // Compute cholesky decomposition of A into
    // lower triangular matrix L. A stored
    // as symmetric matrix. and L a full matrix
    // for ease of computation.
    _cholesky : function _choleskyFn()
    {
        var data = this._data;
        var A = this._K_MASS;
        var L = this._K_CHOLESKY;
        var dim = this.dimension;

        var j;
        for (j = 0; j < dim; j += 1)
        {
            var sum = 0;
            var k;
            for (k = 0; k <= (j - 1); k += 1)
            {
                var Lval = data[L + (j * dim) + k];
                sum += (Lval * Lval);
            }

            var rec = data[A] - sum;
            var zeroRank = (rec <= 0);
            if (zeroRank)
            {
                rec = data[A];
            }
            rec = (rec <= 0 ? 0 : Math.sqrt(rec));
            A += 1;
            data[L + (j * dim) + j] = rec;

            var i;
            if (rec !== 0 && !zeroRank)
            {
                rec = (1 / rec);
                for (i = (j + 1); i < dim; i += 1)
                {
                    sum = 0;
                    for (k = 0; k <= (j - 1); k += 1)
                    {
                        sum += (data[L + (i * dim) + k] * data[L + (j * dim) + k]);
                    }
                    data[L + (i * dim) + j] = rec * (data[A] - sum);
                    A += 1;
                }
            }

            if (zeroRank)
            {
                for (i = (j + 1); i < dim; i += 1)
                {
                    data[L + (i * dim) + j] = 0;
                }
                for (i = 0; i < j; i += 1)
                {
                    data[L + (j * dim) + i] = 0;
                }
                A += (dim - j - 1);
            }
        }
    },

    // Perform multiplication with inverse of eff-mass matrix.
    // X = (LL^T)^-1 * X for L = CHOLESKY
    _transform : function _transformFn(X)
    {
        var data = this._data;
        var Y = this._VECTOR_TMP;
        var L = this._K_CHOLESKY;
        var dim = this.dimension;

        // Y = (L^-1) * X
        var i, lii, sum, k;
        for (i = 0; i < dim; i += 1)
        {
            sum = data[X + i];
            lii = data[L + (i * dim) + i];
            if (lii !== 0)
            {
                for (k = 0; k < i; k += 1)
                {
                    sum -= data[L + (i * dim) + k] * data[Y + k];
                }
                data[Y + i] = (sum / lii);
            }
            else
            {
                data[Y + i] = 0;
            }
        }

        // X = (L^T)^-1 * Y
        var ix;
        for (ix = 0; ix < dim; ix += 1)
        {
            i = (dim - 1 - ix);
            lii = data[L + (i * dim) + i];
            if (lii !== 0)
            {
                sum = data[Y + i];
                for (k = (i + 1); k < dim; k += 1)
                {
                    sum -= data[L + (k * dim) + i] * data[X + k];
                }
                data[X + i] = (sum / lii);
            }
            else
            {
                data[X + i] = 0;
            }
        }
    },

    _effMass : function _effMassFn()
    {
        var data = this._data;
        var dimension = this.dimension;
        var bodies = this.bodies;
        var limit = bodies.length;
        var length = (limit * 3);

        // Compute non-inverted effective mass
        var JAC = this._JACOBIAN;
        var KMASS = this._K_MASS;
        var i, j, k;
        for (i = 0; i < dimension; i += 1)
        {
            var JACI = (JAC + (i * length));
            for (j = i; j < dimension; j += 1)
            {
                var JACJ = (JAC + (j * length));
                var sum = 0;
                for (k = 0; k < limit; k += 1)
                {
                    var body = bodies[k]._data;
                    var k3 = (k * 3);
                    sum += (body[(/*BODY_IMASS*/0)] * ((data[JACI + k3] * data[JACJ + k3]) +
                                                       (data[JACI + k3 + 1] * data[JACJ + k3 + 1])));
                    sum += (body[(/*BODY_IINERTIA*/1)] * (data[JACI + k3 + 2] * data[JACJ + k3 + 2]));
                }
                data[KMASS] = sum;
                KMASS += 1;
            }
        }
    },

    _preStep : function _preStepFn(deltaTime)
    {
        var dimension = this.dimension;
        var data = this._data;
        var i, limit;

        if (this._posConsts)
        {
            this._posConsts.call(this);
        }

        var JAC = this._JACOBIAN;
        var K_CHOLESKY = this._K_CHOLESKY;
        var BIAS = this._BIAS;


        if (!this._stiff && !this._velocityOnly)
        {
            this._posError.call(this, data, BIAS);

            this._jacobian.call(this, data, JAC);
            this._effMass();
            this._cholesky();

            // Compute |BIAS|^2
            var bsq = 0;
            limit = (BIAS + dimension);
            for (i = BIAS; i < limit; i += 1)
            {
                var bias = data[i];
                bsq += (bias * bias);
            }

            var maxError = data[(/*JOINT_MAX_ERROR*/3)];
            if (this._breakUnderError && (bsq > (maxError * maxError)))
            {
                return true;
            }

            var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/0)]);
            var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/1)]) + (omega * deltaTime))));
            var iG = (1 / (1 + gamma));
            var biasCoef = -(deltaTime * omega * omega * gamma);

            data[(/*CUSTOM_GAMMA*/6)] = (gamma * iG);

            // Multiply K_CHOLESKY with (1 / sqrt(iG)).
            //
            //   (We want to mulitply inverted eff-mass with iG.
            //    Instead of iG * K^1 we have:
            //    (g * L)^T^-1 * (g * L)^-1
            //    so we must have g = 1 / sqrt(iG)
            //    so that after multiplication we get iG * K^-1
            limit = (K_CHOLESKY + (dimension * dimension));
            iG = (1 / Math.sqrt(iG));
            for (i = K_CHOLESKY; i < limit; i += 1)
            {
                data[i] *= iG;
            }

            // Clamp BIAS magnitude to maxError
            // (implicit via scaling of biasCoef)
            bsq *= (biasCoef * biasCoef);
            if (bsq > (maxError * maxError))
            {
                biasCoef *= (maxError / Math.sqrt(bsq));
            }

            // Multiply BIAS with biasCoef
            limit = (BIAS + dimension);
            for (i = BIAS; i < limit; i += 1)
            {
                data[i] *= biasCoef;
            }
        }
        else
        {
            this._jacobian.call(this, data, JAC);
            this._effMass();
            this._cholesky();

            // BIAS = 0
            limit = (BIAS + dimension);
            for (i = BIAS; i < limit; i += 1)
            {
                data[i] = 0;
            }
            data[(/*CUSTOM_GAMMA*/6)] = 0;
        }

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        // Multiply J_ACC with dtRatio.
        var J_ACC = this._J_ACC;
        limit = (J_ACC + this.dimension);
        for (i = J_ACC; i < limit; i += 1)
        {
            data[i] *= dtRatio;
        }

        data[(/*CUSTOM_JMAX*/5)] = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        this._applyImpulse(this._J_ACC);
    },

    getImpulseForBody : function getImpulseOnBody(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var data = this._data;
        var JAC = this._JACOBIAN;
        var J = this._J_ACC;

        var bodies = this.bodies;
        var limit = bodies.length;
        var length = (limit * 3);
        var dim = this.dimension;

        var i;
        for (i = 0; i < limit; i += 1)
        {
            var b = bodies[i];
            if (b === body)
            {
                var sumX = 0;
                var sumY = 0;
                var sumW = 0;
                var j;
                for (j = 0; j < dim; j += 1)
                {
                    sumX += (data[J + j] * data[JAC + (length * j)]);
                    sumY += (data[J + j] * data[JAC + (length * j) + 1]);
                    sumW += (data[J + j] * data[JAC + (length * j) + 2]);
                }

                dst[0] = sumX;
                dst[1] = sumY;
                dst[2] = sumW;
                return dst;
            }

            JAC += 3;
        }

        dst[0] = dst[1] = dst[2] = 0;
        return dst;
    },

    _applyImpulse : function _applyImpulseFn(J, position)
    {
        var data = this._data;
        var JAC = this._JACOBIAN;

        var bodies = this.bodies;
        var limit = bodies.length;
        var length = (limit * 3);
        var dim = this.dimension;

        var i;
        for (i = 0; i < limit; i += 1)
        {
            var b = bodies[i];
            var body = b._data;

            var sumX = 0;
            var sumY = 0;
            var sumW = 0;
            var j;
            for (j = 0; j < dim; j += 1)
            {
                sumX += (data[J + j] * data[JAC + (length * j)]);
                sumY += (data[J + j] * data[JAC + (length * j) + 1]);
                sumW += (data[J + j] * data[JAC + (length * j) + 2]);
            }

            var im = body[(/*BODY_IMASS*/0)];
            var dr = sumW * body[(/*BODY_IINERTIA*/1)];
            if (position)
            {
                body[(/*BODY_POS*/2)]     += sumX * im;
                body[(/*BODY_POS*/2) + 1] += sumY * im;
                if (dr !== 0)
                {
                    b._deltaRotation(dr);
                }
            }
            else
            {
                body[(/*BODY_VEL*/7)]     += sumX * im;
                body[(/*BODY_VEL*/7) + 1] += sumY * im;
                body[(/*BODY_VEL*/7) + 2] += dr;
            }

            JAC += 3;
        }
    },

    _iterateVel : function _iterateVelFn()
    {
        var dimension = this.dimension;
        var data = this._data;
        var i, limit;

        var VECTOR = this._VECTOR;
        var BIAS = this._BIAS;
        // VECTOR = BIAS - velocity()
        var j;
        var bodies = this.bodies;
        var limit2 = bodies.length;
        var JAC = this._JACOBIAN;
        for (i = 0; i < dimension; i += 1)
        {
            var term = data[BIAS + i];
            for (j = 0; j < limit2; j += 1)
            {
                var body = bodies[j]._data;
                term -= ((body[(/*BODY_VEL*/7)]     * data[JAC]) +
                         (body[(/*BODY_VEL*/7) + 1] * data[JAC + 1]) +
                         (body[(/*BODY_VEL*/7) + 2] * data[JAC + 2]));
                JAC += 3;
            }
            data[VECTOR + i] = term;
        }

        // VECTOR = KMASS * VECTOR
        this._transform(VECTOR);

        // JOLD = JACC
        // JACC += (VECTOR - JOLD * gamma)
        var JACC = this._J_ACC;
        var JOLD = this._VECTOR_TMP;
        var jAcc;
        var gamma = data[(/*CUSTOM_GAMMA*/6)];
        for (i = 0; i < dimension; i += 1)
        {
            jAcc = data[JOLD + i] = data[JACC + i];
            data[JACC + i] += (data[VECTOR + i] - (jAcc * gamma));
        }

        if (this._velClamp)
        {
            this._velClamp.call(this, data, JACC);
        }

        // jlsq = |JACC|^2
        var jlsq = 0;
        limit = (JACC + dimension);
        for (i = JACC; i < limit; i += 1)
        {
            jAcc = data[i];
            jlsq += (jAcc * jAcc);
        }

        var jMax = data[(/*CUSTOM_JMAX*/5)];
        if (this._breakUnderForce && jlsq > (jMax * jMax))
        {
            return true;
        }
        else if (!this._stiff && jlsq > (jMax * jMax))
        {
            // clamp(JACC, jMax)
            jlsq = (jMax / Math.sqrt(jlsq));
            for (i = JACC; i < limit; i += 1)
            {
                data[i] *= jlsq;
            }
        }

        // VECTOR = JACC - JOLD
        for (i = 0; i < dimension; i += 1)
        {
            data[VECTOR + i] = (data[JACC + i] - data[JOLD + i]);
        }

        this._applyImpulse(VECTOR);

        return false;
    },

    _iteratePos : function _iteratePosFn()
    {
        if (this._velocityOnly)
        {
            return false;
        }

        if (this._posConsts)
        {
            this._posConsts.call(this);
        }

        var dimension = this.dimension;
        var data = this._data;
        var i, limit;

        var BIAS = this._BIAS;
        this._posError.call(this, data, BIAS);

        // elsq = |BIAS|^2
        // BIAS = -BIAS
        limit = (BIAS + dimension);
        var err;
        var elsq = 0;
        for (i = BIAS; i < limit; i += 1)
        {
            err = data[i];
            elsq += (err * err);
            data[i] = -err;
        }

        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (this._breakUnderError && (elsq > (maxError * maxError)))
        {
            return true;
        }

        var JAC = this._JACOBIAN;

        // Recompute jacobian
        this._jacobian.call(this, data, JAC);

        // Recompute effective mass.
        this._effMass();
        this._cholesky();

        // BIAS = KMASS * BIAS
        this._transform(BIAS);
        if (this._posClamp)
        {
            this._posClamp.call(this, data, BIAS);
        }

        this._applyImpulse(BIAS, true);

        return false;
    }
};

Physics2DCustomConstraint.create = function userConstraintFn(params)
{
    var p = new Physics2DCustomConstraint();

    var dim = p.dimension = params.dimension;
    p.bodies = params.bodies.concat();

    // K_MASS     = (dim * (dim + 1)) / 2
    // K_CHOLSEKY = (dim * dim)
    // BIAS       = dim
    // J_ACC      = dim
    // VECTOR     = dim
    // JACOBIAN   = (dim * bodies.length * 3)
    // VECTOR_TMP = dim
    var dataSize = 7 + (dim * (4 + dim) + ((dim * (dim + 1)) / 2));
    dataSize += (dim * p.bodies.length * 3);
    p._data = new Physics2DDevice.prototype.floatArray(dataSize);
    Physics2DConstraint.prototype.init(p, params);

    p._K_MASS     = 7;
    p._K_CHOLESKY = p._K_MASS + ((dim * (dim + 1)) / 2);
    p._BIAS       = p._K_CHOLESKY + (dim * dim);
    p._J_ACC      = p._BIAS + dim;
    p._VECTOR     = p._J_ACC + dim;
    p._JACOBIAN   = p._VECTOR + dim;
    p._VECTOR_TMP = p._JACOBIAN + (dim * p.bodies.length * 3);

    p._draw      = params.debugDraw;
    p._posConsts = params.positionConstants;
    p._posError  = params.position;
    p._velError  = params.velocity;
    p._posClamp  = params.positionClamp;
    p._velClamp  = params.velocityClamp;
    p._jacobian  = params.jacobian;

    p._velocityOnly = (p._posError === undefined);

    return p;
};


// =========================================================================
//
//
// Pulley Constraint
//
// PULLEY DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*PULLEY_JOINTMIN*/5   // Joint limits
///*PULLEY_JOINTMAX*/6   //
///*PULLEY_RATIO*/7      // Pulley ratio
///*PULLEY_KMASS*/8      // Effective-mass (scalar)
///*PULLEY_JACC*/9       // Accumulated impulse (scalar)
///*PULLEY_JMAX*/10      // Maximum impulse (maxForce derived)
///*PULLEY_LANCHOR1*/11  // Local anchor position on bodyA (x, y)
///*PULLEY_LANCHOR2*/13  // Local anchor position on bodyB (x, y)
///*PULLEY_LANCHOR3*/15  // Local anchor position on bodyC (x, y)
///*PULLEY_LANCHOR4*/17  // Local anchor position on bodyD (x, y)
///*PULLEY_RANCHOR1*/19  // Relative anchor position on bodyA (x, y)
///*PULLEY_RANCHOR2*/21  // Relative anchor position on bodyB (x, y)
///*PULLEY_RANCHOR3*/23  // Relative anchor position on bodyC (x, y)
///*PULLEY_RANCHOR4*/25  // Relative anchor position on bodyD (x, y)
///*PULLEY_GAMMA*/27     // Soft constraint gamma
///*PULLEY_BIAS*/28      // Soft constraint bias (scalar)
///*PULLEY_N12*/29       // Direction of constraint (r1 -> r2) (x, y)
///*PULLEY_N34*/31       // Direction of constraint (r3 -> r4) (x, y)
///*PULLEY_CX1*/33       // (RANCHOR1 cross N12)
///*PULLEY_CX2*/34       // (RANCHOR2 cross N12)
///*PULLEY_CX3*/35       // (RANCHOR3 cross N34)
///*PULLEY_CX4*/36       // (RANCHOR4 cross N34)
//
///*PULLEY_DATA_SIZE*/37

function Physics2DPulleyConstraint() {}
Physics2DPulleyConstraint.prototype = {

    type : "PULLEY",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    getRatio : function getRatioFn()
    {
        return this._data[(/*PULLEY_RATIO*/7)];
    },
    setRatio : function setRatioFn(ratio)
    {
        var data = this._data;
        if (data[(/*PULLEY_RATIO*/7)] !== ratio)
        {
            data[(/*PULLEY_RATIO*/7)] = ratio;
            this.wake(true);
        }
    },

    getLowerBound : function getLowerBound()
    {
        return this._data[(/*PULLEY_JOINTMIN*/5)];
    },
    getUpperBound : function getUpperBound()
    {
        return this._data[(/*PULLEY_JOINTMAX*/6)];
    },

    setLowerBound : function setLowerBoundFn(lowerBound)
    {
        var data = this._data;
        if (data[(/*PULLEY_JOINTMIN*/5)] !== lowerBound)
        {
            data[(/*PULLEY_JOINTMIN*/5)] = lowerBound;
            this._equal = (lowerBound === data[(/*PULLEY_JOINTMAX*/6)]);
            this.wake(true);
        }
    },
    setUpperBound : function setUpperBoundFn(upperBound)
    {
        var data = this._data;
        if (data[(/*PULLEY_JOINTMAX*/6)] !== upperBound)
        {
            data[(/*PULLEY_JOINTMAX*/6)] = upperBound;
            this._equal = (upperBound === data[(/*PULLEY_JOINTMIN*/5)]);
            this.wake(true);
        }
    },

    // Inherited
    _ANCHOR_A : (/*PULLEY_LANCHOR1*/11),
    getAnchorA : Physics2DConstraint.prototype.getAnchorA,
    setAnchorA : Physics2DConstraint.prototype.setAnchorA,

    _ANCHOR_B : (/*PULLEY_LANCHOR2*/13),
    getAnchorB : Physics2DConstraint.prototype.getAnchorB,
    setAnchorB : Physics2DConstraint.prototype.setAnchorB,

    _ANCHOR_C : (/*PULLEY_LANCHOR3*/15),
    getAnchorC : function getAnchorCFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var INDEX = this._ANCHOR_C;
        dst[0] = data[INDEX];
        dst[1] = data[INDEX + 1];
        return dst;
    },
    setAnchorC : function setAnchorCFn(anchor)
    {
        var data = this._data;
        var INDEX = this._ANCHOR_C;
        var newX = anchor[0];
        var newY = anchor[1];
        if (newX !== data[INDEX] || newY !== data[INDEX + 1])
        {
            data[INDEX]     = newX;
            data[INDEX + 1] = newY;
            this.wake(true);
        }
    },

    _ANCHOR_D : (/*PULLEY_LANCHOR4*/17),
    getAnchorD : function getAnchorDFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var INDEX = this._ANCHOR_D;
        dst[0] = data[INDEX];
        dst[1] = data[INDEX + 1];
        return dst;
    },
    setAnchorD : function setAnchorDFn(anchor)
    {
        var data = this._data;
        var INDEX = this._ANCHOR_D;
        var newX = anchor[0];
        var newY = anchor[1];
        if (newX !== data[INDEX] || newY !== data[INDEX + 1])
        {
            data[INDEX]     = newX;
            data[INDEX + 1] = newY;
            this.wake(true);
        }
    },

    // =========================================================

    _inWorld : function inWorldFn()
    {
        this.bodyA.constraints.push(this);
        this.bodyB.constraints.push(this);
        if (this.bodyB !== this.bodyC)
        {
            this.bodyC.constraints.push(this);
        }
        this.bodyD.constraints.push(this);
    },

    _outWorld : function outWorldFn()
    {
        var constraints = this.bodyA.constraints;
        var index = constraints.indexOf(this);
        constraints[index] = constraints[constraints.length - 1];
        constraints.pop();

        constraints = this.bodyB.constraints;
        index = constraints.indexOf(this);
        constraints[index] = constraints[constraints.length - 1];
        constraints.pop();

        if (this.bodyB !== this.bodyC)
        {
            constraints = this.bodyB.constraints;
            index = constraints.indexOf(this);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();
        }

        constraints = this.bodyD.constraints;
        index = constraints.indexOf(this);
        constraints[index] = constraints[constraints.length - 1];
        constraints.pop();
    },

    _pairExists : function pairExistsFn(b1, b2)
    {
        var bodyA = this.bodyA;
        var bodyB = this.bodyB;
        var bodyC = this.bodyC;
        var bodyD = this.bodyD;

        return ((b1 === bodyA && (b2 === bodyB || b2 === bodyC || b2 === bodyD)) ||
                (b1 === bodyB && (b2 === bodyA || b2 === bodyC || b2 === bodyD)) ||
                (b1 === bodyC && (b2 === bodyA || b2 === bodyB || b2 === bodyD)) ||
                (b1 === bodyD && (b2 === bodyA || b2 === bodyB || b2 === bodyC)));
    },

    _wakeConnected : function wakeConnectedFn()
    {
        var body = this.bodyA;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            body.wake(true);
        }

        body = this.bodyB;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            body.wake(true);
        }

        body = this.bodyC;
        if (body !== this.bodyB && body._type === (/*TYPE_DYNAMIC*/0))
        {
            body.wake(true);
        }

        body = this.bodyD;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            body.wake(true);
        }
    },

    _sleepComputation : function sleepComputationFn(union)
    {
        var body = this.bodyA;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            union(body, this);
        }

        body = this.bodyB;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            union(body, this);
        }

        body = this.bodyC;
        if (body !== this.bodyB && body._type === (/*TYPE_DYNAMIC*/0))
        {
            union(body, this);
        }

        body = this.bodyD;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            union(body, this);
        }
    },

    // =====================================================

    // Inherited
    _JACC : (/*PULLEY_JACC*/9),
    _clearCache : Physics2DConstraint.prototype.clearCache,

    _posError : function _posErrorFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var b3 = this.bodyC._data;
        var b4 = this.bodyD._data;

        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*PULLEY_LANCHOR1*/11), (/*PULLEY_RANCHOR1*/19));
        Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*PULLEY_LANCHOR2*/13), (/*PULLEY_RANCHOR2*/21));
        Physics2DConstraint.prototype.rotateAnchor(data, b3, (/*PULLEY_LANCHOR3*/15), (/*PULLEY_RANCHOR3*/23));
        Physics2DConstraint.prototype.rotateAnchor(data, b4, (/*PULLEY_LANCHOR4*/17), (/*PULLEY_RANCHOR4*/25));

        var jointMin = data[(/*PULLEY_JOINTMIN*/5)];
        var jointMax = data[(/*PULLEY_JOINTMAX*/6)];

        var n12x = ((b2[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR2*/21)])     -
                    (b1[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR1*/19)]));
        var n12y = ((b2[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR2*/21) + 1]) -
                    (b1[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR1*/19) + 1]));
        var n34x = ((b4[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR4*/25)])     -
                    (b3[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR3*/23)]));
        var n34y = ((b4[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR4*/25) + 1]) -
                    (b3[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR3*/23) + 1]));

        var err12 = ((n12x * n12x) + (n12y * n12y));
        var err34 = ((n34x * n34x) + (n34y * n34y));
        var rec;
        if (err12 < Physics2DConfig.NORMALIZE_SQ_EPSILON)
        {
            err12 = 0;
            n12x = data[(/*PULLEY_N12*/29)];
            n12y = data[(/*PULLEY_N12*/29) + 1];
        }
        else
        {
            err12 = Math.sqrt(err12);
            rec = (1 / err12);
            n12x *= rec;
            n12y *= rec;
        }

        var ratio = data[(/*PULLEY_RATIO*/7)];
        if (err34 < Physics2DConfig.NORMALIZE_SQ_EPSILON)
        {
            err34 = 0;
            n34x = data[(/*PULLEY_N34*/31)];
            n34y = data[(/*PULLEY_N34*/31) + 1];
        }
        else
        {
            err34 = Math.sqrt(err34);
            rec = (ratio / err34);
            n34x *= rec;
            n34y *= rec;
        }

        var err = (err12 + (err34 * ratio));
        if (this._equal)
        {
            err -= jointMin;
            this._slack = false;
        }
        else if (err < jointMin)
        {
            err = (jointMin - err);
            n12x = -n12x;
            n12y = -n12y;
            n34x = -n34x;
            n34y = -n34y;
            this._slack = false;
        }
        else if (err > jointMax)
        {
            err -= jointMax;
            this._slack = false;
        }
        else
        {
            // Don't set normals to 0.
            // In this case that _slack is true, we do no further work
            // So we permit normals to persist so that should constraint
            // become degenerate we can still choose a 'good' direction.
            //
            // Constraint only becomes degenerate when jointMin = 0 and we reach this
            // limit. In this condition we want negated normals, so that's what we
            // allow to persist.
            n12x = -n12x;
            n12y = -n12y;
            n34x = -n34x;
            n34y = -n34y;

            err = 0;
            this._slack = true;
        }

        data[(/*PULLEY_N12*/29)]     = n12x;
        data[(/*PULLEY_N12*/29) + 1] = n12y;
        data[(/*PULLEY_N34*/31)]     = n34x;
        data[(/*PULLEY_N34*/31) + 1] = n34y;
        data[(/*PULLEY_BIAS*/28)]    = (-err);
    },

    _preStep : function _preStepFn(deltaTime)
    {
        this._posError();
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var b3 = this.bodyC._data;
        var b4 = this.bodyD._data;

        // Compute non-inverted effective mass.
        var ratioSq = data[(/*PULLEY_RATIO*/7)];
        ratioSq *= ratioSq;
        var n12x = data[(/*PULLEY_N12*/29)];
        var n12y = data[(/*PULLEY_N12*/29) + 1];
        var n34x = data[(/*PULLEY_N34*/31)];
        var n34y = data[(/*PULLEY_N34*/31) + 1];
        var cx1 = data[(/*PULLEY_CX1*/33)] = ((data[(/*PULLEY_RANCHOR1*/19)] * n12y) - (data[(/*PULLEY_RANCHOR1*/19) + 1] * n12x));
        var cx2 = data[(/*PULLEY_CX2*/34)] = ((data[(/*PULLEY_RANCHOR2*/21)] * n12y) - (data[(/*PULLEY_RANCHOR2*/21) + 1] * n12x));
        var cx3 = data[(/*PULLEY_CX3*/35)] = ((data[(/*PULLEY_RANCHOR3*/23)] * n34y) - (data[(/*PULLEY_RANCHOR3*/23) + 1] * n34x));
        var cx4 = data[(/*PULLEY_CX4*/36)] = ((data[(/*PULLEY_RANCHOR4*/25)] * n34y) - (data[(/*PULLEY_RANCHOR4*/25) + 1] * n34x));
        var im3 = b3[(/*BODY_IMASS*/0)];
        var ii3 = b3[(/*BODY_IINERTIA*/1)];
        var K = (b1[(/*BODY_IMASS*/0)] + b2[(/*BODY_IMASS*/0)] + (ratioSq * (im3 + b4[(/*BODY_IMASS*/0)])) +
                 (cx1 * b1[(/*BODY_IINERTIA*/1)] * cx1) + (cx2 * b2[(/*BODY_IINERTIA*/1)] * cx2) + (cx3 * ii3 * cx3) +
                 (cx4 * b4[(/*BODY_IINERTIA*/1)] * cx4));
        if (b2 === b3)
        {
            K -= 2 * ((((n12x * n34x) + (n12y * n34y)) * im3) + (cx2 * cx3 * ii3));
        }
        data[(/*PULLEY_KMASS*/8)] = K;

        // Invert effective mass
        Physics2DConstraint.prototype.safe_invert(data, (/*PULLEY_KMASS*/8), (/*PULLEY_JACC*/9));

        if (!this._stiff)
        {
            if (Physics2DConstraint.prototype.soft_params(data, (/*PULLEY_KMASS*/8), (/*PULLEY_GAMMA*/27), (/*PULLEY_BIAS*/28), deltaTime, this._breakUnderError))
            {
                return true;
            }
        }
        else
        {
            data[(/*PULLEY_GAMMA*/27)] = 0;
            data[(/*PULLEY_BIAS*/28)]  = 0;
        }

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        data[(/*PULLEY_JACC*/9)]  *= dtRatio;
        data[(/*PULLEY_JMAX*/10)] = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var b3 = this.bodyC._data;
        var b4 = this.bodyD._data;

        var jAcc = data[(/*PULLEY_JACC*/9)];
        var jx = (data[(/*PULLEY_N12*/29)]     * jAcc);
        var jy = (data[(/*PULLEY_N12*/29) + 1] * jAcc);

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (data[(/*PULLEY_CX1*/33)] * jAcc * b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (data[(/*PULLEY_CX2*/34)] * jAcc * b2[(/*BODY_IINERTIA*/1)]);

        jx = (data[(/*PULLEY_N34*/31)]     * jAcc);
        jy = (data[(/*PULLEY_N34*/31) + 1] * jAcc);

        im = b3[(/*BODY_IMASS*/0)];
        b3[(/*BODY_VEL*/7)]     -= (jx * im);
        b3[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b3[(/*BODY_VEL*/7) + 2] -= (data[(/*PULLEY_CX3*/35)] * jAcc * b3[(/*BODY_IINERTIA*/1)]);

        im = b4[(/*BODY_IMASS*/0)];
        b4[(/*BODY_VEL*/7)]     += (jx * im);
        b4[(/*BODY_VEL*/7) + 1] += (jy * im);
        b4[(/*BODY_VEL*/7) + 2] += (data[(/*PULLEY_CX4*/36)] * jAcc * b4[(/*BODY_IINERTIA*/1)]);
    },

    getImpulseForBody : function getImpulseForBody(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var jAcc = data[(/*PULLEY_JACC*/9)];

        var data = this._data;
        if (body === this.bodyA)
        {
            dst[0] = -(data[(/*PULLEY_N12*/29)]     * jAcc);
            dst[1] = -(data[(/*PULLEY_N12*/29) + 1] * jAcc);
            dst[2] = -data[(/*PULLEY_CX1*/33)] * jAcc;
        }
        else if (body === this.bodyD)
        {
            dst[0] = (data[(/*PULLEY_N34*/31)]     * jAcc);
            dst[1] = (data[(/*PULLEY_N34*/31) + 1] * jAcc);
            dst[2] = data[(/*PULLEY_CX4*/36)] * jAcc;
        }
        else
        {
            var sumX = 0;
            var sumY = 0;
            var sumW = 0;
            if (body === this.bodyB)
            {
                sumX += (data[(/*PULLEY_N12*/29)]     * jAcc);
                sumY += (data[(/*PULLEY_N12*/29) + 1] * jAcc);
                sumW += data[(/*PULLEY_CX2*/34)] * jAcc;
            }
            if (body === this.bodyC)
            {
                sumX -= (data[(/*PULLEY_N34*/31)]     * jAcc);
                sumY -= (data[(/*PULLEY_N34*/31) + 1] * jAcc);
                sumW -= data[(/*PULLEY_CX3*/35)] * jAcc;
            }
            dst[0] = sumX;
            dst[1] = sumY;
            dst[2] = sumW;
        }

        return dst;
    },

    _iterateVel : function _iterateVelFn()
    {
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var b3 = this.bodyC._data;
        var b4 = this.bodyD._data;

        // x = Bias - VelocityError
        var n12x = data[(/*PULLEY_N12*/29)];
        var n12y = data[(/*PULLEY_N12*/29) + 1];
        var n34x = data[(/*PULLEY_N34*/31)];
        var n34y = data[(/*PULLEY_N34*/31) + 1];
        var cx1  = data[(/*PULLEY_CX1*/33)];
        var cx2  = data[(/*PULLEY_CX2*/34)];
        var cx3  = data[(/*PULLEY_CX3*/35)];
        var cx4  = data[(/*PULLEY_CX4*/36)];
        var x = (data[(/*PULLEY_BIAS*/28)] - ((n12x * (b2[(/*BODY_VEL*/7)]     - b1[(/*BODY_VEL*/7)])) +
                                              (n12y * (b2[(/*BODY_VEL*/7) + 1] - b1[(/*BODY_VEL*/7) + 1])) +
                                              (n34x * (b4[(/*BODY_VEL*/7)]     - b3[(/*BODY_VEL*/7)])) +
                                              (n34y * (b4[(/*BODY_VEL*/7) + 1] - b3[(/*BODY_VEL*/7) + 1])) +
                                              (cx2 * b2[(/*BODY_VEL*/7) + 2]) -
                                              (cx1 * b1[(/*BODY_VEL*/7) + 2]) +
                                              (cx4 * b4[(/*BODY_VEL*/7) + 2]) -
                                              (cx3 * b3[(/*BODY_VEL*/7) + 2])));

        var jOld = data[(/*PULLEY_JACC*/9)];
        // Impulse.
        // j = K * x - jAcc * gamma
        var j = ((data[(/*PULLEY_KMASS*/8)] * x) - (jOld * data[(/*PULLEY_GAMMA*/27)]));

        // Accumulate and clamp.
        var jAcc = (jOld + j);
        var jMax = data[(/*PULLEY_JMAX*/10)];
        if (!this._equal && jAcc > 0)
        {
            jAcc = 0;
        }
        if (this._breakUnderForce)
        {
            if (jAcc > jMax || jAcc < -jMax)
            {
                return true;
            }
        }
        else if (!this._stiff)
        {
            if (jAcc > jMax)
            {
                jAcc = jMax;
            }
            else if (jAcc < -jMax)
            {
                jAcc = -jMax;
            }
        }

        j = (jAcc - jOld);
        data[(/*PULLEY_JACC*/9)] = jAcc;

        // Apply impulse.
        var jx = (data[(/*PULLEY_N12*/29)]     * j);
        var jy = (data[(/*PULLEY_N12*/29) + 1] * j);

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (cx1 * j * b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (cx2 * j * b2[(/*BODY_IINERTIA*/1)]);

        jx = (data[(/*PULLEY_N34*/31)]     * j);
        jy = (data[(/*PULLEY_N34*/31) + 1] * j);

        im = b3[(/*BODY_IMASS*/0)];
        b3[(/*BODY_VEL*/7)]     -= (jx * im);
        b3[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b3[(/*BODY_VEL*/7) + 2] -= (cx3 * j * b3[(/*BODY_IINERTIA*/1)]);

        im = b4[(/*BODY_IMASS*/0)];
        b4[(/*BODY_VEL*/7)]     += (jx * im);
        b4[(/*BODY_VEL*/7) + 1] += (jy * im);
        b4[(/*BODY_VEL*/7) + 2] += (cx4 * j * b4[(/*BODY_IINERTIA*/1)]);

        return false;
    },

    _iteratePos : function _iteratePosFn()
    {
        this._posError();
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;
        var b3 = this.bodyC._data;
        var b4 = this.bodyD._data;

        var im1 = b1[(/*BODY_IMASS*/0)];
        var im2 = b2[(/*BODY_IMASS*/0)];
        var im3 = b3[(/*BODY_IMASS*/0)];
        var im4 = b4[(/*BODY_IMASS*/0)];
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];
        var ii3 = b3[(/*BODY_IINERTIA*/1)];
        var ii4 = b4[(/*BODY_IINERTIA*/1)];

        var err = data[(/*PULLEY_BIAS*/28)];
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];

        if (this._breakUnderError && (err > maxError || err < -maxError))
        {
            return true;
        }

        var slop = Physics2DConfig.PULLEY_SLOP_SQ;
        if ((err * err) < slop)
        {
            return false;
        }

        err *= Physics2DConfig.PULLEY_BIAS_COEF;

        var ratioSq = data[(/*PULLEY_RATIO*/7)];
        ratioSq *= ratioSq;

        var K = (im1 + im2 + (ratioSq * (im3 + im4)));
        var n12x = data[(/*PULLEY_N12*/29)];
        var n12y = data[(/*PULLEY_N12*/29) + 1];
        var n34x = data[(/*PULLEY_N34*/31)];
        var n34y = data[(/*PULLEY_N34*/31) + 1];
        if (b2 === b3)
        {
            K -= 2 * ((n12x * n34x) + (n12y * n34y)) * im2;
        }

        var j, jx, jy;
        // Handle large error seperately.
        if ((err * err) > Physics2DConfig.PULLEY_LARGE_ERROR_SQ)
        {
            if (K > Physics2DConfig.EFF_MASS_EPSILON)
            {
                j = (err * Physics2DConfig.PULLEY_LARGE_ERROR_BIAS / K);
                if (this._equal || j < 0)
                {
                    jx = (n12x * j);
                    jy = (n12y * j);
                    b1[(/*BODY_POS*/2)]     -= (jx * im1);
                    b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
                    b2[(/*BODY_POS*/2)]     += (jx * im2);
                    b2[(/*BODY_POS*/2) + 1] += (jy * im2);

                    jx = (n34x * j);
                    jy = (n34y * j);
                    b3[(/*BODY_POS*/2)]     -= (jx * im3);
                    b3[(/*BODY_POS*/2) + 1] -= (jy * im3);
                    b4[(/*BODY_POS*/2)]     += (jx * im4);
                    b4[(/*BODY_POS*/2) + 1] += (jy * im4);

                    // Recalculate error.
                    this._posError();
                    n12x = data[(/*PULLEY_N12*/29)];
                    n12y = data[(/*PULLEY_N12*/29) + 1];
                    n34x = data[(/*PULLEY_N34*/31)];
                    n34y = data[(/*PULLEY_N34*/31) + 1];
                    err = data[(/*PULLEY_BIAS*/28)] * Physics2DConfig.PULLEY_BIAS_COEF;
                }
            }
        }

        var cx1 = ((data[(/*PULLEY_RANCHOR1*/19)] * n12y) - (data[(/*PULLEY_RANCHOR1*/19) + 1] * n12x));
        var cx2 = ((data[(/*PULLEY_RANCHOR2*/21)] * n12y) - (data[(/*PULLEY_RANCHOR2*/21) + 1] * n12x));
        var cx3 = ((data[(/*PULLEY_RANCHOR3*/23)] * n34y) - (data[(/*PULLEY_RANCHOR3*/23) + 1] * n34x));
        var cx4 = ((data[(/*PULLEY_RANCHOR4*/25)] * n34y) - (data[(/*PULLEY_RANCHOR4*/25) + 1] * n34x));
        K += ((cx1 * ii1 * cx1) + (cx2 * ii2 * cx2) + (cx3 * ii3 * cx3) + (cx4 * ii4 * cx4));
        if (b2 === b2)
        {
            K -= (2 * cx2 * ii2 * cx3);
        }

        data[(/*PULLEY_KMASS*/8)] = K;
        data[(/*PULLEY_BIAS*/28)] = err;
        Physics2DConstraint.prototype.safe_solve(data, (/*PULLEY_KMASS*/8), (/*PULLEY_BIAS*/28), (/*PULLEY_BIAS*/28));
        j = data[(/*PULLEY_BIAS*/28)];

        if (this._equal || j < 0)
        {
            var dr;
            jx = (n12x * j);
            jy = (n12y * j);
            b1[(/*BODY_POS*/2)]     -= (jx * im1);
            b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
            dr = (-cx1 * j * ii1);
            if (dr !== 0)
            {
                this.bodyA._deltaRotation(dr);
            }

            b2[(/*BODY_POS*/2)]     += (jx * im2);
            b2[(/*BODY_POS*/2) + 1] += (jy * im2);
            dr = (cx2 * j * ii2);
            if (dr !== 0)
            {
                this.bodyB._deltaRotation(dr);
            }

            jx = (n34x * j);
            jy = (n34y * j);
            b3[(/*BODY_POS*/2)]     -= (jx * im3);
            b3[(/*BODY_POS*/2) + 1] -= (jy * im3);
            dr = (-cx3 * j * ii3);
            if (dr !== 0)
            {
                this.bodyC._deltaRotation(dr);
            }

            b4[(/*BODY_POS*/2)]     += (jx * im4);
            b4[(/*BODY_POS*/2) + 1] += (jy * im4);
            dr = (cx4 * j * ii4);
            if (dr !== 0)
            {
                this.bodyD._deltaRotation(dr);
            }
        }

        return false;
    }
};


// params = {
//   bodyA, bodyB, bodyC, bodyD // bodyB permitted equal to bodyC
//   anchorA, anchorB, anchorC, anchorD
//   lowerBound, upperBound, ratio
//   .. common constraint params
// }
Physics2DPulleyConstraint.create = function pulleyConstraintFn(params)
{
    var p = new Physics2DPulleyConstraint();
    p.dimension = 1;
    var data = p._data = new Physics2DDevice.prototype.floatArray((/*PULLEY_DATA_SIZE*/37));
    Physics2DConstraint.prototype.init(p, params);

    var anchor = params.anchorA;
    data[(/*PULLEY_LANCHOR1*/11)]     = (anchor ? anchor[0] : 0);
    data[(/*PULLEY_LANCHOR1*/11) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.anchorB;
    data[(/*PULLEY_LANCHOR2*/13)]     = (anchor ? anchor[0] : 0);
    data[(/*PULLEY_LANCHOR2*/13) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.anchorC;
    data[(/*PULLEY_LANCHOR3*/15)]     = (anchor ? anchor[0] : 0);
    data[(/*PULLEY_LANCHOR3*/15) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.anchorD;
    data[(/*PULLEY_LANCHOR4*/17)]     = (anchor ? anchor[0] : 0);
    data[(/*PULLEY_LANCHOR4*/17) + 1] = (anchor ? anchor[1] : 0);

    var min = data[(/*PULLEY_JOINTMIN*/5)] = (params.lowerBound !== undefined ? params.lowerBound : 0);
    var max = data[(/*PULLEY_JOINTMAX*/6)] = (params.upperBound !== undefined ? params.upperBound : 0);
    p._equal = (min === max);

    data[(/*PULLEY_RATIO*/7)] = (params.ratio !== undefined ? params.ratio : 1);

    p._slack = false;

    p.bodyA = params.bodyA;
    p.bodyB = params.bodyB;
    p.bodyC = params.bodyC;
    p.bodyD = params.bodyD;

    // Seed normal incase initial anchors are degenerate.
    data[(/*PULLEY_N12*/29)]     = 1;
    data[(/*PULLEY_N12*/29) + 1] = 0;
    data[(/*PULLEY_N34*/31)]     = 1;
    data[(/*PULLEY_N34*/31) + 1] = 0;

    return p;
};


// =========================================================================
//
// Motor Constraint
//

// MOTOR DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*MOTOR_RATE*/5   // Motor rate
///*MOTOR_RATIO*/6  // Motor ratio
///*MOTOR_KMASS*/7  // Effective mass (scalar)
///*MOTOR_JACC*/8   // Accumulated impulse (scalar)
///*MOTOR_JMAX*/9   // Maximum impulse (maxForce derived)
//
///*MOTOR_DATA_SIZE*/10

function Physics2DMotorConstraint() {}
Physics2DMotorConstraint.prototype = {

    type : "MOTOR",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    getRate : function getRateFn()
    {
        return this._data[(/*MOTOR_RATE*/5)];
    },
    getRatio : function getRatioFn()
    {
        return this._data[(/*MOTOR_RATIO*/6)];
    },

    setRate : function setRateFn(rate)
    {
        var data = this._data;
        if (data[(/*MOTOR_RATE*/5)] !== rate)
        {
            data[(/*MOTOR_RATE*/5)] = rate;
            this.wake(true);
        }
    },
    setRatio : function setRatioFn(ratio)
    {
        var data = this._data;
        if (data[(/*MOTOR_RATIO*/6)] !== ratio)
        {
            data[(/*MOTOR_RATIO*/6)] = ratio;
            this.wake(true);
        }
    },

    // =========================================================

    // Inherited
    _inWorld          : Physics2DConstraint.prototype.twoBodyInWorld,
    _outWorld         : Physics2DConstraint.prototype.twoBodyOutWorld,
    _pairExists       : Physics2DConstraint.prototype.twoBodyPairExists,
    _wakeConnected    : Physics2DConstraint.prototype.twoBodyWakeConnected,
    _sleepComputation : Physics2DConstraint.prototype.twoBodySleepComputation,

    // ==========================================================

    // Inherited
    _JACC : (/*MOTOR_JACC*/8),
    _clearCache : Physics2DConstraint.prototype.clearCache,

    _preStep : function _preStepFn(deltaTime)
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        // Compute non-inverted effective mass
        var ratio = data[(/*MOTOR_RATIO*/6)];
        data[(/*MOTOR_KMASS*/7)] = (b1[(/*BODY_IINERTIA*/1)] + (ratio * ratio * b2[(/*BODY_IINERTIA*/1)]));

        // Invert eff-mass matrix
        Physics2DConstraint.prototype.safe_invert(data, (/*MOTOR_KMASS*/7), (/*MOTOR_JACC*/8));

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        data[(/*MOTOR_JACC*/8)] *= dtRatio;
        data[(/*MOTOR_JMAX*/9)] = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var j = data[(/*MOTOR_JACC*/8)];
        b1[(/*BODY_VEL*/7) + 2] -= (j * b1[(/*BODY_IINERTIA*/1)]);
        b2[(/*BODY_VEL*/7) + 2] += (data[(/*MOTOR_RATIO*/6)] * j * b2[(/*BODY_IINERTIA*/1)]);
    },

    getImpulseForBody : function getImpulseForBodyFn(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var data = this._data;

        dst[0] = dst[1] = 0;
        dst[2] = (body === this.bodyA ? -1 : (body === this.bodyB ? data[(/*MOTOR_RATIO*/6)] : 0)) * data[(/*MOTOR_JACC*/8)];
        return dst;
    },

    _iterateVel : function _iterateVelFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var ratio = data[(/*MOTOR_RATIO*/6)];
        var j = (data[(/*MOTOR_KMASS*/7)] * (data[(/*MOTOR_RATE*/5)] + b1[(/*BODY_VEL*/7) + 2] -
                                             (ratio * b2[(/*BODY_VEL*/7) + 2])));
        var jOld = data[(/*MOTOR_JACC*/8)];
        var jAcc = (jOld + j);
        var jMax = data[(/*MOTOR_JMAX*/9)];
        if (this._breakUnderForce && (jAcc > jMax || jAcc < -jMax))
        {
            return true;
        }
        else
        {
            if (jAcc > jMax)
            {
                jAcc = jMax;
            }
            else if (jAcc < -jMax)
            {
                jAcc = -jMax;
            }
        }

        j = (jAcc - jOld);
        data[(/*MOTOR_JACC*/8)] = jAcc;

        b1[(/*BODY_VEL*/7) + 2] -= (j * b1[(/*BODY_IINERTIA*/1)]);
        b2[(/*BODY_VEL*/7) + 2] += (ratio * j * b2[(/*BODY_IINERTIA*/1)]);

        return false;
    },

    // Velocity only constraint.
    _iteratePos : function _iteratePosFn()
    {
        return false;
    }

};

Physics2DMotorConstraint.create = function motorConstraintFn(params)
{
    var p = new Physics2DMotorConstraint();
    p.dimension = 1;
    var data = p._data = new Physics2DDevice.prototype.floatArray((/*MOTOR_DATA_SIZE*/10));
    Physics2DConstraint.prototype.init(p, params);

    data[(/*MOTOR_RATE*/5)]  = (params.rate  !== undefined ? params.rate  : 0);
    data[(/*MOTOR_RATIO*/6)] = (params.ratio !== undefined ? params.ratio : 1);

    p.bodyA = params.bodyA;
    p.bodyB = params.bodyB;

    return p;
};


// =========================================================================
//
// Line Constraint
//

// LINE DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*LINE_JOINTMIN*/5   // Joint limits (axial)
///*LINE_JOINTMAX*/6   //
///*LINE_LANCHOR1*/7   // Local anchor on bodyA (x, y)
///*LINE_LANCHOR2*/9   // Local anchor on bodyB (x, y)
///*LINE_LAXIS*/11     // Local axis on bodyA (x, y)
///*LINE_RANCHOR1*/13  // Relative anchor on bodyA (x, y)
///*LINE_RANCHOR2*/15  // Relative anchor on bodyB (x, y)
///*LINE_RAXIS*/17     // Relative/World axis on bodyA (x, y)
///*LINE_KMASS*/19     // Effective mass [a b; b c] (symmetric)
///*LINE_JACC*/22      // Accumulated impuse (x, y)
///*LINE_JMAX*/24      // Maximum impulse magnitude
///*LINE_GAMMA*/25     // Soft constraint gamma
///*LINE_BIAS*/26      // Soft constraint bias (x, y)
///*LINE_CX1*/28
///*LINE_CX2*/29
///*LINE_DOT1*/30
///*LINE_DOT2*/31
///*LINE_SCALE*/32     // Direction scaling of axis.
//
///*LINE_DATA_SIZE*/33

function Physics2DLineConstraint() {}
Physics2DLineConstraint.prototype = {

    type : "LINE",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    getLowerBound : function getLowerBound()
    {
        return this._data[(/*LINE_JOINTMIN*/5)];
    },
    getUpperBound : function getUpperBound()
    {
        return this._data[(/*LINE_JOINTMAX*/6)];
    },

    setLowerBound : function setLowerBoundFn(lowerBound)
    {
        var data = this._data;
        if (data[(/*LINE_JOINTMIN*/5)] !== lowerBound)
        {
            data[(/*LINE_JOINTMIN*/5)] = lowerBound;
            this._equal = (lowerBound === data[(/*LINE_JOINTMAX*/6)]);
            this.wake(true);
        }
    },
    setUpperBound : function setUpperBoundFn(upperBound)
    {
        var data = this._data;
        if (data[(/*LINE_JOINTMAX*/6)] !== upperBound)
        {
            data[(/*LINE_JOINTMAX*/6)] = upperBound;
            this._equal = (upperBound === data[(/*LINE_JOINTMIN*/5)]);
            this.wake(true);
        }
    },

    // Inherited
    _ANCHOR_A : (/*LINE_LANCHOR1*/7),
    getAnchorA : Physics2DConstraint.prototype.getAnchorA,
    setAnchorA : Physics2DConstraint.prototype.setAnchorA,

    _ANCHOR_B : (/*LINE_LANCHOR2*/9),
    getAnchorB : Physics2DConstraint.prototype.getAnchorB,
    setAnchorB : Physics2DConstraint.prototype.setAnchorB,

    getAxis : function getAxisFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        dst[0] = data[(/*LINE_LAXIS*/11)];
        dst[1] = data[(/*LINE_LAXIS*/11) + 1];
        return dst;
    },
    setAxis : function setAxisFn(axis)
    {
        var data = this._data;
        var newX = axis[0];
        var newY = axis[1];
        if (newX !== data[(/*LINE_LAXIS*/11)] || newY !== data[(/*LINE_LAXIS*/11) + 1])
        {
            var nlsq = ((newX * newX) + (newY * newY));
            if (nlsq === 0)
            {
                return;
            }
            else
            {
                nlsq = (1 / Math.sqrt(nlsq));
                newX *= nlsq;
                newY *= nlsq;
            }
            data[(/*LINE_LAXIS*/11)]     = newX;
            data[(/*LINE_LAXIS*/11) + 1] = newY;
            this.wake(true);
        }
    },

    // =========================================================

    // Inherited
    _inWorld          : Physics2DConstraint.prototype.twoBodyInWorld,
    _outWorld         : Physics2DConstraint.prototype.twoBodyOutWorld,
    _pairExists       : Physics2DConstraint.prototype.twoBodyPairExists,
    _wakeConnected    : Physics2DConstraint.prototype.twoBodyWakeConnected,
    _sleepComputation : Physics2DConstraint.prototype.twoBodySleepComputation,

    // ==========================================================

    // Inherited
    _JACC : (/*LINE_JACC*/22),
    _clearCache : Physics2DConstraint.prototype.clearCache2,

    _posError : function _posErrorFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*LINE_LANCHOR1*/7), (/*LINE_RANCHOR1*/13));
        Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*LINE_LANCHOR2*/9), (/*LINE_RANCHOR2*/15));
        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*LINE_LAXIS*/11), (/*LINE_RAXIS*/17));

        var jointMin = data[(/*LINE_JOINTMIN*/5)];
        var jointMax = data[(/*LINE_JOINTMAX*/6)];

        var rx1 = data[(/*LINE_RANCHOR1*/13)];
        var ry1 = data[(/*LINE_RANCHOR1*/13) + 1];
        var rx2 = data[(/*LINE_RANCHOR2*/15)];
        var ry2 = data[(/*LINE_RANCHOR2*/15) + 1];
        var nx  = data[(/*LINE_RAXIS*/17)];
        var ny  = data[(/*LINE_RAXIS*/17) + 1];

        // Store (dx, dy) in (cx1, cx2) temporarigly.
        // As this information is needed in subsequent calculations for eff-mass.
        // We take care not to alias values!
        var dx = data[(/*LINE_CX1*/28)] = ((b2[(/*BODY_POS*/2)]     + rx2) - (b1[(/*BODY_POS*/2)]     + rx1));
        var dy = data[(/*LINE_CX2*/29)] = ((b2[(/*BODY_POS*/2) + 1] + ry2) - (b1[(/*BODY_POS*/2) + 1] + ry1));

        var errX = ((nx * dy) - (ny * dx));
        var errY = ((nx * dx) + (ny * dy));
        if (this._equal)
        {
            errY -= jointMin;
            data[(/*LINE_SCALE*/32)] = 1.0;
        }
        else
        {
            if (errY > jointMax)
            {
                errY -= jointMax;
                data[(/*LINE_SCALE*/32)] = 1.0;
            }
            else if (errY < jointMin)
            {
                errY = (jointMin - errY);
                data[(/*LINE_SCALE*/32)] = -1.0;
            }
            else
            {
                errY = 0;
                data[(/*LINE_SCALE*/32)] = 0.0;
            }
        }

        data[(/*LINE_BIAS*/26)]     = (-errX);
        data[(/*LINE_BIAS*/26) + 1] = (-errY);
    },

    _preStep : function _preStepFn(deltaTime)
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        // Must compute (dx, dy) (stored into cx1/cx2)
        // As well as scale for eff-mass computation.
        this._posError();

        // Compute non-inverted effective mass.
        var rx1 = data[(/*LINE_RANCHOR1*/13)];
        var ry1 = data[(/*LINE_RANCHOR1*/13) + 1];
        var rx2 = data[(/*LINE_RANCHOR2*/15)];
        var ry2 = data[(/*LINE_RANCHOR2*/15) + 1];
        var nx  = data[(/*LINE_RAXIS*/17)];
        var ny  = data[(/*LINE_RAXIS*/17) + 1];
        var scale = data[(/*LINE_SCALE*/32)];
        var delX = (data[(/*LINE_CX1*/28)] + rx1);
        var delY = (data[(/*LINE_CX2*/29)] + ry1);

        var cx1  = data[(/*LINE_CX1*/28)]  = (nx * delY) - (ny * delX);
        var cx2  = data[(/*LINE_CX2*/29)]  = (nx * ry2)  - (ny * rx2);
        var dot1 = data[(/*LINE_DOT1*/30)] = (nx * delX) + (ny * delY);
        var dot2 = data[(/*LINE_DOT2*/31)] = (nx * rx2)  + (ny * ry2);

        var massSum = (b1[(/*BODY_IMASS*/0)] + b2[(/*BODY_IMASS*/0)]);
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];

        data[(/*LINE_KMASS*/19)]     = massSum + (dot1 * ii1 * dot1) + (dot2 * ii2 * dot2);
        data[(/*LINE_KMASS*/19) + 1] = -scale * ((dot1 * ii1 * cx1) + (dot2 * ii2 * cx2));
        data[(/*LINE_KMASS*/19) + 2] = scale * scale * (massSum + (cx1 * ii1 * cx1) + (cx2 * ii2 * cx2));

        // Invert effective mass.
        Physics2DConstraint.prototype.safe_invert2(data, (/*LINE_KMASS*/19), (/*LINE_JACC*/22));

        if (!this._stiff)
        {
            if (Physics2DConstraint.prototype.soft_params2(data, (/*LINE_KMASS*/19), (/*LINE_GAMMA*/25), (/*LINE_BIAS*/26), deltaTime, this._breakUnderError))
            {
                return true;
            }
        }
        else
        {
            data[(/*LINE_GAMMA*/25)]    = 0;
            data[(/*LINE_BIAS*/26)]     = 0;
            data[(/*LINE_BIAS*/26) + 1] = 0;
        }

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        data[(/*LINE_JACC*/22)]     *= dtRatio;
        data[(/*LINE_JACC*/22) + 1] *= dtRatio;
        data[(/*LINE_JMAX*/24)]     = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var jx    = data[(/*LINE_JACC*/22)];
        var jy    = data[(/*LINE_JACC*/22) + 1];
        var scale = data[(/*LINE_SCALE*/32)];
        var nx    = data[(/*LINE_RAXIS*/17)];
        var ny    = data[(/*LINE_RAXIS*/17) + 1];

        var lx = (scale * nx * jy) - (ny * jx);
        var ly = (nx * jx) + (scale * ny * jy);

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (lx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (ly * im);
        b1[(/*BODY_VEL*/7) + 2] += (((scale * data[(/*LINE_CX1*/28)] * jy) -
                                     (data[(/*LINE_DOT1*/30)] * jx)) *
                                    b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (lx * im);
        b2[(/*BODY_VEL*/7) + 1] += (ly * im);
        b2[(/*BODY_VEL*/7) + 2] += (((data[(/*LINE_DOT2*/31)] * jx) -
                                     (scale * data[(/*LINE_CX2*/29)] * jy)) *
                                   b2[(/*BODY_IINERTIA*/1)]);
    },

    getImpulseForBody : function getImpulseForBodyFn(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var data = this._data;
        var jx    = data[(/*LINE_JACC*/22)];
        var jy    = data[(/*LINE_JACC*/22) + 1];
        var scale = data[(/*LINE_SCALE*/32)];
        var nx    = data[(/*LINE_RAXIS*/17)];
        var ny    = data[(/*LINE_RAXIS*/17) + 1];

        var lx = (scale * nx * jy) - (ny * jx);
        var ly = (nx * jx) + (scale * ny * jy);

        if (body === this.bodyA)
        {
            dst[0] = -lx;
            dst[1] = -ly;
            dst[2] = ((scale * data[(/*LINE_CX1*/28)] * jy) -
                      (data[(/*LINE_DOT1*/30)] * jx));
        }
        else if (body === this.bodyB)
        {
            dst[0] = lx;
            dst[1] = ly;
            dst[2] = ((data[(/*LINE_DOT2*/31)] * jx) -
                      (scale * data[(/*LINE_CX2*/29)] * jy));
        }
        else
        {
            dst[0] = dst[1] = dst[2] = 0;
        }

        return dst;
    },

    _iterateVel : function _iterateVelFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        // (x, y) = Bias - VelocityError
        var scale = data[(/*LINE_SCALE*/32)];
        var nx    = data[(/*LINE_RAXIS*/17)];
        var ny    = data[(/*LINE_RAXIS*/17) + 1];
        var cx1   = data[(/*LINE_CX1*/28)];
        var cx2   = data[(/*LINE_CX2*/29)];
        var dot1  = data[(/*LINE_DOT1*/30)];
        var dot2  = data[(/*LINE_DOT2*/31)];

        var vx = (b2[(/*BODY_VEL*/7)]     - b1[(/*BODY_VEL*/7)]);
        var vy = (b2[(/*BODY_VEL*/7) + 1] - b1[(/*BODY_VEL*/7) + 1]);
        var vw1 = b1[(/*BODY_VEL*/7) + 2];
        var vw2 = b2[(/*BODY_VEL*/7) + 2];
        var x = (data[(/*LINE_BIAS*/26)]     - ((nx * vy) - (ny * vx) + (vw2 * dot2) - (vw1 * dot1)));
        var y = (data[(/*LINE_BIAS*/26) + 1] - (scale * ((nx * vx) + (ny * vy) - (vw2 * cx2) + (vw1 * cx1))));

        var jOldX = data[(/*LINE_JACC*/22)];
        var jOldY = data[(/*LINE_JACC*/22) + 1];
        var gamma = data[(/*LINE_GAMMA*/25)];
        // Impulse.
        // (jx, jy) = K * (x, y) - Jacc * gamma
        var Kb = data[(/*LINE_KMASS*/19) + 1];
        var jx = ((data[(/*LINE_KMASS*/19)] * x)     + (Kb * y)) - (jOldX * gamma);
        var jy = ((Kb * x) + (data[(/*LINE_KMASS*/19) + 2] * y)) - (jOldY * gamma);

        // Accumulate and clamp
        var jAccX = (jOldX + jx);
        var jAccY = (jOldY + jy);
        if (!this._equal && jAccY > 0)
        {
            jAccY = 0;
        }

        var jlsq = ((jAccX * jAccX) + (jAccY * jAccY));
        var jMax = data[(/*LINE_JMAX*/24)];
        if (this._breakUnderForce)
        {
            if (jlsq > (jMax * jMax))
            {
                return true;
            }
        }
        else if (!this._stiff)
        {
            if (jlsq > (jMax * jMax))
            {
                jlsq = (jMax / Math.sqrt(jlsq));
                jAccX *= jlsq;
                jAccY *= jlsq;
            }
        }

        jx = (jAccX - jOldX);
        jy = (jAccY - jOldY);
        data[(/*LINE_JACC*/22)]     = jAccX;
        data[(/*LINE_JACC*/22) + 1] = jAccY;

        // Apply impulse.
        var lx = (scale * nx * jy) - (ny * jx);
        var ly = (nx * jx) + (scale * ny * jy);

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (lx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (ly * im);
        b1[(/*BODY_VEL*/7) + 2] += (((scale * cx1 * jy) - (dot1 * jx)) * b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (lx * im);
        b2[(/*BODY_VEL*/7) + 1] += (ly * im);
        b2[(/*BODY_VEL*/7) + 2] += (((dot2 * jx) - (scale * cx2 * jy)) * b2[(/*BODY_IINERTIA*/1)]);

        return false;
    },

    _iteratePos : function _iteratePosFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        this._posError();
        var errX = data[(/*LINE_BIAS*/26)];
        var errY = data[(/*LINE_BIAS*/26) + 1];
        var elsq = ((errX * errX) + (errY * errY));

        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (this._breakUnderError && elsq > (maxError * maxError))
        {
            return true;
        }

        var slop = Physics2DConfig.LINE_SLOP_SQ;
        if (elsq < slop)
        {
            return false;
        }

        var bias = Physics2DConfig.LINE_BIAS_COEF;
        errX *= bias;
        errY *= bias;
        elsq *= (bias * bias);

        var im1 = b1[(/*BODY_MASS*/0)];
        var im2 = b2[(/*BODY_MASS*/0)];
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];
        var massSum = (im1 + im2);

        var nx = data[(/*LINE_RAXIS*/17)];
        var ny = data[(/*LINE_RAXIS*/17) + 1];
        var scale = data[(/*LINE_SCALE*/32)];

        var lx, ly;

        // Solve large error case seperately.
        if (elsq > Physics2DConfig.LINE_LARGE_ERROR_SQ)
        {
            if (massSum > Physics2DConfig.EFF_MASS_EPSILON)
            {
                var K = (Physics2DConfig.LINE_LARGE_ERROR_BIAS / massSum);
                lx = K * ((ny * errX) - (scale * nx * errY));
                ly = K * ((nx * errX * scale) - (ny * errX));

                b1[(/*BODY_POS*/2)]     -= (lx * im1);
                b1[(/*BODY_POS*/2) + 1] -= (ly * im1);
                b2[(/*BODY_POS*/2)]     += (lx * im2);
                b2[(/*BODY_POS*/2) + 1] += (ly * im2);

                this._posError();
                nx = data[(/*LINE_RAXIS*/17)];
                ny = data[(/*LINE_RAXIS*/17) + 1];
                scale = data[(/*LINE_SCALE*/32)];

                errX = (data[(/*LINE_BIAS*/26)]     * bias);
                errY = (data[(/*LINE_BIAS*/26) + 1] * bias);
            }
        }

        // Compute non-inverted effective mass.
        var rx1 = data[(/*LINE_RANCHOR1*/13)];
        var ry1 = data[(/*LINE_RANCHOR1*/13) + 1];
        var rx2 = data[(/*LINE_RANCHOR2*/15)];
        var ry2 = data[(/*LINE_RANCHOR2*/15) + 1];
        var delX = (data[(/*LINE_CX1*/28)] + rx1);
        var delY = (data[(/*LINE_CX2*/29)] + ry1);

        var cx1  = (nx * delY) - (ny * delX);
        var cx2  = (nx * ry2)  - (ny * rx2);
        var dot1 = (nx * delX) + (ny * delY);
        var dot2 = (nx * rx2)  + (ny * ry2);

        data[(/*LINE_KMASS*/19)]     = massSum + (dot1 * ii1 * dot1) + (dot2 * ii2 * dot2);
        data[(/*LINE_KMASS*/19) + 1] = -scale * ((dot1 * ii1 * cx1) + (dot2 * ii2 * cx2));
        data[(/*LINE_KMASS*/19) + 2] = scale * scale * (massSum + (cx1 * ii1 * cx1) + (cx2 * ii2 * cx2));

        data[(/*LINE_BIAS*/26)]     = errX;
        data[(/*LINE_BIAS*/26) + 1] = errY;
        Physics2DConstraint.prototype.safe_solve2(data, (/*LINE_KMASS*/19), (/*LINE_BIAS*/26), (/*LINE_BIAS*/26));
        var jx = data[(/*LINE_BIAS*/26)];
        var jy = data[(/*LINE_BIAS*/26) + 1];

        if (!this._equal && jy > 0)
        {
            jy = 0;
        }

        lx = (scale * nx * jy) - (ny * jx);
        ly = (nx * jx) + (scale * ny * jy);

        b1[(/*BODY_POS*/2)]     -= (lx * im1);
        b1[(/*BODY_POS*/2) + 1] -= (ly * im1);
        var dr = (((scale * cx1 * jy) - (dot1 * jx)) * ii1);
        if (dr !== 0)
        {
            this.bodyA._deltaRotation(dr);
        }

        b2[(/*BODY_POS*/2)]     += (lx * im2);
        b2[(/*BODY_POS*/2) + 1] += (ly * im2);
        dr = (((dot2 * jx) - (scale * cx2 * jy)) * ii2);
        if (dr !== 0)
        {
            this.bodyB._deltaRotation(dr);
        }

        return false;
    }
};


// params = {
//   bodyA, bodyB
//   anchorA, anchorB, axis
//   lowerBound, upperBound
//   .. common constraint params
// }
Physics2DLineConstraint.create = function lineConstraintFn(params)
{
    var p = new Physics2DLineConstraint();
    p.dimension = 2;
    var data = p._data = new Physics2DDevice.prototype.floatArray((/*LINE_DATA_SIZE*/33));
    Physics2DConstraint.prototype.init(p, params);

    var anchor = params.anchorA;
    data[(/*LINE_LANCHOR1*/7)]     = (anchor ? anchor[0] : 0);
    data[(/*LINE_LANCHOR1*/7) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.anchorB;
    data[(/*LINE_LANCHOR2*/9)]     = (anchor ? anchor[0] : 0);
    data[(/*LINE_LANCHOR2*/9) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.axis;
    data[(/*LINE_LAXIS*/11)]     = anchor[0];
    data[(/*LINE_LAXIS*/11) + 1] = anchor[1];

    var min = data[(/*LINE_JOINTMIN*/5)] = (params.lowerBound !== undefined ? params.lowerBound : Number.NEGATIVE_INFINITY);
    var max = data[(/*LINE_JOINTMAX*/6)] = (params.upperBound !== undefined ? params.upperBound : Number.POSITIVE_INFINITY);
    p._equal = (min === max);

    p.bodyA = params.bodyA;
    p.bodyB = params.bodyB;

    return p;
};


// =========================================================================
//
// Distance Constraint
//

// DIST DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*DIST_JOINTMIN*/5   // Joint limits
///*DIST_JOINTMAX*/6   //
///*DIST_LANCHOR1*/7   // Local anchor on bodyA (x, y)
///*DIST_LANCHOR2*/9   // Local anchor on bodyB (x, y)
///*DIST_RANCHOR1*/11  // Relative anchor on bodyA (x, y)
///*DIST_RANCHOR2*/13  // Relative anchor on bodyB (x, y)
///*DIST_KMASS*/15     // Effective mass matrix (scalar)
///*DIST_JACC*/16      // Accumulated impulse
///*DIST_JMAX*/17      // Maximum impulse (maxForce derived)
///*DIST_GAMMA*/18     // Soft constraint gamma
///*DIST_BIAS*/19      // Bias for soft constraint (scalar)
///*DIST_NORMAL*/20    // Direction of constraint error (x, y)
///*DIST_CX1*/22       // (RANCHOR1 cross NORMAL)
///*DIST_CX2*/23       // (RANCHOR2 cross NORMAL)
//
///*DIST_DATA_SIZE*/24

function Physics2DDistanceConstraint() {}
Physics2DDistanceConstraint.prototype = {

    type : "DISTANCE",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    getLowerBound : function getLowerBound()
    {
        return this._data[(/*DIST_JOINTMIN*/5)];
    },
    getUpperBound : function getUpperBound()
    {
        return this._data[(/*DIST_JOINTMAX*/6)];
    },

    setLowerBound : function setLowerBoundFn(lowerBound)
    {
        var data = this._data;
        if (data[(/*DIST_JOINTMIN*/5)] !== lowerBound)
        {
            data[(/*DIST_JOINTMIN*/5)] = lowerBound;
            this._equal = (lowerBound === data[(/*DIST_JOINTMAX*/6)]);
            this.wake(true);
        }
    },
    setUpperBound : function setUpperBoundFn(upperBound)
    {
        var data = this._data;
        if (data[(/*DIST_JOINTMAX*/6)] !== upperBound)
        {
            data[(/*DIST_JOINTMAX*/6)] = upperBound;
            this._equal = (upperBound === data[(/*DIST_JOINTMIN*/5)]);
            this.wake(true);
        }
    },

    // Inherited
    _ANCHOR_A : (/*DIST_LANCHOR1*/7),
    getAnchorA : Physics2DConstraint.prototype.getAnchorA,
    setAnchorA : Physics2DConstraint.prototype.setAnchorA,

    _ANCHOR_B : (/*DIST_LANCHOR2*/9),
    getAnchorB : Physics2DConstraint.prototype.getAnchorB,
    setAnchorB : Physics2DConstraint.prototype.setAnchorB,

    // =========================================================

    // Inherited
    _inWorld          : Physics2DConstraint.prototype.twoBodyInWorld,
    _outWorld         : Physics2DConstraint.prototype.twoBodyOutWorld,
    _pairExists       : Physics2DConstraint.prototype.twoBodyPairExists,
    _wakeConnected    : Physics2DConstraint.prototype.twoBodyWakeConnected,
    _sleepComputation : Physics2DConstraint.prototype.twoBodySleepComputation,

    // =======================================================

    // Inherited
    _JACC : (/*DIST_JACC*/16),
    _clearCache : Physics2DConstraint.prototype.clearCache,

    _posError : function _posErrorFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var jointMin = data[(/*DIST_JOINTMIN*/5)];
        var jointMax = data[(/*DIST_JOINTMAX*/6)];

        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*DIST_LANCHOR1*/7), (/*DIST_RANCHOR1*/11));
        Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*DIST_LANCHOR2*/9), (/*DIST_RANCHOR2*/13));

        var nx = ((b2[(/*BODY_POS*/2)]     + data[(/*DIST_RANCHOR2*/13)])     -
                  (b1[(/*BODY_POS*/2)]     + data[(/*DIST_RANCHOR1*/11)]));
        var ny = ((b2[(/*BODY_POS*/2) + 1] + data[(/*DIST_RANCHOR2*/13) + 1]) -
                  (b1[(/*BODY_POS*/2) + 1] + data[(/*DIST_RANCHOR1*/11) + 1]));

        var err = ((nx * nx) + (ny * ny));
        if (err < Physics2DConfig.NORMALIZE_SQ_EPSILON)
        {
            nx = data[(/*DIST_NORMAL*/20)];
            ny = data[(/*DIST_NORMAL*/20) + 1];
            err = 0;
        }
        else
        {
            err = Math.sqrt(err);
            var rec = (1 / err);
            nx *= rec;
            ny *= rec;
        }

        if (this._equal)
        {
            err -= jointMin;
            this._slack = false;
        }
        else if (err < jointMin)
        {
            err = (jointMin - err);
            nx = -nx;
            ny = -ny;
            this._slack = false;
        }
        else if (err > jointMax)
        {
            err -= jointMax;
            this._slack = false;
        }
        else
        {
            // Don't set normals to 0.
            // In this case that _slack is true, we do no further work
            // So we permit normals to persist so that should constraint
            // become degenerate we can still choose a 'good' direction.
            //
            // Constraint only becomes degenerate when jointMin = 0 and we reach this
            // limit. In this condition we want negated normals, so that's what we
            // allow to persist.
            nx = -nx;
            ny = -ny;

            err = 0;
            this._slack = true;
        }

        data[(/*DIST_NORMAL*/20)]     = nx;
        data[(/*DIST_NORMAL*/20) + 1] = ny;
        data[(/*DIST_BIAS*/19)]       = (-err);
    },

    _preStep : function _preStepFn(deltaTime)
    {
        this._posError();
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        // Compute non-inverted effective mass.
        var nx = data[(/*DIST_NORMAL*/20)];
        var ny = data[(/*DIST_NORMAL*/20) + 1];
        var cx1 = data[(/*DIST_CX1*/22)] = ((data[(/*DIST_RANCHOR1*/11)] * ny) - (data[(/*DIST_RANCHOR1*/11) + 1] * nx));
        var cx2 = data[(/*DIST_CX2*/23)] = ((data[(/*DIST_RANCHOR2*/13)] * ny) - (data[(/*DIST_RANCHOR2*/13) + 1] * nx));
        data[(/*DIST_KMASS*/15)] = (b1[(/*BODY_IMASS*/0)] + (cx1 * b1[(/*BODY_IINERTIA*/1)] * cx1) +
                                    b2[(/*BODY_IMASS*/0)] + (cx2 * b2[(/*BODY_IINERTIA*/1)] * cx2));

        // Invert effective mass
        Physics2DConstraint.prototype.safe_invert(data, (/*DIST_KMASS*/15), (/*DIST_JACC*/16));

        if (!this._stiff)
        {
            if (Physics2DConstraint.prototype.soft_params(data, (/*DIST_KMASS*/15), (/*DIST_GAMMA*/18), (/*DIST_BIAS*/19), deltaTime, this._breakUnderError))
            {
                return true;
            }
        }
        else
        {
            data[(/*DIST_GAMMA*/18)] = 0.0;
            data[(/*DIST_BIAS*/19)]  = 0.0;
        }

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        data[(/*DIST_JACC*/16)] *= dtRatio;
        data[(/*DIST_JMAX*/17)] = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var jAcc = data[(/*DIST_JACC*/16)];
        var jx = (data[(/*DIST_NORMAL*/20)]     * jAcc);
        var jy = (data[(/*DIST_NORMAL*/20) + 1] * jAcc);

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (data[(/*DIST_CX1*/22)] * jAcc * b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (data[(/*DIST_CX2*/23)] * jAcc * b2[(/*BODY_IINERTIA*/1)]);
    },

    getImpulseForBody : function getImpulseForBodyFn(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var data = this._data;

        var jAcc = data[(/*DIST_JACC*/16)];
        var jx = (data[(/*DIST_NORMAL*/20)]     * jAcc);
        var jy = (data[(/*DIST_NORMAL*/20) + 1] * jAcc);

        if (body === this.bodyA)
        {
            dst[0] = -jx;
            dst[1] = -jy;
            dst[2] = -(data[(/*DIST_CX1*/22)] * jAcc);
        }
        else if (body === this.bodyB)
        {
            dst[0] = jx;
            dst[1] = jy;
            dst[2] = (data[(/*DIST_CX2*/23)] * jAcc);
        }
        else
        {
            dst[0] = dst[1] = dst[2] = 0;
        }

        return dst;
    },

    _iterateVel : function _iterateVelFn()
    {
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        // x = Bias - VelocityError
        var nx = data[(/*DIST_NORMAL*/20)];
        var ny = data[(/*DIST_NORMAL*/20) + 1];
        var cx1 = data[(/*DIST_CX1*/22)];
        var cx2 = data[(/*DIST_CX2*/23)];
        var x = (data[(/*DIST_BIAS*/19)] - ((nx * (b2[(/*BODY_VEL*/7)]     - b1[(/*BODY_VEL*/7)])) +
                                            (ny * (b2[(/*BODY_VEL*/7) + 1] - b1[(/*BODY_VEL*/7) + 1])) +
                                            (cx2 * b2[(/*BODY_VEL*/7) + 2]) -
                                            (cx1 * b1[(/*BODY_VEL*/7) + 2])));

        var jOld = data[(/*DIST_JACC*/16)];
        // Impulse.
        // j = K * x - Jacc * gamma
        var j = ((data[(/*DIST_KMASS*/15)] * x) - (jOld * data[(/*DIST_GAMMA*/18)]));

        // Accumulate and clamp.
        var jAcc = (jOld + j);
        var jMax = data[(/*DIST_JMAX*/17)];
        if (!this._equal && jAcc > 0)
        {
            jAcc = 0;
        }
        if (this._breakUnderForce)
        {
            if (jAcc > jMax || jAcc < -jMax)
            {
                return true;
            }
        }
        else if (!this._stiff)
        {
            if (jAcc > jMax)
            {
                jAcc = jMax;
            }
            else if (jAcc < -jMax)
            {
                jAcc = -jMax;
            }
        }

        j = (jAcc - jOld);
        data[(/*DIST_JACC*/16)] = jAcc;

        // Apply impulse.
        var jx = (nx * j);
        var jy = (ny * j);

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (data[(/*DIST_CX1*/22)] * j * b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (data[(/*DIST_CX2*/23)] * j * b2[(/*BODY_IINERTIA*/1)]);

        return false;
    },

    _iteratePos : function _iteratePosFn()
    {
        this._posError();
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var im1 = b1[(/*BODY_IMASS*/0)];
        var im2 = b2[(/*BODY_IMASS*/0)];
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];

        var err = data[(/*DIST_BIAS*/19)];
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (this._breakUnderError && (err > maxError || err < -maxError))
        {
            return true;
        }

        var slop = Physics2DConfig.DIST_SLOP_SQ;
        if ((err * err) < slop)
        {
            return false;
        }

        err *= Physics2DConfig.DIST_BIAS_COEF;

        var massSum = (im1 + im2);
        var nx = data[(/*DIST_NORMAL*/20)];
        var ny = data[(/*DIST_NORMAL*/20) + 1];

        var j, jx, jy;
        // Handle large error seperately
        if ((err * err) > Physics2DConfig.DIST_LARGE_ERROR_SQ)
        {
            if (massSum > Physics2DConfig.EFF_MASS_EPSILON)
            {
                j = (err * Physics2DConfig.DIST_LARGE_ERROR_BIAS / massSum);
                if (this._equal || j < 0)
                {
                    jx = (nx * j);
                    jy = (ny * j);
                    b1[(/*BODY_POS*/2)]     -= (jx * im1);
                    b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
                    b2[(/*BODY_POS*/2)]     += (jx * im2);
                    b2[(/*BODY_POS*/2) + 1] += (jy * im2);

                    // Recalculate error.
                    this._posError();
                    err = data[(/*DIST_BIAS*/19)] * Physics2DConfig.DIST_BIAS_COEF;
                    nx = data[(/*DIST_NORMAL*/20)];
                    ny = data[(/*DIST_NORMAL*/20) + 1];
                }
            }
        }

        var cx1 = ((data[(/*DIST_RANCHOR1*/11)] * ny) - (data[(/*DIST_RANCHOR1*/11) + 1] * nx));
        var cx2 = ((data[(/*DIST_RANCHOR2*/13)] * ny) - (data[(/*DIST_RANCHOR2*/13) + 1] * nx));
        data[(/*DIST_KMASS*/15)] = (massSum + (cx1 * ii1 * cx1) + (cx2 * ii2 * cx2));

        data[(/*DIST_BIAS*/19)] = err;
        Physics2DConstraint.prototype.safe_solve(data, (/*DIST_KMASS*/15), (/*DIST_BIAS*/19), (/*DIST_BIAS*/19));
        j = data[(/*DIST_BIAS*/19)];

        if (this._equal || j < 0)
        {
            jx = (nx * j);
            jy = (ny * j);

            b1[(/*BODY_POS*/2)]     -= (jx * im1);
            b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
            var dr = (-cx1 * ii1 * j);
            if (dr !== 0)
            {
                this.bodyA._deltaRotation(dr);
            }

            b2[(/*BODY_POS*/2)]     += (jx * im2);
            b2[(/*BODY_POS*/2) + 1] += (jy * im2);
            dr = (cx2 * ii2 * j);
            if (dr !== 0)
            {
                this.bodyB._deltaRotation(dr);
            }
        }

        return false;
    }
};

// params = {
//   bodyA, bodyB
//   anchorA, anchorB,
//   lowerBound, upperBound
//   .. common constraint params
// }
Physics2DDistanceConstraint.create = function distanceConstraintFn(params)
{
    var p = new Physics2DDistanceConstraint();
    p.dimension = 1;
    var data = p._data = new Physics2DDevice.prototype.floatArray((/*DIST_DATA_SIZE*/24));
    Physics2DConstraint.prototype.init(p, params);

    var anchor = params.anchorA;
    data[(/*DIST_LANCHOR1*/7)]     = (anchor ? anchor[0] : 0);
    data[(/*DIST_LANCHOR1*/7) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.anchorB;
    data[(/*DIST_LANCHOR2*/9)]     = (anchor ? anchor[0] : 0);
    data[(/*DIST_LANCHOR2*/9) + 1] = (anchor ? anchor[1] : 0);

    var min = data[(/*DIST_JOINTMIN*/5)] = (params.lowerBound !== undefined ? params.lowerBound : 0);
    var max = data[(/*DIST_JOINTMAX*/6)] = (params.upperBound !== undefined ? params.upperBound : 0);
    p._equal = (min === max);

    p._slack = false;

    p.bodyA = params.bodyA;
    p.bodyB = params.bodyB;

    // Seed normal incase initial anchors are degenerate.
    data[(/*DIST_NORMAL*/20)]     = 1;
    data[(/*DIST_NORMAL*/20) + 1] = 0;

    return p;
};


// =========================================================================
//
// Angle Constraint
//

// ANGLE DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*ANGLE_JOINTMIN*/5 // Joint limits
///*ANGLE_JOINTMAX*/6 //
///*ANGLE_RATIO*/7    // Angle ratio for constraint
///*ANGLE_KMASS*/8    // Effective mass matrix (Scalar)
///*ANGLE_JACC*/9     // Accumulated impulse
///*ANGLE_JMAX*/10    // Maximum impulse (maxForce derived)
///*ANGLE_GAMMA*/11   // Gamma for soft constraint
///*ANGLE_BIAS*/12    // Bias for soft constraint (scalar)
///*ANGLE_SCALE*/13   // Scaling for impulse direction.
//
///*ANGLE_DATA_SIZE*/14

function Physics2DAngleConstraint() {}
Physics2DAngleConstraint.prototype = {

    type : "ANGLE",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    getLowerBound : function getLowerBound()
    {
        return this._data[(/*ANGLE_JOINTMIN*/5)];
    },
    getUpperBound : function getUpperBound()
    {
        return this._data[(/*ANGLE_JOINTMAX*/6)];
    },
    getRatio : function getRatioFn()
    {
        return this._data[(/*ANGLE_RATIO*/7)];
    },

    setLowerBound : function setLowerBoundFn(lowerBound)
    {
        var data = this._data;
        if (data[(/*ANGLE_JOINTMIN*/5)] !== lowerBound)
        {
            data[(/*ANGLE_JOINTMIN*/5)] = lowerBound;
            this._equal = (lowerBound === data[(/*ANGLE_JOINTMAX*/6)]);
            this.wake(true);
        }
    },
    setUpperBound : function setUpperBoundFn(upperBound)
    {
        var data = this._data;
        if (data[(/*ANGLE_JOINTMAX*/6)] !== upperBound)
        {
            data[(/*ANGLE_JOINTMAX*/6)] = upperBound;
            this._equal = (upperBound === data[(/*ANGLE_JOINTMIN*/5)]);
            this.wake(true);
        }
    },
    setRatio : function setRatioFn(ratio)
    {
        var data = this._data;
        if (data[(/*ANGLE_RATIO*/7)] !== ratio)
        {
            data[(/*ANGLE_RATIO*/7)] = ratio;
            this.wake(true);
        }
    },

    // =========================================================

    // Inherited
    _inWorld          : Physics2DConstraint.prototype.twoBodyInWorld,
    _outWorld         : Physics2DConstraint.prototype.twoBodyOutWorld,
    _pairExists       : Physics2DConstraint.prototype.twoBodyPairExists,
    _wakeConnected    : Physics2DConstraint.prototype.twoBodyWakeConnected,
    _sleepComputation : Physics2DConstraint.prototype.twoBodySleepComputation,

    // =======================================================

    // Inherited
    _JACC : (/*ANGLE_JACC*/9),
    _clearCache : Physics2DConstraint.prototype.clearCache,

    _posError : function _posErrorFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var ratio = data[(/*ANGLE_RATIO*/7)];
        var jointMin = data[(/*ANGLE_JOINTMIN*/5)];
        var jointMax = data[(/*ANGLE_JOINTMAX*/6)];

        var err = ((ratio * b2[(/*BODY_POS*/2) + 2]) - b1[(/*BODY_POS*/2) + 2]);
        if (this._equal)
        {
            err -= jointMax;
            this._slack = false;
            data[(/*ANGLE_SCALE*/13)] = 1;
        }
        else
        {
            if (err < jointMin)
            {
                err = (jointMin - err);
                this._slack = false;
                data[(/*ANGLE_SCALE*/13)] = -1;
            }
            else if (err > jointMax)
            {
                err -= jointMax;
                this._slack = false;
                data[(/*ANGLE_SCALE*/13)] = 1;
            }
            else
            {
                err = 0;
                this._slack = true;
                data[(/*ANGLE_SCALE*/13)] = 0;
            }
        }
        data[(/*ANGLE_BIAS*/12)] = (-err);
    },

    _preStep : function _preStepFn(deltaTime)
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        // Compute effective mass before existing on _slack
        // As effective-mass is not recomputed in iteratePos
        // for stiff constraints.

        var ratio = data[(/*ANGLE_RATIO*/7)];
        // Compute non-inverted effective mass.
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];
        data[(/*ANGLE_KMASS*/8)] = ii1 + (ratio * ratio * ii2);

        // Invert effective mass
        Physics2DConstraint.prototype.safe_invert(data, (/*ANGLE_KMASS*/8), (/*ANGLE_JACC*/9));

        this._posError();
        if (this._slack)
        {
            return false;
        }

        if (!this._stiff)
        {
            if (Physics2DConstraint.prototype.soft_params(data, (/*ANGLE_KMASS*/8), (/*ANGLE_GAMMA*/11), (/*ANGLE_BIAS*/12), deltaTime, this._breakUnderError))
            {
                return true;
            }
        }
        else
        {
            data[(/*ANGLE_GAMMA*/11)] = 0;
            data[(/*ANGLE_BIAS*/12)] = 0;
        }

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        data[(/*ANGLE_JACC*/9)] *= dtRatio;
        data[(/*ANGLE_JMAX*/10)] = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var j = (data[(/*ANGLE_JACC*/9)] * data[(/*ANGLE_SCALE*/13)]);
        b1[(/*BODY_VEL*/7) + 2] -= (j * b1[(/*BODY_IINERTIA*/1)]);
        b2[(/*BODY_VEL*/7) + 2] += (j * data[(/*ANGLE_RATIO*/7)] * b2[(/*BODY_IINERTIA*/1)]);
    },

    getImpulseForBody : function getImpulseForBodyFn(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var data = this._data;
        var j = (data[(/*ANGLE_JACC*/9)] * data[(/*ANGLE_SCALE*/13)]);

        dst[0] = dst[1] = 0;
        dst[2] = (body === this.bodyA ? -1 : (body === this.bodyB ? data[(/*ANGLE_RATIO*/7)] : 0)) * j;

        return dst;
    },

    _iterateVel : function _iterateVelFn()
    {
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        // x = Bias - VelocityError
        var scale = data[(/*ANGLE_SCALE*/13)];
        var ratio = data[(/*ANGLE_RATIO*/7)];
        var x = (data[(/*ANGLE_BIAS*/12)] - (scale * ((ratio * b2[(/*BODY_VEL*/7) + 2]) - b1[(/*BODY_VEL*/7) + 2])));

        var jOld = data[(/*ANGLE_JACC*/9)];
        // Impulse.
        // j = K * x - Jacc * gamma
        var j = (data[(/*ANGLE_KMASS*/8)] * x) - (jOld * data[(/*ANGLE_GAMMA*/11)]);

        // Accumulate and clamp
        var jAcc = (jOld + j);
        var jMax = data[(/*ANGLE_JMAX*/10)];
        if (this._breakUnderForce)
        {
            if (jAcc > jMax || jAcc < -jMax)
            {
                return true;
            }
            else if (!this._equal && jAcc > 0)
            {
                jAcc = 0;
            }
        }
        else if (!this._stiff)
        {
            if (!this._equal)
            {
                if (jAcc > 0)
                {
                    jAcc = 0;
                }
                else if (jAcc < -jMax)
                {
                    jAcc = -jMax;
                }
            }
            else
            {
                if (jAcc > jMax)
                {
                    jAcc = jMax;
                }
                else if (jAcc < -jMax)
                {
                    jAcc = -jMax;
                }
            }
        }
        else if (!this._equal && jAcc > 0)
        {
            jAcc = 0;
        }

        j = (jAcc - jOld);
        data[(/*ANGLE_JACC*/9)] = jAcc;

        // Apply impulse
        j *= scale;
        b1[(/*BODY_VEL*/7) + 2] -= (j * b1[(/*BODY_IINERTIA*/1)]);
        b2[(/*BODY_VEL*/7) + 2] += (j * ratio * b2[(/*BODY_IINERTIA*/1)]);

        return false;
    },

    _iteratePos : function _iteratePosFn()
    {
        this._posError();
        if (this._slack)
        {
            return false;
        }

        var data = this._data;
        var err = data[(/*ANGLE_BIAS*/12)];
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (this._breakUnderError && (err > maxError || err < -maxError))
        {
            return true;
        }

        var slop = Physics2DConfig.ANGLE_SLOP_SQ;
        if ((err * err) < slop)
        {
            return false;
        }

        err *= Physics2DConfig.ANGLE_BIAS_COEF;
        var j = (err * Physics2DConfig.ANGLE_BIAS_COEF * data[(/*ANGLE_KMASS*/8)]);

        if (this._equal || j < 0)
        {
            var b = this.bodyA;
            j *= data[(/*ANGLE_SCALE*/13)];
            var dr = (-j * b._data[(/*BODY_IINERTIA*/1)]);
            if (dr !== 0)
            {
                b._deltaRotation(dr);
            }

            b = this.bodyB;
            dr = (j * b._data[(/*BODY_IINERTIA*/1)]);
            if (dr !== 0)
            {
                b._deltaRotation(dr);
            }
        }

        return false;
    }
};

// params = {
//   bodyA, bodyB,
//   lowerBound, upperBound, ratio
//   ... common constraint params
// }
Physics2DAngleConstraint.create = function angleConstraintFn(params)
{
    var p = new Physics2DAngleConstraint();
    p.dimension = 1;
    var data = p._data = new Physics2DDevice.prototype.floatArray((/*ANGLE_DATA_SIZE*/14));
    Physics2DConstraint.prototype.init(p, params);

    data[(/*ANGLE_RATIO*/7)] = (params.ratio !== undefined ? params.ratio : 1);
    var min = data[(/*ANGLE_JOINTMIN*/5)] = (params.lowerBound !== undefined ? params.lowerBound : 0);
    var max = data[(/*ANGLE_JOINTMAX*/6)] = (params.upperBound !== undefined ? params.upperBound : 0);
    p._equal = (min === max);

    p._slack = false;

    p.bodyA = params.bodyA;
    p.bodyB = params.bodyB;

    return p;
};

// =========================================================================
//
// Weld Constraint
//

// WELD DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*WELD_LANCHOR1*/5  // Locally defined anchor on first body.
///*WELD_LANCHOR2*/7  // Locally defined anchor on second body.
///*WELD_RANCHOR1*/9  // Relatively defined anchor on first body.
///*WELD_RANCHOR2*/11 // Relatively defined anchor on second body.
///*WELD_PHASE*/13    // Rotational phase between bodies
///*WELD_KMASS*/14    // Effective mass matrix [ a b c ; b d e ; c e f ] symmetric.
///*WELD_JACC*/20     // Accumulated impulse (x, y, w).
///*WELD_JMAX*/23     // Maximum impulse magnitude (maxForce derived).
///*WELD_GAMMA*/24    // Gamma for soft constraint
///*WELD_BIAS*/25     // Bias for soft constraint (x, y, w) (maxError derived).
//
///*WELD_DATA_SIZE*/28

function Physics2DWeldConstraint() {}
Physics2DWeldConstraint.prototype = {

    type : "WELD",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    // Inherited
    _ANCHOR_A : (/*WELD_LANCHOR1*/5),
    getAnchorA : Physics2DConstraint.prototype.getAnchorA,
    setAnchorA : Physics2DConstraint.prototype.setAnchorA,

    _ANCHOR_B : (/*WELD_LANCHOR2*/7),
    getAnchorB : Physics2DConstraint.prototype.getAnchorB,
    setAnchorB : Physics2DConstraint.prototype.setAnchorB,

    getPhase : function getPhaseFn()
    {
        return this._data[(/*WELD_PHASE*/13)];
    },
    setPhase : function setPhaseFn(phase)
    {
        var data = this._data;
        if (phase !== data[(/*WELD_PHASE*/13)])
        {
            data[(/*WELD_PHASE*/13)] = phase;
            this.wake(true);
        }
    },

    // =========================================================

    // Inherited
    _inWorld          : Physics2DConstraint.prototype.twoBodyInWorld,
    _outWorld         : Physics2DConstraint.prototype.twoBodyOutWorld,
    _pairExists       : Physics2DConstraint.prototype.twoBodyPairExists,
    _wakeConnected    : Physics2DConstraint.prototype.twoBodyWakeConnected,
    _sleepComputation : Physics2DConstraint.prototype.twoBodySleepComputation,

    // =======================================================

    // Inherited
    _JACC : (/*WELD_JACC*/20),
    _clearCache : Physics2DConstraint.prototype.clearCache3,

    _preStep : function _preStepFn(deltaTime)
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*WELD_LANCHOR1*/5), (/*WELD_RANCHOR1*/9));
        var rx1 = data[(/*WELD_RANCHOR1*/9)];
        var ry1 = data[(/*WELD_RANCHOR1*/9) + 1];

        Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*WELD_LANCHOR2*/7), (/*WELD_RANCHOR2*/11));
        var rx2 = data[(/*WELD_RANCHOR2*/11)];
        var ry2 = data[(/*WELD_RANCHOR2*/11) + 1];

        // Compute non-inverted effective mass.
        var massSum = (b1[(/*BODY_IMASS*/0)] + b2[(/*BODY_IMASS*/0)]);
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];
        data[(/*WELD_KMASS*/14)]     = massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2);
        data[(/*WELD_KMASS*/14) + 1] =         - (rx1 * ii1 * ry1) - (rx2 * ii2 * ry2);
        data[(/*WELD_KMASS*/14) + 2] =         - (ry1 * ii1)       - (ry2 * ii2);
        data[(/*WELD_KMASS*/14) + 3] = massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2);
        data[(/*WELD_KMASS*/14) + 4] =           (rx1 * ii1)       + (rx2 * ii2);
        data[(/*WELD_KMASS*/14) + 5] = ii1 + ii2;

        // Invert effective mass
        Physics2DConstraint.prototype.safe_invert3(data, (/*WELD_KMASS*/14), (/*WELD_JACC*/20));

        if (!this._stiff)
        {
            data[(/*WELD_BIAS*/25)]     = ((b1[(/*BODY_POS*/2)]     + rx1) - (b2[(/*BODY_POS*/2)]     + rx2));
            data[(/*WELD_BIAS*/25) + 1] = ((b1[(/*BODY_POS*/2) + 1] + ry1) - (b2[(/*BODY_POS*/2) + 1] + ry2));
            data[(/*WELD_BIAS*/25) + 2] = ((b1[(/*BODY_POS*/2) + 2] + data[(/*WELD_PHASE*/13)]) - b2[(/*BODY_POS*/2) + 2]);
            if (Physics2DConstraint.prototype.soft_params3(data, (/*WELD_KMASS*/14), (/*WELD_GAMMA*/24), (/*WELD_BIAS*/25),
                                                        deltaTime, this._breakUnderError))
            {
                return true;
            }
        }
        else
        {
            data[(/*WELD_GAMMA*/24)]    = 0.0;
            data[(/*WELD_BIAS*/25)]     = 0.0;
            data[(/*WELD_BIAS*/25) + 1] = 0.0;
            data[(/*WELD_BIAS*/25) + 2] = 0.0;
        }

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        data[(/*WELD_JACC*/20)]     *= dtRatio;
        data[(/*WELD_JACC*/20) + 1] *= dtRatio;
        data[(/*WELD_JACC*/20) + 2] *= dtRatio;
        data[(/*WELD_JMAX*/23)]     = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var jx = data[(/*WELD_JACC*/20)];
        var jy = data[(/*WELD_JACC*/20) + 1];
        var jz = data[(/*WELD_JACC*/20) + 2];

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (((data[(/*WELD_RANCHOR1*/9)]     * jy) -
                                     (data[(/*WELD_RANCHOR1*/9) + 1] * jx) +
                                     jz) *
                                    b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (((data[(/*WELD_RANCHOR2*/11)]     * jy) -
                                     (data[(/*WELD_RANCHOR2*/11) + 1] * jx) +
                                     jz) *
                                    b2[(/*BODY_IINERTIA*/1)]);
    },

    getImpulseForBody : function getImpulseForBodyFn(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var data = this._data;
        var jx = data[(/*WELD_JACC*/20)];
        var jy = data[(/*WELD_JACC*/20) + 1];
        var jz = data[(/*WELD_JACC*/20) + 2];

        if (body === this.bodyA)
        {
            dst[0] = -jx;
            dst[1] = -jy;
            dst[2] = -((data[(/*WELD_RANCHOR1*/9)]     * jy) -
                       (data[(/*WELD_RANCHOR1*/9) + 1] * jx) +
                       jz);
        }
        else if (body === this.bodyB)
        {
            dst[0] = jx;
            dst[1] = jy;
            dst[2] = ((data[(/*WELD_RANCHOR2*/11)]     * jy) -
                      (data[(/*WELD_RANCHOR2*/11) + 1] * jx) +
                      jz);
        }
        else
        {
            dst[0] = dst[1] = dst[2] = 0;
        }

        return dst;
    },

    _iterateVel : function _iterateVelFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var rx1 = data[(/*WELD_RANCHOR1*/9)];
        var ry1 = data[(/*WELD_RANCHOR1*/9) + 1];
        var rx2 = data[(/*WELD_RANCHOR2*/11)];
        var ry2 = data[(/*WELD_RANCHOR2*/11) + 1];

        // (x, y, z) = Bias - VelocityError
        var vw1 = b1[(/*BODY_VEL*/7) + 2];
        var vw2 = b2[(/*BODY_VEL*/7) + 2];
        var x = (data[(/*WELD_BIAS*/25)]     - (b2[(/*BODY_VEL*/7)]     - (ry2 * vw2)) + (b1[(/*BODY_VEL*/7)]     - (ry1 * vw1)));
        var y = (data[(/*WELD_BIAS*/25) + 1] - (b2[(/*BODY_VEL*/7) + 1] + (rx2 * vw2)) + (b1[(/*BODY_VEL*/7) + 1] + (rx1 * vw1)));
        var z = (data[(/*WELD_BIAS*/25) + 2] - vw2 + vw1);

        var jOldX = data[(/*WELD_JACC*/20)];
        var jOldY = data[(/*WELD_JACC*/20) + 1];
        var jOldZ = data[(/*WELD_JACC*/20) + 2];
        var gamma = data[(/*WELD_GAMMA*/24)];

        // Impulse.
        // (jx, jy, jz) = K * (x, y, z) - (JAcc * gamma);
        var Kb = data[(/*WELD_KMASS*/14) + 1];
        var Kc = data[(/*WELD_KMASS*/14) + 2];
        var Ke = data[(/*WELD_KMASS*/14) + 4];
        var jx = ((data[(/*WELD_KMASS*/14)]     * x) + (Kb * y) + (Kc * z)) - (jOldX * gamma);
        var jy = ((Kb * x) + (data[(/*WELD_KMASS*/14) + 3] * y) + (Ke * z)) - (jOldY * gamma);
        var jz = ((Kc * x) + (Ke * y) + (data[(/*WELD_KMASS*/14) + 5] * z)) - (jOldZ * gamma);

        // Accumulate and clamp.
        var jAccX = (jOldX + jx);
        var jAccY = (jOldY + jy);
        var jAccZ = (jOldZ + jz);
        var jsq = ((jAccX * jAccX) + (jAccY * jAccY) + (jAccZ * jAccZ));
        var jMax = data[(/*WELD_JMAX*/23)];
        if (this._breakUnderForce)
        {
            if (jsq > (jMax * jMax))
            {
                return true;
            }
        }
        else if (!this._stiff)
        {
            if (jsq > (jMax * jMax))
            {
                jsq = (jMax / Math.sqrt(jsq));
                jAccX *= jsq;
                jAccY *= jsq;
                jAccZ *= jsq;
            }
        }

        jx = (jAccX - jOldX);
        jy = (jAccY - jOldY);
        jz = (jAccZ - jOldZ);
        data[(/*WELD_JACC*/20)]     = jAccX;
        data[(/*WELD_JACC*/20) + 1] = jAccY;
        data[(/*WELD_JACC*/20) + 2] = jAccZ;

        // Apply impulse
        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (((rx1 * jy) - (ry1 * jx) + jz) * b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (((rx2 * jy) - (ry2 * jx) + jz) * b2[(/*BODY_IINERTIA*/1)]);

        return false;
    },

    _iteratePos : function _iteratePosFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var im1 = b1[(/*BODY_IMASS*/0)];
        var im2 = b2[(/*BODY_IMASS*/0)];
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];

        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*WELD_LANCHOR1*/5), (/*WELD_RANCHOR1*/9));
        var rx1 = data[(/*WELD_RANCHOR1*/9)];
        var ry1 = data[(/*WELD_RANCHOR1*/9) + 1];

        Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*WELD_LANCHOR2*/7), (/*WELD_RANCHOR2*/11));
        var rx2 = data[(/*WELD_RANCHOR2*/11)];
        var ry2 = data[(/*WELD_RANCHOR2*/11) + 1];

        // Positional error
        var errX = ((b1[(/*BODY_POS*/2)]     + rx1) - (b2[(/*BODY_POS*/2)]     + rx2));
        var errY = ((b1[(/*BODY_POS*/2) + 1] + ry1) - (b2[(/*BODY_POS*/2) + 1] + ry2));
        var errZ = ((b1[(/*BODY_POS*/2) + 2] + data[(/*WELD_PHASE*/13)]) - b2[(/*BODY_POS*/2) + 2]);

        var elsq = ((errX * errX) + (errY * errY));
        var wlsq = (errZ * errZ);
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (this._breakUnderError && (elsq + wlsq > (maxError * maxError)))
        {
            return true;
        }

        if (elsq < Physics2DConfig.WELD_LINEAR_SLOP_SQ && wlsq < Physics2DConfig.WELD_ANGULAR_SLOP_SQ)
        {
            return false;
        }

        var scale = Physics2DConfig.WELD_BIAS_COEF;
        errX *= scale;
        errY *= scale;
        errZ *= scale;
        elsq *= (scale * scale);

        var massSum = (im1 + im2);
        var jx, jy;
        // Handle large error seperately.
        if (elsq > Physics2DConfig.WELD_LARGE_ERROR_SQ)
        {
            if (massSum > Physics2DConfig.EFF_MASS_EPSILON)
            {
                var K = (Physics2DConfig.WELD_BIAS_COEF / massSum);
                jx = (errX * K);
                jy = (errY * K);

                // Clamp
                var jsq = ((jx * jx) + (jy * jy));
                var maxJ = Physics2DConfig.WELD_LARGE_ERROR_MAX;
                if (jsq > (maxJ * maxJ))
                {
                    jsq = (maxJ / Math.sqrt(jsq));
                    jx *= jsq;
                    jy *= jsq;
                }

                // Apply impulse
                b1[(/*BODY_POS*/2)]     -= (jx * im1);
                b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
                b2[(/*BODY_POS*/2)]     += (jx * im1);
                b2[(/*BODY_POS*/2) + 1] += (jy * im1);

                // Recompute error.
                errX = ((b1[(/*BODY_POS*/2)]     + rx1) - (b2[(/*BODY_POS*/2)]     + rx2));
                errY = ((b1[(/*BODY_POS*/2) + 1] + ry1) - (b2[(/*BODY_POS*/2) + 1] + ry2));
                errX *= scale;
                errY *= scale;
                elsq = ((errX * errX) + (errY * errY));
            }
        }

        // Compute non-inverted effective mass.
        data[(/*WELD_KMASS*/14)]     = massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2);
        data[(/*WELD_KMASS*/14) + 1] =         - (rx1 * ii1 * ry1) - (rx2 * ii2 * ry2);
        data[(/*WELD_KMASS*/14) + 2] =         - (ry1 * ii1)       - (ry2 * ii2);
        data[(/*WELD_KMASS*/14) + 3] = massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2);
        data[(/*WELD_KMASS*/14) + 4] =           (rx1 * ii1)       + (rx2 * ii2);
        data[(/*WELD_KMASS*/14) + 5] = ii1 + ii2;

        if (elsq > Physics2DConfig.WELD_MAX_LINEAR_ERROR_SQ)
        {
            elsq = (Physics2DConfig.WELD_MAX_LINEAR_ERROR / Math.sqrt(elsq));
            errX *= elsq;
            errY *= elsq;
        }

        var maxW = Physics2DConfig.WELD_MAX_ANGULAR_ERROR;
        if (errZ > maxW)
        {
            errZ = maxW;
        }
        else if (errZ < -maxW)
        {
            errZ = -maxW;
        }

        data[(/*WELD_BIAS*/25)]     = errX;
        data[(/*WELD_BIAS*/25) + 1] = errY;
        data[(/*WELD_BIAS*/25) + 2] = errZ;
        Physics2DConstraint.prototype.safe_solve3(data, (/*WELD_KMASS*/14), (/*WELD_BIAS*/25), (/*WELD_BIAS*/25));
        jx = data[(/*WELD_BIAS*/25)];
        jy = data[(/*WELD_BIAS*/25) + 1];
        var jz = data[(/*WELD_BIAS*/25) + 2];

        // Apply impulse
        b1[(/*BODY_POS*/2)]     -= (jx * im1);
        b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
        var dW = -(((rx1 * jy) - (ry1 * jx) + jz) * ii1);
        if (dW !== 0)
        {
            this.bodyA._deltaRotation(dW);
        }

        b2[(/*BODY_POS*/2)]     += (jx * im2);
        b2[(/*BODY_POS*/2) + 1] += (jy * im2);
        dW = (((rx2 * jy) - (ry2 * jx) + jz) * ii2);
        if (dW !== 0)
        {
            this.bodyB._deltaRotation(dW);
        }

        return false;
    }
};

// params = {
//   bodyA, bodyB,
//   anchorA, anchorB,
//   phase
//   ... common constraint params
// }
Physics2DWeldConstraint.create = function weldConstraintFn(params)
{
    var p = new Physics2DWeldConstraint();
    p.dimension = 3;
    var data = p._data = new Physics2DDevice.prototype.floatArray((/*WELD_DATA_SIZE*/28));
    Physics2DConstraint.prototype.init(p, params);

    var anchor = params.anchorA;
    data[(/*WELD_LANCHOR1*/5)]     = (anchor ? anchor[0] : 0);
    data[(/*WELD_LANCHOR1*/5) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.anchorB;
    data[(/*WELD_LANCHOR2*/7)]     = (anchor ? anchor[0] : 0);
    data[(/*WELD_LANCHOR2*/7) + 1] = (anchor ? anchor[1] : 0);

    data[(/*WELD_PHASE*/13)] = (params.phase !== undefined ? params.phase : 0);

    p.bodyA = params.bodyA;
    p.bodyB = params.bodyB;

    return p;
};

// =========================================================================
//
// Point Constraint
//

// POINT DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*POINT_LANCHOR1*/5  // Locally defined anchor on first body.
///*POINT_LANCHOR2*/7  // Locally defined anchor on second body.
///*POINT_RANCHOR1*/9  // Relatively defined anchor on first body.
///*POINT_RANCHOR2*/11 // Relatively defined anchor on second body.
///*POINT_KMASS*/13    // Effective mass matrix [ a b ; b c] symmetric.
///*POINT_JACC*/16     // Accumulated impulses (x, y).
///*POINT_JMAX*/18     // Maximimum impulse magnitude (maxForce derived).
///*POINT_GAMMA*/19    // Gamma for soft constraint.
///*POINT_BIAS*/20     // Bias for soft constraint (x, y) (maxError derived).
//
///*POINT_DATA_SIZE*/22

function Physics2DPointConstraint() {}
Physics2DPointConstraint.prototype = {

    type : "POINT",

    // Inherited
    wake  : Physics2DConstraint.prototype.wake,
    sleep : Physics2DConstraint.prototype.sleep,

    configure  : Physics2DConstraint.prototype.configure,
    isEnabled  : Physics2DConstraint.prototype.isEnabled,
    isDisabled : Physics2DConstraint.prototype.isDisabled,
    enable     : Physics2DConstraint.prototype.enable,
    disable    : Physics2DConstraint.prototype.disable,

    addEventListener    : Physics2DConstraint.prototype.addEventListener,
    removeEventListener : Physics2DConstraint.prototype.removeEventListener,

    // ===============================================

    // Inherited
    _ANCHOR_A : (/*POINT_LANCHOR1*/5),
    getAnchorA : Physics2DConstraint.prototype.getAnchorA,
    setAnchorA : Physics2DConstraint.prototype.setAnchorA,

    _ANCHOR_B : (/*POINT_LANCHOR2*/7),
    getAnchorB : Physics2DConstraint.prototype.getAnchorB,
    setAnchorB : Physics2DConstraint.prototype.setAnchorB,

    // =========================================================

    // Inherited
    _inWorld          : Physics2DConstraint.prototype.twoBodyInWorld,
    _outWorld         : Physics2DConstraint.prototype.twoBodyOutWorld,
    _pairExists       : Physics2DConstraint.prototype.twoBodyPairExists,
    _wakeConnected    : Physics2DConstraint.prototype.twoBodyWakeConnected,
    _sleepComputation : Physics2DConstraint.prototype.twoBodySleepComputation,

    // =======================================================

    // Inherited
    _JACC : (/*POINT_JACC*/16),
    _clearCache : Physics2DConstraint.prototype.clearCache2,

    _preStep : function _preStepFn(deltaTime)
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*POINT_LANCHOR1*/5), (/*POINT_RANCHOR1*/9));
        var rx1 = data[(/*POINT_RANCHOR1*/9)];
        var ry1 = data[(/*POINT_RANCHOR1*/9) + 1];

        Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*POINT_LANCHOR2*/7), (/*POINT_RANCHOR2*/11));
        var rx2 = data[(/*POINT_RANCHOR2*/11)];
        var ry2 = data[(/*POINT_RANCHOR2*/11) + 1];

        // Compute non-inverted effective mass.
        var massSum = (b1[(/*BODY_IMASS*/0)] + b2[(/*BODY_IMASS*/0)]);
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];
        data[(/*POINT_KMASS*/13)]     = massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2);
        data[(/*POINT_KMASS*/13) + 1] =         - (rx1 * ii1 * ry1) - (rx2 * ii2 * ry2);
        data[(/*POINT_KMASS*/13) + 2] = massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2);

        // Invert effective mass
        Physics2DConstraint.prototype.safe_invert2(data, (/*POINT_KMASS*/13), (/*POINT_JACC*/16));

        if (!this._stiff)
        {
            data[(/*POINT_BIAS*/20)]     = ((b1[(/*BODY_POS*/2)]     + rx1) - (b2[(/*BODY_POS*/2)]     + rx2));
            data[(/*POINT_BIAS*/20) + 1] = ((b1[(/*BODY_POS*/2) + 1] + ry1) - (b2[(/*BODY_POS*/2) + 1] + ry2));
            if (Physics2DConstraint.prototype.soft_params2(data, (/*POINT_KMASS*/13), (/*POINT_GAMMA*/19), (/*POINT_BIAS*/20),
                                                        deltaTime, this._breakUnderError))
            {
                return true;
            }
        }
        else
        {
            data[(/*POINT_GAMMA*/19)]    = 0.0;
            data[(/*POINT_BIAS*/20)]     = 0.0;
            data[(/*POINT_BIAS*/20) + 1] = 0.0;
        }

        var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
        data[(/*POINT_JACC*/16)]     *= dtRatio;
        data[(/*POINT_JACC*/16) + 1] *= dtRatio;
        data[(/*POINT_JMAX*/18)]     = (data[(/*JOINT_MAX_FORCE*/2)] * deltaTime);

        return false;
    },

    _warmStart : function _warmStartFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var jx = data[(/*POINT_JACC*/16)];
        var jy = data[(/*POINT_JACC*/16) + 1];

        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (((data[(/*POINT_RANCHOR1*/9)]     * jy) -
                                     (data[(/*POINT_RANCHOR1*/9) + 1] * jx)) *
                                    b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (((data[(/*POINT_RANCHOR2*/11)]     * jy) -
                                     (data[(/*POINT_RANCHOR2*/11) + 1] * jx)) *
                                    b2[(/*BODY_IINERTIA*/1)]);
    },

    getImpulseForBody : function getImpulseForBodyFn(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var data = this._data;

        var jx = data[(/*POINT_JACC*/16)];
        var jy = data[(/*POINT_JACC*/16) + 1];

        if (body === this.bodyA)
        {
            dst[0] = -jx;
            dst[1] = -jy;
            dst[2] = -((data[(/*WELD_RANCHOR1*/9)]     * jy) -
                       (data[(/*WELD_RANCHOR1*/9) + 1] * jx));
        }
        else if (body === this.bodyB)
        {
            dst[0] = jx;
            dst[1] = jy;
            dst[2] = ((data[(/*WELD_RANCHOR2*/11)]     * jy) -
                      (data[(/*WELD_RANCHOR2*/11) + 1] * jx));
        }
        else
        {
            dst[0] = dst[1] = dst[2] = 0;
        }

        return dst;
    },

    _iterateVel : function _iterateVelFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var rx1 = data[(/*POINT_RANCHOR1*/9)];
        var ry1 = data[(/*POINT_RANCHOR1*/9) + 1];
        var rx2 = data[(/*POINT_RANCHOR2*/11)];
        var ry2 = data[(/*POINT_RANCHOR2*/11) + 1];

        // (x, y) = Bias - VelocityError
        var vw1 = b1[(/*BODY_VEL*/7) + 2];
        var vw2 = b2[(/*BODY_VEL*/7) + 2];
        var x = (data[(/*POINT_BIAS*/20)]     - (b2[(/*BODY_VEL*/7)]     - (ry2 * vw2)) + (b1[(/*BODY_VEL*/7)]     - (ry1 * vw1)));
        var y = (data[(/*POINT_BIAS*/20) + 1] - (b2[(/*BODY_VEL*/7) + 1] + (rx2 * vw2)) + (b1[(/*BODY_VEL*/7) + 1] + (rx1 * vw1)));

        var jOldX = data[(/*POINT_JACC*/16)];
        var jOldY = data[(/*POINT_JACC*/16) + 1];
        var Kb = data[(/*POINT_KMASS*/13) + 1];
        var gamma = data[(/*POINT_GAMMA*/19)];

        // Impulse.
        // (jx, jy) = K * (x, y) - (JAcc * gamma);
        var jx = ((data[(/*POINT_KMASS*/13)]     * x)  + (Kb * y)) - (jOldX * gamma);
        var jy = ((Kb * x) + (data[(/*POINT_KMASS*/13) + 2] * y)) - (jOldY * gamma);

        // Accumulate and clamp.
        var jAccX = (jOldX + jx);
        var jAccY = (jOldY + jy);
        var jsq = ((jAccX * jAccX) + (jAccY * jAccY));
        var jMax = data[(/*POINT_JMAX*/18)];
        if (this._breakUnderForce)
        {
            if (jsq > (jMax * jMax))
            {
                return true;
            }
        }
        else if (!this._stiff)
        {
            if (jsq > (jMax * jMax))
            {
                jsq = (jMax / Math.sqrt(jsq));
                jAccX *= jsq;
                jAccY *= jsq;
            }
        }

        jx = (jAccX - jOldX);
        jy = (jAccY - jOldY);
        data[(/*POINT_JACC*/16)]     = jAccX;
        data[(/*POINT_JACC*/16) + 1] = jAccY;

        // Apply impulse
        var im = b1[(/*BODY_IMASS*/0)];
        b1[(/*BODY_VEL*/7)]     -= (jx * im);
        b1[(/*BODY_VEL*/7) + 1] -= (jy * im);
        b1[(/*BODY_VEL*/7) + 2] -= (((rx1 * jy) - (ry1 * jx)) * b1[(/*BODY_IINERTIA*/1)]);

        im = b2[(/*BODY_IMASS*/0)];
        b2[(/*BODY_VEL*/7)]     += (jx * im);
        b2[(/*BODY_VEL*/7) + 1] += (jy * im);
        b2[(/*BODY_VEL*/7) + 2] += (((rx2 * jy) - (ry2 * jx)) * b2[(/*BODY_IINERTIA*/1)]);

        return false;
    },

    _iteratePos : function _iteratePosFn()
    {
        var data = this._data;
        var b1 = this.bodyA._data;
        var b2 = this.bodyB._data;

        var im1 = b1[(/*BODY_IMASS*/0)];
        var im2 = b2[(/*BODY_IMASS*/0)];
        var ii1 = b1[(/*BODY_IINERTIA*/1)];
        var ii2 = b2[(/*BODY_IINERTIA*/1)];

        Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*POINT_LANCHOR1*/5), (/*POINT_RANCHOR1*/9));
        var rx1 = data[(/*POINT_RANCHOR1*/9)];
        var ry1 = data[(/*POINT_RANCHOR1*/9) + 1];

        Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*POINT_LANCHOR2*/7), (/*POINT_RANCHOR2*/11));
        var rx2 = data[(/*POINT_RANCHOR2*/11)];
        var ry2 = data[(/*POINT_RANCHOR2*/11) + 1];

        // Positional error
        var errX = ((b1[(/*BODY_POS*/2)]     + rx1) - (b2[(/*BODY_POS*/2)]     + rx2));
        var errY = ((b1[(/*BODY_POS*/2) + 1] + ry1) - (b2[(/*BODY_POS*/2) + 1] + ry2));
        var elsq = ((errX * errX) + (errY * errY));
        var maxError = data[(/*JOINT_MAX_ERROR*/3)];
        if (this._breakUnderError && (elsq > (maxError * maxError)))
        {
            return true;
        }

        if (elsq < Physics2DConfig.POINT_SLOP_SQ)
        {
            return false;
        }

        var scale = Physics2DConfig.POINT_BIAS_COEF;
        errX *= scale;
        errY *= scale;
        elsq *= (scale * scale);

        var massSum = (im1 + im2);
        var jx, jy;
        // Handle large seperation  for stability
        if (elsq > Physics2DConfig.POINT_LARGE_ERROR_SQ)
        {
            if (massSum > Physics2DConfig.EFF_MASS_EPSILON)
            {
                // We resolve error assuming infinite inertia (ignore rotation).
                var K = (Physics2DConfig.POINT_LARGE_ERROR_BIAS / massSum);
                jx = (errX * K);
                jy = (errY * K);

                // Clamp
                var jsq = ((jx * jx) + (jy * jy));
                var maxJ = Physics2DConfig.POINT_LARGE_ERROR_MAX;
                if (jsq > (maxJ * maxJ))
                {
                    jsq = (maxJ / Math.sqrt(jsq));
                    jx *= jsq;
                    jy *= jsq;
                }

                // Apply impulse
                b1[(/*BODY_POS*/2)]     -= (jx * im1);
                b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
                b2[(/*BODY_POS*/2)]     += (jx * im1);
                b2[(/*BODY_POS*/2) + 1] += (jy * im1);

                // Recompute error.
                errX = ((b1[(/*BODY_POS*/2)]     + rx1) - (b2[(/*BODY_POS*/2)]     + rx2));
                errY = ((b1[(/*BODY_POS*/2) + 1] + ry1) - (b2[(/*BODY_POS*/2) + 1] + ry2));
                errX *= scale;
                errY *= scale;
                elsq = ((errX * errX) + (errY * errY));
            }
        }

        // Compute non-inverted effective mass.
        data[(/*POINT_KMASS*/13)]     = (massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2));
        data[(/*POINT_KMASS*/13) + 1] = (        - (rx1 * ii1 * ry1) - (rx2 * ii2 * ry2));
        data[(/*POINT_KMASS*/13) + 2] = (massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2));

        if (elsq > Physics2DConfig.POINT_MAX_ERROR_SQ)
        {
            elsq = (Physics2DConfig.POINT_MAX_ERROR / Math.sqrt(elsq));
            errX *= elsq;
            errY *= elsq;
        }

        data[(/*POINT_BIAS*/20)]     = errX;
        data[(/*POINT_BIAS*/20) + 1] = errY;
        Physics2DConstraint.prototype.safe_solve2(data, (/*POINT_KMASS*/13), (/*POINT_BIAS*/20), (/*POINT_BIAS*/20));
        jx = data[(/*POINT_BIAS*/20)];
        jy = data[(/*POINT_BIAS*/20) + 1];

        // Apply impulse
        b1[(/*BODY_POS*/2)]     -= (jx * im1);
        b1[(/*BODY_POS*/2) + 1] -= (jy * im1);
        var dW = -(((rx1 * jy) - (ry1 * jx)) * ii1);
        if (dW !== 0)
        {
            this.bodyA._deltaRotation(dW);
        }

        b2[(/*BODY_POS*/2)]     += (jx * im2);
        b2[(/*BODY_POS*/2) + 1] += (jy * im2);
        dW = (((rx2 * jy) - (ry2 * jx)) * ii2);
        if (dW !== 0)
        {
            this.bodyB._deltaRotation(dW);
        }

        return false;
    }
};

// params = {
//   bodyA, bodyB,
//   anchorA, anchorB,
//   ... common constraint params
// }
Physics2DPointConstraint.create = function pointConstraintFn(params)
{
    var p = new Physics2DPointConstraint();
    p.dimension = 2;
    var data = p._data = new Physics2DDevice.prototype.floatArray((/*POINT_DATA_SIZE*/22));
    Physics2DConstraint.prototype.init(p, params);

    var anchor = params.anchorA;
    data[(/*POINT_LANCHOR1*/5)]     = (anchor ? anchor[0] : 0);
    data[(/*POINT_LANCHOR1*/5) + 1] = (anchor ? anchor[1] : 0);

    anchor = params.anchorB;
    data[(/*POINT_LANCHOR2*/7)]     = (anchor ? anchor[0] : 0);
    data[(/*POINT_LANCHOR2*/7) + 1] = (anchor ? anchor[1] : 0);

    p.bodyA = params.bodyA;
    p.bodyB = params.bodyB;

    return p;
};

// =========================================================================
//
// Common to both circles and polygons
//

// SHAPE DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*SHAPE_AABB*/0           // World space AABB of shape (minX, minY, maxx, maxy)
//   index of 0 required for Broadphase
///*SHAPE_SWEEP_RADIUS*/4   // Radius of shape about (0,0)
///*SHAPE_SWEEP_FACTOR*/5   // Sweep factor to bias conservative advancement


// SHAPE TYPE IDENTIFIERS
// !! Must use regexp to change these globally (in all files) !!
//
///*TYPE_CIRCLE*/0
///*TYPE_POLYGON*/1
//

function Physics2DShape() {}
Physics2DShape.uniqueId = 0;
Physics2DShape.prototype = {

    getGroup : function getGroupFn()
    {
        return this._group;
    },

    setGroup : function setGroupFn(group)
    {
        this._group = group;
        if (this.body)
        {
            this.body.wake(true);
        }
    },

    getMask : function getMaskFn()
    {
        return this._mask;
    },

    setMask : function setMaskFn(mask)
    {
        this._mask = mask;
        if (this.body)
        {
            this.body.wake(true);
        }
    },

    getMaterial : function getMaterialFn(material)
    {
        return this._material;
    },

    setMaterial : function setMaterialFn(material)
    {
        if (this._material !== material)
        {
            this._material = material;
            if (this.body)
            {
                this.body._invalidate();
            }

            var arbiters = this.arbiters;
            var limit2 = arbiters.length;
            var j;
            for (j = 0; j < limit2; j += 1)
            {
                arbiters[j]._invalidate();
            }
        }
    },

    copyCommon : function copyCommonFn(from, to)
    {
        to._type = from._type;

        to._material = from._material;
        to._group = from._group;
        to._mask  = from._mask;
        to.sensor = from.sensor;

        to.id = Physics2DShape.uniqueId;
        Physics2DShape.uniqueId += 1;

        to.arbiters = [];
        to._bphaseHandle = null;

        to.userData = from.userData;

        var fromData = from._data;
        var limit = from._data.length;
        var toData = to._data = new Physics2DDevice.prototype.floatArray(limit);
        var i;
        for (i = 0; i < limit; i += 1)
        {
            toData[i] = fromData[i];
        }

        to._onPreSolve = [];
        to._events = []; // onBegin, onEnd, onProgress combined.
    },

    init : function shapeInit(shape, params)
    {
        shape._material = params.material || Physics2DMaterial.create();
        shape._group = (params.group !== undefined) ? params.group : 1;
        shape._mask  = (params.mask  !== undefined) ? params.mask  : 0xffffffff;
        shape.sensor = (params.sensor !== undefined) ? params.sensor : false;

        shape.arbiters = [];
        shape._bphaseHandle = null;
        shape.userData = (params.userData !== undefined) ? params.userData : null;

        shape.id = Physics2DShape.uniqueId;
        Physics2DShape.uniqueId += 1;

        shape._onPreSolve = [];
        shape._events = []; // onBegin, onEnd, onProgress combined.
    },

    // =============================================================================

    eventIndex : function shapeEventIndexFn(events, type, callback, callbackMask)
    {
        var limit = events.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var eventObject = events[i];
            if (eventObject.callback === callback &&
                eventObject.mask === callbackMask &&
                eventObject.type === type)
            {
                return i;
            }
        }

        return -1;
    },

    addEventListener : function shapeAddEventListenerFn(eventType, callback, callbackMask, deterministic)
    {
        var events, type;
        if (eventType === 'preSolve')
        {
            events = this._onPreSolve;
            type = (/*EVENT_PRESOLVE*/6);
        }
        else
        {
            events = this._events;
            type = (eventType === 'begin'    ? (/*EVENT_BEGIN*/1) :
                    eventType === 'progress' ? (/*EVENT_PROGRESS*/2) :
                    eventType === 'end'      ? (/*EVENT_END*/3) :
                    null);
        }

        if (type === null)
        {
            return false;
        }

        if (eventType !== 'preSolve')
        {
            deterministic = undefined;
        }
        else if (deterministic === undefined)
        {
            deterministic = false;
        }

        var index = Physics2DShape.prototype.eventIndex(events, type, callback, callbackMask);
        if (index !== -1)
        {
            return false;
        }

        events.push({
            callback : callback,
            mask : callbackMask,
            type : type,
            deterministic : deterministic
        });

        if (this.body)
        {
            this.body.wake(true);
        }

        return true;
    },

    removeEventListener : function shapeRemoveEventListenerFn(eventType, callback, callbackMask)
    {
        var events, type;
        if (eventType === 'preSolve')
        {
            events = this._onPreSolve;
            type = (/*EVENT_PRESOLVE*/6);
        }
        else
        {
            events = this._events;
            type = (eventType === 'begin'    ? (/*EVENT_BEGIN*/1) :
                    eventType === 'progress' ? (/*EVENT_PROGRESS*/2) :
                    eventType === 'end'      ? (/*EVENT_END*/3) :
                    null);
        }

        if (type === null)
        {
            return false;
        }

        var index = Physics2DShape.prototype.eventIndex(events, type, callback, callbackMask);
        if (index === -1)
        {
            return false;
        }

        // Need to keep order, cannot use swap-pop
        events.splice(index, 1);

        if (this.body)
        {
            this.body.wake(true);
        }

        return true;
    }
};


// =========================================================================

//
// Physics2D Circle
//

// CIRCLE DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*CIRCLE_RADIUS*/6    // Radius of circle about its origin
///*CIRCLE_LOCAL*/7     // Local position of circle origin (x, y)
///*CIRCLE_WORLD*/9     // World position of circle origin (x, y)
//
///*CIRCLE_DATA_SIZE*/11

function Physics2DCircle() {}
Physics2DCircle.prototype = {

    version : 1,
    type : "CIRCLE",

    // Inherited
    getMaterial : Physics2DShape.prototype.getMaterial,
    setMaterial : Physics2DShape.prototype.setMaterial,
    getGroup    : Physics2DShape.prototype.getGroup,
    setGroup    : Physics2DShape.prototype.setGroup,
    getMask     : Physics2DShape.prototype.getMask,
    setMask     : Physics2DShape.prototype.setMask,

    addEventListener    : Physics2DShape.prototype.addEventListener,
    removeEventListener : Physics2DShape.prototype.removeEventListener,

    // ==============================================================

    computeArea : function computeAreaFn()
    {
        var r = this._data[(/*CIRCLE_RADIUS*/6)];
        return (Math.PI * r * r);
    },

    computeMasslessInertia : function getInertiaFn()
    {
        var data = this._data;
        var r = this._data[(/*CIRCLE_RADIUS*/6)];
        var x = data[(/*CIRCLE_LOCAL*/7)];
        var y = data[(/*CIRCLE_LOCAL*/7) + 1];
        return ((0.5 * r * r) + ((x * x) + (y * y)));
    },

    // ==============================================================

    getRadius : function getCircleRadiusFn()
    {
        return this._data[(/*CIRCLE_RADIUS*/6)];
    },

    setRadius : function setRadiusFn(radius)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        var data = this._data;
        if (radius !== data[(/*CIRCLE_RADIUS*/6)])
        {
            data[(/*CIRCLE_RADIUS*/6)] = radius;
            this._validate();
            if (body)
            {
                body._invalidate();
            }
        }
    },

    // ==============================================================

    getOrigin : function getOriginFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        dst[0] = data[(/*CIRCLE_LOCAL*/7)];
        dst[1] = data[(/*CIRCLE_LOCAL*/7) + 1];
        return dst;
    },

    setOrigin : function setOriginFn(origin)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        var data = this._data;
        var originX = origin[0];
        var originY = origin[1];

        if (data[(/*CIRCLE_LOCAL*/7)] !== originX || data[(/*CIRCLE_LOCAL*/7) + 1] !== originY)
        {
            data[(/*CIRCLE_LOCAL*/7)]     = originX;
            data[(/*CIRCLE_LOCAL*/7) + 1] = originY;
            this._validate();
            if (body)
            {
                body._invalidate();
            }
        }
    },

    // ==============================================================

    clone : function circleCopyFn()
    {
        var c = new Physics2DCircle();
        Physics2DShape.prototype.copyCommon(this, c);
        return c;
    },

    // ==============================================================

    scale : function scaleFn(scale)
    {
        if (scale <= 0)
        {
            return;
        }

        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        var data = this._data;
        data[(/*CIRCLE_LOCAL*/7)]     *= scale;
        data[(/*CIRCLE_LOCAL*/7) + 1] *= scale;
        data[(/*CIRCLE_RADIUS*/6)]    *= scale;

        this._validate();
        if (body)
        {
            body._invalidate();
        }
    },

    translate : function translateFn(translation, skip)
    {
        var body = this.body;
        if (!skip && body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        var data = this._data;
        data[(/*CIRCLE_LOCAL*/7)]     += translation[0];
        data[(/*CIRCLE_LOCAL*/7) + 1] += translation[1];

        this._validate();
        if (!skip && body)
        {
            body._invalidate();
        }
    },

    rotate : function rotateFn(rotation)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        var cos = Math.cos(rotation);
        var sin = Math.sin(rotation);
        var data = this._data;
        var x = data[(/*CIRCLE_LOCAL*/7)];
        var y = data[(/*CIRCLE_LOCAL*/7) + 1];
        data[(/*CIRCLE_LOCAL*/7)]     = ((cos * x) - (sin * y));
        data[(/*CIRCLE_LOCAL*/7) + 1] = ((sin * x) + (cos * y));

        this._validate();
        if (body)
        {
            body._invalidate();
        }
    },

    transform : function transformFn(matrix)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        // a b tx
        // c d ty
        var a = matrix[0];
        var b = matrix[2];
        var c = matrix[1];
        var d = matrix[3];

        var data = this._data;
        var det = ((a * d) - (b * c));
        if (det <= 0)
        {
            return;
        }

        data[(/*CIRCLE_RADIUS*/6)] *= Math.sqrt(det);

        var x = data[(/*CIRCLE_LOCAL*/7)];
        var y = data[(/*CIRCLE_LOCAL*/7) + 1];
        data[(/*CIRCLE_LOCAL*/7)]     = ((a * x) + (b * y) + matrix[4]);
        data[(/*CIRCLE_LOCAL*/7) + 1] = ((c * x) + (d * y) + matrix[5]);

        this._validate();
        if (body)
        {
            body._invalidate();
        }
    },

    // ==============================================================

    _update : function circleUpdateFn(posX, posY, cos, sin, skipAABB)
    {
        var data = this._data;
        var originX = data[(/*CIRCLE_LOCAL*/7)];
        var originY = data[(/*CIRCLE_LOCAL*/7) + 1];
        var ox = data[(/*CIRCLE_WORLD*/9)]     = posX + (cos * originX) - (sin * originY);
        var oy = data[(/*CIRCLE_WORLD*/9) + 1] = posY + (sin * originX) + (cos * originY);

        if (!skipAABB)
        {
            var radius = data[(/*CIRCLE_RADIUS*/6)];
            data[(/*SHAPE_AABB*/0)]     = (ox - radius);
            data[(/*SHAPE_AABB*/0) + 1] = (oy - radius);
            data[(/*SHAPE_AABB*/0) + 2] = (ox + radius);
            data[(/*SHAPE_AABB*/0) + 3] = (oy + radius);
        }
    },

    _validate : function _validateFn()
    {
        var data = this._data;
        var originX = data[(/*CIRCLE_LOCAL*/7)];
        var originY = data[(/*CIRCLE_LOCAL*/7) + 1];
        var radius  = data[(/*CIRCLE_RADIUS*/6)];

        var olength = Math.sqrt((originX * originX) + (originY * originY));
        data[(/*SHAPE_SWEEP_RADIUS*/4)] = (radius + olength);
        data[(/*SHAPE_SWEEP_FACTOR*/5)] = (data[(/*SHAPE_SWEEP_RADIUS*/4)] - Math.max(radius - olength, 0));
    }
};

Physics2DCircle.prototype.computeCenterOfMass = Physics2DCircle.prototype.getOrigin;

// params = {
//      radius : ##,
//      origin : [##, ##] = [0, 0],
//      ... common shape props.
// }
Physics2DCircle.create = function circle2DFn(params)
{
    var c = new Physics2DCircle();
    c._type = (/*TYPE_CIRCLE*/0);
    Physics2DShape.prototype.init(c, params);

    var radius = params.radius;
    var originX = (params.origin ? params.origin[0] : 0);
    var originY = (params.origin ? params.origin[1] : 0);

    var data = c._data = new Physics2DDevice.prototype.floatArray((/*CIRCLE_DATA_SIZE*/11));
    data[(/*CIRCLE_RADIUS*/6)] = radius;
    data[(/*CIRCLE_LOCAL*/7)]     = originX;
    data[(/*CIRCLE_LOCAL*/7) + 1] = originY;
    c._validate();

    return c;
};

// =========================================================================

//
// Physics2D Polygon
//

// POLYGON DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*POLY_VERTICES*/6   // Start of vertex data
///*POLY_STRIDE*/13    // Values per vertex till end of object.
//
// PER VERTEX CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*POLY_LOCAL*/0     // Local position of vertex (x, y)
///*POLY_WORLD*/2     // World position of vertex (x, y)
///*POLY_LNORMAL*/4   // Local normal of edge starting at vertex (x, y)
///*POLY_WNORMAL*/6   // World normal of edge starting at vertex (x, y)
///*POLY_LPROJ*/8     // Local projection of polygon to edge.
///*POLY_WPROJ*/9      // World projection of polygon to edge.
///*POLY_CROSS1*/10    // World cross-projection of vertex to its edge.
///*POLY_CROSS2*/11   // World cross-projection of 'next' vertex to this edge.
///*POLY_LENGTH*/12   // Length of edge startinga t this vertex.

function Physics2DPolygon() {}
Physics2DPolygon.prototype = {

    version : 1,
    type : "POLYGON",

    // Inherited
    getMaterial : Physics2DShape.prototype.getMaterial,
    setMaterial : Physics2DShape.prototype.setMaterial,
    getGroup    : Physics2DShape.prototype.getGroup,
    setGroup    : Physics2DShape.prototype.setGroup,
    getMask     : Physics2DShape.prototype.getMask,
    setMask     : Physics2DShape.prototype.setMask,

    addEventListener    : Physics2DShape.prototype.addEventListener,
    removeEventListener : Physics2DShape.prototype.removeEventListener,

    // ===========================================================================

    computeArea : function getPolyAreaFn()
    {
        var data = this._data;
        var index = (/*POLY_VERTICES*/6);
        var limit = data.length;
        var doubleArea = 0;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var next = index + (/*POLY_STRIDE*/13);
            if (next === limit)
            {
                next = (/*POLY_VERTICES*/6);
            }

            doubleArea += ((data[index + (/*POLY_LOCAL*/0)] * data[next + (/*POLY_LOCAL*/0) + 1]) -
                           (data[index + (/*POLY_LOCAL*/0) + 1] * data[next + (/*POLY_LOCAL*/0)]));
        }
        return (doubleArea * 0.5);
    },

    computeMasslessInertia : function getPolyInertiaFn()
    {
        var data = this._data;
        var index = (/*POLY_VERTICES*/6);
        var limit = data.length;
        var s1 = 0;
        var s2 = 0;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var next = index + (/*POLY_STRIDE*/13);
            if (next === limit)
            {
                next = (/*POLY_VERTICES*/6);
            }

            var x1 = data[index + (/*POLY_LOCAL*/0)];
            var y1 = data[index + (/*POLY_LOCAL*/0) + 1];
            var x2 = data[next + (/*POLY_LOCAL*/0)];
            var y2 = data[next + (/*POLY_LOCAL*/0) + 1];

            var a = (x1 * y2) - (x2 * y1);
            var b = ((x1 * x1) + (y1 * y1)) + ((x2 * x2) + (y2 * y2)) + ((x1 * x2) + (y1 * y2));

            s1 += (a * b);
            s2 += a;
        }

        return (s1 / (6 * s2));
    },

    computeCenterOfMass : function computeCenterOfMassFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }

        var data = this._data;
        var index = (/*POLY_VERTICES*/6);
        var limit = data.length;
        var doubleArea = 0;
        var cx = 0;
        var cy = 0;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var next = index + (/*POLY_STRIDE*/13);
            if (next === limit)
            {
                next = (/*POLY_VERTICES*/6);
            }

            var x1 = data[index + (/*POLY_LOCAL*/0)];
            var y1 = data[index + (/*POLY_LOCAL*/0) + 1];
            var x2 = data[next  + (/*POLY_LOCAL*/0)];
            var y2 = data[next  + (/*POLY_LOCAL*/0) + 1];

            var cross = ((x1 * y2) - (y1 * x2));
            doubleArea += cross;
            cx += ((x1 + x2) * cross);
            cy += ((y1 + y2) * cross);
        }

        var rec = (1 / (3 * doubleArea));
        dst[0] = (cx * rec);
        dst[1] = (cy * rec);
    },

    // ===========================================================================

    setVertices : function setVerticesFn(vertices)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        this._validate(vertices);
        if (body)
        {
            body._invalidate();
        }
    },

    // ===========================================================================

    clone : function polygonCopyFn()
    {
        var c = new Physics2DPolygon();
        Physics2DShape.prototype.copyCommon(this, c);
        return c;
    },

    // ===========================================================================

    scale : function scaleFn(scaleX, scaleY)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        if (scaleY === undefined)
        {
            scaleY = scaleX;
        }

        if (scaleX <= 0 || scaleY <= 0)
        {
            return;
        }

        var iscaleX = (1 / scaleX);
        var iscaleY = (1 / scaleY);

        var data = this._data;
        var limit = data.length;
        var index = (/*POLY_VERTICES*/6);

        var radius = 0.0;
        var minProj = Number.POSITIVE_INFINITY;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var x = (data[index + (/*POLY_LOCAL*/0)]     *= scaleX);
            var y = (data[index + (/*POLY_LOCAL*/0) + 1] *= scaleY);

            var nx = (data[index + (/*POLY_LNORMAL*/4)]     * iscaleX);
            var ny = (data[index + (/*POLY_LNORMAL*/4) + 1] * iscaleY);
            var rec = (1 / Math.sqrt((nx * nx) + (ny * ny)));

            data[index + (/*POLY_LNORMAL*/4)]     = (nx *= rec);
            data[index + (/*POLY_LNORMAL*/4) + 1] = (ny *= rec);
            var lproj = data[index + (/*POLY_LPROJ*/8)] = ((nx * x) + (ny * y));
            if (lproj < minProj)
            {
                minProj = lproj;
            }
            var vlsq = ((x * x) + (y * y));
            if (vlsq > radius)
            {
                radius = vlsq;
            }

            var next = (index + (/*POLY_STRIDE*/13));
            if (next === limit)
            {
                next = (/*POLY_VERTICES*/6);
            }

            var dx = ((data[next + (/*POLY_LOCAL*/0)]     * scaleX) - x);
            var dy = ((data[next + (/*POLY_LOCAL*/0) + 1] * scaleY) - y);
            var dL = Math.sqrt((dx * dx) + (dy * dy));
            data[index + (/*POLY_LENGTH*/12)] = dL;
        }

        data[(/*SHAPE_SWEEP_RADIUS*/4)] = Math.sqrt(radius);
        data[(/*SHAPE_SWEEP_FACTOR*/5)] = (data[(/*SHAPE_SWEEP_RADIUS*/4)] - Math.max(minProj, 0));
        if (body)
        {
            body._invalidate();
        }
    },

    translate : function translateFn(translation, skip)
    {
        var body = this.body;
        if (!skip && body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        var data = this._data;
        var limit = data.length;
        var index = (/*POLY_VERTICES*/6);

        var tx = translation[0];
        var ty = translation[1];

        var radius = 0.0;
        var minProj = Number.POSITIVE_INFINITY;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var x = (data[index + (/*POLY_LOCAL*/0)]     += tx);
            var y = (data[index + (/*POLY_LOCAL*/0) + 1] += ty);

            var nx = data[index + (/*POLY_LNORMAL*/4)];
            var ny = data[index + (/*POLY_LNORMAL*/4) + 1];
            var lproj = (data[index + (/*POLY_LPROJ*/8)] += ((nx * tx) + (ny * ty)));
            if (lproj < minProj)
            {
                minProj = lproj;
            }
            var vlsq = ((x * x) + (y * y));
            if (vlsq > radius)
            {
                radius = vlsq;
            }

            // Translation does not effect local normal or edge length.
        }

        data[(/*SHAPE_SWEEP_RADIUS*/4)] = Math.sqrt(radius);
        data[(/*SHAPE_SWEEP_FACTOR*/5)] = (data[(/*SHAPE_SWEEP_RADIUS*/4)] - Math.max(minProj, 0));
        if (!skip && body)
        {
            body._invalidate();
        }
    },

    rotate : function rotateFn(rotation)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        var data = this._data;
        var limit = data.length;
        var index = (/*POLY_VERTICES*/6);

        var cos = Math.cos(rotation);
        var sin = Math.sin(rotation);

        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var x = data[index + (/*POLY_LOCAL*/0)];
            var y = data[index + (/*POLY_LOCAL*/0) + 1];
            data[index + (/*POLY_LOCAL*/0)]     = ((x * cos) - (y * sin));
            data[index + (/*POLY_LOCAL*/0) + 1] = ((x * sin) + (y * cos));

            x = data[index + (/*POLY_LNORMAL*/4)];
            y = data[index + (/*POLY_LNORMAL*/4) + 1];
            data[index + (/*POLY_LNORMAL*/4)]     = ((x * cos) - (y * sin));
            data[index + (/*POLY_LNORMAL*/4) + 1] = ((x * sin) + (y * cos));

            // Rotation does not effect local projection, edge length
            // nor does it effect radius and sweep factor.
        }

        if (body)
        {
            body._invalidate();
        }
    },

    transform : function transformFn(matrix)
    {
        var body = this.body;
        if (body && body.world && (body._type === (/*TYPE_STATIC*/2) || body.world._midStep))
        {
            return;
        }

        // a b tx
        // c d ty
        var a  = matrix[0];
        var b  = matrix[2];
        var c  = matrix[1];
        var d  = matrix[3];
        var tx = matrix[4];
        var ty = matrix[5];

        if (((a * d) - (b * c)) <= 0)
        {
            return;
        }

        var data = this._data;
        var limit = data.length;
        var index = (/*POLY_VERTICES*/6);
        var x, y;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            x = data[index + (/*POLY_LOCAL*/0)];
            y = data[index + (/*POLY_LOCAL*/0) + 1];
            data[index + (/*POLY_LOCAL*/0)]     = ((a * x) + (b * y) + tx);
            data[index + (/*POLY_LOCAL*/0) + 1] = ((c * x) + (d * y) + ty);
        }

        var radius = 0.0;
        var minProj = Number.POSITIVE_INFINITY;
        index = (/*POLY_VERTICES*/6);
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            x = data[index + (/*POLY_LOCAL*/0)];
            y = data[index + (/*POLY_LOCAL*/0) + 1];

            var next = (index + (/*POLY_STRIDE*/13));
            if (next === limit)
            {
                next = (/*POLY_VERTICES*/6);
            }

            var dx = -(data[next + (/*POLY_LOCAL*/0)]     - x);
            var dy = -(data[next + (/*POLY_LOCAL*/0) + 1] - y);
            var dL = Math.sqrt((dx * dx) + (dy * dy));
            var rec = (1 / dL);

            var nx = (-dy * rec);
            var ny = (dx * rec);

            data[index + (/*POLY_LNORMAL*/4)]     = nx;
            data[index + (/*POLY_LNORMAL*/4) + 1] = ny;
            data[index + (/*POLY_LENGTH*/12)] = dL;
            var lproj = data[index + (/*POLY_LPROJ*/8)] = ((nx * x) + (ny * y));

            var vlsq = ((x * x) + (y * y));
            if (vlsq > radius)
            {
                radius = vlsq;
            }
            if (lproj < minProj)
            {
                minProj = lproj;
            }
        }

        data[(/*SHAPE_SWEEP_RADIUS*/4)] = Math.sqrt(radius);
        data[(/*SHAPE_SWEEP_FACTOR*/5)] = (data[(/*SHAPE_SWEEP_RADIUS*/4)] - Math.max(minProj, 0));
        if (body)
        {
            body._invalidate();
        }
    },

    // ===========================================================================

    _update : function polygonUpdateFn(posX, posY, cos, sin, skipAABB)
    {
        var data = this._data;
        var limit = data.length;
        var index = (/*POLY_VERTICES*/6);
        var j;

        var minX, minY, maxX, maxY;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            // Compute world-space vertex.
            var x = data[index + (/*POLY_LOCAL*/0)];
            var y = data[index + (/*POLY_LOCAL*/0) + 1];
            var vX = data[index + (/*POLY_WORLD*/2)]     = posX + (cos * x) - (sin * y);
            var vY = data[index + (/*POLY_WORLD*/2) + 1] = posY + (sin * x) + (cos * y);

            // Compute world-space normal.
            x = data[index + (/*POLY_LNORMAL*/4)];
            y = data[index + (/*POLY_LNORMAL*/4) + 1];
            var nx = data[index + (/*POLY_WNORMAL*/6)]     = (cos * x) - (sin * y);
            var ny = data[index + (/*POLY_WNORMAL*/6) + 1] = (sin * x) + (cos * y);

            // Compute world-space projections.
            data[index + (/*POLY_WPROJ*/9)]   = (nx * vX) + (ny * vY);
            data[index + (/*POLY_CROSS1*/10)] = (nx * vY) - (ny * vX);
            if (index !== (/*POLY_VERTICES*/6))
            {
                j = index - (/*POLY_STRIDE*/13);
                data[j + (/*POLY_CROSS2*/11)] =
                    ((data[j + (/*POLY_WNORMAL*/6)]     * vY) -
                     (data[j + (/*POLY_WNORMAL*/6) + 1] * vX));

                if (!skipAABB)
                {
                    // Update partial AABB.
                    if (vX < minX)
                    {
                        minX = vX;
                    }
                    else if (vX > maxX)
                    {
                        maxX = vX;
                    }

                    if (vY < minY)
                    {
                        minY = vY;
                    }
                    else if (vY > maxY)
                    {
                        maxY = vY;
                    }
                }
            }
            else if (!skipAABB)
            {
                // Init. partial AABB.
                minX = maxX = vX;
                minY = maxY = vY;
            }
        }

        // Compute remaining projection
        index = (/*POLY_VERTICES*/6);
        j = data.length - (/*POLY_STRIDE*/13);
        data[j + (/*POLY_CROSS2*/11)] =
            ((data[j + (/*POLY_WNORMAL*/6)] * data[index + (/*POLY_WORLD*/2) + 1]) -
             (data[j + (/*POLY_WNORMAL*/6) + 1] * data[index + (/*POLY_WORLD*/2)]));

        if (!skipAABB)
        {
            // AABB
            data[(/*SHAPE_AABB*/0)]     = minX;
            data[(/*SHAPE_AABB*/0) + 1] = minY;
            data[(/*SHAPE_AABB*/0) + 2] = maxX;
            data[(/*SHAPE_AABB*/0) + 3] = maxY;
        }
    },

    _validate : function _validateFn(vertices)
    {
        var vCount = vertices.length;
        var data = this._data;

        // Avoid recreating array if number of vertices is unchanged!
        var newLimit = (/*POLY_VERTICES*/6) + (vCount * (/*POLY_STRIDE*/13));
        if (!data || newLimit !== data.length)
        {
            data = this._data = new Physics2DDevice.prototype.floatArray(newLimit);
        }

        var radius = 0.0;
        var minProj = Number.POSITIVE_INFINITY;

        var index = (/*POLY_VERTICES*/6);
        var i;
        for (i = 0; i < vCount; i += 1, index += (/*POLY_STRIDE*/13))
        {
            var v1 = vertices[i];
            var v2 = vertices[(i === (vCount - 1) ? 0 : (i + 1))];

            var x = v1[0];
            var y = v1[1];
            var dx = x - v2[0];
            var dy = y - v2[1];
            var dL = Math.sqrt((dx * dx) + (dy * dy));
            var rec = (1 / dL);

            var nx = (-dy * rec);
            var ny = (dx * rec);

            data[index + (/*POLY_LOCAL*/0)]       = x;
            data[index + (/*POLY_LOCAL*/0) + 1]   = y;
            data[index + (/*POLY_LNORMAL*/4)]     = nx;
            data[index + (/*POLY_LNORMAL*/4) + 1] = ny;
            data[index + (/*POLY_LENGTH*/12)] = dL;
            var lproj = data[index + (/*POLY_LPROJ*/8)] = ((nx * x) + (ny * y));

            // ---

            var vlsq = ((x * x) + (y * y));
            if (vlsq > radius)
            {
                radius = vlsq;
            }
            if (lproj < minProj)
            {
                minProj = lproj;
            }
        }

        data[(/*SHAPE_SWEEP_RADIUS*/4)] = Math.sqrt(radius);
        data[(/*SHAPE_SWEEP_FACTOR*/5)] = (data[(/*SHAPE_SWEEP_RADIUS*/4)] - Math.max(minProj, 0));
    }
};

// params = {
//      vertices : [v2, v2, ...]  (CLOCKWISE)
//      ... common shape props.
// }
// inVertices optionally replacing params.vertices
Physics2DPolygon.create = function polygon2DFn(params, inVertices)
{
    var p = new Physics2DPolygon();
    p._type = (/*TYPE_POLYGON*/1);
    Physics2DShape.prototype.init(p, params);

    p._validate(inVertices || params.vertices);
    return p;
};


// =========================================================================

//
// Physics2D Rigid Body
//

// BODY DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*BODY_IMASS*/0           // 1 / mass (possibly 0) for body. Always 0 for non-dynamic
///*BODY_IINERTIA*/1        // 1 / inertia (possibly 0) for body. Always 0 for non-dynamic
///*BODY_POS*/2             // World position and rotation (CW rad) of body (x, y, r)
///*BODY_AXIS*/5            // (cos(rotation), sin(rotation))
///*BODY_VEL*/7             // World velocity and ang.vel of body (vx, vy, w)
///*BODY_FORCE*/10          // World force + torque, persistently applied (fx, fy, t)
///*BODY_SURFACE_VEL*/13    // Surface velocity biasing contact physics (vt, vn)
///*BODY_PRE_POS*/15        // Previous position and rotation (x, y, r)
///*BODY_SWEEP_TIME*/18     // Time alpha for current partial integration of body.
///*BODY_RADIUS*/19         // Approximate radius of body about its origin.
///*BODY_SWEEP_ANGVEL*/20   // Angular velocity % (2 * pi / timeStep) for sweeps.
///*BODY_LIN_DRAG*/21       // Log of (1 - linear drag).
///*BODY_ANG_DRAG*/22       // Log of (1 - angular drag).
///*BODY_MASS*/23           // Untainted by body type mass.
///*BODY_INERTIA*/24        // Untainted by body type inertia.
//
///*BODY_DATA_SIZE*/25
//
// BODY TYPE CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*TYPE_DYNAMIC*/0
///*TYPE_KINEMATIC*/1
///*TYPE_STATIC*/2


function Physics2DRigidBody() {}
Physics2DRigidBody.prototype = {

    version : 1,

    isDynamic : function isDynamicFn()
    {
        return (this._type === (/*TYPE_DYNAMIC*/0));
    },

    setAsDynamic : function setAsDynamicFn()
    {
        if (this.world && this.world._midStep)
        {
            return;
        }

        this._setTypeValue((/*TYPE_DYNAMIC*/0));
        var data = this._data;

        var mass    = data[(/*BODY_MASS*/23)];
        var inertia = data[(/*BODY_INERTIA*/24)];
        data[(/*BODY_IMASS*/0)]    = (mass    === Number.POSITIVE_INFINITY ? 0 : (1 / mass));
        data[(/*BODY_IINERTIA*/1)] = (inertia === Number.POSITIVE_INFINITY ? 0 : (1 / inertia));
    },

    isStatic : function isStaticFn()
    {
        return (this._type === (/*TYPE_STATIC*/2));
    },

    setAsStatic : function setAsStaticFn()
    {
        if (this.world && this.world._midStep)
        {
            return;
        }

        this._setTypeValue((/*TYPE_STATIC*/2));
        var data = this._data;
        data[(/*BODY_IMASS*/0)] = data[(/*BODY_IINERTIA*/1)] = 0;
        // Static body cannot have velocity
        data[(/*BODY_VEL*/7)] = data[(/*BODY_VEL*/7) + 1] = data[(/*BODY_VEL*/7) + 2] = 0;
    },

    isKinematic : function isKinematicFn()
    {
        return (this._type === (/*TYPE_KINEMATIC*/1));
    },

    setAsKinematic : function setAsKinematicFn()
    {
        if (this.world && this.world._midStep)
        {
            return;
        }

        this._setTypeValue((/*TYPE_KINEMATIC*/1));
        var data = this._data;
        data[(/*BODY_IMASS*/0)] = data[(/*BODY_IINERTIA*/1)] = 0;
    },

    _setTypeValue : function _setTypeValueFn(newType)
    {
        if (newType === this._type)
        {
            return;
        }

        if (!this.world)
        {
            this._type = newType;
            return;
        }

        this.world._transmitBodyType(this, newType);
    },

    // ===============================================================================

    applyImpulse : function applyImpulse(impulse, position)
    {
        // Static cannot have velocity
        // Kinematic always has infinite mass/inertia (physics wise) so impulse has no effect.
        if (this._type !== (/*TYPE_DYNAMIC*/0))
        {
            return;
        }

        var data = this._data;
        var x, y;
        if (position)
        {
            x = (position[0] - data[(/*BODY_POS*/2)]);
            y = (position[1] - data[(/*BODY_POS*/2) + 1]);
        }
        else
        {
            x = 0;
            y = 0;
        }
        var ix = impulse[0];
        var iy = impulse[1];
        var im = data[(/*BODY_IMASS*/0)];
        data[(/*BODY_VEL*/7)]     += (ix * im);
        data[(/*BODY_VEL*/7) + 1] += (iy * im);
        data[(/*BODY_VEL*/7) + 2] += (((x * iy) - (y * ix)) * data[(/*BODY_IINERTIA*/1)]);
        this.wake(true);
    },

    setVelocityFromPosition : function setVelocityFromPositionFn(newPosition, newRotation, deltaTime)
    {
        if (this._type === (/*TYPE_STATIC*/2))
        {
            return;
        }

        var data = this._data;
        var idt = (1 / deltaTime);
        data[(/*BODY_VEL*/7)]     = ((newPosition[0] - data[(/*BODY_POS*/2)])     * idt);
        data[(/*BODY_VEL*/7) + 1] = ((newPosition[1] - data[(/*BODY_POS*/2) + 1]) * idt);
        data[(/*BODY_VEL*/7) + 2] = ((newRotation    - data[(/*BODY_POS*/2) + 2]) * idt);
        this.wake(true);
    },

    // ===============================================================================

    transformWorldPointToLocal : function transformWorldPointToLocalFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var cos = data[(/*BODY_AXIS*/5)];
        var sin = data[(/*BODY_AXIS*/5) + 1];
        var x = (src[0] - data[(/*BODY_POS*/2)]);
        var y = (src[1] - data[(/*BODY_POS*/2) + 1]);
        dst[0] = ((cos * x) + (sin * y));
        dst[1] = ((cos * y) - (sin * x));
        return dst;
    },

    transformWorldVectorToLocal : function transformWorldVectorToLocalFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var cos = data[(/*BODY_AXIS*/5)];
        var sin = data[(/*BODY_AXIS*/5) + 1];
        var x = src[0];
        var y = src[1];
        dst[0] = ((cos * x) + (sin * y));
        dst[1] = ((cos * y) - (sin * x));
        return dst;
    },

    transformLocalPointToWorld : function transformLocalPointToWorldFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var cos = data[(/*BODY_AXIS*/5)];
        var sin = data[(/*BODY_AXIS*/5) + 1];
        var x = src[0];
        var y = src[1];
        dst[0] = ((cos * x) - (sin * y) + data[(/*BODY_POS*/2)]);
        dst[1] = ((sin * x) + (cos * y) + data[(/*BODY_POS*/2) + 1]);
        return dst;
    },

    transformLocalVectorToWorld : function transformLocalVectorToWorldFn(src, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        var cos = data[(/*BODY_AXIS*/5)];
        var sin = data[(/*BODY_AXIS*/5) + 1];
        var x = src[0];
        var y = src[1];
        dst[0] = ((cos * x) - (sin * y));
        dst[1] = ((sin * x) + (cos * y));
        return dst;
    },

    // ===============================================================================

    getPosition : function getPositionFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }

        var data = this._data;
        dst[0] = data[(/*BODY_POS*/2)];
        dst[1] = data[(/*BODY_POS*/2) + 1];
        return dst;
    },

    setPosition : function setPosition(position)
    {
        if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/2)))
        {
            return;
        }

        var data = this._data;
        var newX = position[0];
        var newY = position[1];
        if ((data[(/*BODY_POS*/2)] !== newX) || (data[(/*BODY_POS*/2) + 1] !== newY))
        {
            data[(/*BODY_POS*/2)]     = newX;
            data[(/*BODY_POS*/2) + 1] = newY;
            this._invalidated = true;
            this.wake(true);
        }
    },

    getRotation : function getRotationFn()
    {
        return this._data[(/*BODY_POS*/2) + 2];
    },

    setRotation : function setRotationFn(rotation)
    {
        if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/2)))
        {
            return;
        }

        var data = this._data;
        if (data[(/*BODY_POS*/2) + 2] !== rotation)
        {
            this._data[(/*BODY_POS*/2) + 2]  = rotation;
            this._data[(/*BODY_AXIS*/5)]     = Math.cos(rotation);
            this._data[(/*BODY_AXIS*/5) + 1] = Math.sin(rotation);
            this._invalidated = true;
            this.wake(true);
        }
    },

    // ===============================================================================

    getVelocity : function getVelocityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }

        var data = this._data;
        dst[0] = data[(/*BODY_VEL*/7)];
        dst[1] = data[(/*BODY_VEL*/7) + 1];
        return dst;
    },

    setVelocity : function setVelocity(velocity)
    {
        // Static body cannot have velocity.
        if (this._type === (/*TYPE_STATIC*/2))
        {
            return;
        }

        var data = this._data;
        var newX = velocity[0];
        var newY = velocity[1];
        if ((data[(/*BODY_VEL*/7)] !== newX) || (data[(/*BODY_VEL*/7) + 1] !== newY))
        {
            data[(/*BODY_VEL*/7)]     = newX;
            data[(/*BODY_VEL*/7) + 1] = newY;
            this.wake(true);
        }
    },

    getAngularVelocity : function getAngularVelocity()
    {
        return this._data[(/*BODY_VEL*/7) + 2];
    },

    setAngularVelocity : function setAngularVelocityFn(angularVelocity)
    {
        // Static body cannot have velocity.
        if (this._type === (/*TYPE_STATIC*/2))
        {
            return;
        }

        var data = this._data;
        if (data[(/*BODY_VEL*/7) + 2] !== angularVelocity)
        {
            data[(/*BODY_VEL*/7) + 2] = angularVelocity;
            this.wake(true);
        }
    },

    // ===============================================================================

    getForce : function getForceFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }

        var data = this._data;
        dst[0] = data[(/*BODY_FORCE*/10)];
        dst[1] = data[(/*BODY_FORCE*/10) + 1];
        return dst;
    },

    setForce : function setForce(force)
    {
        var data = this._data;
        var newX = force[0];
        var newY = force[1];
        if ((data[(/*BODY_FORCE*/10)] !== newX) || (data[(/*BODY_FORCE*/10) + 1] !== newY))
        {
            data[(/*BODY_FORCE*/10)]     = newX;
            data[(/*BODY_FORCE*/10) + 1] = newY;
            // we wake static/kinematic bodies even if force has no effect
            // incase user has some crazy callback that queries force to
            // make a decision
            this.wake(true);
        }
    },

    getTorque : function getTorque()
    {
        return this._data[(/*BODY_FORCE*/10) + 2];
    },

    setTorque : function setTorqueFn(torque)
    {
        var data = this._data;
        if (data[(/*BODY_FORCE*/10) + 2] !== torque)
        {
            data[(/*BODY_FORCE*/10) + 2] = torque;
            // we wake static/kinematic bodies even if force has no effect
            // incase user has some crazy callback that queries torque to
            // make a decision
            this.wake(true);
        }
    },

    // ===============================================================================

    getSurfaceVelocity : function getSurfaceVelocity(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }

        var data = this._data;
        dst[0] = data[(/*BODY_SURFACE_VEL*/13)];
        dst[1] = data[(/*BODY_SURFACE_VEL*/13) + 1];
        return dst;
    },

    setSurfaceVelocity : function setSurfaceVelocity(surfaceVelocity)
    {
        var data = this._data;
        data[(/*BODY_SURFACE_VEL*/13)]     = surfaceVelocity[0];
        data[(/*BODY_SURFACE_VEL*/13) + 1] = surfaceVelocity[1];
        this.wake(true);
    },

    // ===============================================================================

    getMass : function getMassFn()
    {
        return this._data[(/*BODY_MASS*/23)];
    },

    getInertia : function getInertiaFn()
    {
        return this._data[(/*BODY_INERTIA*/24)];
    },

    setMass : function setMassFn(mass)
    {
        var data = this._data;
        var oldMass = data[(/*BODY_MASS*/23)];
        if (!this._customMass || (oldMass !== mass))
        {
            data[(/*BODY_MASS*/23)] = mass;
            this._customMass = true;
            this._invalidateMassInertia();
        }
    },

    setMassFromShapes : function setMassFromShapesFn()
    {
        if (this._customMass)
        {
            this._customMass = false;
            this._data[(/*BODY_MASS*/23)] = this.computeMassFromShapes();
            this._invalidateMassInertia();
        }
    },

    setInertia : function setInertiaFn(inertia)
    {
        var data = this._data;
        var oldInertia = data[(/*BODY_INERTIA*/24)];
        if (!this._customInertia || (oldInertia !== inertia))
        {
            data[(/*BODY_INERTIA*/24)] = inertia;
            this._customInertia = true;
            this._invalidateMassInertia();
        }
    },

    setInertiaFromShapes : function setInertiaFromShapesFn()
    {
        if (this._customInertia)
        {
            this._customInertia = false;
            this._data[(/*BODY_INERTIA*/24)] = this.computeInertiaFromShapes();
            this._invalidateMassInertia();
        }
    },

    _invalidateMassInertia : function _invalidateMassInertiaFn()
    {
        var data = this._data;
        var mass    = data[(/*BODY_MASS*/23)];
        var inertia = data[(/*BODY_INERTIA*/24)];

        var staticType = (this._type !== (/*TYPE_DYNAMIC*/0));
        var inf = Number.POSITIVE_INFINITY;
        data[(/*BODY_IMASS*/0)]    = (staticType || mass    === inf) ? 0 : (1 / mass);
        data[(/*BODY_IINERTIA*/1)] = (staticType || inertia === inf) ? 0 : (1 / inertia);

        // We wake body, even if static/kinematic incase user has some crazy
        // callback which queries mass/inertia to make decision
        this.wake(true);
    },

    // ===============================================================================

    getLinearDrag : function getLinearDragFn()
    {
        return (1 - Math.exp(this._data[(/*BODY_LIN_DRAG*/21)]));
    },

    setLinearDrag : function setLinearDragFn(linearDrag)
    {
        this._data[(/*BODY_LIN_DRAG*/21)] = Math.log(1 - linearDrag);
        // We wake body, even if static/kinematic incase user has some crazy
        // callback which queries mass/inertia to make decision
        this.wake(true);
    },

    getAngularDrag : function getAngularDragFn()
    {
        return (1 - Math.exp(this._data[(/*BODY_ANG_DRAG*/22)]));
    },

    setAngularDrag : function setAngularDragFn(angularDrag)
    {
        this._data[(/*BODY_ANG_DRAG*/22)] = Math.log(1 - angularDrag);
        // We wake body, even if static/kinematic incase user has some crazy
        // callback which queries mass/inertia to make decision
        this.wake(true);
    },

    // ===============================================================================

    addShape : function addShapeFn(shape)
    {
        if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/2)))
        {
            return false;
        }

        if (shape.body)
        {
            return false;
        }

        shape.body = this;
        this.shapes.push(shape);

        if (this.world)
        {
            this.wake(true);
            this.world._addShape(shape);
        }

        // Recompute body radius
        var rad = shape._data[(/*SHAPE_SWEEP_RADIUS*/4)];
        var data = this._data;
        if (rad > data[(/*BODY_RADIUS*/19)])
        {
            data[(/*BODY_RADIUS*/19)] = rad;
        }

        this._invalidate();

        return true;
    },

    removeShape : function removeShapeFn(shape)
    {
        if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/2)))
        {
            return false;
        }

        if (shape.body !== this)
        {
            return false;
        }

        if (this.world)
        {
            this.wake(true);
            this.world._removeShape(shape);
        }

        shape.body = null;
        var shapes = this.shapes;
        var limit = (shapes.length - 1);
        var index = shapes.indexOf(shape);
        shapes[index] = shapes[limit];
        shapes.pop();

        // Recompute body radius.
        var i;
        var radius = 0;
        for (i = 0; i < limit; i += 1)
        {
            shape = shapes[i];
            var rad = shape._data[(/*SHAPE_SWEEP_RADIUS*/4)];
            if (rad > radius)
            {
                radius = rad;
            }
        }
        this._data[(/*BODY_RADIUS*/19)] = radius;

        this._invalidate();

        return true;
    },

    // ===============================================================================

    computeMassFromShapes : function computeMassFromShapesFn()
    {
        var mass = 0;
        var i;
        var shapes = this.shapes;
        var limit = shapes.length;
        for (i = 0; i < limit; i += 1)
        {
            var shape = shapes[i];
            mass += shape._material._data[(/*MAT_DENSITY*/4)] * shape.computeArea();
        }
        return mass;
    },

    computeInertiaFromShapes : function computeInertiaFromShapesFn()
    {
        var inertia = 0;
        var i;
        var shapes = this.shapes;
        var limit = shapes.length;
        for (i = 0; i < limit; i += 1)
        {
            var shape = shapes[i];
            inertia += shape._material._data[(/*MAT_DENSITY*/4)] * shape.computeMasslessInertia() * shape.computeArea();
        }
        return inertia;
    },

    // ===============================================================================

    wake : function wakeFn(automated)
    {
        if (!this.world)
        {
            this.sleeping = false;
            return;
        }

        this.world._wakeBody(this, !automated);
    },

    sleep : function sleepFn()
    {
        if (!this.world)
        {
            this.sleeping = true;
            return;
        }

        this.world._forceSleepBody(this);
    },

    // ===============================================================================

    computeLocalCenterOfMass : function computeLocalCenterOfMassFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var comX = 0;
        var comY = 0;
        var totalMass = 0;

        var shapes = this.shapes;
        var limit = shapes.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var shape = shapes[i];
            shape.computeCenterOfMass(dst);
            var mass = shape.computeArea() * shape._material._data[(/*MAT_DENSITY*/4)];
            comX += (dst[0] * mass);
            comY += (dst[1] * mass);
            totalMass += mass;
        }

        var imass = (1 / totalMass);
        dst[0] = (comX * imass);
        dst[1] = (comY * imass);
        return dst;
    },

    computeWorldBounds : function computeWorldBoundsFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(4);
        }
        var inf = Number.POSITIVE_INFINITY;
        var minX = inf;
        var minY = inf;
        var maxX = -inf;
        var maxY = -inf;

        this._update();
        var shapes = this.shapes;
        var limit = shapes.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var shape = shapes[i]._data;
            var x0 = shape[(/*SHAPE_AABB*/0)];
            var y0 = shape[(/*SHAPE_AABB*/0) + 1];
            var x1 = shape[(/*SHAPE_AABB*/0) + 2];
            var y1 = shape[(/*SHAPE_AABB*/0) + 3];
            if (x0 < minX)
            {
                minX = x0;
            }
            if (x1 > maxX)
            {
                maxX = x1;
            }
            if (y0 < minY)
            {
                minY = y0;
            }
            if (y1 > maxY)
            {
                maxY = y1;
            }
        }

        dst[0] = minX;
        dst[1] = minY;
        dst[2] = maxX;
        dst[3] = maxY;
        return dst;
    },

    // ===============================================================================

    alignWithOrigin : function alignWithOriginFn()
    {
        if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/2)))
        {
            return;
        }

        var negCOM = this.computeLocalCenterOfMass();
        negCOM[0] *= -1;
        negCOM[1] *= -1;

        var shapes = this.shapes;
        var limit = shapes.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            shapes[i].translate(negCOM, true);
        }
        this._invalidate();
    },

    // ===============================================================================

    _invalidate : function _invalidateFn()
    {
        this._invalidated = true;

        var customMass    = this._customMass;
        var customInertia = this._customInertia;
        if ((!customMass) || (!customInertia))
        {
            if (!customMass)
            {
                this._data[(/*BODY_MASS*/23)] = this.computeMassFromShapes();
            }
            if (!customInertia)
            {
                this._data[(/*BODY_INERTIA*/24)] = this.computeInertiaFromShapes();
            }

            this._invalidateMassInertia();
        }

        this.wake(true);
    },

    _update : function _updateFn()
    {
        if (this._invalidated)
        {
            this._invalidated = false;
            var data = this._data;
            var shapes = this.shapes;
            var limit = shapes.length;
            var i;
            for (i = 0; i < limit; i += 1)
            {
                shapes[i]._update(
                    data[(/*BODY_POS*/2)],
                    data[(/*BODY_POS*/2) + 1],
                    data[(/*BODY_AXIS*/5)],
                    data[(/*BODY_AXIS*/5) + 1]
                );
            }
        }
    },

    // =====================================================================

    _atRest : function _atRestFn(deltaTime, timeStamp)
    {
        if (this._type !== (/*TYPE_DYNAMIC*/0))
        {
            return this.sleeping;
        }
        else
        {
            var data = this._data;
            var canSleep;

            do {
                var x = data[(/*BODY_VEL*/7)];
                var y = data[(/*BODY_VEL*/7) + 1];
                var conf = Physics2DConfig.SLEEP_LINEAR_SQ;
                if (((x * x) + (y * y)) > conf)
                {
                    canSleep = false;
                    break;
                }

                x = (data[(/*BODY_POS*/2)]     - data[(/*BODY_PRE_POS*/15)]);
                y = (data[(/*BODY_POS*/2) + 1] - data[(/*BODY_PRE_POS*/15) + 1]);
                var threshold = (deltaTime * deltaTime * conf);
                if (((x * x) + (y * y)) > threshold)
                {
                    canSleep = false;
                    break;
                }

                y = data[(/*BODY_RADIUS*/19)];
                x = data[(/*BODY_VEL*/7) + 2] * y;
                conf = Physics2DConfig.SLEEP_ANGULAR_SQ;
                if ((x * x) > conf)
                {
                    canSleep = false;
                    break;
                }

                x = (data[(/*BODY_POS*/2) + 2] - data[(/*BODY_PRE_POS*/15) + 2]) * y;
                threshold = (deltaTime * deltaTime * conf);
                canSleep = (x * x <= threshold);
            }
            while (false);

            if (!canSleep)
            {
                this._wakeTime = timeStamp;
                return false;
            }
            else
            {
                return ((this._wakeTime + Physics2DConfig.SLEEP_DELAY) < timeStamp);
            }
        }
    },

    // =====================================================================

    _deltaRotation : function _deltaRotationFn(delta)
    {
        var data = this._data;
        var rotation = (data[(/*BODY_POS*/2) + 2] += delta);
        if ((delta * delta) > Physics2DConfig.DELTA_ROTATION_EPSILON)
        {
            data[(/*BODY_AXIS*/5)]     = Math.cos(rotation);
            data[(/*BODY_AXIS*/5) + 1] = Math.sin(rotation);
        }
        else
        {
            // approximation of axis rotation
            // p, delta provide small angle approximations
            // whilst m provides an approximation to 1/|axis| after
            // the small angle rotation approximation, so as to
            // approximate the the normalization and hugely reduce
            // errors over many calls
            //
            // in testing even with an epsilon above of 0.01
            // the error in the axis is limited to 0.00002 after 100
            // updates.
            //
            // each update of the world, sin/cos is recomputed fully
            // so the accumulate error here is limited to a single step
            // and is really, very, very small.
            var d2 = (delta * delta);
            var p = (1 - (0.5 * d2));
            var m = (1 - (d2 * d2 * 0.125));

            var cos = data[(/*BODY_AXIS*/5)];
            var sin = data[(/*BODY_AXIS*/5) + 1];

            var nSin = ((p * sin) + (delta * cos)) * m;
            var nCos = ((p * cos) - (delta * sin)) * m;
            data[(/*BODY_AXIS*/5)]     = nCos;
            data[(/*BODY_AXIS*/5) + 1] = nSin;
        }
        return rotation;
    },

    // Integrate to deltaTime from current sweepTime (back or forth).
    _sweepIntegrate : function _sweepIntegrateFn(deltaTime)
    {
        var data = this._data;
        var delta = (deltaTime - data[(/*BODY_SWEEP_TIME*/18)]);
        if (delta !== 0)
        {
            data[(/*BODY_SWEEP_TIME*/18)] = deltaTime;
            data[(/*BODY_POS*/2)]     += (data[(/*BODY_VEL*/7)]     * delta);
            data[(/*BODY_POS*/2) + 1] += (data[(/*BODY_VEL*/7) + 1] * delta);

            var angVel = data[(/*BODY_SWEEP_ANGVEL*/20)];
            if (angVel !== 0)
            {
                this._deltaRotation(data[(/*BODY_SWEEP_ANGVEL*/20)] * delta);
            }
        }
    },

    integrate : function integrateFn(deltaTime)
    {
        if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/2)))
        {
            return;
        }

        var data = this._data;
        data[(/*BODY_SWEEP_TIME*/18)] = 0;
        data[(/*BODY_SWEEP_ANGVEL*/20)] = data[(/*BODY_VEL*/7) + 2];
        this._sweepIntegrate(deltaTime);
        data[(/*BODY_SWEEP_TIME*/18)] = 0;
        this._invalidated = true;
        this.wake(true);
    },

    // ==========================================================

    addEventListener : function bodyAddEventListener(eventType, callback)
    {
        var events = (eventType === 'wake'  ? this._onWake  :
                      eventType === 'sleep' ? this._onSleep :
                      null);

        if (events === null)
        {
            return false;
        }

        var index = events.indexOf(callback);
        if (index !== -1)
        {
            return false;
        }

        events.push(callback);

        this.wake();

        return true;
    },

    removeEventListener : function removeEventListener(eventType, callback)
    {
        var events = (eventType === 'wake'  ? this._onWake  :
                      eventType === 'sleep' ? this._onSleep :
                      null);

        if (events === null)
        {
            return false;
        }

        var index = events.indexOf(callback);
        if (index === -1)
        {
            return false;
        }

        // Need to keep order, cannot use swap-pop
        events.splice(index, 1);

        this.wake();

        return true;
    }
};


// params = {
//      shapes : [...],
//      mass : [...] = computed from shapes + type
//      inertia : [...] = computed from shapes + type
//      type : 'static', 'kinematic', 'dynamic' = 'kinematic'
//      sleeping : = false,
//      force : [, ] = [0,0],
//      torque : = 0
//      position : [...] = [0,0],
//      rotation : = 0
//      surfaceVelocity = [0,0]
//      velocity : = [0,0],
//      angularVelocity : = 0,
//      bullet = false,
//      linearDrag = 0.05,
//      angularDrag = 0.05
// }
Physics2DRigidBody.create = function phys2DRigidBodyFn(params)
{
    var b = new Physics2DRigidBody();
    var data = b._data = new Physics2DDevice.prototype.floatArray((/*BODY_DATA_SIZE*/25));

    var inf = Number.POSITIVE_INFINITY;

    b._type = (params.type === 'dynamic'   ? (/*TYPE_DYNAMIC*/0) :
               params.type === 'static'    ? (/*TYPE_STATIC*/2) :
               params.type === 'kinematic' ? (/*TYPE_KINEMATIC*/1) :
               (/*TYPE_DYNAMIC*/0));

    var shapes = params.shapes;
    b.shapes = [];
    b.constraints = [];
    b.world = null;

    var radius = 0;
    if (shapes)
    {
        var limit = shapes.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var shape = shapes[i];
            if (shape.body === b)
            {
                continue;
            }

            shape.body = b;
            b.shapes.push(shape);

            var rad = shape._data[(/*SHAPE_SWEEP_RADIUS*/4)];
            if (rad > radius)
            {
                radius = rad;
            }
        }
    }

    data[(/*BODY_RADIUS*/19)] = radius;

    b._customMass    = (params.mass    !== undefined);
    b._customInertia = (params.inertia !== undefined);
    var mass    = (b._customMass    ? params.mass    : b.computeMassFromShapes());
    var inertia = (b._customInertia ? params.inertia : b.computeInertiaFromShapes());

    var isDynamic = (b._type === (/*TYPE_DYNAMIC*/0));
    var isStatic  = (b._type === (/*TYPE_STATIC*/2));

    data[(/*BODY_IMASS*/0)]    = ((!isDynamic) || mass    === inf) ? 0 : (1 / mass);
    data[(/*BODY_IINERTIA*/1)] = ((!isDynamic) || inertia === inf) ? 0 : (1 / inertia);
    data[(/*BODY_MASS*/23)]    = mass;
    data[(/*BODY_INERTIA*/24)] = inertia;

    var vec = params.position;
    var x = data[(/*BODY_POS*/2)]       = (vec ? vec[0] : 0);
    var y = data[(/*BODY_POS*/2) + 1]   = (vec ? vec[1] : 0);
    var rot = data[(/*BODY_POS*/2) + 2] = (params.rotation || 0);

    data[(/*BODY_AXIS*/5)]     = Math.cos(rot);
    data[(/*BODY_AXIS*/5) + 1] = Math.sin(rot);

    data[(/*BODY_PRE_POS*/15)]     = x;
    data[(/*BODY_PRE_POS*/15) + 1] = y;
    data[(/*BODY_PRE_POS*/15) + 2] = rot;

    vec = params.velocity;
    data[(/*BODY_VEL*/7)]     = (((!isStatic) && vec) ? vec[0] : 0);
    data[(/*BODY_VEL*/7) + 1] = (((!isStatic) && vec) ? vec[1] : 0);
    data[(/*BODY_VEL*/7) + 2] = (((!isStatic) && params.angularVelocity) || 0);

    vec = params.force;
    data[(/*BODY_FORCE*/10)]     = (vec ? vec[0] : 0);
    data[(/*BODY_FORCE*/10) + 1] = (vec ? vec[1] : 0);
    data[(/*BODY_FORCE*/10) + 2] = (params.torque || 0);

    vec = params.surfaceVelocity;
    data[(/*BODY_SURFACE_VEL*/13)]     = (vec ? vec[0] : 0);
    data[(/*BODY_SURFACE_VEL*/13) + 1] = (vec ? vec[1] : 0);

    b.sleeping = (params.sleeping || false);
    b.bullet = (params.bullet || false);

    // Static/kinematic always 'frozen'
    b._sweepFrozen = (b._type !== (/*TYPE_DYNAMIC*/0));
    b._deferred = false;

    b._island = null;
    b._islandRank = 0;
    b._islandRoot = null;

    b._isBody = true;
    b._wakeTime = 0;
    b._woken = false; // for deferred WAKE callbacks.

    b._invalidated = true;

    data[(/*BODY_LIN_DRAG*/21)] = Math.log(1 - (params.linearDrag  !== undefined ? params.linearDrag  : 0.05));
    data[(/*BODY_ANG_DRAG*/22)] = Math.log(1 - (params.angularDrag !== undefined ? params.angularDrag : 0.05));

    b.userData = (params.userData || null);

    b._onWake = [];
    b._onSleep = [];

    return b;
};


// =====================================================================

//
// Physics2D Callback
//

// EVENT TYPES
// !! Must use regexp to change these globally (in all files) !!
//
// (Order here is used to order deferred event dispatch)
///*EVENT_WAKE*/0
///*EVENT_BEGIN*/1
///*EVENT_PROGRESS*/2
///*EVENT_END*/3
///*EVENT_SLEEP*/4
///*EVENT_BREAK*/5
//
// (not deferred)
///*EVENT_PRESOLVE*/6

///*EVENT_TIME_PRE*/-1
///*EVENT_TIME_STANDARD*/0
///*EVENT_TIME_CONTINUOUS*/1

function Physics2DCallback() {
    // All events
    this.thisObject = null;
    this.callback = null;

    // Used to ensure time ordering of deferred events.
    // -1 if event corresponds to action performed before step()
    // 0  if event is a standard event during step()
    // 1  if event is result of a continuous collision during step()
    this.time = 0;

    // Interaction events
    this.index = 0;
    this.arbiter = null;

    this.next = null;
}
// Object pooled;
Physics2DCallback.pool = null;
Physics2DCallback.allocate = function ()
{
    if (Physics2DCallback.pool)
    {
        var ret = Physics2DCallback.pool;
        Physics2DCallback.pool = ret.next;
        ret.next = null;
        return ret;
    }
    else
    {
        return (new Physics2DCallback());
    }
};

Physics2DCallback.deallocate = function (callback)
{
    callback.next = Physics2DCallback.pool;
    Physics2DCallback.pool = callback;

    callback.thisObject = null;
    callback.callback = null;
    callback.arbiter = null;
};

// =====================================================================

//
// Physics2D Island
//
function Physics2DIsland() {
    this.components = [];
    this.sleeping = false;
    this.wakeTime = 0;
    this.next = null;
}
// Object pooled.
Physics2DIsland.pool = null;
Physics2DIsland.allocate = function ()
{
    if (Physics2DIsland.pool)
    {
        var ret = Physics2DIsland.pool;
        Physics2DIsland.pool = ret.next;
        ret.next = null;
        return ret;
    }
    else
    {
        return (new Physics2DIsland());
    }
};

Physics2DIsland.deallocate = function (island)
{
    island.next = Physics2DIsland.pool;
    Physics2DIsland.pool = island;
    island.wakeTime = 0;
};


// =====================================================================

//
// Physics2D TOI Event
//

// TOI DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*TOI_AXIS*/0       - seperating/MTV axis (x, y)
///*TOI_WITNESS_A*/2  - witness on shape A (x, y)
///*TOI_WITNESS_B*/4  - witness on shape B (x, y)
///*TOI_TOI_ALPHA*/6  - time of impact.
//
///*TOI_DATA_SIZE*/7

function Physics2DTOIEvent() {
    this.next = null;
    this.shapeA = null;
    this.shapeB = null;
    this.frozenA = this.frozenB = false;
    this.arbiter = null;
    this.failed = false;
    this.slipped = false;
    this._data = new Physics2DDevice.prototype.floatArray((/*TOI_DATA_SIZE*/7));
}

// Object pooled.
Physics2DTOIEvent.pool = null;
Physics2DTOIEvent.allocate = function ()
{
    if (Physics2DTOIEvent.pool)
    {
        var ret = Physics2DTOIEvent.pool;
        Physics2DTOIEvent.pool = ret.next;
        ret.next = null;
        return ret;
    }
    else
    {
        return (new Physics2DTOIEvent());
    }
};

Physics2DTOIEvent.deallocate = function (toi)
{
    toi.next = Physics2DTOIEvent.pool;
    Physics2DTOIEvent.pool = toi;

    toi.shapeA = toi.shapeB = null;
    toi.failed = false;
    toi.slipped = false;
    toi.arbiter = null;
};


// =====================================================================

//
// Physics2D Box Tree Broadphase
//
function Physics2DBoxTreeBroadphaseHandle()
{
    this.boxTreeIndex = -1;

    this.data = null;
    this.isStatic = false;
}

Physics2DBoxTreeBroadphaseHandle.pool = [];
Physics2DBoxTreeBroadphaseHandle.allocate = function allocateBTHandle()
{
    if (0 < this.pool.length)
    {
        return this.pool.pop();
    }
    else
    {
        return new Physics2DBoxTreeBroadphaseHandle();
    }
};

Physics2DBoxTreeBroadphaseHandle.deallocate = function deallocateBTHandle(handle)
{
    this.pool.push(handle);

    handle.data = null;
};


function Physics2DBoxTreeBroadphase()
{
    this.staticTree = BoxTree.create(true);
    this.dynamicTree = BoxTree.create(false);
    this.overlappingNodes = [];
}

Physics2DBoxTreeBroadphase.prototype = {

    version : 1,

    sample : function sampleFn(box, lambda, thisObject)
    {
        var overlappingNodes = this.overlappingNodes;

        var numOverlappingNodes = this.staticTree.getOverlappingNodes(box, overlappingNodes, 0);
        numOverlappingNodes += this.dynamicTree.getOverlappingNodes(box, overlappingNodes, numOverlappingNodes);

        var n;
        for (n = 0; n < numOverlappingNodes; n += 1)
        {
            lambda.call(thisObject, overlappingNodes[n], box);
        }
    },

    insert : function insertFn(data, box, isStatic)
    {
        var handle = Physics2DBoxTreeBroadphaseHandle.allocate();
        handle.data = data;
        handle.isStatic = isStatic;

        if (isStatic)
        {
            this.staticTree.add(handle, box);
        }
        else
        {
            this.dynamicTree.add(handle, box);
        }

        return handle;
    },

    update : function updateFn(handle, box, isStatic)
    {
        if (isStatic !== undefined &&
            handle.isStatic !== isStatic)
        {
            if (handle.isStatic)
            {
                this.staticTree.remove(handle);
                this.dynamicTree.add(handle, box);
            }
            else
            {
                this.dynamicTree.remove(handle);
                this.staticTree.add(handle, box);
            }
            handle.isStatic = isStatic;
        }
        else
        {
            if (isStatic)
            {
                this.staticTree.update(handle, box);
            }
            else
            {
                this.dynamicTree.update(handle, box);
            }
        }
    },

    remove : function removeFn(handle)
    {
        if (handle.isStatic)
        {
            this.staticTree.remove(handle);
        }
        else
        {
            this.dynamicTree.remove(handle);
        }

        Physics2DBoxTreeBroadphaseHandle.deallocate(handle);
    },

    clear : function clearFn(callback, thisObject)
    {
        this._clearTree(this.staticTree, callback, thisObject);
        this._clearTree(this.dynamicTree, callback, thisObject);
    },

    _clearTree : function _clearTreeFn(tree, callback, thisObject)
    {
        var nodes = tree.getNodes();
        var numNodes = nodes.length;
        var n;
        for (n = 0; n < numNodes; n += 1)
        {
            var handle = nodes[n].externalNode;
            if (handle)
            {
                if (callback)
                {
                    callback.call(thisObject, handle);
                }
                Physics2DBoxTreeBroadphaseHandle.deallocate(handle);
            }
        }
        tree.clear();
    },

    _validate : function validateFn()
    {
        this.staticTree.finalize();
        this.dynamicTree.finalize();
    },

    perform : function performFn(lambda, thisObject)
    {
        this._validate();

        var overlappingNodes = this.overlappingNodes;

        var staticTree = this.staticTree;
        var dynamicTree = this.dynamicTree;

        var dynamicNodes = dynamicTree.getNodes();
        var numDynamicNodes = dynamicNodes.length;
        var n;
        for (n = 0; n < numDynamicNodes; n += 1)
        {
            var dynamicNode = dynamicNodes[n];
            var handle = dynamicNode.externalNode;
            if (handle)
            {
                var numOverlappingNodes = staticTree.getOverlappingNodes(dynamicNode.extents,
                                                                         overlappingNodes,
                                                                         0);
                var i;
                for (i = 0; i < numOverlappingNodes; i += 1)
                {
                    lambda.call(thisObject, handle, overlappingNodes[i]);
                }
            }
        }

        var numPairs = dynamicTree.getOverlappingPairs(overlappingNodes, 0);
        for (n = 0; n < numPairs; n += 2)
        {
            lambda.call(thisObject, overlappingNodes[n], overlappingNodes[n + 1]);
        }
    }
};

Physics2DBoxTreeBroadphase.create = function phys2DSAPFn()
{
    return new Physics2DBoxTreeBroadphase();
};

// =====================================================================

//
// Physics2D 1D (x) Sweep and Prune Broadphase
//
function Physics2DSweepAndPruneHandle() {
    this._next = null;
    this._prev = null;
    this._aabb = new Physics2DDevice.prototype.floatArray(4);

    this.data = null;
    this.isStatic = false;
}

Physics2DSweepAndPruneHandle.pool = null;
Physics2DSweepAndPruneHandle.allocate = function allocateSAPHandle()
{
    if (!this.pool)
    {
        return new Physics2DSweepAndPruneHandle();
    }
    else
    {
        var ret = this.pool;
        this.pool = ret._next;
        ret._next = null;
        return ret;
    }
};

Physics2DSweepAndPruneHandle.deallocate = function deallocateSAPHandle(handle)
{
    handle._prev = null;
    handle._next = this.pool;
    this.pool = handle;

    handle.data = null;
};


function Physics2DSweepAndPrune() {}
Physics2DSweepAndPrune.prototype = {

    version : 1,

    sample : function sampleFn(rectangle, lambda, thisObject)
    {
        var minX = rectangle[0];
        var minY = rectangle[1];
        var maxX = rectangle[2];
        var maxY = rectangle[3];

        this._validate();

        var d1 = this._list;
        while (d1)
        {
            var aabb = d1._aabb;
            // Slip element preceeding rectangle.
            if (aabb[2] < minX)
            {
                d1 = d1._next;
                continue;
            }

            // Discard all list proceeding rectangle.
            if (aabb[0] > maxX)
            {
                break;
            }

            // Full AABB check (only y-check needed)
            if (aabb[1] <= maxY &&
                minY <= aabb[3])
            {
                lambda.call(thisObject, d1, rectangle);
            }
            d1 = d1._next;
        }
    },

    insert : function insertFn(data, aabb, isStatic)
    {
        var handle = Physics2DSweepAndPruneHandle.allocate();
        var ab = handle._aabb;
        ab[0] = aabb[0];
        ab[1] = aabb[1];
        ab[2] = aabb[2];
        ab[3] = aabb[3];

        handle.data = data;
        handle.isStatic = isStatic;

        // Insert at beginning, let broadphase update deal with it.
        var list = this._list;
        handle._next = list;
        if (list)
        {
            list._prev = handle;
        }
        this._list = handle;

        return handle;
    },

    update : function updateFn(handle, aabb, isStatic)
    {
        var ab = handle._aabb;
        ab[0] = aabb[0];
        ab[1] = aabb[1];
        ab[2] = aabb[2];
        ab[3] = aabb[3];

        // Not used in this broadphase, but must provide consistency
        if (isStatic !== undefined)
        {
            handle.isStatic = isStatic;
        }
    },

    remove : function removeFn(handle)
    {
        if (!handle._prev)
        {
            this._list = handle._next;
        }
        else
        {
            handle._prev._next = handle._next;
        }

        if (handle._next)
        {
            handle._next._prev = handle._prev;
        }

        Physics2DSweepAndPruneHandle.deallocate(handle);
    },

    clear : function clearFn(callback, thisObject)
    {
        var handle = this._list;
        while (handle)
        {
            var next = handle._next;
            if (callback)
            {
                callback.call(thisObject, handle);
            }
            Physics2DSweepAndPruneHandle.deallocate(handle);
            handle = next;
        }
        this._list = null;
    },

    _validate : function validateFn()
    {
        if (!this._list)
        {
            return;
        }

        var a = this._list._next;
        while (a)
        {
            var next = a._next;
            var b = a._prev;

            var aMinX = a._aabb[0];
            if (aMinX > b._aabb[0])
            {
                // Nothing to do.
                a = next;
                continue;
            }

            // Find insertion point.
            while (b._prev && b._prev._aabb[0] > aMinX)
            {
                b = b._prev;
            }

            // Remove a
            var prev = a._prev;
            prev._next = next;
            if (next)
            {
                next._prev = prev;
            }

            // Insert a before b
            if (!b._prev)
            {
                a._prev = null;
                this._list = a;
                a._next = b;
                b._prev = a;
            }
            else
            {
                a._prev = b._prev;
                b._prev = a;
                a._prev._next = a;
                a._next = b;
            }

            a = next;
        }
    },

    perform : function performFn(lambda, thisObject)
    {
        this._validate();

        var d1 = this._list;
        while (d1)
        {
            var d2 = d1._next;
            var aabb1 = d1._aabb;
            var d1Static = d1.isStatic;

            var maxX = aabb1[2];
            while (d2)
            {
                var aabb2 = d2._aabb;
                if (aabb2[0] > maxX)
                {
                    break;
                }

                if (d1Static && d2.isStatic)
                {
                    d2 = d2._next;
                    continue;
                }

                // Check AABB's fully. (test y-axis, x-axis already checked)
                if (aabb1[1] > aabb2[3] ||
                    aabb2[1] > aabb1[3])
                {
                    d2 = d2._next;
                    continue;
                }

                lambda.call(thisObject, d1, d2);
                d2 = d2._next;
            }

            d1 = d1._next;
        }
    }
};

Physics2DSweepAndPrune.create = function phys2DSAPFn()
{
    var b = new Physics2DSweepAndPrune();
    b._list = null;
    return b;
};


// =====================================================================

//
// Physics2D Contact
//

//
// CONTACT DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*CON_POS*/0         // World position of contact (x, y)
///*CON_DIST*/2        // Penetration distance of contact
///*CON_BOUNCE*/3      // Per-contact bounce error.
///*CON_FRICTION*/4    // Per-contact friction (based on arbiter and rel. velocity)
///*CON_NMASS*/5       // Normal effective mass
///*CON_TMASS*/6       // Tangent effective mass
///*CON_REL1*/7        // Contact relative to object 1 (x, y)
///*CON_REL2*/9        // Contact relative to object 2 (x, y)
///*CON_JNACC*/11      // Normal accumulated impulse
///*CON_JTACC*/12      // Tangent accumulated impulse
///*CON_LREL1*/13      // Local contact point on object 1 (position iteration) (x, y)
///*CON_LREL2*/15      // Local contact point on object 2 (position iteration) (x, y)
//
///*CON_DATA_SIZE*/17

function Physics2DContact()
{
    this._data = new Physics2DDevice.prototype.floatArray((/*CON_DATA_SIZE*/17));
    this.fresh = false;
    this._hash = 0;
    this._timeStamp = 0;
    this._next = null;
    this.active = false;
    this.virtual = false;
}

Physics2DContact.prototype = {

    version : 1,

    getPosition : function getPositionFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        var data = this._data;
        dst[0] = data[(/*CON_POS*/0)];
        dst[1] = data[(/*CON_POS*/0) + 1];
        return dst;
    },

    getPenetration : function getPenetrationFn()
    {
        return (-this._data[(/*CON_DIST*/2)]);
    },

    getNormalImpulse : function getNormalImpulseFn()
    {
        return (this.virtual ? 0 : this._data[(/*CON_JNACC*/11)]);
    },

    getTangentImpulse : function getTangentImpulseFn()
    {
        return (this.virtual ? 0 : this._data[(/*CON_JTACC*/12)]);
    }
};


Physics2DContact.pool = null;
Physics2DContact.allocate = function allocateContactFn()
{
    if (!this.pool)
    {
        return new Physics2DContact();
    }
    else
    {
        var ret = this.pool;
        this.pool = ret._next;
        ret._next = null;
        return ret;
    }
};

Physics2DContact.deallocate = function deallocateContactFn(contact)
{
    contact._next = this.pool;
    this.pool = contact;
};


// =====================================================================

//
// Physics2D Arbiter
//

//
// ARBITER DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
// Velocity iterations.
// these values must remain below (31) as used as bit accessors
// on userdef flag.
///*ARB_DYN_FRIC*/0      // Coef. dynamic friction
///*ARB_STATIC_FRIC*/1   // Coef. static friction
///*ARB_ELASTICITY*/2    // Coef. elasticity
///*ARB_ROLLING_FRIC*/3  // Coef. rolling friction
//
///*ARB_NORMAL*/4        // World space normal (velocity iterations) (x, y)
///*ARB_PREDT*/6         // Previous time-step on computation for scaling.
//
// Jacobian (first contact)
///*ARB_RN1A*/7          // (contact1.ra cross normal)
///*ARB_RN1B*/8          // (contact1.rb cross normal)
///*ARB_RT1A*/9          // (contact1.ra dot normal)
///*ARB_RT1B*/10          // (contact1.rb dot normal)
//
// Position iterations.
///*ARB_LNORM*/11         // Local normal of reference edge (x, y)
///*ARB_LPROJ*/13         // Local projection onto reference edge.
///*ARB_RADIUS*/14        // Sum radius of shapes (0 poly, radius circle)
///*ARB_BIAS*/15          // Bias coeffecient
//
// 2-contact arbiter only.
// Jacobian second contact
///*ARB_RN2A*/16          // (contact2.ra cross normal)
///*ARB_RN2B*/17          // (contact2.rb cross normal)
///*ARB_RT2A*/18          // (contact2.ra dot normal)
///*ARB_RT2B*/19          // (contact2.rb dot normal)
////**/
///*ARB_K*/20             // Block solver non-inverted effectivemass [a b; b c] (sym. matrix)
///*ARB_KMASS*/23         // (1 / det) of ARB_K for on the fly inversion.
//
// 1-contact arbiter only. (when one is a circle)
///*ARB_JRACC*/16         // Accumulated rolling friction impulse
///*ARB_RMASS*/17         // Rolling friction effectivemass.
//
//
//
///*ARB_DATA_SIZE*/24
//
//
// Flags for when user has explicitly set values on arbiter.
///*USERDEF_DYN*/1
///*USERDEF_STAT*/2
///*USERDEF_ROLLING*/4
///*USERDEF_ELASTICITY*/8
//
// Face flags
///*FACE_CIRCLE*/0
///*FACE_1*/1
///*FACE_2*/2
//
// Hash flags
///*HASH_CIRCLE*/0
///*HASH_LEFT*/1
///*HASH_RIGHT*/2
//
// State flags
///*STATE_ACCEPT*/1
///*STATE_ALWAYS*/2

function Physics2DArbiter()
{
    this.shapeA = null;
    this.shapeB = null;
    this.bodyA = null;
    this.bodyB = null;
    this._next = null;

    this._retired = false; // set to true when arbiter is lazily retired to be removed in step()
    this._lazyRetired = false;
    this._static = false;
    this._state = 0;
    this.sensor = false;

    this._createStamp = 0; // time stamp at which arbiter was created.
    this._updateStamp = 0; // time stamp at which arbiter was updated.
    this._sleepStamp = 0;  // time stamp at which arbiter was put to sleep
    this._timeStamp = 0;   // time stamp set before collision detection so that
                           // injected contacts have correct time set without later
                           // iteration.
    this._createContinuous = false; // Marks createStamp as having been set during
                                    // continuous collisions for callbacks.
    this._endGenerated = 0; // time stamp at which end event was generated.
                            // This deals with another corner case where
                            // object seperates (end event), then continuously collide
                            // needing to generate a begin even for the same pair of
                            // objects (same arbiter) in the same step!.

    this._midStep = false; // Set to true before preSolve events are called to avoid waking bodies.

    this.sleeping = false;
    this.active = false;
    this._invalidated = false;

    this._data = new Physics2DDevice.prototype.floatArray((/*ARB_DATA_SIZE*/24));
    this.contacts = [];

    this._userdef = 0; // bit-flags for if user has set an elasticity/friction value.
    this._velocity2Contact = false;
    this._position2Contact = false;
    this._contact1 = this._contact2 = null;
    this._faceType = 0; // FACE_CIRCLE/FACE_1/FACE_2
}

Physics2DArbiter.prototype = {

    version : 1,

    getNormal : function getNormalFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }
        if (this.sensor)
        {
            dst[0] = dst[1] = 0;
        }
        else
        {
            var data = this._data;
            dst[0] = data[(/*ARB_NORMAL*/4)];
            dst[1] = data[(/*ARB_NORMAL*/4) + 1];
        }
        return dst;
    },

    getRollingImpulse : function getRollingImpulseFn()
    {
        if (this.sensor || this._velocity2Contact || this._contact1._hash !== (/*HASH_CIRCLE*/0))
        {
            return 0;
        }
        else
        {
            return this._data[(/*ARB_JRACC*/16)];
        }
    },

    // =========================================================

    getElasticity : function getElasticityFn()
    {
        if (this.sensor)
        {
            return undefined;
        }

        this._validate();
        return this._data[(/*ARB_ELASTICITY*/2)];
    },

    getDynamicFriction : function getDynamicFrictionFn()
    {
        if (this.sensor)
        {
            return undefined;
        }

        this._validate();
        return this._data[(/*ARB_DYN_FRIC*/0)];
    },

    getStaticFriction : function getStaticFrictionFn()
    {
        if (this.sensor)
        {
            return undefined;
        }

        this._validate();
        return this._data[(/*ARB_STATIC_FRIC*/1)];
    },

    getRollingFriction : function getRollingFrictionFn()
    {
        if (this.sensor)
        {
            return undefined;
        }

        this._validate();
        return this._data[(/*ARB_ROLLING_FRIC*/3)];
    },

    /*jshint bitwise: false*/
    setElasticity : function setElasticityFn(elasticity)
    {
        if (this.sensor)
        {
            return;
        }

        this._data[(/*ARB_ELASTICITY*/2)] = elasticity;
        this._userdef |= (1 << (/*ARB_ELASTICITY*/2));
        this._invalidate(true);
    },

    setDynamicFriction : function setDynamicFrictionFn(dynamicFriction)
    {
        if (this.sensor)
        {
            return;
        }

        this._data[(/*ARB_DYN_FRIC*/0)] = dynamicFriction;
        this._userdef |= (1 << (/*ARB_DYN_FRIC*/0));
        this._invalidate(true);
    },

    setStaticFriction : function setStaticFrictionFn(staticFriction)
    {
        if (this.sensor)
        {
            return;
        }

        this._data[(/*ARB_STAT_FRIC*/1)] = staticFriction;
        this._userdef |= (1 << (/*ARB_STAT_FRIC*/1));
        this._invalidate(true);
    },

    setRollingFriction : function setRollingFrictionFn(rollingFriction)
    {
        if (this.sensor)
        {
            return;
        }

        this._data[(/*ARB_ROLLING_FRIC*/3)] = rollingFriction;
        this._userdef |= (1 << (/*ARB_ROLLING_FRIC*/3));
        this._invalidate(true);
    },

    setElasticityFromShapes : function setElasticityFromShapesFn()
    {
        if (this.sensor)
        {
            return;
        }

        this._userdef &= ~(1 << (/*ARB_ELASTICITY*/2));
        this._invalidate(true);
    },

    setDynamicFrictionFromShapes : function setDynamicFrictionFromShapesFn()
    {
        if (this.sensor)
        {
            return;
        }

        this._userdef &= ~(1 << (/*ARB_DYN_FRIC*/0));
        this._invalidate(true);
    },

    setStaticFrictionFromShapes : function setStaticFrictionFromShapesFn()
    {
        if (this.sensor)
        {
            return;
        }

        this._userdef &= ~(1 << (/*ARB_STAT_FRIC*/1));
        this._invalidate(true);
    },

    setRollingFrictionFromShapes : function setRollingFrictionFromShapesFn()
    {
        if (this.sensor)
        {
            return;
        }

        this._userdef &= ~(1 << (/*ARB_ROLLING_FRIC*/3));
        this._invalidate(true);
    },
    /*jshint bitwise: true*/

    // =========================================================

    /*jshint bitwise: false*/
    isStateAccepted : function acceptedFn()
    {
        if (this.sensor)
        {
            return undefined;
        }
        else
        {
            return ((this._state & (/*STATE_ACCEPT*/1)) !== 0);
        }
    },

    isStatePersistent : function persistentFn()
    {
        if (this.sensor)
        {
            return undefined;
        }
        else
        {
            return ((this._state & (/*STATE_ALWAYS*/2)) !== 0);
        }
    },

    setAcceptedState : function acceptingStateFn(accepted)
    {
        if (this.sensor)
        {
            return;
        }

        if (accepted)
        {
            this._state |= (/*STATE_ACCEPT*/1);
        }
        else
        {
            this._state &= ~(/*STATE_ACCEPT*/1);
        }
        this._invalidate(true);
    },

    setPersistentState : function persistentStateFn(persistent)
    {
        if (this.sensor)
        {
            return;
        }

        if (persistent)
        {
            this._state |= (/*STATE_ALWAYS*/2);
        }
        else
        {
            this._state &= ~(/*STATE_ALWAYS*/2);
        }
        this._invalidate(true);
    },
    /*jshint bitwise: true*/

    // =========================================================

    // Called when arbiter is destroyed by removal of a shape
    // Or change in body type signialling end of an interaction.
    // In either case, arbiter was woken and sleeping is false.
    //
    // Effect is that in following step, arbiter is permitted
    // to persist one additional frame (for any end events)
    // and then in the next step retired fully and reused.
    _lazyRetire : function _lazyRetireFn(ignoreShape)
    {
        this._lazyRetired = true;
        this._retired = true;
        this.active = false;

        var arbiters;
        var index;
        if (this.shapeA !== ignoreShape)
        {
            arbiters = this.shapeA.arbiters;
            index = arbiters.indexOf(this);
            arbiters[index] = arbiters[arbiters.length - 1];
            arbiters.pop();
        }
        if (this.shapeB !== ignoreShape)
        {
            arbiters = this.shapeB.arbiters;
            index = arbiters.indexOf(this);
            arbiters[index] = arbiters[arbiters.length - 1];
            arbiters.pop();
        }
    },

    _assign : function _assignFn(s1, s2)
    {
        this.bodyA = s1.body;
        this.bodyB = s2.body;
        this.shapeA = s1;
        this.shapeB = s2;

        s1.arbiters.push(this);
        s2.arbiters.push(this);

        this._retired = false;
        this.sleeping = false;

        this._invalidate();
    },

    _retire : function _retireFn()
    {
        this.shapeA = this.shapeB = null;
        this.bodyA = this.bodyB = null;
        this._retired = true;
        this._lazyRetired = false;
        this.active = false;
        this._data[(/*ARB_PREDT*/6)] = 0;

        var contacts = this.contacts;
        while (contacts.length > 0)
        {
            var contact = contacts.pop();
            Physics2DContact.deallocate(contact);
        }
        this._contact1 = this._contact2 = null;
    },

    // =====================================================================

    _invalidate : function _invalidateFn(dontSkip)
    {
        this._invalidated = true;
        if (dontSkip && !this._midStep)
        {
            this.shapeA.body.wake();
            this.shapeB.body.wake();
        }
    },

    _validate : function _validateFn()
    {
        this._invalidated = false;

        var data = this._data;
        var mA = this.shapeA._material._data;
        var mB = this.shapeB._material._data;
        var userdef = this._userdef;

        /*jshint bitwise: false*/
        if ((userdef & (1 << (/*ARB_ELASTICITY*/2))) === 0)
        {
            var elasticity;
            var elasticA = mA[(/*MAT_ELASTICITY*/0)];
            var elasticB = mB[(/*MAT_ELASTICITY*/0)];
            if (elasticA <= Number.NEGATIVE_INFINITY || elasticB <= Number.NEGATIVE_INFINITY)
            {
                elasticity = 0;
            }
            else if (elasticA >= Number.POSITIVE_INFINITY || elasticB >= Number.POSITIVE_INFINITY)
            {
                elasticity = 1;
            }
            else
            {
                elasticity = (elasticA + elasticB) * 0.5;
                if (elasticity < 0)
                {
                    elasticity = 0;
                }
                else if (elasticity > 1)
                {
                    elasticity = 1;
                }
            }
            data[(/*ARB_ELASTICITY*/2)]   = elasticity;
        }

        var sqrt = Math.sqrt;
        if ((userdef & (1 << (/*ARB_DYN_FRIC*/0))) === 0)
        {
            data[(/*ARB_DYN_FRIC*/0)] = sqrt(mA[(/*MAT_DYNAMIC*/2)] * mB[(/*MAT_DYNAMIC*/2)]);
        }
        if ((userdef & (1 << (/*ARB_STATIC_FRIC*/1))) === 0)
        {
            data[(/*ARB_STATIC_FRIC*/1)] = sqrt(mA[(/*MAT_STATIC*/1)]  * mB[(/*MAT_STATIC*/1)]);
        }
        if ((userdef & (1 << (/*ARB_ROLLING_FRIC*/3))) === 0)
        {
            data[(/*ARB_ROLLING_FRIC*/3)] = sqrt(mA[(/*MAT_ROLLING*/3)] * mB[(/*MAT_ROLLING*/3)]);
        }
        /*jshint bitwise: true*/
    },

    // =====================================================================

    _injectContact : function _injectContactFn(px, py, nx, ny, dist, hash, virtual)
    {
        var contact;
        var contacts = this.contacts;
        var limit = contacts.length;
        if (limit !== 0)
        {
            contact = contacts[0];
            if (contact._hash !== hash)
            {
                if (limit !== 1)
                {
                    contact = contacts[1];
                    if (contact._hash !== hash)
                    {
                        contact = null;
                    }
                }
                else
                {
                    contact = null;
                }
            }
        }

        if (virtual === undefined)
        {
            virtual = false;
        }

        var data;
        if (!contact)
        {
            contact = Physics2DContact.allocate();
            data = contact._data;
            data[(/*CON_JNACC*/11)] = data[(/*CON_JTACC*/12)] = 0;
            contact._hash = hash;
            contact.fresh = (!virtual);
            contacts.push(contact);

            if (hash === (/*HASH_CIRCLE*/0))
            {
                this._data[(/*ARB_JRACC*/16)] = 0;
            }
        }
        else
        {
            contact.fresh = (!virtual && contact.virtual);
            data = contact._data;
        }

        data[(/*CON_POS*/0)]     = px;
        data[(/*CON_POS*/0) + 1] = py;
        data[(/*CON_DIST*/2)] = dist;
        contact._timeStamp = this._timeStamp;
        contact.virtual = virtual;

        data = this._data;
        data[(/*ARB_NORMAL*/4)]     = nx;
        data[(/*ARB_NORMAL*/4) + 1] = ny;

        return contact;
    },

    _cleanContacts : function _cleanContactsFn(timeStamp)
    {
        var fst = true;
        this._position2Contact = false;
        this._contact2 = null;
        var contacts = this.contacts;
        var limit = contacts.length;
        var i;
        for (i = 0; i < limit;)
        {
            var c = contacts[i];
            if (c._timeStamp + Physics2DConfig.DELAYED_DEATH < timeStamp)
            {
                limit -= 1;
                contacts[i] = contacts[limit];
                contacts.pop();
                Physics2DContact.deallocate(c);
                continue;
            }

            c.active = (c._timeStamp === timeStamp);
            if (c.active)
            {
                if (fst)
                {
                    this._contact1 = c;
                    fst = false;
                }
                else
                {
                    this._contact2 = c;
                    this._position2Contact = true;
                }
            }

            i += 1;
        }

        if (this._position2Contact)
        {
            if (this._contact1.virtual)
            {
                var tmp = this._contact1;
                this._contact1 = this._contact2;
                this._contact2 = tmp;
            }
            this._velocity2Contact = !(this._contact2.virtual);
        }
        else
        {
            this._velocity2Contact = false;
        }

        return !fst;
    },

    // =====================================================================

    _preStep : function _preStepFn(deltaTime, timeStamp, continuous)
    {
        if (!this._cleanContacts(timeStamp))
        {
            return false;
        }

        if (this._invalidated)
        {
            this._validate();
        }

        var adata = this._data;
        var predt = adata[(/*ARB_PREDT*/6)];
        var dtRatio = (predt === 0) ? 1 : (deltaTime / predt);
        adata[(/*ARB_PREDT*/6)] = deltaTime;

        var data1 = this.bodyA._data;
        var data2 = this.bodyB._data;

        var px1 = data1[(/*BODY_POS*/2)];
        var py1 = data1[(/*BODY_POS*/2) + 1];
        var px2 = data2[(/*BODY_POS*/2)];
        var py2 = data2[(/*BODY_POS*/2) + 1];

        var vx1 = data1[(/*BODY_VEL*/7)];
        var vy1 = data1[(/*BODY_VEL*/7) + 1];
        var vw1 = data1[(/*BODY_VEL*/7) + 2];
        var vx2 = data2[(/*BODY_VEL*/7)];
        var vy2 = data2[(/*BODY_VEL*/7) + 1];
        var vw2 = data2[(/*BODY_VEL*/7) + 2];

        var nx = adata[(/*ARB_NORMAL*/4)];
        var ny = adata[(/*ARB_NORMAL*/4) + 1];

        var massSum = data1[(/*BODY_IMASS*/0)] + data2[(/*BODY_IMASS*/0)];

        var ii1 = data1[(/*BODY_IINERTIA*/1)];
        var ii2 = data2[(/*BODY_IINERTIA*/1)];

        var EPS = Physics2DConfig.EFF_MASS_EPSILON;
        var BIAS = (continuous   ? (this._static ? Physics2DConfig.CONT_STATIC_BIAS_COEF :
                                                   Physics2DConfig.CONT_BIAS_COEF) :
                    this._static ? Physics2DConfig.STATIC_BIAS_COEF :
                                   Physics2DConfig.BIAS_COEF);
        adata[(/*ARB_BIAS*/15)] = BIAS;

        var c = this._contact1;
        var data;
        var rx1, ry1, rx2, ry2;
        while (true)
        {
            data = c._data;

            var px = data[(/*CON_POS*/0)];
            var py = data[(/*CON_POS*/0) + 1];

            // Contact point relative vectors.
            rx1 = data[(/*CON_REL1*/7)]      = (px - px1);
            ry1 = data[(/*CON_REL1*/7) + 1]  = (py - py1);
            rx2 = data[(/*CON_REL2*/9)]     = (px - px2);
            ry2 = data[(/*CON_REL2*/9) + 1] = (py - py2);

            // Tangent effective mass.
            var v1 = (rx1 * nx) + (ry1 * ny);
            var v2 = (rx2 * nx) + (ry2 * ny);
            var kt = massSum + (ii2 * v2 * v2) + (ii1 * v1 * v1);
            data[(/*CON_TMASS*/6)] = (kt < EPS) ? 0 : (1 / kt);

            // Normal effective mass.
            v1 = (rx1 * ny) - (ry1 * nx);
            v2 = (rx2 * ny) - (ry2 * nx);
            var kn = massSum + (ii2 * v2 * v2) + (ii1 * v1 * v1);
            data[(/*CON_NMASS*/5)] = (kn < EPS) ? 0 : (1 / kn);

            // Relative velocity at contact point.
            var vrx = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
            var vry = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));

            // Compute bounce error
            var vdot = (nx * vrx) + (ny * vry);
            var bounce = (vdot * adata[(/*ARB_ELASTICITY*/2)]);
            if (bounce > -Physics2DConfig.BOUNCE_VELOCITY_THRESHOLD)
            {
                bounce = 0;
            }
            data[(/*CON_BOUNCE*/3)] = bounce;

            // Compute friction coef.
            vdot = (nx * vry) - (ny * vrx);
            if ((vdot * vdot) > Physics2DConfig.STATIC_FRIC_SQ_EPSILON)
            {
                data[(/*CON_FRICTION*/4)] = adata[(/*ARB_DYN_FRIC*/0)];
            }
            else
            {
                data[(/*CON_FRICTION*/4)] = adata[(/*ARB_STATIC_FRIC*/1)];
            }

            // Scale impulses from change in time step
            data[(/*CON_JNACC*/11)] *= dtRatio;
            data[(/*CON_JTACC*/12)] *= dtRatio;

            // Advance to next contact.
            if (this._velocity2Contact)
            {
                if (c === this._contact2)
                {
                    break;
                }
                c = this._contact2;
            }
            else
            {
                break;
            }
        }

        data = this._contact1._data;
        rx1 = data[(/*CON_REL1*/7)];
        ry1 = data[(/*CON_REL1*/7) + 1];
        rx2 = data[(/*CON_REL2*/9)];
        ry2 = data[(/*CON_REL2*/9) + 1];
        var rn1a = adata[(/*ARB_RN1A*/7)] = (rx1 * ny) - (ry1 * nx);
        var rn1b = adata[(/*ARB_RN1B*/8)] = (rx2 * ny) - (ry2 * nx);
        adata[(/*ARB_RT1A*/9)]  = (rx1 * nx) + (ry1 * ny);
        adata[(/*ARB_RT1B*/10)] = (rx2 * nx) + (ry2 * ny);

        if (!this._velocity2Contact && this._contact1._hash === (/*HASH_CIRCLE*/0))
        {
            adata[(/*ARB_JRACC*/16)] *= dtRatio;
            var sum = ii1 + ii2;
            adata[(/*ARB_RMASS*/17)] = (sum < EPS) ? 0 : (1 / sum);
        }
        else if (this._velocity2Contact)
        {
            data = this._contact2._data;
            var r2x1 = data[(/*CON_REL1*/7)];
            var r2y1 = data[(/*CON_REL1*/7) + 1];
            var r2x2 = data[(/*CON_REL2*/9)];
            var r2y2 = data[(/*CON_REL2*/9) + 1];
            var rn2a = adata[(/*ARB_RN2A*/16)] = (r2x1 * ny) - (r2y1 * nx);
            var rn2b = adata[(/*ARB_RN2B*/17)] = (r2x2 * ny) - (r2y2 * nx);
            adata[(/*ARB_RT2A*/18)] = (r2x1 * nx) + (r2y1 * ny);
            adata[(/*ARB_RT2B*/19)] = (r2x2 * nx) + (r2y2 * ny);

            var Ka = adata[(/*ARB_K*/20)]     = massSum + (ii1 * rn1a * rn1a) + (ii2 * rn1b * rn1b);
            var Kb = adata[(/*ARB_K*/20) + 1] = massSum + (ii1 * rn1a * rn2a) + (ii2 * rn1b * rn2b);
            var Kc = adata[(/*ARB_K*/20) + 2] = massSum + (ii1 * rn2a * rn2a) + (ii2 * rn2b * rn2b);

            // Degenerate case! eek.
            var det = ((Ka * Kc) - (Kb * Kb));
            if ((Ka * Ka) > (Physics2DConfig.ILL_THRESHOLD * det))
            {
                if (this._contact2._data[(/*CON_DIST*/2)] < this._contact1._data[(/*CON_DIST*/2)])
                {
                    this._contact1 = this._contact2;
                    adata[(/*ARB_RN1A*/7)]  = rn2a;
                    adata[(/*ARB_RN1B*/8)]  = rn2b;
                    adata[(/*ARB_RT1A*/9)]  = adata[(/*ARB_RT2A*/18)];
                    adata[(/*ARB_RT1B*/10)] = adata[(/*ARB_RT2B*/19)];
                }
                this._velocity2Contact = false;
                this._position2Contact = false;
                this._contact2 = null;
            }
            else
            {
                adata[(/*ARB_KMASS*/23)] = (1 / det);
            }
        }

        return true;
    },

    // =====================================================================

    _iterateVelocity : function _iterateVelocity()
    {
        var data1 = this.bodyA._data;
        var data2 = this.bodyB._data;
        var im1 = data1[(/*BODY_IMASS*/0)];
        var ii1 = data1[(/*BODY_IINERTIA*/1)];
        var im2 = data2[(/*BODY_IMASS*/0)];
        var ii2 = data2[(/*BODY_IINERTIA*/1)];
        var vx1 = data1[(/*BODY_VEL*/7)];
        var vy1 = data1[(/*BODY_VEL*/7) + 1];
        var vw1 = data1[(/*BODY_VEL*/7) + 2];
        var vx2 = data2[(/*BODY_VEL*/7)];
        var vy2 = data2[(/*BODY_VEL*/7) + 1];
        var vw2 = data2[(/*BODY_VEL*/7) + 2];

        var adata = this._data;
        var nx = adata[(/*ARB_NORMAL*/4)];
        var ny = adata[(/*ARB_NORMAL*/4) + 1];
        var rn1a = adata[(/*ARB_RN1A*/7)];
        var rn1b = adata[(/*ARB_RN1B*/8)];
        var rt1a = adata[(/*ARB_RT1A*/9)];
        var rt1b = adata[(/*ARB_RT1B*/10)];

        var cdata1 = this._contact1._data;
        var rx1 = cdata1[(/*CON_REL1*/7)];
        var ry1 = cdata1[(/*CON_REL1*/7) + 1];
        var rx2 = cdata1[(/*CON_REL2*/9)];
        var ry2 = cdata1[(/*CON_REL2*/9) + 1];

        var surfaceX = (data2[(/*BODY_SURFACE_VEL*/13)]     - data1[(/*BODY_SURFACE_VEL*/13)]);
        var surfaceY = (data2[(/*BODY_SURFACE_VEL*/13) + 1] - data1[(/*BODY_SURFACE_VEL*/13) + 1]);

        // Relative velocity first contact
        var vrx1 = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
        var vry1 = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));

        var j, jOld, cjAcc, jx, jy, jMax;

        // First contact friction
        j = (((nx * vry1) - (ny * vrx1)) + surfaceX) * cdata1[(/*CON_TMASS*/6)];
        jMax = (cdata1[(/*CON_FRICTION*/4)] * cdata1[(/*CON_JNACC*/11)]);
        jOld = cdata1[(/*CON_JTACC*/12)];
        cjAcc = (jOld - j);
        if (cjAcc > jMax)
        {
            cjAcc = jMax;
        }
        else if (cjAcc < -jMax)
        {
            cjAcc = -jMax;
        }
        j = (cjAcc - jOld);
        cdata1[(/*CON_JTACC*/12)] = cjAcc;

        jx = (-ny * j);
        jy = (nx * j);
        vx1 -= (jx * im1);
        vy1 -= (jy * im1);
        vw1 -= (rt1a * j * ii1);
        vx2 += (jx * im2);
        vy2 += (jy * im2);
        vw2 += (rt1b * j * ii2);

        if (this._velocity2Contact)
        {
            var cdata2 = this._contact2._data;
            var r2x1 = cdata2[(/*CON_REL1*/7)];
            var r2y1 = cdata2[(/*CON_REL1*/7) + 1];
            var r2x2 = cdata2[(/*CON_REL2*/9)];
            var r2y2 = cdata2[(/*CON_REL2*/9) + 1];

            var Ka = adata[(/*ARB_K*/20)];
            var Kb = adata[(/*ARB_K*/20) + 1];
            var Kc = adata[(/*ARB_K*/20) + 2];
            var idet = adata[(/*ARB_KMASS*/23)];

            var rn2a = adata[(/*ARB_RN2A*/16)];
            var rn2b = adata[(/*ARB_RN2B*/17)];
            var rt2a = adata[(/*ARB_RT2A*/18)];
            var rt2b = adata[(/*ARB_RT2B*/19)];

            // Second contact friction
            var vrx2 = (vx2 - (r2y2 * vw2)) - (vx1 - (r2y1 * vw1));
            var vry2 = (vy2 + (r2x2 * vw2)) - (vy1 + (r2x1 * vw1));

            j = (((nx * vry2) - (ny * vrx2)) + surfaceX) * cdata2[(/*CON_TMASS*/6)];
            jMax = (cdata2[(/*CON_FRICTION*/4)] * cdata2[(/*CON_JNACC*/11)]);
            jOld = cdata2[(/*CON_JTACC*/12)];
            cjAcc = (jOld - j);
            if (cjAcc > jMax)
            {
                cjAcc = jMax;
            }
            else if (cjAcc < -jMax)
            {
                cjAcc = -jMax;
            }
            j = (cjAcc - jOld);
            cdata2[(/*CON_JTACC*/12)] = cjAcc;

            jx = (-ny * j);
            jy = (nx * j);
            vx1 -= (jx * im1);
            vy1 -= (jy * im1);
            vw1 -= (rt2a * j * ii1);
            vx2 += (jx * im2);
            vy2 += (jy * im2);
            vw2 += (rt2b * j * ii2);

            // Normal impulses.
            vrx1 = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
            vry1 = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));
            vrx2 = (vx2 - (r2y2 * vw2)) - (vx1 - (r2y1 * vw1));
            vry2 = (vy2 + (r2x2 * vw2)) - (vy1 + (r2x1 * vw1));

            var ax = cdata1[(/*CON_JNACC*/11)];
            var ay = cdata2[(/*CON_JNACC*/11)];

            // Block solver for both normal impulses together.
            var jnx = ((vrx1 * nx) + (vry1 * ny)) + surfaceY + cdata1[(/*CON_BOUNCE*/3)] - ((Ka * ax) + (Kb * ay));
            var jny = ((vrx2 * nx) + (vry2 * ny)) + surfaceY + cdata2[(/*CON_BOUNCE*/3)] - ((Kb * ax) + (Kc * ay));

            var xx = idet * ((Kb * jny) - (Kc * jnx));
            var xy = idet * ((Kb * jnx) - (Ka * jny));

            if (xx >= 0 && xy >= 0)
            {
                jnx = (xx - ax);
                jny = (xy - ay);
                cdata1[(/*CON_JNACC*/11)] = xx;
                cdata2[(/*CON_JNACC*/11)] = xy;
            }
            else
            {
                xx = -(cdata1[(/*CON_NMASS*/5)] * jnx);
                if (xx >= 0 && ((Kb * xx) + jny) >= 0)
                {
                    jnx = (xx - ax);
                    jny = -ay;
                    cdata1[(/*CON_JNACC*/11)] = xx;
                    cdata2[(/*CON_JNACC*/11)] = 0;
                }
                else
                {
                    xy = -(cdata2[(/*CON_NMASS*/5)] * jny);
                    if (xy >= 0 && ((Kb * xy) + jnx) >= 0)
                    {
                        jnx = -ax;
                        jny = (xy - ay);
                        cdata1[(/*CON_JNACC*/11)] = 0;
                        cdata2[(/*CON_JNACC*/11)] = xy;
                    }
                    else if (jnx >= 0 && jny >= 0)
                    {
                        jnx = -ax;
                        jny = -ay;
                        cdata1[(/*CON_JNACC*/11)] = cdata2[(/*CON_JNACC*/11)] = 0;
                    }
                    else
                    {
                        jnx = 0;
                        jny = 0;
                    }
                }
            }

            // Apply impulses
            j = (jnx + jny);
            jx = (nx * j);
            jy = (ny * j);

            vx1 -= (jx * im1);
            vy1 -= (jy * im1);
            vw1 -= ((rn1a * jnx) + (rn2a * jny)) * ii1;
            vx2 += (jx * im2);
            vy2 += (jy * im2);
            vw2 += ((rn1b * jnx) + (rn2b * jny)) * ii2;
        }
        else
        {
            if (this._contact1._hash === (/*HASH_CIRCLE*/0))
            {
                // rolling impulse.
                var dw = (vw2 - vw1);
                j = (dw * adata[(/*ARB_RMASS*/17)]);
                jMax = (adata[(/*ARB_ROLLING_FRIC*/3)] * cdata1[(/*CON_JNACC*/11)]);
                jOld = adata[(/*ARB_JRACC*/16)];
                cjAcc = (jOld - j);
                if (cjAcc > jMax)
                {
                    cjAcc = jMax;
                }
                else if (cjAcc < -jMax)
                {
                    cjAcc = -jMax;
                }
                j = (cjAcc - jOld);
                adata[(/*ARB_JRACC*/16)] = cjAcc;

                vw1 -= (j * ii1);
                vw2 += (j * ii2);
            }

            // normal impulse.
            vrx1 = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
            vry1 = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));

            j = (cdata1[(/*CON_BOUNCE*/3)] + surfaceY + ((nx * vrx1) + (ny * vry1))) * cdata1[(/*CON_NMASS*/5)];
            jOld = cdata1[(/*CON_JNACC*/11)];
            cjAcc = (jOld - j);
            if (cjAcc < 0)
            {
                cjAcc = 0;
            }
            j = (cjAcc - jOld);
            cdata1[(/*CON_JNACC*/11)] = cjAcc;

            jx = (nx * j);
            jy = (ny * j);
            vx1 -= (jx * im1);
            vy1 -= (jy * im1);
            vw1 -= (rn1a * j * ii1);
            vx2 += (jx * im2);
            vy2 += (jy * im2);
            vw2 += (rn1b * j * ii2);

        }

        data1[(/*BODY_VEL*/7)]     = vx1;
        data1[(/*BODY_VEL*/7) + 1] = vy1;
        data1[(/*BODY_VEL*/7) + 2] = vw1;
        data2[(/*BODY_VEL*/7)]     = vx2;
        data2[(/*BODY_VEL*/7) + 1] = vy2;
        data2[(/*BODY_VEL*/7) + 2] = vw2;
    },

    // =====================================================================

    _refreshContactData : function _refreshContactDataFn()
    {
        var data1 = this.bodyA._data;
        var data2 = this.bodyB._data;
        var cos1 = data1[(/*BODY_AXIS*/5)];
        var sin1 = data1[(/*BODY_AXIS*/5) + 1];
        var cos2 = data2[(/*BODY_AXIS*/5)];
        var sin2 = data2[(/*BODY_AXIS*/5) + 1];
        var px1 = data1[(/*BODY_POS*/2)];
        var py1 = data1[(/*BODY_POS*/2) + 1];
        var px2 = data2[(/*BODY_POS*/2)];
        var py2 = data2[(/*BODY_POS*/2) + 1];

        var err, nx, ny;
        var adata = this._data;
        var rad = adata[(/*ARB_RADIUS*/14)];
        var cdata1 = this._contact1._data;
        if (this._faceType === (/*FACE_CIRCLE*/0))
        {
            var x = cdata1[(/*CON_LREL1*/13)];
            var y = cdata1[(/*CON_LREL1*/13) + 1];
            var rx1 = ((cos1 * x) - (sin1 * y) + px1);
            var ry1 = ((sin1 * x) + (cos1 * y) + py1);

            x = cdata1[(/*CON_LREL2*/15)];
            y = cdata1[(/*CON_LREL2*/15) + 1];
            var rx2 = ((cos2 * x) - (sin2 * y) + px2);
            var ry2 = ((sin2 * x) + (cos2 * y) + py2);

            var dx = (rx2 - rx1);
            var dy = (ry2 - ry1);
            var dl = Math.sqrt((dx * dx) + (dy * dy));

            nx = adata[(/*ARB_NORMAL*/4)];
            ny = adata[(/*ARB_NORMAL*/4) + 1];
            if (dl < Physics2DConfig.NORMALIZE_EPSILON)
            {
                dx = nx;
                dy = ny;
            }
            else
            {
                var rec = (1 / dl);
                dx *= rec;
                dy *= rec;
            }

            err = (dl - rad);
            if (((dx * nx) + (dy * ny)) < 0)
            {
                err -= rad;
                dx = -dx;
                dy = -dy;
            }

            adata[(/*ARB_NORMAL*/4)]     = dx;
            adata[(/*ARB_NORMAL*/4) + 1] = dy;
            var px, py, r1;
            if (this.shapeA._type === (/*TYPE_CIRCLE*/0))
            {
                r1 = this.shapeA._data[(/*CIRCLE_RADIUS*/6)] + (err * 0.5);
                px = cdata1[(/*CON_POS*/0)]     = (rx1 + (dx * r1));
                py = cdata1[(/*CON_POS*/0) + 1] = (ry1 + (dy * r1));
            }
            else
            {
                r1 = this.shapeB._data[(/*CIRCLE_RADIUS*/6)] + (err * 0.5);
                px = cdata1[(/*CON_POS*/0)]     = (rx2 - (dx * r1));
                py = cdata1[(/*CON_POS*/0) + 1] = (ry2 - (dy * r1));
            }
            cdata1[(/*CON_DIST*/2)] = err;
        }
        else
        {
            var cdata2 = (this._position2Contact ? this._contact2._data : null);
            var proj;
            var cx1, cx2, cy1, cy2;

            var lx = adata[(/*ARB_LNORM*/11)];
            var ly = adata[(/*ARB_LNORM*/11) + 1];
            var rx = cdata1[(/*CON_LREL1*/13)];
            var ry = cdata1[(/*CON_LREL1*/13) + 1];
            if (this._faceType === (/*FACE_1*/1))
            {
                nx = (lx * cos1) - (ly * sin1);
                ny = (lx * sin1) + (ly * cos1);
                proj = adata[(/*ARB_LPROJ*/13)] + ((nx * px1) + (ny * py1));
                cx1 = (px2 + (rx * cos2) - (ry * sin2));
                cy1 = (py2 + (rx * sin2) + (ry * cos2));
                if (cdata2)
                {
                    rx = cdata2[(/*CON_LREL1*/13)];
                    ry = cdata2[(/*CON_LREL1*/13) + 1];
                    cx2 = (px2 + (rx * cos2) - (ry * sin2));
                    cy2 = (py2 + (rx * sin2) + (ry * cos2));
                }
            }
            else
            {
                nx = (lx * cos2) - (ly * sin2);
                ny = (lx * sin2) + (ly * cos2);
                proj = adata[(/*ARB_LPROJ*/13)] + ((nx * px2) + (ny * py2));
                cx1 = (px1 + (rx * cos1) - (ry * sin1));
                cy1 = (py1 + (rx * sin1) + (ry * cos1));
                if (cdata2)
                {
                    rx = cdata2[(/*CON_LREL1*/13)];
                    ry = cdata2[(/*CON_LREL1*/13) + 1];
                    cx2 = (px1 + (rx * cos1) - (ry * sin1));
                    cy2 = (py1 + (rx * sin1) + (ry * cos1));
                }
            }

            var flip = (this._reverse ? -1 : 1);
            adata[(/*ARB_NORMAL*/4)]     = (flip * nx);
            adata[(/*ARB_NORMAL*/4) + 1] = (flip * ny);

            var bias = -proj - rad;

            err = ((cx1 * nx) + (cy1 * ny)) + bias;
            var df = ((err * 0.5) + rad);
            cdata1[(/*CON_POS*/0)]     = (cx1 - (nx * df));
            cdata1[(/*CON_POS*/0) + 1] = (cy1 - (ny * df));
            cdata1[(/*CON_DIST*/2)]    = err;

            if (cdata2)
            {
                err = ((cx2 * nx) + (cy2 * ny)) + bias;
                df = ((err * 0.5) + rad);
                cdata2[(/*CON_POS*/0)]     = (cx2 - (nx * df));
                cdata2[(/*CON_POS*/0) + 1] = (cy2 - (ny * df));
                cdata2[(/*CON_DIST*/2)]    = err;
            }
        }
    },

    _iteratePosition : function _iteratePositionFn()
    {
        this._refreshContactData();

        var b1 = this.bodyA;
        var b2 = this.bodyB;
        var data1 = b1._data;
        var data2 = b2._data;
        var im1 = data1[(/*BODY_IMASS*/0)];
        var ii1 = data1[(/*BODY_IINERTIA*/1)];
        var im2 = data2[(/*BODY_IMASS*/0)];
        var ii2 = data2[(/*BODY_IINERTIA*/1)];
        var px1 = data1[(/*BODY_POS*/2)];
        var py1 = data1[(/*BODY_POS*/2) + 1];
        var px2 = data2[(/*BODY_POS*/2)];
        var py2 = data2[(/*BODY_POS*/2) + 1];

        var px, py, nx, ny, Jx, Jy, jn, dr, Ka, bc;
        var c1r1x, c1r1y, c1r2x, c1r2y, rn1a, rn1b;

        var adata = this._data;
        var cdata1 = this._contact1._data;
        var err1 = cdata1[(/*CON_DIST*/2)] + Physics2DConfig.CONTACT_SLOP;
        if (this._position2Contact)
        {
            var cdata2 = this._contact2._data;
            var err2 = cdata2[(/*CON_DIST*/2)] + Physics2DConfig.CONTACT_SLOP;
            if (err1 < 0 || err2 < 0)
            {
                px = cdata1[(/*CON_POS*/0)];
                py = cdata1[(/*CON_POS*/0) + 1];
                c1r1x = (px - px1);
                c1r1y = (py - py1);
                c1r2x = (px - px2);
                c1r2y = (py - py2);

                px = cdata2[(/*CON_POS*/0)];
                py = cdata2[(/*CON_POS*/0) + 1];
                var c2r1x = (px - px1);
                var c2r1y = (py - py1);
                var c2r2x = (px - px2);
                var c2r2y = (py - py2);

                nx = adata[(/*ARB_NORMAL*/4)];
                ny = adata[(/*ARB_NORMAL*/4) + 1];

                rn1a = (c1r1x * ny) - (c1r1y * nx);
                rn1b = (c1r2x * ny) - (c1r2y * nx);
                var rn2a = (c2r1x * ny) - (c2r1y * nx);
                var rn2b = (c2r2x * ny) - (c2r2y * nx);

                // Non-inverted block effective-mass.
                var massSum = (im1 + im2);
                Ka = massSum + (ii1 * rn1a * rn1a) + (ii2 * rn1b * rn1b);
                var Kb = massSum + (ii1 * rn1a * rn2a) + (ii2 * rn1b * rn2b);
                var Kc = massSum + (ii1 * rn2a * rn2a) + (ii2 * rn2b * rn2b);

                bc = adata[(/*ARB_BIAS*/15)];
                var bx = (err1 * bc);
                var by = (err2 * bc);

                // Block solver.
                var det = ((Ka * Kc) - (Kb * Kb));
                var xx, xy;
                if (det === 0)
                {
                    xx = (Ka === 0) ? 0 : (-bx / Ka);
                    xy = (Kc === 0) ? 0 : (-by / Kc);
                }
                else
                {
                    det = (1 / det);
                    xx = (det * (Kb * by - Kc * bx));
                    xy = (det * (Kb * bx - Ka * by));
                }

                if (xx < 0 || xy < 0)
                {
                    xx = (-bx / Ka);
                    xy = 0;
                    if (xx < 0 || ((Kb * xx) + by) < 0)
                    {
                        xx = 0;
                        xy = (-by / Kc);
                        if (xy < 0 || ((Kb * xy) + bx) < 0)
                        {
                            xx = xy = 0;
                        }
                    }
                }

                // Apply impulses.
                jn = xx + xy;
                Jx = (nx * jn);
                Jy = (ny * jn);

                px1 -= (Jx * im1);
                py1 -= (Jy * im1);
                dr = -((rn1a * xx) + (rn2a * xy)) * ii1;
                if (dr !== 0)
                {
                    b1._deltaRotation(dr);
                }
                px2 += (Jx * im2);
                py2 += (Jy * im2);
                dr = ((rn1b * xx) + (rn2b * xy)) * ii2;
                if (dr !== 0)
                {
                    b2._deltaRotation(dr);
                }
            }
        }
        else
        {
            if (err1 < 0)
            {
                px = cdata1[(/*CON_POS*/0)];
                py = cdata1[(/*CON_POS*/0) + 1];

                c1r1x = (px - px1);
                c1r1y = (py - py1);
                c1r2x = (px - px2);
                c1r2y = (py - py2);

                nx = adata[(/*ARB_NORMAL*/4)];
                ny = adata[(/*ARB_NORMAL*/4) + 1];

                // jac
                rn1a = (c1r1x * ny) - (c1r1y * nx);
                rn1b = (c1r2x * ny) - (c1r2y * nx);

                // eff-mass
                Ka = im2 + (rn1b * rn1b * ii2) + im1 + (rn1a * rn1a * ii1);
                if (Ka !== 0)
                {
                    bc = adata[(/*ARB_BIAS*/15)];
                    jn = -(bc * err1 / Ka);
                    Jx = (nx * jn);
                    Jy = (ny * jn);

                    px1 -= (Jx * im1);
                    py1 -= (Jy * im1);
                    dr = -(rn1a * ii1 * jn);
                    if (dr !== 0)
                    {
                        b1._deltaRotation(dr);
                    }
                    px2 += (Jx * im2);
                    py2 += (Jy * im2);
                    dr = (rn1b * ii2 * jn);
                    if (dr !== 0)
                    {
                        b2._deltaRotation(dr);
                    }
                }
            }
        }

        data1[(/*BODY_POS*/2)]     = px1;
        data1[(/*BODY_POS*/2) + 1] = py1;
        data2[(/*BODY_POS*/2)]     = px2;
        data2[(/*BODY_POS*/2) + 1] = py2;
    },

    // =====================================================================

    _warmStart : function _warmStartFn()
    {
        var data1 = this.bodyA._data;
        var data2 = this.bodyB._data;
        var im1 = data1[(/*BODY_IMASS*/0)];
        var ii1 = data1[(/*BODY_IINERTIA*/1)];
        var im2 = data2[(/*BODY_IMASS*/0)];
        var ii2 = data2[(/*BODY_IINERTIA*/1)];

        var adata = this._data;
        var nx = adata[(/*ARB_NORMAL*/4)];
        var ny = adata[(/*ARB_NORMAL*/4) + 1];

        var cdata = this._contact1._data;
        var jn = cdata[(/*CON_JNACC*/11)];
        var jt = cdata[(/*CON_JTACC*/12)];

        var jx = (nx * jn) - (ny * jt);
        var jy = (ny * jn) + (nx * jt);
        data1[(/*BODY_VEL*/7)]     -= (jx * im1);
        data1[(/*BODY_VEL*/7) + 1] -= (jy * im1);
        data1[(/*BODY_VEL*/7) + 2] -= ((cdata[(/*CON_REL1*/7)] * jy) - (cdata[(/*CON_REL1*/7) + 1] * jx)) * ii1;
        data2[(/*BODY_VEL*/7)]     += (jx * im2);
        data2[(/*BODY_VEL*/7) + 1] += (jy * im2);
        data2[(/*BODY_VEL*/7) + 2] += ((cdata[(/*CON_REL2*/9)] * jy) - (cdata[(/*CON_REL2*/9) + 1] * jx)) * ii2;

        if (this._velocity2Contact)
        {
            cdata = this._contact2._data;
            jn = cdata[(/*CON_JNACC*/11)];
            jt = cdata[(/*CON_JTACC*/12)];

            jx = (nx * jn) - (ny * jt);
            jy = (ny * jn) + (nx * jt);
            data1[(/*BODY_VEL*/7)]     -= (jx * im1);
            data1[(/*BODY_VEL*/7) + 1] -= (jy * im1);
            data1[(/*BODY_VEL*/7) + 2] -= ((cdata[(/*CON_REL1*/7)] * jy) - (cdata[(/*CON_REL1*/7) + 1] * jx)) * ii1;
            data2[(/*BODY_VEL*/7)]     += (jx * im2);
            data2[(/*BODY_VEL*/7) + 1] += (jy * im2);
            data2[(/*BODY_VEL*/7) + 2] += ((cdata[(/*CON_REL2*/9)] * jy) - (cdata[(/*CON_REL2*/9) + 1] * jx)) * ii2;
        }
        else if (this._contact1._hash === (/*HASH_CIRCLE*/0))
        {
            jn = adata[(/*ARB_JRACC*/16)];

            data1[(/*BODY_VEL*/7) + 2] -= (jn * ii1);
            data2[(/*BODY_VEL*/7) + 2] += (jn * ii2);
        }
    },

    getImpulseForBody : function getImpulseForBodyFn(body, dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(3);
        }

        var adata = this._data;
        var nx = adata[(/*ARB_NORMAL*/4)];
        var ny = adata[(/*ARB_NORMAL*/4) + 1];

        var cdata = this._contact1._data;
        var jn = cdata[(/*CON_JNACC*/11)];
        var jt = cdata[(/*CON_JTACC*/12)];

        var jx = (nx * jn) - (ny * jt);
        var jy = (ny * jn) + (nx * jt);

        var sumX = 0;
        var sumY = 0;
        var sumW = 0;
        if (body === this.bodyA)
        {
            sumX -= jx;
            sumY -= jy;
            sumW -= ((cdata[(/*CON_REL1*/7)] * jy) - (cdata[(/*CON_REL1*/7) + 1] * jx));
        }
        else if (body === this.bodyB)
        {
            sumX += jx;
            sumY += jy;
            sumW += ((cdata[(/*CON_REL2*/9)] * jy) - (cdata[(/*CON_REL2*/9) + 1] * jx));
        }

        if (this._velocity2Contact)
        {
            cdata = this._contact2._data;
            jn = cdata[(/*CON_JNACC*/11)];
            jt = cdata[(/*CON_JTACC*/12)];

            jx = (nx * jn) - (ny * jt);
            jy = (ny * jn) + (nx * jt);
            if (body === this.bodyA)
            {
                sumX -= jx;
                sumY -= jy;
                sumW -= ((cdata[(/*CON_REL1*/7)] * jy) - (cdata[(/*CON_REL1*/7) + 1] * jx));
            }
            else if (body === this.bodyB)
            {
                sumX += jx;
                sumY += jy;
                sumW += ((cdata[(/*CON_REL2*/9)] * jy) - (cdata[(/*CON_REL2*/9) + 1] * jx));
            }
        }
        else if (this._contact1._hash === (/*HASH_CIRCLE*/0))
        {
            jn = adata[(/*ARB_JRACC*/16)];
            sumW += (body === this.bodyA ? -1 : (body === this.bodyB ? 1 : 0)) * jn;
        }

        dst[0] = sumX;
        dst[1] = sumY;
        dst[2] = sumW;
        return dst;
    }
};


Physics2DArbiter.pool = null;
Physics2DArbiter.allocate = function allocateArbiterFn()
{
    if (!this.pool)
    {
        return new Physics2DArbiter();
    }
    else
    {
        var arb = this.pool;
        this.pool = arb._next;
        arb._next = null;
        return arb;
    }
};

Physics2DArbiter.deallocate = function deallocateArbiterFn(arb)
{
    arb._next = this.pool;
    this.pool = arb;

    arb._userdef = 0;
};

// =========================================================================

//
// Physics2D World
//
function Physics2DWorld() {}
Physics2DWorld.prototype = {

    version : 1,

    getGravity : function getGravityFn(dst)
    {
        if (dst === undefined)
        {
            dst = new Physics2DDevice.prototype.floatArray(2);
        }

        dst[0] = this._gravityX;
        dst[1] = this._gravityY;
        return dst;
    },

    setGravity : function setGravityFn(gravity)
    {
        var newX = gravity[0];
        var newY = gravity[1];
        if (newX !== this._gravityX || newY !== this._gravityY)
        {
            this._gravityX = newX;
            this._gravityY = newY;

            var bodies = this.rigidBodies;
            var limit = bodies.length;
            var i;
            for (i = 0; i < limit; i += 1)
            {
                this._wakeBody(bodies[i]);
            }
        }
    },

    // =====================================================================

    _addShape : function _addShapeFn(shape)
    {
        var body = shape.body;
        body._update();

        var isStaticHandle = ((body._type === (/*TYPE_STATIC*/2)) || body.sleeping);
        shape._bphaseHandle = this.broadphase.insert(shape, shape._data, isStaticHandle);
    },

    // precon: body was woken before calling this method.
    //         therefore all arbiters are in the world as
    //         non-sleeping.
    _removeShape : function _removeShapeFn(shape, noCallbacks)
    {
        var body = shape.body;
        this.broadphase.remove(shape._bphaseHandle);
        shape._bphaseHandle = null;

        var arbiters = shape.arbiters;
        while (arbiters.length !== 0)
        {
            var arb = arbiters.pop();
            if (arb._retired)
            {
                continue;
            }

            if (arb.bodyA !== body && arb.bodyA._type === (/*TYPE_DYNAMIC*/0))
            {
                this._wakeBody(arb.bodyA);
            }
            if (arb.bodyB !== body && arb.bodyB._type === (/*TYPE_DYNAMIC*/0))
            {
                this._wakeBody(arb.bodyB);
            }

            arb._lazyRetire(shape);
            if (!noCallbacks)
            {
                this._pushInteractionEvents((/*EVENT_END*/3), arb);
            }
        }
    },

    // Call on constraint when:
    //  A)  active (outside world), and then added to world
    //  B)  in world (inactive), and then enabled
    _enabledConstraint : function _enabledConstraintFn(constraint)
    {
        // prepare constraint for disjoint set forest.
        constraint._islandRoot = constraint;
        constraint._islandRank = 0;

        if (!constraint.sleeping)
        {
            constraint.sleeping = true; // force wake.
            this._wakeConstraint(constraint, true);
        }
    },

    // Call on constraint when:
    //  A)  active (in world), and then removed from world
    //  B)  in world (active), and then disabled.
    _disabledConstraint : function _disabledConstraintFn(constraint)
    {
        this._wakeConstraint(constraint);

        var constraints = this.liveConstraints;
        var index = constraints.indexOf(constraint);
        constraints[index] = constraints[constraints.length - 1];
        constraints.pop();
    },

    addConstraint : function addConstraintFn(constraint)
    {
        if (constraint.world)
        {
            return false;
        }

        constraint.world = this;
        this.constraints.push(constraint);

        constraint._inWorld();

        if (constraint._active)
        {
            this._enabledConstraint(constraint);
        }

        return true;
    },

    removeConstraint : function removeConstraintFn(constraint)
    {
        if (constraint.world !== this)
        {
            return false;
        }

        var constraints = this.constraints;
        var index = constraints.indexOf(constraint);
        constraints[index] = constraints[constraints.length - 1];
        constraints.pop();

        if (constraint._active)
        {
            this._disabledConstraint(constraint);
        }

        constraint.world = null;
        constraint._outWorld();

        return true;
    },

    addRigidBody : function addRigidBodyFn(body)
    {
        if (body.world)
        {
            return false;
        }

        body.world = this;
        this.rigidBodies.push(body);

        body._update();

        var i;
        var shapes = body.shapes;
        var limit = shapes.length;
        for (i = 0; i < limit; i += 1)
        {
            this._addShape(shapes[i]);
        }

        if (body._type === (/*TYPE_STATIC*/2))
        {
            body.sleeping = true;
            return true;
        }

        // prepare body for disjoint set forest.
        body._islandRoot = body;
        body._islandRank = 0;

        if (!body.sleeping)
        {
            body.sleeping = true; //force wake.
            this._wakeBody(body, true);
        }

        return true;
    },

    removeRigidBody : function removeRigidBodyFn(body, noCallbacks)
    {
        if (body.world !== this)
        {
            return false;
        }

        this._wakeBody(body);

        body.world = null;
        var rigidBodies = this.rigidBodies;
        var index = rigidBodies.indexOf(body);
        rigidBodies[index] = rigidBodies[rigidBodies.length - 1];
        rigidBodies.pop();

        if (!body.sleeping && (body._type !== (/*TYPE_STATIC*/2)))
        {
            if (body._type === (/*TYPE_DYNAMIC*/0))
            {
                rigidBodies = this.liveDynamics;
            }
            else
            {
                rigidBodies = this.liveKinematics;
            }

            index = rigidBodies.indexOf(body);
            rigidBodies[index] = rigidBodies[rigidBodies.length - 1];
            rigidBodies.pop();
        }

        var i;
        var shapes = body.shapes;
        var limit = shapes.length;
        for (i = 0; i < limit; i += 1)
        {
            this._removeShape(shapes[i], noCallbacks);
        }

        // Remove constraints!
        var constraints = body.constraints;
        while (constraints.length > 0)
        {
            this.removeConstraint(constraints[0]);
        }

        return true;
    },

    // =====================================================================

    clear : function clearFn()
    {
        // Clean up rigidBodies, liveDynamics, liveKinematics
        var bodies = this.rigidBodies;
        var limit = bodies.length;
        while (limit > 0)
        {
            limit -= 1;
            this.removeRigidBody(bodies[limit], true);
        }

        // Clean up constraints, liveConstraints
        var constraints = this.constraints;
        limit = constraints.length;
        while (limit > 0)
        {
            limit -= 1;
            this.removeConstraint(constraints[limit]);
        }

        // Clean up dynamicArbiters, staticArbiters
        this._clearArbiters(this.staticArbiters);
        this._clearArbiters(this.dynamicArbiters);

        // Clean up any deferred callbacks generated
        // outside of world::step()
        // (Waking a constraint/body indirectly)
        // (Removing a shape)
        var callbacks = this._callbacks;
        limit = callbacks.length;
        while (limit > 0)
        {
            limit -= 1;
            Physics2DCallback.deallocate(callbacks.pop());
        }

        // _island, _toiEvents already empty
        // broadphase already clear by removal of shapes.
    },

    _clearArbiters : function _clearArbitersFn(arbiters)
    {
        var limit = arbiters.length;
        while (limit > 0)
        {
            var arb = arbiters.pop();
            limit -= 1;

            arb._retire();
            Physics2DArbiter.deallocate(arb);
        }
    },

    // =====================================================================

    shapePointQuery : function shapePointQueryFn(point, store)
    {
        return this._pointQuery(this._shapePointCallback, point, store);
    },

    bodyPointQuery : function bodyPointQueryFn(point, store)
    {
        return this._pointQuery(this._bodyPointCallback, point, store);
    },

    _pointQuery : function _pointQueryFn(callback, point, store)
    {
        var rect = this._sampleRectangle;
        rect[0] = rect[2] = point[0];
        rect[1] = rect[3] = point[1];

        callback.store = store;
        callback.count = 0;
        this.broadphase.sample(rect, callback.sample, callback);
        return callback.count;
    },

    // -------------------------------------

    shapeCircleQuery : function shapeCircleQueryFn(center, radius, store)
    {
        return this._circleQuery(this._shapeCircleCallback, center, radius, store);
    },

    bodyCircleQuery : function bodyCircleQueryFn(center, radius, store)
    {
        return this._circleQuery(this._bodyCircleCallback, center, radius, store);
    },

    _circleQuery : function _circleQueryFn(callback, center, radius, store)
    {
        var circle = this._circleQueryShape;
        circle.setRadius(radius);

        var posX = center[0];
        var posY = center[1];
        circle._update(posX, posY, 1, 0);

        var rect = this._sampleRectangle;
        rect[0] = (posX - radius);
        rect[1] = (posY - radius);
        rect[2] = (posX + radius);
        rect[3] = (posY + radius);

        callback.store = store;
        callback.count = 0;
        this.broadphase.sample(rect, callback.sample, callback);
        return callback.count;
    },

    // -------------------------------------

    shapeRectangleQuery : function shapeRectangleQueryFn(point, store)
    {
        return this._rectangleQuery(this._shapeRectangleCallback, point, store);
    },

    bodyRectangleQuery : function bodyRectangleQueryFn(point, store)
    {
        return this._rectangleQuery(this._bodyRectangleCallback, point, store);
    },

    _rectangleQuery : function _rectangleQueryFn(callback, aabb, store)
    {
        var vertices = this._rectangleQueryVertices;

        var x1 = aabb[0];
        var y1 = aabb[1];
        var x2 = aabb[2];
        var y2 = aabb[3];
        vertices[0][0] = vertices[3][0] = (x1 < x2 ? x1 : x2);
        vertices[0][1] = vertices[1][1] = (y1 < y2 ? y1 : y2);
        vertices[1][0] = vertices[2][0] = (x1 < x2 ? x2 : x1);
        vertices[2][1] = vertices[3][1] = (y1 < y2 ? y2 : y1);

        var poly = this._rectangleQueryShape;
        poly.setVertices(vertices);
        poly._update(0, 0, 1, 0);

        callback.store = store;
        callback.count = 0;
        this.broadphase.sample(aabb, callback.sample, callback);
        return callback.count;
    },

    // =====================================================================

    rayCast : function rayCastFn(ray, noInnerSurfaces, customCallback, thisObject)
    {
        var origin = ray.origin;
        var direction = ray.direction;
        var maxFactor = ray.maxFactor;
        var x1 = origin[0];
        var y1 = origin[1];
        var x2 = x1 + (direction[0] * maxFactor);
        var y2 = y1 + (direction[1] * maxFactor);

        var rect = this._sampleRectangle;
        rect[0] = (x1 < x2 ? x1 : x2);
        rect[1] = (y1 < y2 ? y1 : y2);
        rect[2] = (x1 < x2 ? x2 : x1);
        rect[3] = (y1 < y2 ? y2 : y1);

        var callback = this._rayCast;
        callback.ray = ray;
        callback.noInner = (noInnerSurfaces || false);
        callback.minFactor = ray.maxFactor;
        callback.userCallback = customCallback;
        callback.userThis = thisObject;
        this.broadphase.sample(rect, callback.sample, callback);

        if (callback.minShape)
        {
            var data = callback.minNormal;
            var hitNormal = new Physics2DDevice.prototype.floatArray(2);
            var hitPoint = new Physics2DDevice.prototype.floatArray(2);
            hitNormal[0] = data[0];
            hitNormal[1] = data[1];
            hitPoint[0] = (x1 + (direction[0] * callback.minFactor));
            hitPoint[1] = (y1 + (direction[1] * callback.minFactor));
            return {
                shape     : callback.minShape,
                hitNormal : hitNormal,
                hitPoint  : hitPoint,
                factor    : callback.minFactor
            };
        }
        else
        {
            return null;
        }
    },

    convexCast : function convexCastFn(shape, deltaTime, customCallback, thisObject)
    {
        var body = shape.body;
        var bdata = body._data;
        var preX = bdata[(/*BODY_POS*/2)];
        var preY = bdata[(/*BODY_POS*/2) + 1];
        body._sweepIntegrate(deltaTime);
        var curX = bdata[(/*BODY_POS*/2)];
        var curY = bdata[(/*BODY_POS*/2) + 1];

        var rect = this._sampleRectangle;
        var radius = shape._data[(/*SHAPE_SWEEP_RADIUS*/4)];
        rect[0] = ((preX < curX ? preX : curX) - radius);
        rect[1] = ((preY < curY ? preY : curY) - radius);
        rect[2] = ((preX < curX ? curX : preX) + radius);
        rect[3] = ((preY < curY ? curY : preY) + radius);

        body[(/*BODY_SWEEP_ANGVEL*/20)] = body[(/*BODY_VEL*/7) + 2];

        var callback = this._convexCast;
        callback.deltaTime = deltaTime;
        callback.minTOIAlpha = 1;
        callback.minShape = null;
        callback.toi.shapeA = shape;
        callback.userCallback = customCallback;
        callback.userThis = thisObject;
        this.broadphase.sample(rect, callback.sample, callback);

        // reset sweep body and shape.
        body._sweepIntegrate(0);
        shape._update(preX, preY, bdata[(/*BODY_AXIS*/5)], bdata[(/*BODY_AXIS*/5) + 1], true);

        if (callback.minShape)
        {
            var data = callback.minData;
            var hitNormal = new Physics2DDevice.prototype.floatArray(2);
            var hitPoint  = new Physics2DDevice.prototype.floatArray(2);
            hitNormal[0] = -data[0];
            hitNormal[1] = -data[1];
            hitPoint[0] = data[2];
            hitPoint[1] = data[3];
            return {
                shape     : callback.minShape,
                hitNormal : hitNormal,
                hitPoint  : hitPoint,
                factor    : (callback.minTOIAlpha * deltaTime)
            };
        }
        else
        {
            return null;
        }
    },

    // =====================================================================

    step : function stepFn(deltaTime)
    {
        this._midStep = true;
        this._eventTime = (/*EVENT_TIME_STANDARD*/0);
        this.timeStamp += 1;
        this._deltaTime = deltaTime;
        this.simulatedTime += deltaTime;

        // Update objects for current position/rotation
        // As well as preparing delayed WAKE callbacks.
        this._validate();

        // Perform discrete collision detection
        this._discreteCollisions();

        // Perform sleeping
        this._sleepComputations(deltaTime);

        // Pre-step arbiters
        this._preStep(deltaTime);

        // Sort arbiters
        this._sortArbiters();

        // Integrate velocities
        this._integrateVelocity(deltaTime);

        // Warm start arbiters
        this._warmStart();

        // Velocity iterators.
        this._iterateVelocity(this.velocityIterations);

        // Integrate positions and prepare for continuous collision detection.
        this._integratePosition(deltaTime);

        // Perform continous collision detection
        this._eventTime = (/*EVENT_TIME_CONTINUOUS*/1);
        this._continuousCollisions(deltaTime);

        // Sort arbiters (continuous may have inserted more).
        this._sortArbiters();

        // Positional iterationrs
        this._iteratePosition(this.positionIterations);

        // Finalize bodies, invalidating if necessary
        // Put kinematics that have not moved to sleep
        // Finalize contact positions, generate interaction callbacks.
        this._finalize();

        // Issue callbacks
        this._midStep = false;
        this._eventTime = (/*EVENT_TIME_PRE*/-1);
        this._doCallbacks();
    },

    // =========================================================================
    // =========================================================================

    _discreteCollisions : function _discreteCollisionsFn()
    {
        this.broadphase.perform(this._discreteNarrowPhase, this);
        this._doDeferredWake(false);
    },

    _doDeferredWake : function _deferredWakeFn(continuous)
    {
        // Waking of bodies by collision must be deferred,
        // Broadphase must not be modified during 'perform' call.
        var wakes = this._deferredWake;
        var limit = wakes.length;
        while (limit > 0)
        {
            var body = wakes.pop();
            body._deferred = false;

            // In the case of waking bodies after continuous collisions.
            // We must prestep the arbiters both for correct physics
            // and for callbacks to be properly generated (progress on sleeping arbiters).
            //
            // This is given by the continuous argument.
            this._wakeBody(body, false, continuous);
            limit -= 1;
        }
    },

    _collisionType : function _collisionTypeFn(s1, s2, b1, b2)
    {
        if (b1 === b2)
        {
            return undefined;
        }

        var constraints = ((b1.constraints.length < b2.constraints.length) ? b1.constraints : b2.constraints);
        var limit = constraints.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var con = constraints[i];
            if (con._active && con._ignoreInteractions && con._pairExists(b1, b2))
            {
                return undefined;
            }
        }

        /*jshint bitwise: false*/
        if ((s1._group & s2._mask) === 0 ||
            (s2._group & s1._mask) === 0)
        /*jshint bitwise: true*/
        {
            return undefined;
        }

        var collisionType = !(s1.sensor || s2.sensor);
        // Interaction between two static/kinematics cannot be
        // a collision type.
        if (b1._type !== (/*TYPE_DYNAMIC*/0) && b2._type !== (/*TYPE_DYNAMIC*/0) && collisionType)
        {
            return undefined;
        }

        return collisionType;
    },

    _discreteNarrowPhase : function _discreteNarrowPhase(handleA, handleB, continuous)
    {
        var s1 = handleA.data;
        var s2 = handleB.data;

        var b1 = s1.body;
        var b2 = s2.body;

        var ctype = this._collisionType(s1, s2, b1, b2);
        if (ctype === undefined)
        {
            // No interaction wanted.
            return null;
        }

        var staticType = (b1._type !== (/*TYPE_DYNAMIC*/0) || b2._type !== (/*TYPE_DYNAMIC*/0));
        // Order shapes by id for consistent Arbiter lookup without two-way check.
        var sa, sb;
        if (s1.id < s2.id)
        {
            sa = s1;
            sb = s2;
        }
        else
        {
            sa = s2;
            sb = s1;
        }

        // Search for existing Arbiter using smallest of shapes' arbiters lists.
        var arbiters = (sa.arbiters.length < sb.arbiters.length ? sa : sb).arbiters;
        var limit = arbiters.length;
        var i;
        var arb;
        for (i = 0; i < limit; i += 1)
        {
            var sarb = arbiters[i];
            if (sarb.shapeA === sa && sarb.shapeB === sb)
            {
                arb = sarb;
                break;
            }
        }

        var first = (!arb);
        if (first)
        {
            arb = Physics2DArbiter.allocate();
        }

        // Ensure we do not check collisions again in the same time step
        // Unless we are performing continuous collisions.
        if (first || arb._timeStamp !== this.timeStamp || continuous)
        {
            arb._timeStamp = this.timeStamp;
            if ((ctype && this._collisions._collide(sa, sb, arb)) ||
                (!ctype && this._collisions._test(sa, sb)))
            {
                if (first)
                {
                    arb.sensor = (!ctype);
                    arb._assign(sa, sb);
                    arb._static = staticType;
                    if (staticType)
                    {
                        this.staticArbiters.push(arb);
                    }
                    else
                    {
                        this.dynamicArbiters.push(arb);
                    }
                }

                // Expressions check the two cases where an arbiter is re-used
                // without a retirement inbetween, and which correspond to a
                // 'fresh' collision.
                if (first ||
                    (arb._endGenerated === this.timeStamp && continuous) ||
                    (arb._updateStamp < (this.timeStamp - 1)))
                {
                    arb._createContinuous = continuous;
                    arb._createStamp = this.timeStamp;

                    // Sensor type interaction takes no presolve events.
                    // so we immediately set state to ACCEPT|ALWAYS
                    /*jshint bitwise: false*/
                    arb._state = (ctype ? 0 : ((/*STATE_ACCEPT*/1) | (/*STATE_ALWAYS*/2)));
                    /*jshint bitwise: true*/
                }

                arb._updateStamp = this.timeStamp;

                var anyIndeterminate = false;
                // Check pre solve events in collision interactino type case.
                /*jshint bitwise: false*/
                if (ctype && (arb._state & (/*STATE_ALWAYS*/2)) === 0)
                /*jshint bitwise: true*/
                {
                    // Reset to default of ACCEPT, but not ALWAYS
                    // so that if no events are yet added, and one is then added
                    // it will be called.
                    arb._state = (/*STATE_ACCEPT*/1);
                    arb._midStep = true;

                    var events = sa._onPreSolve;
                    limit = events.length;
                    var eventObject;
                    for (i = 0; i < limit; i += 1)
                    {
                        eventObject = events[i];
                        eventObject.callback.call(eventObject.thisObject, arb, sb);
                        if (!eventObject.deterministic)
                        {
                            anyIndeterminate = true;
                        }
                    }

                    events = sb._onPreSolve;
                    limit = events.length;
                    for (i = 0; i < limit; i += 1)
                    {
                        eventObject = events[i];
                        eventObject.callback.call(eventObject.thisObject, arb, sa);
                        if (!eventObject.deterministic)
                        {
                            anyIndeterminate = true;
                        }
                    }

                    arb._midStep = false;
                    arb._indeterminate = anyIndeterminate;
                    // Imdeterministic, arbiter state must prevent objects
                    // from being put to sleep!
                    /*jshint bitwise: false*/
                    if (anyIndeterminate && (arb._state & (/*STATE_ALWAYS*/2)) === 0)
                    /*jshint bitwise: true*/
                    {
                        // we do not check they are sleeping before waking
                        // so that they may never sleep (wake time will be updated).
                        // Otherwise they could sleep if both were to be put to sleep at same
                        // time, or if it is a dynamic-static pair etc.
                        if (b1._type === (/*TYPE_DYNAMIC*/0) && !b1._deferred)
                        {
                            b1._deferred = true;
                            this._deferredWake.push(b1);
                        }
                        if (b2._type === (/*TYPE_DYNAMIC*/0) && !b1._deferred)
                        {
                            b2._deferred = true;
                            this._deferredWake.push(b2);
                        }
                    }
                }

                /*jshint bitwise: false*/
                if (ctype && (arb._state & (/*STATE_ACCEPT*/1) !== 0))
                /*jshint bitwise: true*/
                {
                    if (b1._type === (/*TYPE_DYNAMIC*/0) && b1.sleeping && !b1._deferred)
                    {
                        b1._deferred = true;
                        this._deferredWake.push(b1);
                    }
                    if (b2._type === (/*TYPE_DYNAMIC*/0) && b2.sleeping && !b2._deferred)
                    {
                        b2._deferred = true;
                        this._deferredWake.push(b2);
                    }
                }

                if (arb.sleeping)
                {
                    this._wakeArbiter(arb);
                }
            }
            else if (first)
            {
                Physics2DArbiter.deallocate(arb);
                arb = null;
            }
        }

        return arb;
    },

    // =====================================================================

    _continuousCollisions : function _continuousCollisionsFn(deltaTime)
    {
        this.broadphase.perform(this._continuousNarrowPhase, this);

        var curTimeAlpha = 0.0;
        var toiEvents = this._toiEvents;
        var limit = toiEvents.length;
        var toi, i;
        while (curTimeAlpha < 1.0 && limit !== 0)
        {
            var minTOIAlpha = Number.POSITIVE_INFINITY;
            var minKinematic = false;
            var min = -1;

            var b1, b2;
            for (i = 0; i < limit;)
            {
                toi = toiEvents[i];
                b1 = toi.shapeA.body;
                b2 = toi.shapeB.body;

                // TOI invalid.
                if (b1._sweepFrozen && b2._sweepFrozen)
                {
                    limit -= 1;
                    toiEvents[i] = toiEvents[limit];
                    toiEvents.pop();
                    Physics2DTOIEvent.deallocate(toi);
                    continue;
                }

                // TOI invalidated.
                if (toi.frozenA !== b1._sweepFrozen ||
                    toi.frozenB !== b2._sweepFrozen)
                {
                    // Recompute TOI
                    toi.frozenA = b1._sweepFrozen;
                    toi.frozenB = b2._sweepFrozen;

                    // Check if order of objects in event need swapped
                    // (_staticSweep restrictions on order)
                    if (toi.frozenA)
                    {
                        var tmp = toi.shapeA;
                        toi.shapeA = toi.shapeB;
                        toi.shapeB = tmp;
                        toi.frozenA = false;
                        toi.frozenB = true;
                    }

                    this._collisions._staticSweep(toi, deltaTime, Physics2DConfig.SWEEP_SLOP);
                    if (toi._data[(/*TOI_TOI_ALPHA*/6)] < 0)
                    {
                        limit -= 1;
                        toiEvents[i] = toiEvents[limit];
                        toiEvents.pop();
                        Physics2DTOIEvent.deallocate(toi);
                        continue;
                    }
                }

                var curTOIAlpha = toi._data[(/*TOI_TOI_ALPHA*/6)];
                if (curTOIAlpha >= 0 && (curTOIAlpha < minTOIAlpha || (!minKinematic && toi.kinematic)))
                {
                    minTOIAlpha = curTOIAlpha;
                    minKinematic = toi.kinematic;
                    min = i;
                }

                i += 1;
            }

            if (min === -1)
            {
                break;
            }

            // Remove TOI event from list
            toi = toiEvents[min];
            limit -= 1;
            toiEvents[min] = toiEvents[limit];
            toiEvents.pop();

            // Advance time alpha
            curTimeAlpha = minTOIAlpha;

            var s1 = toi.shapeA;
            var s2 = toi.shapeB;
            b1 = s1.body;
            b2 = s2.body;
            var data1 = b1._data;
            var data2 = b2._data;

            // Update body (and collided shapes) to TOI.
            if (!b1._sweepFrozen || toi.kinematic)
            {
                b1._sweepIntegrate(curTimeAlpha * deltaTime);
                s1._update(data1[(/*BODY_POS*/2)],  data1[(/*BODY_POS*/2) + 1],
                           data1[(/*BODY_AXIS*/5)], data1[(/*BODY_AXIS*/5) + 1], true);
            }
            if (!b2._sweepFrozen || toi.kinematic)
            {
                b2._sweepIntegrate(curTimeAlpha * deltaTime);
                s2._update(data2[(/*BODY_POS*/2)],  data2[(/*BODY_POS*/2) + 1],
                           data2[(/*BODY_AXIS*/5)], data2[(/*BODY_AXIS*/5) + 1], true);
            }

            var arb = this._discreteNarrowPhase(s1._bphaseHandle, s2._bphaseHandle, true);
            if (arb)
            {
                // Discrete collision detected, pre-step for position iterations
                // (For sensors, issue begin callbacks if appropriate)
                this._continuousArbiterPrepare(arb, deltaTime);
            }

            /*jshint bitwise: false*/
            if (arb && !arb.sensor && (arb._state & (/*STATE_ACCEPT*/1)) !== 0)
            /*jshint bitwise: true*/
            {
                // Freeze objects
                if (!b1._sweepFrozen && b1._type === (/*TYPE_DYNAMIC*/0))
                {
                    b1._sweepFrozen = true;
                    if (toi.failed)
                    {
                        data1[(/*BODY_SWEEP_ANGVEL*/20)] = 0;
                    }
                    else if (toi.slipped)
                    {
                        data1[(/*BODY_SWEEP_ANGVEL*/20)] *= Physics2DConfig.TOI_SLIP_SCALE;
                    }
                    data1[(/*BODY_VEL*/7) + 2] = data1[(/*BODY_SWEEP_ANGVEL*/20)];
                }
                if (!b2._sweepFrozen && b2._type === (/*TYPE_DYNAMIC*/0))
                {
                    b2._sweepFrozen = true;
                    if (toi.failed)
                    {
                        data2[(/*BODY_SWEEP_ANGVEL*/20)] = 0;
                    }
                    else if (toi.slipped)
                    {
                        data2[(/*BODY_SWEEP_ANGVEL*/20)] *= Physics2DConfig.TOI_SLIP_SCALE;
                    }
                    data2[(/*BODY_VEL*/7) + 2] = data2[(/*BODY_SWEEP_ANGVEL*/20)];
                }
            }

            Physics2DTOIEvent.deallocate(toi);
        }

        while (limit > 0)
        {
            toi = toiEvents.pop();
            Physics2DTOIEvent.deallocate(toi);
            limit -= 1;
        }

        // Advance remaining, unfrozen objects to end of time step.
        var bodies = this.liveDynamics;
        limit = bodies.length;
        for (i = 0; i < limit; i += 1)
        {
            var body = bodies[i];
            if (!body._sweepFrozen)
            {
                body._sweepIntegrate(deltaTime);
            }
        }

        // Advance all kinematics to end of time step.
        bodies = this.liveKinematics;
        limit = bodies.length;
        for (i = 0; i < limit; i += 1)
        {
            bodies[i]._sweepIntegrate(deltaTime);
        }

        // We do not need to do any more work with sleeping arbiters
        // here like pre-stepping before position iterations
        //
        // Arbiters were sleeping -> objects were sleeping -> data
        // is the same.
        this._doDeferredWake(true);
    },

    _continuousNarrowPhase : function _continuousNarrowPhase(handleA, handleB)
    {
        var s1 = handleA.data;
        var s2 = handleB.data;
        var b1 = s1.body;
        var b2 = s2.body;
        if (b1._sweepFrozen && b2._sweepFrozen)
        {
            return;
        }

        var staticType = (b1._type !== (/*TYPE_DYNAMIC*/0) || b2._type !== (/*TYPE_DYNAMIC*/0));
        if (staticType || (b1._bullet || b2._bullet))
        {
            var toi = Physics2DTOIEvent.allocate();
            var kin = (b1._type === (/*TYPE_KINEMATIC*/1) || b2._type === (/*TYPE_KINEMATIC*/1));
            if (staticType && !kin)
            {
                if (b1._type !== (/*TYPE_DYNAMIC*/0))
                {
                    toi.shapeB = s1;
                    toi.shapeA = s2;
                }
                else
                {
                    toi.shapeA = s1;
                    toi.shapeB = s2;
                }
                this._collisions._staticSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP);
            }
            else
            {
                toi.shapeA = s1;
                toi.shapeB = s2;
                this._collisions._dynamicSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP);
            }

            // Permit dynamic-dynamic events that represent missed collisions
            // to persist as freezing of one of the two objects may cause
            // event to change and we miss too many dynamic-dynamic collisions
            // by not allowing the event to persist.
            if ((staticType && toi._data[(/*TOI_TOI_ALPHA*/6)] < 0) || toi.failed)
            {
                Physics2DTOIEvent.deallocate(toi);
            }
            else
            {
                this._toiEvents.push(toi);
                toi.frozenA = toi.shapeA.body._sweepFrozen;
                toi.frozenB = toi.shapeB.body._sweepFrozen;
                toi.staticType = staticType;
                toi.kinematic = kin;
            }
        }
    },

    // =====================================================================

    __union : function __unionFn(x, y)
    {
        var stack, next;
        // x = __find(x)
        while (x !== x._islandRoot)
        {
            next = x._islandRoot;
            x._islandRoot = stack;
            stack = x;
            x = next;
        }
        while (stack)
        {
            next = stack._islandRoot;
            stack._islandRoot = x;
            stack = next;
        }

        // y = __find(y)
        while (y !== y._islandRoot)
        {
            next = y._islandRoot;
            y._islandRoot = stack;
            stack = y;
            y = next;
        }
        while (stack)
        {
            next = stack._islandRoot;
            stack._islandRoot = y;
            stack = next;
        }

        if (x !== y)
        {
            if (x._islandRank < y._islandRank)
            {
                x._islandRoot = y;
            }
            else if (y._islandRank < x._islandRank)
            {
                y._islandRoot = x;
            }
            else
            {
                y._islandRoot = x;
                x._islandRank += 1;
            }
        }
    },

    __find : function __findFn(x)
    {
        if (x === x._islandRoot)
        {
            return x;
        }

        var stack = null;
        var next;
        while (x !== x._islandRoot)
        {
            next = x._islandRoot;
            x._islandRoot = stack;
            stack = x;
            x = next;
        }
        while (stack)
        {
            next = stack._islandRoot;
            stack._islandRoot = x;
            stack = next;
        }
        return x;
    },

    // =====================================================================

    _sleepComputations : function _sleepComputationsFn(deltaTime)
    {
        // Build disjoint set forest.
        //
        // arb.active not yet computed, so base it on currently available info.
        var arbiters = this.dynamicArbiters;
        var arb;
        var limit = arbiters.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            arb = arbiters[i];
            /*jshint bitwise: false*/
            if (!arb.sensor && !arb._retired &&
                arb._updateStamp === this.timeStamp &&
                (arb._state & (/*STATE_ACCEPT*/1)) !== 0)
            {
            /*jshint bitwise: true*/
                var b1 = arb.bodyA;
                var b2 = arb.bodyB;
                if (b1._type === (/*TYPE_DYNAMIC*/0) && b2._type === (/*TYPE_DYNAMIC*/0))
                {
                    this.__union(b1, b2);
                }
            }
        }

        var constraints = this.liveConstraints;
        limit = constraints.length;
        for (i = 0; i < limit; i += 1)
        {
            constraints[i]._sleepComputation(this.__union);
        }

        // Build islands.
        var islands = this._islands;
        var island, root;
        var bodies = this.liveDynamics;
        limit = bodies.length;
        while (limit > 0)
        {
            limit -= 1;
            var body = bodies.pop();

            root = this.__find(body);
            island = root._island;
            if (island === null)
            {
                root._island = island = Physics2DIsland.allocate();
                islands.push(island);
                island.sleeping = true;
                island.wakeTime = 0;
            }
            body._island = island;
            island.components.push(body);

            var atRest = body._atRest(deltaTime, this.timeStamp);
            island.sleeping = (island.sleeping && atRest);
            if (body._wakeTime > island.wakeTime)
            {
                island.wakeTime = body._wakeTime;
            }
        }

        limit = constraints.length;
        while (limit > 0)
        {
            limit -= 1;
            var con = constraints.pop();

            root = this.__find(con);
            island = root._island;
            if (island === null)
            {
                root._island = island = Physics2DIsland.allocate();
                islands.push(island);
                island.sleeping = true;
                island.wakeTime = 0;
            }

            con._island = island;
            island.components.push(con);
            if (con._wakeTime > island.wakeTime)
            {
                island.wakeTime = con._wakeTime;
            }
        }

        // Build new live lists of bodies and constraints.
        // live lists of arbiters is deferred to preStep.
        // And destroy waking islands.
        limit = islands.length;
        var limit2;
        var bphase = this.broadphase;
        while (limit > 0)
        {
            limit -= 1;
            island = islands[limit];
            islands.pop();

            var comp, comps;
            if (island.sleeping)
            {
                comps = island.components;
                limit2 = comps.length;
                var j;
                for (j = 0; j < limit2; j += 1)
                {
                    comp = comps[j];
                    comp.sleeping = true;

                    if (comp._isBody)
                    {
                        var shapes = comp.shapes;
                        var limit3 = shapes.length;
                        var k;
                        for (k = 0; k < limit3; k += 1)
                        {
                            var shape = shapes[k];
                            bphase.update(shape._bphaseHandle, shape._data, true);
                        }
                        var data = comp._data;
                        data[(/*BODY_VEL*/7)]     = 0;
                        data[(/*BODY_VEL*/7) + 1] = 0;
                        data[(/*BODY_VEL*/7) + 2] = 0;

                    }

                    // Body + Constraint
                    if (comp._onSleep.length > 0)
                    {
                        this._pushCallbacks(comp, comp._onSleep);
                    }
                }
            }
            else
            {
                comps = island.components;
                limit2 = comps.length;
                while (limit2 > 0)
                {
                    limit2 -= 1;
                    comp = comps.pop();

                    comp._wakeTime = island.wakeTime;
                    if (comp._isBody)
                    {
                        bodies.push(comp);
                    }
                    else
                    {
                        constraints.push(comp);
                    }

                    // Reset island properties
                    comp._island = null;
                    comp._islandRoot = comp;
                    comp._islandRank = 0;
                }

                Physics2DIsland.deallocate(island);
            }
        }
    },

    // =====================================================================

    _sortArbiters : function _sortArbitersFn()
    {
        this._subSortArbiters(this.dynamicArbiters);
        this._subSortArbiters(this.staticArbiters);
    },

    _subSortArbiters : function _subSortArbitersFn(arbiters)
    {
        // Insertion sort of arbiters list using shape id's as
        // lexicographical keys.
        //
        // Insertion sort is suitable here, as arbiter list will be
        // SUBSTANTIALLY sorted already.
        //
        // We perform this sort so that broadphase has no effect
        // on physics behaviour.
        var i;
        var limit = arbiters.length - 1;
        for (i = 1; i < limit; i += 1)
        {
            var item = arbiters[i];
            var idA = item.shapeA.id;
            var idB = item.shapeB.id;

            var hole = i;
            while (hole > 0)
            {
                var cur = arbiters[hole - 1];
                var curIDA = cur.shapeA.id;
                if (curIDA < idA || (curIDA === idA && cur.shapeB.id < idB))
                {
                    break;
                }

                arbiters[hole] = cur;
                hole -= 1;
            }

            arbiters[hole] = item;
        }
    },

    // =====================================================================

    _onWakeCallbacks : function _onWakeCallbacks(component)
    {
        if (this._midStep)
        {
            if (component._onWake.length > 0)
            {
                this._pushCallbacks(component, component._onWake);
            }
        }
        else
        {
            component._woken = true;
        }
    },

    _pushCallbacks : function _pushCallbacksFn(thisObject, callbacks)
    {
        var cbs = this._callbacks;
        var limit = callbacks.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var cb = Physics2DCallback.allocate();
            cb.thisObject = thisObject;
            cb.callback = callbacks[i];
            cb.time = this._eventTime;
            cb.index = i;
            cbs.push(cb);
        }
    },

    _pushInteractionEvents : function _pushInteractionEventsFn(eventType, arb)
    {
        var cbs = this._callbacks;

        var shapeA = arb.shapeA;
        var shapeB = arb.shapeB;

        var groupA = shapeA._group;
        var groupB = shapeB._group;

        // Event listeners on shapeA
        var events = shapeA._events;
        var limit = events.length;
        var i, eventObject, cb;
        for (i = 0; i < limit; i += 1)
        {
            eventObject = events[i];
            /*jshint bitwise: false*/
            if (eventObject.type === eventType &&
                (eventObject.mask === undefined || ((eventObject.mask & groupB) !== 0)))
            /*jshint bitwise: true*/
            {
                cb = Physics2DCallback.allocate();
                cb.thisObject = shapeA;
                cb.callback = eventObject.callback;
                cb.time = this._eventTime;
                cb.index = i;
                cb.arbiter = arb;
                cbs.push(cb);
            }
        }

        // Event listeners on shapeB
        events = shapeB._events;
        limit = events.length;
        for (i = 0; i < limit; i += 1)
        {
            eventObject = events[i];
            /*jshint bitwise: false*/
            if (eventObject.type === eventType &&
                (eventObject.mask === undefined || ((eventObject.mask & groupA) !== 0)))
            /*jshint bitwise: true*/
            {
                cb = Physics2DCallback.allocate();
                cb.thisObject = shapeA;
                cb.callback = eventObject.callback;
                cb.time = this._eventTime;
                cb.index = i;
                cb.arbiter = arb;
                cbs.push(cb);
            }
        }
    },

    // =====================================================================

    // precon: constraint was removed from live list.
    _brokenConstraint : function _brokenConstraint(con)
    {
        if (con._onBreak.length > 0)
        {
            this._pushCallbacks(con, con._onBreak);
        }

        if (con._removeOnBreak)
        {
            con.world = null;

            var constraints = this.constraints;
            var index = constraints.indexOf(con);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();

            con._outWorld();
        }
        else
        {
            con._active = false;
        }

        con._clearCache();
    },

    _preStep : function _preStepFn(deltaTime)
    {
        var constraints = this.liveConstraints;
        var limit = constraints.length;
        var i;
        for (i = 0; i < limit;)
        {
            var con = constraints[i];
            if (con._preStep(deltaTime))
            {
                limit -= 1;
                constraints[i] = constraints[limit];
                constraints.pop();
                this._brokenConstraint(con);
                continue;
            }

            i += 1;
        }

        this._preStepArbiters(this.dynamicArbiters, deltaTime);
        this._preStepArbiters(this.staticArbiters, deltaTime);
    },

    // Used in continuous collisions, only want to pre-step a single arbiter.
    _preStepArbiter : function _preStepArbiterFn(arb, deltaTime, progressEvents)
    {
        var timeStamp = this.timeStamp;

        // Should never be the case that arbiter needs to be put to sleep
        // Or needs to be retired, or to issue an end.

        arb.active = (arb._updateStamp === timeStamp);

        // Will however, require a begin callback to be issued in certain
        // cases (Continuous collision). and a progress callback (continuous
        // collision causing objects to be woken).
        if (arb._createContinuous && arb._createStamp === timeStamp)
        {
            this._pushInteractionEvents((/*EVENT_BEGIN*/1), arb);
        }
        else if (progressEvents && arb.active)
        {
            this._pushInteractionEvents((/*EVENT_PROGRESS*/2), arb);
        }

        if (arb.active)
        {
            /*jshint bitwise: false*/
            if ((arb._state & (/*STATE_ACCEPT*/1)) !== 0)
            /*jshint bitwise: true*/
            {
                if (!arb._preStep(deltaTime, timeStamp, true))
                {
                    arb.active = false;
                }
            }
            else if (!arb.sensor && !arb._cleanContacts(timeStamp))
            {
                arb.active = false;
            }
        }
    },

    // Used in usual case, pre stepping whole list of arbiters.
    _preStepArbiters : function _preStepArbitersFn(arbiters, deltaTime)
    {
        var timeStamp = this.timeStamp;
        var limit = arbiters.length;
        var i;
        for (i = 0; i < limit;)
        {
            var arb = arbiters[i];
            if (!arb._retired && (arb.bodyA.sleeping && arb.bodyB.sleeping))
            {
                arb._sleepStamp = timeStamp;
                arb.sleeping = true;
                arb.active = false;

                // Issue progress callback for first update that arbiter sleeps!
                this._pushInteractionEvents((/*EVENT_PROGRESS*/2), arb);

                limit -= 1;
                arbiters[i] = arbiters[limit];
                arbiters.pop();
                continue;
            }

            // Permit arbiter to exist for 1 further update.
            // So that we can issue end callbacks.
            if (!arb._lazyRetired)
            {
                if (arb._retired ||
                    arb._updateStamp + (arb.sensor ? 1 : Physics2DConfig.DELAYED_DEATH) < timeStamp)
                {
                    arb._retire();
                    limit -= 1;
                    arbiters[i] = arbiters[limit];
                    arbiters.pop();
                    Physics2DArbiter.deallocate(arb);
                    continue;
                }
            }
            else
            {
                arb._lazyRetired = false;
                i += 1;
                continue;
            }

            arb.active = (arb._updateStamp === timeStamp);

            // Set up callbacks.
            if (arb._createStamp === timeStamp)
            {
                this._pushInteractionEvents((/*EVENT_BEGIN*/1), arb);
            }
            else if (arb.active)
            {
                this._pushInteractionEvents((/*EVENT_PROGRESS*/2), arb);
            }
            else if (arb._updateStamp === (timeStamp - 1))
            {
                this._pushInteractionEvents((/*EVENT_END*/3), arb);
                arb._endGenerated = this.timeStamp;
            }

            if (arb.active)
            {
                /*jshint bitwise: false*/
                if ((arb._state & (/*STATE_ACCEPT*/1)) !== 0)
                /*jshint bitwise: true*/
                {
                    if (!arb._preStep(deltaTime, timeStamp))
                    {
                        arb.active = false;
                    }
                }
                else if (!arb.sensor && !arb._cleanContacts(timeStamp))
                {
                    arb.active = false;
                }
            }

            i += 1;
        }
    },

    // =====================================================================

    _iterateVelocity : function _iterateVelocityFn(count)
    {
        var constraints = this.liveConstraints;
        while (count > 0)
        {
            var limit = constraints.length;
            var i;
            for (i = 0; i < limit;)
            {
                var con = constraints[i];
                if (con._iterateVel())
                {
                    limit -= 1;
                    constraints[i] = constraints[limit];
                    constraints.pop();
                    this._brokenConstraint(con);
                    continue;
                }

                i += 1;
            }

            this._iterateVelocityArbiters(this.dynamicArbiters);
            this._iterateVelocityArbiters(this.staticArbiters);
            count -= 1;
        }
    },

    _iterateVelocityArbiters : function _iterateVelocityArbitersFn(arbiters)
    {
        var limit = arbiters.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var arb = arbiters[i];
            /*jshint bitwise: false*/
            if (arb.active && !arb.sensor &&
                (arb._state & (/*STATE_ACCEPT*/1)) !== 0)
            /*jshint bitwise: true*/
            {
                arb._iterateVelocity();
            }
        }
    },

    // =====================================================================

    _iteratePosition : function _iteratePositionFn(count)
    {
        var constraints = this.liveConstraints;
        while (count > 0)
        {
            var limit = constraints.length;
            var i;
            for (i = 0; i < limit;)
            {
                var con = constraints[i];
                if (con._stiff && con._iteratePos())
                {
                    limit -= 1;
                    constraints[i] = constraints[limit];
                    constraints.pop();
                    this._brokenConstraint(con);
                    continue;
                }

                i += 1;
            }

            this._iteratePositionArbiters(this.dynamicArbiters);
            this._iteratePositionArbiters(this.staticArbiters);
            count -= 1;
        }
    },

    _iteratePositionArbiters : function _iteratePositionArbitersFn(arbiters)
    {
        var limit = arbiters.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var arb = arbiters[i];
            /*jshint bitwise: false*/
            if (arb.active && !arb.sensor &&
                (arb._state & (/*STATE_ACCEPT*/1)) !== 0)
            /*jshint bitwise: true*/
            {
                arb._iteratePosition();
            }
        }
    },

    // =====================================================================

    _integrateVelocity : function _integrateVelocityFn(deltaTime)
    {
        var gravityX = this._gravityX;
        var gravityY = this._gravityY;

        var bodies = this.liveDynamics;
        var limit = bodies.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var body = bodies[i];
            var data = body._data;

            var imass = data[(/*BODY_IMASS*/0)];
            var drag;
            if (imass !== 0)
            {
                data[(/*BODY_VEL*/7)]     += ((data[(/*BODY_FORCE*/10)]     * imass) + gravityX) * deltaTime;
                data[(/*BODY_VEL*/7) + 1] += ((data[(/*BODY_FORCE*/10) + 1] * imass) + gravityY) * deltaTime;

                drag = Math.exp(deltaTime * data[(/*BODY_LIN_DRAG*/21)]);
                data[(/*BODY_VEL*/7)]     *= drag;
                data[(/*BODY_VEL*/7) + 1] *= drag;
            }

            var iinertia = data[(/*BODY_IINERTIA*/1)];
            if (iinertia !== 0)
            {
                data[(/*BODY_VEL*/7) + 2] += (data[(/*BODY_FORCE*/10) + 2] * iinertia) * deltaTime;
                data[(/*BODY_VEL*/7) + 2] *= Math.exp(deltaTime * data[(/*BODY_ANG_DRAG*/22)]);
            }
        }
    },

    // =====================================================================

    _integratePosition : function _integratePositionFn(deltaTime)
    {
        this._integratePositionBodies(this.liveDynamics, deltaTime);
        this._integratePositionBodies(this.liveKinematics, deltaTime);
    },

    _integratePositionBodies : function _integratePositionBodiesFn(bodies, deltaTime)
    {
        var MAX_VEL = (2 * Math.PI / deltaTime);
        var idt2 = (1 / (deltaTime * deltaTime));

        var linThreshold = Physics2DConfig.MIN_LINEAR_STATIC_SWEEP;
        var angThreshold = Physics2DConfig.MIN_ANGULAR_STATIC_SWEEP;
        linThreshold *= linThreshold * idt2;
        angThreshold *= angThreshold * idt2;

        var bulletLinThreshold = Physics2DConfig.MIN_LINEAR_BULLET_SWEEP;
        var bulletAngThreshold = Physics2DConfig.MIN_ANGULAR_BULLET_SWEEP;
        bulletLinThreshold *= bulletLinThreshold * idt2;
        bulletAngThreshold *= bulletAngThreshold * idt2;

        var bphase = this.broadphase;

        var limit = bodies.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var body = bodies[i];
            var data = body._data;
            var preX = data[(/*BODY_PRE_POS*/15)]     = data[(/*BODY_POS*/2)];
            var preY = data[(/*BODY_PRE_POS*/15) + 1] = data[(/*BODY_POS*/2) + 1];
            data[(/*BODY_PRE_POS*/15) + 2] = data[(/*BODY_POS*/2) + 2];

            var curX = data[(/*BODY_POS*/2)]     += (data[(/*BODY_VEL*/7)]     * deltaTime);
            var curY = data[(/*BODY_POS*/2) + 1] += (data[(/*BODY_VEL*/7) + 1] * deltaTime);
            var angVel = data[(/*BODY_VEL*/7) + 2];
            body._deltaRotation(angVel * deltaTime);

            data[(/*BODY_SWEEP_TIME*/18)] = deltaTime;

            // If moving very slowly, treat as static freezing object at t = deltaTime
            var vx = data[(/*BODY_VEL*/7)];
            var vy = data[(/*BODY_VEL*/7) + 1];
            var vw = data[(/*BODY_SWEEP_ANGVEL*/20)] = (angVel % MAX_VEL);

            var rad = data[(/*BODY_RADIUS*/19)];
            var lin = (linThreshold * rad * rad);
            var vmag = ((vx * vx) + (vy * vy));
            if (vmag > lin || (vw * vw) > angThreshold)
            {
                // Compute swept AABB
                var minX = (preX < curX ? preX : curX);
                var minY = (preY < curY ? preY : curY);
                var maxX = (preX < curX ? curX : preX);
                var maxY = (preY < curY ? curY : preY);

                var shapes = body.shapes;
                var limit2 = shapes.length;
                var j;
                for (j = 0; j < limit2; j += 1)
                {
                    var shape = shapes[j];
                    var sdata = shape._data;
                    rad = sdata[(/*SHAPE_SWEEP_RADIUS*/4)];
                    sdata[(/*SHAPE_AABB*/0)]     = (minX - rad);
                    sdata[(/*SHAPE_AABB*/0) + 1] = (minY - rad);
                    sdata[(/*SHAPE_AABB*/0) + 2] = (maxX + rad);
                    sdata[(/*SHAPE_AABB*/0) + 3] = (maxY + rad);

                    bphase.update(shape._bphaseHandle, sdata);
                }

                body._sweepFrozen = false;

                if (body._type === (/*TYPE_DYNAMIC*/0))
                {
                    body._bullet = (body.bullet &&
                                    (vmag > (bulletLinThreshold * rad * rad) || (vw * vw) > bulletAngThreshold));
                }
            }
            else
            {
                body._sweepFrozen = true;
                body._bullet = false;
            }
        }
    },

    // =====================================================================

    _finalize : function _finalizeFn()
    {
        this._finalizeBodies(this.liveDynamics);
        this._finalizeBodies(this.liveKinematics);

        // Finalize contact positions for API to be correct at end of step() in queries
        this._finalizeArbiters(this.dynamicArbiters);
        this._finalizeArbiters(this.staticArbiters);
    },

    _finalizeArbiters : function _iteratePositionArbitersFn(arbiters)
    {
        var limit = arbiters.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var arb = arbiters[i];
            if (arb.active && !arb.sensor)
            {
                arb._refreshContactData();
            }
        }
    },

    _finalizeBodies : function _finalizeBodies(bodies)
    {
        var bphase = this.broadphase;
        var limit = bodies.length;
        var i;
        for (i = 0; i < limit;)
        {
            var body = bodies[i];
            var data = body._data;

            var shapes = body.shapes;
            var limit2 = shapes.length;
            var j, shape;

            if (data[(/*BODY_PRE_POS*/15)]     !== data[(/*BODY_POS*/2)] ||
                data[(/*BODY_PRE_POS*/15) + 1] !== data[(/*BODY_POS*/2) + 1] ||
                data[(/*BODY_PRE_POS*/15) + 2] !== data[(/*BODY_POS*/2) + 2])
            {
                body._invalidated = true;
            }
            else if (body._type === (/*TYPE_KINEMATIC*/1))
            {
                limit -= 1;
                bodies[i] = bodies[limit];
                bodies.pop();

                body.sleeping = true;

                for (j = 0; j < limit2; j += 1)
                {
                    shape = shapes[j];
                    bphase.update(shape._bphaseHandle, shape._data, true);
                }
                continue;
            }

            i += 1;
        }
    },

    // =====================================================================

    _doCallbacks : function _doCallbacksFn()
    {
        // Order by event index so as to guarantee that event listeners
        // added first, are processed first.
        //
        // Inlined quick sort, builtin JS.sort was too slow with function comparator.
        var callbacks = this._callbacks;
        var i;
        var stack = [callbacks.length - 1, 0];
        do
        {
            var left = stack.pop();
            var right = stack.pop();
            if (left > right)
            {
                continue;
            }

            /*jshint bitwise: false*/
            var pivot = (left + right) >> 1;
            /*jshint bitwise: true*/

            // Partition about center
            var pivotValue = callbacks[pivot];
            var index = left;
            var pIndex = pivotValue.index;
            var pTime = pivotValue.time;

            callbacks[pivot] = callbacks[right];
            callbacks[right] = pivotValue;
            for (i = left; i < right; i += 1)
            {
                var cur = callbacks[i];
                if (cur.time < pTime ||
                    (cur.time === pTime && cur.index < pIndex))
                {
                    callbacks[i] = callbacks[index];
                    callbacks[index] = cur;
                    index += 1;
                }
            }
            callbacks[right] = callbacks[index];
            callbacks[index] = pivotValue;

            // index + 1 <-> right
            if (index + 1 < right)
            {
                stack.push(right);
                stack.push(index + 1);
            }

            // left <-> index - 1
            if (left < index - 1)
            {
                stack.push(index - 1);
                stack.push(left);
            }
        }
        while (stack.length > 0);

        // Issue callbacks
        var limit = callbacks.length;
        for (i = 0; i < limit; i += 1)
        {
            var cb = callbacks[i];
            if (cb.arbiter)
            {
                // BEGIN/PROGRESS/END
                var arb = cb.arbiter;
                var sa = arb.shapeA;
                var sb = arb.shapeB;
                var thisShape = cb.thisObject;
                cb.callback.call(thisShape, arb, (thisShape === sa ? sb : sa));
            }
            else
            {
                // WAKE/SLEEP/BREAK
                cb.callback.call(cb.thisObject);
            }
            Physics2DCallback.deallocate(cb);
        }
        callbacks.length = 0;
    },

    // =====================================================================

    _warmStart : function _warmStartFn()
    {
        var constraints = this.liveConstraints;
        var limit = constraints.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            constraints[i]._warmStart();
        }

        this._warmStartArbiters(this.dynamicArbiters);
        this._warmStartArbiters(this.staticArbiters);
    },

    _warmStartArbiters : function _warmStartArbitersFn(arbiters)
    {
        var limit = arbiters.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var arb = arbiters[i];
            /*jshint bitwise: false*/
            if (arb.active && !arb.sensor &&
                (arb._state & (/*STATE_ACCEPT*/1)) !== 0)
            /*jshint bitwise: true*/
            {
                arb._warmStart();
            }
        }
    },

    // =====================================================================

    _forceSleepBody : function _forceSleepBodyFn(body)
    {
        if (body.sleeping || body._type !== (/*TYPE_DYNAMIC*/0))
        {
            return;
        }

        body.sleeping = true;

        var bodies = this.liveDynamics;
        var index = bodies.indexOf(body);
        bodies[index] = bodies[bodies.length - 1];
        bodies.pop();

        var shapes = body.shapes;
        var limit = shapes.length;
        var i;
        var bphase = this.broadphase;
        for (i = 0; i < limit; i += 1)
        {
            var shape = shapes[i];
            bphase.update(shape._bphaseHandle, shape._data, true);

            // Force arbiters to go to sleep.
            var arbiters = shape.arbiters;
            var limit2 = arbiters.length;
            var j;
            for (j = 0; j < limit2; j += 1)
            {
                var arb = arbiters[j];
                if (arb._retired || arb.sleeping)
                {
                    continue;
                }

                arb.sleeping = true;
                arb._sleepStamp = this.timeStamp;
                var arbs;
                if (arb._static)
                {
                    arbs = this.staticArbiters;
                }
                else
                {
                    arbs = this.dynamicArbiters;
                }

                index = arbs.indexOf(arb);
                arbs[index] = arbs[arbs.length - 1];
                arbs.pop();
            }
        }
    },

    _forceSleepConstraint : function forceSleepConstraintFn(constraint)
    {
        if (constraint.sleeping)
        {
            return;
        }

        constraint.sleeping = true;

        if (constraint._active)
        {
            var constraints = this.liveConstraints;
            var index = constraints.indexOf(constraint);
            constraints[index] = constraints[constraints.length - 1];
            constraints.pop();
        }
    },

    _wakeConstraint : function _wakeConstraintFn(constraint, noCallback)
    {
        if (constraint.world !== this)
        {
            return;
        }

        if (constraint._active)
        {
            constraint._wakeTime = (this.timeStamp + (this._midStep ? 0 : 1));
            if (constraint.sleeping)
            {
                if (!constraint._island)
                {
                    constraint.sleeping = false;
                    this.liveConstraints.push(constraint);
                    constraint._wakeConnected();

                    if (!noCallback)
                    {
                        this._onWakeCallbacks(constraint);
                    }
                }
                else
                {
                    this._wakeIsland(constraint._island, (noCallback ? constraint : null));
                }
            }
        }
    },

    _wakeBody : function _wakeBodyFn(body, noCallback, continuousCallbacks)
    {
        if (body.world !== this)
        {
            return;
        }

        body._wakeTime = (this.timeStamp + (this._midStep ? 0 : 1));
        if (body.sleeping)
        {
            if (!body._island)
            {
                var bphase = this.broadphase;

                // new body, or forced wake, or kinematic
                if (body._type === (/*TYPE_DYNAMIC*/0))
                {
                    body.sleeping = false;
                    this.liveDynamics.push(body);
                }
                else if (body._type === (/*TYPE_KINEMATIC*/1))
                {
                    body.sleeping = false;
                    this.liveKinematics.push(body);
                }

                var constraints = body.constraints;
                var limit = constraints.length;
                var i;
                for (i = 0; i < limit; i += 1)
                {
                    this._wakeConstraint(constraints[i]);
                }

                var isStatic = (body._type === (/*TYPE_STATIC*/2));

                var shapes = body.shapes;
                limit = shapes.length;
                for (i = 0; i < limit; i += 1)
                {
                    var shape = shapes[i];
                    this._wakeArbiters(shape.arbiters, false, continuousCallbacks);
                    if (!isStatic)
                    {
                        bphase.update(shape._bphaseHandle, shape._data, false);
                    }
                }

                if (!noCallback && (body._type === (/*TYPE_DYNAMIC*/0)))
                {
                    this._onWakeCallbacks(body);
                }
            }
            else
            {
                this._wakeIsland(body._island, (noCallback ? body : null), continuousCallbacks);
            }
        }
    },

    _wakeArbiter : function _wakeArbiterFn(arb, continuousCallbacks)
    {
        arb.sleeping = false;

        var timeStamp = (this.timeStamp + (this._midStep ? 0 : 1));
        var tDelta = (timeStamp - arb._sleepStamp);
        arb._updateStamp += tDelta;
        var contacts = arb.contacts;
        var limit2 = contacts.length;
        var j;
        for (j = 0; j < limit2; j += 1)
        {
            contacts[j]._timeStamp += tDelta;
        }

        if (arb._static)
        {
            this.staticArbiters.push(arb);
        }
        else
        {
            this.dynamicArbiters.push(arb);
        }

        // Arbiter was woken as the result of a continuous collisions
        // And we must pre-step and generate callbacks.
        if (continuousCallbacks)
        {
            this._continuousArbiterPrepare(arb, this._deltaTime, true);
        }
    },

    _continuousArbiterPrepare : function continuousArbiterPrepareFn(arb, deltaTime, progressEvents)
    {
        this._preStepArbiter(arb, deltaTime, progressEvents);
        /*jshint bitwise: false*/
        if (arb.active && !arb.sensor &&
            (arb._state & (/*STATE_ACCEPT*/1)) !== 0)
        /*jshint bitwise: true*/
        {
            // Single velocity iteration of just this arbiter.
            // Helps objects to bounce immediately, any errors will be resolved
            // in following step anyhow.
            arb._iterateVelocity();
        }
    },

    _wakeArbiters : function _wakeArbiters(arbiters, skip, continuousCallbacks)
    {
        var limit = arbiters.length;
        var i;
        var timeStamp = (this.timeStamp + (this._midStep ? 0 : 1));
        for (i = 0; i < limit; i += 1)
        {
            var arb = arbiters[i];
            if (arb._retired)
            {
                continue;
            }

            if (arb.sleeping)
            {
                this._wakeArbiter(arb, continuousCallbacks);
            }

            if (!skip)
            {
                // arb.active is not yet computed.
                /*jshint bitwise: false*/
                if ((arb._updateStamp === timeStamp) && !arb.sensor &&
                    (arb._state & (/*STATE_ACCEPT*/1)) !== 0)
                /*jshint bitwise: true*/
                {
                    var b1 = arb.bodyA;
                    var b2 = arb.bodyB;
                    if (b1._type === (/*TYPE_DYNAMIC*/0) && b1.sleeping)
                    {
                        this._wakeBody(b1, false, continuousCallbacks);
                    }
                    if (b2._type === (/*TYPE_DYNAMIC*/0) && b2.sleeping)
                    {
                        this._wakeBody(b2, false, continuousCallbacks);
                    }
                }
            }
        }
    },

    _wakeIsland : function _wakeIslandFn(island, noCallbackObject, continuousCallbacks)
    {
        var bphase = this.broadphase;
        var bodies = this.liveDynamics;
        var constraints = this.liveConstraints;

        var timeStamp = (this.timeStamp + (this._midStep ? 0 : 1));
        var components = island.components;
        var limit = components.length;
        while (limit > 0)
        {
            limit -= 1;
            var c = components.pop();
            c._wakeTime = timeStamp;

            // Reset island properties.
            c._island = null;
            c._islandRoot = c;
            c._islandRank = 0;

            c.sleeping = false;

            if (c._isBody)
            {
                // only dynamic bodies are inserted to islands.
                bodies.push(c);

                var shapes = c.shapes;
                var limit2 = shapes.length;
                var i;
                for (i = 0; i < limit2; i += 1)
                {
                    var shape = shapes[i];
                    this._wakeArbiters(shape.arbiters, true, continuousCallbacks);
                    bphase.update(shape._bphaseHandle, shape._data, false);
                }
            }
            else
            {
                constraints.push(c);
            }

            // Body + Constraint
            if (noCallbackObject !== c)
            {
                this._onWakeCallbacks(c);
            }
        }

        Physics2DIsland.deallocate(island);
    },

    // =====================================================================

    _transmitBodyType : function _transmitBodyTypeFn(body, newType)
    {
        // Wake as old type.
        // Interactions that are presently active may
        // become ignored.
        this._wakeBody(body);

        // Just woke the body, so it's not sleeping
        var bodies;
        if (body._type === (/*TYPE_DYNAMIC*/0))
        {
            bodies = this.liveDynamics;
        }
        else if (body._type === (/*TYPE_KINEMATIC*/1))
        {
            bodies = this.liveKinematics;
        }

        var index;
        if (bodies)
        {
            index = bodies.indexOf(body);
            bodies[index] = bodies[bodies.length - 1];
            bodies.pop();
        }

        body._type = newType;

        var staticBody = (newType === (/*TYPE_STATIC*/2));
        if (staticBody)
        {
            // Ensure body is updated as run time validation
            // Does not occur for static types.
            body._update();
        }

        if (newType === (/*TYPE_DYNAMIC*/0))
        {
            // Set up ready for island computations
            body._islandRoot = body;
            body._islandRank = 0;
        }

        var bphase = this.broadphase;

        // Destroy redundant arbiters, and mutate arbiter static type.
        var shapes = body.shapes;
        var limit = shapes.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var shape = shapes[i];
            if (staticBody)
            {
                // Static bodies aren't synced by wakeBody
                bphase.update(shape._bphaseHandle, shape._data, true);
            }

            var arbiters = shape.arbiters;
            var limit2 = arbiters.length;
            var j;
            for (j = 0; j < limit2;)
            {
                var arb = arbiters[j];
                if (arb._retired)
                {
                    continue;
                }

                var bothStaticType = (arb.bodyA._type !== (/*TYPE_DYNAMIC*/0) && arb.bodyB._type !== (/*TYPE_DYNAMIC*/0));
                var atleastOneKinematic = (arb.bodyA._type === (/*TYPE_KINEMATIC*/1) || arb.bodyB._type === (/*TYPE_KINEMATIC*/1));
                if (bothStaticType && !(atleastOneKinematic && arb.sensor))
                {
                    limit2 -= 1;
                    arbiters[j] = arbiters[limit2];
                    arbiters.pop();
                    arb._lazyRetire(shape);
                    this._pushInteractionEvents((/*EVENT_END*/3), arb);
                    continue;
                }

                var staticType = (arb.bodyA._type !== (/*TYPE_DYNAMIC*/0) || arb.bodyB._type !== (/*TYPE_DYNAMIC*/0));
                if (staticType !== arb._static)
                {
                    var arbs = (arb._static ? this.staticArbiters : this.dynamicArbiters);
                    index = arbs.indexOf(arb);
                    arbs[index] = arbs[arbs.length - 1];
                    arbs.pop();

                    arb._static = staticType;
                    arbs = (staticType ? this.staticArbiters : this.dynamicArbiters);
                    arbs.push(arb);
                }

                j += 1;
            }
        }

        // Force wake as new type.
        // Interactions that may have been previously ignored
        // may now become active.
        body.sleeping = true;
        this._wakeBody(body);
    },

    // =====================================================================

    _validate : function _validateFn()
    {
        this._validateBodies(this.liveDynamics);
        this._validateBodies(this.liveKinematics);

        // Issue deferred wake callbacks to stack.
        var constraints = this.liveConstraints;
        var i;
        var limit = constraints.length;
        for (i = 0; i < limit; i += 1)
        {
            var con = constraints[i];
            if (con._woken && con._onWake.length > 0)
            {
                this._pushCallbacks(con, con._onWake);
            }
            con._woken = false;
        }
    },

    _validateBodies : function _validateBodiesFn(bodies)
    {
        var bphase = this.broadphase;
        var i;
        var limit = bodies.length;
        for (i = 0; i < limit; i += 1)
        {
            var body = bodies[i];

            // Prevent errors accumulating.
            var data = body._data;
            var rot = data[(/*BODY_POS*/2) + 2];
            data[(/*BODY_AXIS*/5)]     = Math.cos(rot);
            data[(/*BODY_AXIS*/5) + 1] = Math.sin(rot);

            // Update shape world-data.
            body._update();

            if (body._type === (/*TYPE_DYNAMIC*/0) && body._woken && body._onWake.length > 0)
            {
                this._pushCallbacks(body, body._onWake);
            }
            body._woken = false;

            var shapes = body.shapes;
            var limit2 = shapes.length;
            var j;
            for (j = 0; j < limit2; j += 1)
            {
                var shape = shapes[j];
                bphase.update(shape._bphaseHandle, shape._data);
            }
        }
    }
};

Physics2DWorld.create = function phys2DWorldFn(params)
{
    var w = new Physics2DWorld();
    w.simulatedTime = 0;

    // ALL such objects.
    w.rigidBodies = [];
    w.constraints = [];

    // Non-sleeping such objects.
    w.liveDynamics = [];
    w.liveKinematics = [];
    w.liveConstraints = [];

    // Non-sleeping only.
    w.dynamicArbiters = [];
    w.staticArbiters = [];

    w._islands = [];
    w._toiEvents = [];
    w._deferredWake = [];

    w._eventTime = (/*EVENT_TIME_PRE*/-1);
    w._callbacks = [];

    w.broadphase = (params.broadphase || Physics2DBoxTreeBroadphase.create());

    w.velocityIterations = (params.velocityIterations || 8);
    w.positionIterations = (params.positionIterations || 8);

    w._midStep = false;
    w.timeStamp = 0;

    var gravity = params.gravity;
    w._gravityX = (gravity ? gravity[0] : 0);
    w._gravityY = (gravity ? gravity[1] : 10);

    w._collisions = Physics2DCollisionUtils.create();

    // =====================================================================

    w._sampleRectangle = new Physics2DDevice.prototype.floatArray(4);

    function shapeSampler(lambda)
    {
        return {
            store : null,
            count : 0,
            collisions : w._collisions,
            sample : function (handle, bounds)
            {
                var shape = handle.data;
                if (lambda.call(this, shape, bounds))
                {
                    this.store[this.count] = shape;
                    this.count += 1;
                }
            }
        };
    }

    function bodySampler(lambda)
    {
        return {
            store : null,
            count : 0,
            collisions : w._collisions,
            sample : function (handle, bounds)
            {
                var shape = handle.data;
                if (lambda.call(this, shape, bounds))
                {
                    var found = false;
                    var body = shape.body;
                    var i;
                    var limit = this.count;
                    var bodies = this.store;
                    for (i = 0; i < limit; i += 1)
                    {
                        if (bodies[i] === body)
                        {
                            found = true;
                            break;
                        }
                    }

                    if (!found)
                    {
                        bodies[limit] = body;
                        this.count += 1;
                    }
                }
            }
        };
    }

    function pointSampler(shape, point)
    {
        return this.collisions._contains(shape, point[0], point[1]);
    }
    w._shapePointCallback = shapeSampler(pointSampler);
    w._bodyPointCallback  = bodySampler(pointSampler);


    function rectangleSampler(shape, unusedSampleBox)
    {
        return this.collisions._test(shape, this.rectangleShape);
    }
    w._shapeRectangleCallback = shapeSampler(rectangleSampler);
    w._bodyRectangleCallback  = bodySampler(rectangleSampler);

    w._rectangleQueryVertices = [
        new Physics2DDevice.prototype.floatArray(2),
        new Physics2DDevice.prototype.floatArray(2),
        new Physics2DDevice.prototype.floatArray(2),
        new Physics2DDevice.prototype.floatArray(2)
    ];
    w._rectangleQueryShape = Physics2DPolygon.create({ vertices : w._rectangleQueryVertices });
    w._shapeRectangleCallback.rectangleShape = w._rectangleQueryShape;
    w._bodyRectangleCallback.rectangleShape  = w._rectangleQueryShape;


    function circleSampler(shape, unusedSampleBox)
    {
        return this.collisions._test(shape, this.circleShape);
    }
    w._shapeCircleCallback = shapeSampler(circleSampler);
    w._bodyCircleCallback  = bodySampler(circleSampler);

    w._circleQueryShape = Physics2DCircle.create({ radius : 1 });
    w._shapeCircleCallback.circleShape = w._circleQueryShape;
    w._bodyCircleCallback.circleShape  = w._circleQueryShape;


    var tempCastResult = {
        shape : null,
        hitPoint  : new Physics2DDevice.prototype.floatArray(2),
        hitNormal : new Physics2DDevice.prototype.floatArray(2),
        factor : 0
    };

    w._rayCast = {
        minNormal : new Physics2DDevice.prototype.floatArray(2),
        minShape : null,
        minFactor : 0,

        userCallback : null,
        userThis : null,

        ray : null,
        noInner : false,
        normal : new Physics2DDevice.prototype.floatArray(2),
        sample : function sampleFn(handle, _)
        {
            var shape = handle.data;

            var ray = this.ray;
            var normal = this.normal;

            var oldFactor = ray.maxFactor;
            ray.maxFactor = this.minFactor;
            var factor = w._collisions.rayTest(shape, ray, normal, this.noInner);
            ray.maxFactor = oldFactor;

            if (this.userCallback)
            {
                var result = tempCastResult;
                var vector = result.hitNormal;
                vector[0] = normal[0];
                vector[1] = normal[1];

                vector = result.hitPoint;
                var origin = ray.origin;
                var direction = ray.direction;
                vector[0] = (origin[0] + (direction[0] * factor));
                vector[1] = (origin[1] + (direction[1] * factor));
                result.factor = factor;
                result.shape = shape;

                if (!this.userCallback.call(this.userThis, ray, result))
                {
                    return;
                }
            }

            if (factor !== undefined)
            {
                this.minFactor = factor;
                this.minShape = shape;

                var minNormal = this.minNormal;
                minNormal[0] = normal[0];
                minNormal[1] = normal[1];
            }
        }
    };

    w._convexCast = {
        toi : w._collisions._toi, // may as well re-use.

        minData : new Physics2DDevice.prototype.floatArray(4),
        minShape : null,
        minTOIAlpha : 0,

        userCallback : null,
        userThis : null,

        deltaTime : 0,
        sample : function sampleFn(handle, _)
        {
            var toi = this.toi;
            var shape = handle.data;
            // sweeping shape against itself!
            // can happen if input for sweep was a shape in the World.
            if (shape === toi.shapeA)
            {
                return;
            }

            toi.shapeB = shape;
            shape.body._update();
            var ret = w._collisions._staticSweep(toi, (this.minTOIAlpha * this.deltaTime), 0, true) * this.minTOIAlpha;

            if (ret <= 0)
            {
                return;
            }

            var tdata = toi._data;
            if (this.userCallback)
            {
                var result = tempCastResult;
                var vector = result.hitNormal;
                vector[0] = (-tdata[(/*TOI_AXIS*/0)]);
                vector[1] = (-tdata[(/*TOI_AXIS*/0) + 1]);
                vector = result.hitPoint;
                vector[0] = tdata[(/*TOI_WITNESS_B*/4)];
                vector[1] = tdata[(/*TOI_WITNESS_B*/4) + 1];
                result.factor = (ret * this.deltaTime);
                result.shape = shape;
                result.shape = shape;

                if (!this.userCallback.call(this.userThis, toi.shapeA, result))
                {
                    return;
                }
            }

            this.minTOIAlpha = ret;
            var data = this.minData;
            data[0] = tdata[(/*TOI_AXIS*/0)];
            data[1] = tdata[(/*TOI_AXIS*/0) + 1];
            data[2] = tdata[(/*TOI_WITNESS_B*/4)];
            data[3] = tdata[(/*TOI_WITNESS_B*/4) + 1];
            this.minShape = shape;
        }
    };

    return w;
};


// =========================================================================

//
// Physics2D internal collision detection routines.
//
function Physics2DCollisionUtils() {}
Physics2DCollisionUtils.prototype = {

    containsPoint : function containsPointFn(shape, point)
    {
        shape.body._update();
        return this._contains(shape, point[0], point[1]);
    },

    signedDistance : function signedDistanceFn(shapeA, shapeB, witnessA, witnessB, axis)
    {
        shapeA.body._update();
        if (shapeB.body !== shapeA.body)
        {
            shapeB.body._update();
        }

        var data = this._toi._data;
        var ret = this._distance(shapeA, shapeB, data);
        witnessA[0] = data[(/*TOI_WITNESS_A*/2)];
        witnessA[1] = data[(/*TOI_WITNESS_A*/2) + 1];
        witnessB[0] = data[(/*TOI_WITNESS_B*/4)];
        witnessB[1] = data[(/*TOI_WITNESS_B*/4) + 1];
        axis[0]     = data[(/*TOI_AXIS*/0)];
        axis[1]     = data[(/*TOI_AXIS*/0) + 1];

        return ret;
    },

    intersects : function intersectsFn(shapeA, shapeB)
    {
        shapeA.body._update();
        if (shapeB.body !== shapeA.body)
        {
            shapeB.body._update();
        }

        return this._test(shapeA, shapeB);
    },

    rayTest : function rayTestFn(shape, ray, normal, ignoreInnerSurfaces)
    {
        shape.body._update();
        return this._rayTest(shape, ray, normal, ignoreInnerSurfaces);
    },

    sweepTest : function sweepTestFn(shapeA, shapeB, deltaTime, point, normal)
    {
        var toi = this._toi;
        toi.shapeA = shapeA;
        toi.shapeB = shapeB;

        var bodyA = shapeA.body;
        var bodyB = shapeB.body;
        var dataA = bodyA._data;
        var dataB = bodyB._data;
        dataA[(/*BODY_SWEEP_TIME*/18)] = 0;
        dataB[(/*BODY_SWEEP_TIME*/18)] = 0;
        dataA[(/*BODY_SWEEP_ANGVEL*/20)] = (dataA[(/*BODY_VEL*/7) + 2]);
        dataB[(/*BODY_SWEEP_ANGVEL*/20)] = (dataB[(/*BODY_VEL*/7) + 2]);
        var ret = this._dynamicSweep(toi, deltaTime, 0, true);
        bodyA._sweepIntegrate(0);
        bodyB._sweepIntegrate(0);
        shapeA._update(
            dataA[(/*BODY_POS*/2)], dataA[(/*BODY_POS*/2) + 1],
            dataA[(/*BODY_AXIS*/5)], dataA[(/*BODY_AXIS*/5) + 1]
        );
        shapeB._update(
            dataB[(/*BODY_POS*/2)], dataB[(/*BODY_POS*/2) + 1],
            dataB[(/*BODY_AXIS*/5)], dataB[(/*BODY_AXIS*/5) + 1]
        );

        if (ret < 0)
        {
            return undefined;
        }

        var data = toi._data;
        point[0] = (0.5 * (data[(/*TOI_WITNESS_A*/2)]     + data[(/*TOI_WITNESS_B*/4)]));
        point[1] = (0.5 * (data[(/*TOI_WITNESS_A*/2) + 1] + data[(/*TOI_WITNESS_B*/4) + 1]));
        normal[0] = data[(/*TOI_AXIS*/0)];
        normal[1] = data[(/*TOI_AXIS*/0) + 1];
        return (ret * deltaTime);
    },


    //=======================================================================================
    //=======================================================================================
    // Private.

    // Test if (parametric) ray intersects
    // Shape between 0 and ray.maxFactor
    // Assume shape has been updated by a Body.
    // (need not be 'in' a body).
    _rayTest : function _rayTestFn(shape, ray, normal, noInner)
    {
        if (shape._type === (/*TYPE_CIRCLE*/0))
        {
            return this._rayTestCircle(shape, ray, normal, noInner);
        }
        else
        {
            return this._rayTestPolygon(shape, ray, normal, noInner);
        }
    },

    _rayTestPolygon : function _rayTestPolygonFn(poly, ray, normal, noInner)
    {
        var origin = ray.origin;
        var direction = ray.direction;
        var data = poly._data;

        var ox = origin[0];
        var oy = origin[1];
        var dx = direction[0];
        var dy = direction[1];

        var min = ray.maxFactor;
        var edge, inner;

        var index = (/*POLY_VERTICES*/6);
        var limit = data.length;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var nx = data[index + (/*POLY_WNORMAL*/6)];
            var ny = data[index + (/*POLY_WNORMAL*/6) + 1];
            var den = (nx * dx) + (ny * dy);
            if ((den >= 0 && noInner) ||
                (den * den) < Physics2DConfig.COLLINEAR_SQ_EPSILON)
            {
                continue;
            }

            var t = (data[index + (/*POLY_WPROJ*/9)] - ((ox * nx) + (oy * ny))) / den;
            if (t < 0 || t >= min)
            {
                continue;
            }

            var hitX = ox + (dx * t);
            var hitY = oy + (dy * t);
            var dproj = (nx * hitY) - (ny * hitX);
            if (dproj < data[index + (/*POLY_CROSS1*/10)] ||
                dproj > data[index + (/*POLY_CROSS2*/11)])
            {
                continue;
            }

            min = t;
            edge = index;
            inner = (den >= 0);
        }

        if (edge === undefined)
        {
            return undefined;
        }
        else
        {
            var scale = (inner ? -1 : 1);
            normal[0] = (data[edge + (/*POLY_WNORMAL*/6)]     * scale);
            normal[1] = (data[edge + (/*POLY_WNORMAL*/6) + 1] * scale);
            return min;
        }
    },

    _rayTestCircle : function _rayTestCircleFn(circle, ray, normal, noInner)
    {
        var origin = ray.origin;
        var direction = ray.direction;
        var data = circle._data;

        var ox = origin[0];
        var oy = origin[1];
        var dx = direction[0];
        var dy = direction[1];
        var cx = data[(/*CIRCLE_WORLD*/9)];
        var cy = data[(/*CIRCLE_WORLD*/9) + 1];
        var radius = data[(/*CIRCLE_RADIUS*/6)];

        var ocX = (ox - cx);
        var ocY = (oy - cy);

        // Quadratic equation at^2 + bt + c = 0
        var a = ((dx * dx) + (dy * dy));
        var b = 2 * ((ocX * dx) + (ocY * dy));
        var c = (ocX * ocX) + (ocY * ocY) - (radius * radius);

        var determinant = ((b * b) - (4 * a * c));
        if (determinant < 0)
        {
            return undefined;
        }

        var normalScale = 1.0;
        var rec = (1 / (2 * a));
        var rootD = Math.sqrt(determinant);
        var distance = ((-b - rootD) * rec);
        if (distance < 0)
        {
            if (noInner)
            {
                return undefined;
            }
            distance += (rootD * 2 * rec);
            normalScale = -1.0;
        }

        if (0 <= distance && distance < ray.maxFactor)
        {
            var hitX = (ox + (dx * distance) - cx);
            var hitY = (oy + (dy * distance) - cy);
            var scale = (normalScale / radius);
            normal[0] = (hitX * scale);
            normal[1] = (hitY * scale);
            return distance;
        }
        else
        {
            return undefined;
        }
    },

    // =====================================================================

    // Test point containment in shape.
    // no AABB check is performed.
    // Assume shape has been updated by a Body.
    // (need not be 'in' a body).
    _contains : function containsFn(shape, x, y)
    {
        if (shape._type === (/*TYPE_CIRCLE*/0))
        {
            return this._containsCircle(shape, x, y);
        }
        else
        {
            return this._containsPolygon(shape, x, y);
        }
    },

    _containsCircle : function containsCircleFn(circle, x, y)
    {
        var data = circle._data;
        var dx = (data[(/*CIRCLE_WORLD*/9)]     - x);
        var dy = (data[(/*CIRCLE_WORLD*/9) + 1] - y);
        var rad = data[(/*CIRCLE_RADIUS*/6)];
        return ((dx * dx) + (dy * dy) - (rad * rad)) <= Physics2DConfig.CONTAINS_SQ_EPSILON;
    },

    _containsPolygon : function containsPolygonFn(poly, x, y)
    {
        var data = poly._data;
        var index = (/*POLY_VERTICES*/6);
        var limit = data.length;
        var EPS = Physics2DConfig.CONTAINS_EPSILON;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            var proj = ((data[index + (/*POLY_WNORMAL*/6)]     * x) +
                        (data[index + (/*POLY_WNORMAL*/6) + 1] * y)) -
                       data[index + (/*POLY_WPROJ*/9)];
            if (proj > EPS)
            {
                return false;
            }
        }
        return true;
    },

    // =====================================================================

    // slowSweep is true when method is invoked from public API.
    // Or in convexSweep to be more accurate and fail less easily.
    // This is also to disable slipping TOI's and terminate as soon
    // as objects intersect.
    _dynamicSweep : function _dynamicSweepFn(toi, timeStep, negRadius, slowSweep)
    {
        var s1 = toi.shapeA;
        var s2 = toi.shapeB;
        var b1 = s1.body;
        var b2 = s2.body;
        var data1 = b1._data;
        var data2 = b2._data;

        // relative linear velocity and angular bias for distance calculation.
        var deltaX = (data2[(/*BODY_VEL*/7)]     - data1[(/*BODY_VEL*/7)]);
        var deltaY = (data2[(/*BODY_VEL*/7) + 1] - data1[(/*BODY_VEL*/7) + 1]);
        var ang1 = data1[(/*BODY_SWEEP_ANGVEL*/20)];
        var ang2 = data2[(/*BODY_SWEEP_ANGVEL*/20)];
        var angBias = ((s1._data[(/*SHAPE_SWEEP_FACTOR*/5)] * (ang1 < 0 ? -ang1 : ang1)) +
                       (s2._data[(/*SHAPE_SWEEP_FACTOR*/5)] * (ang2 < 0 ? -ang2 : ang2)));

        // If relative linear velocity is near zero
        // and angular bias is near zero, ignore continuous pair.
        if (!slowSweep)
        {
            if (((deltaX * deltaX) + (deltaY * deltaY)) < Physics2DConfig.EQUAL_SQ_VEL &&
                angBias < Physics2DConfig.ZERO_ANG_BIAS)
            {
                toi._data[(/*TOI_TOI_ALPHA*/6)] = undefined;
                toi.failed = true;
                return;
            }
        }

        var curTOIAlpha = 0;
        var curIter = 0;
        var toiData = toi._data;

        var LIMIT = Physics2DConfig.SWEEP_LIMIT;
        var HALF_LIMIT = (LIMIT * 0.5);
        var MIN_ADVANCE = Physics2DConfig.MINIMUM_SWEEP_ADVANCE;
        var MAX_ITER = Physics2DConfig.MAX_SWEEP_ITER;

        while (true)
        {
            b1._sweepIntegrate(curTOIAlpha * timeStep);
            b2._sweepIntegrate(curTOIAlpha * timeStep);
            var posX = data1[(/*BODY_POS*/2)];
            var posY = data1[(/*BODY_POS*/2) + 1];
            s1._update(posX, posY, data1[(/*BODY_AXIS*/5)], data1[(/*BODY_AXIS*/5) + 1], true);
            posX = data2[(/*BODY_POS*/2)];
            posY = data2[(/*BODY_POS*/2) + 1];
            s2._update(posX, posY, data2[(/*BODY_AXIS*/5)], data2[(/*BODY_AXIS*/5) + 1], true);

            var sep = this._distance(s1, s2, toiData) + negRadius;
            var axisX = toiData[(/*TOI_AXIS*/0)];
            var axisY = toiData[(/*TOI_AXIS*/0) + 1];
            var dot = ((axisX * deltaX) + (axisY * deltaY));

            // Objects intersecting!
            if (sep < LIMIT)
            {
                if (slowSweep)
                {
                    break;
                }
                else
                {
                    var d1X = (toiData[(/*TOI_WITNESS_A*/2)]     - posX);
                    var d1Y = (toiData[(/*TOI_WITNESS_A*/2) + 1] - posY);
                    var proj = (dot - (ang1 * ((d1X * axisY) - (d1Y * axisX))));

                    // Terminate if velocity at witness indicates a non-seperating contact
                    // Or if the penetration is too deep.
                    //
                    // Otherwise we continue and try to get a better collision time
                    // To permit fast-rotation of a box about a vertex in collision.
                    // (#)
                    if (proj > 0)
                    {
                        toi.slipped = true;
                    }
                    if (proj <= 0 || sep < HALF_LIMIT)
                    {
                        break;
                    }
                }
            }

            // Lower bound on TOI advancement
            var denom = (angBias - dot) * timeStep;
            if (denom <= 0)
            {
                // fail.
                curTOIAlpha = -1;
                break;
            }

            var delta = (sep / denom);
            // Permit small advancement when objects are already intersecting (#)
            // As well as to avoid failing when a box is rotating with its face
            // parallel to the other collider so that delta is roughly 0.
            //
            // This also helps with performance.
            if (delta < MIN_ADVANCE)
            {
                delta = MIN_ADVANCE;
            }

            curTOIAlpha += delta;
            if (curTOIAlpha >= 1)
            {
                // fail
                curTOIAlpha = -1;
                break;
            }

            curIter += 1;
            if (curIter >= MAX_ITER)
            {
                // If presently intersecting (ignoring slop)
                // Then we mark objects to have their angular
                // velocity set to 0 and permit tunnelling even
                // though we failed to reach tolerance.
                if (sep > negRadius)
                {
                    toi.failed = true;
                }
                else if (slowSweep)
                {
                    // fail
                    curTOIAlpha = -1;
                }
                break;
            }
        }

        toiData[(/*TOI_TOI_ALPHA*/6)] = curTOIAlpha;
        return curTOIAlpha;
    },

    _staticSweep : function _staticSweepFn(toi, timeStep, negRadius)
    {
        var s1 = toi.shapeA; //dynamic
        var s2 = toi.shapeB; //static
        var b1 = s1.body;
        var data1 = b1._data;

        // relative linear velocity and angular bias for distance calculation.
        var deltaX = -data1[(/*BODY_VEL*/7)];
        var deltaY = -data1[(/*BODY_VEL*/7) + 1];
        var ang1 = data1[(/*BODY_SWEEP_ANGVEL*/20)];
        var angBias = (s1._data[(/*SHAPE_SWEEP_FACTOR*/5)] * (ang1 < 0 ? -ang1 : ang1));

        var curTOIAlpha = 0;
        var curIter = 0;
        var toiData = toi._data;

        var LIMIT = Physics2DConfig.SWEEP_LIMIT;
        var HALF_LIMIT = (LIMIT * 0.5);
        var MIN_ADVANCE = Physics2DConfig.MINIMUM_SWEEP_ADVANCE;
        var MAX_ITER = Physics2DConfig.MAX_SWEEP_ITER;

        while (true)
        {
            b1._sweepIntegrate(curTOIAlpha * timeStep);
            var posX = data1[(/*BODY_POS*/2)];
            var posY = data1[(/*BODY_POS*/2) + 1];
            s1._update(posX, posY, data1[(/*BODY_AXIS*/5)], data1[(/*BODY_AXIS*/5) + 1], true);

            var sep = this._distance(s1, s2, toiData) + negRadius;
            var axisX = toiData[(/*TOI_AXIS*/0)];
            var axisY = toiData[(/*TOI_AXIS*/0) + 1];
            var dot = ((axisX * deltaX) + (axisY * deltaY));

            // Objects intersecting!
            if (sep < LIMIT)
            {
                var d1X = (toiData[(/*TOI_WITNESS_A*/2)]     - posX);
                var d1Y = (toiData[(/*TOI_WITNESS_A*/2) + 1] - posY);
                var proj = (dot - (ang1 * ((d1X * axisY) - (d1Y * axisX))));

                // Terminate if velocity at witness indicates a non-seperating contact
                // Or if the penetration is too deep.
                //
                // Otherwise we continue and try to get a better collision time
                // To permit fast-rotation of a box about a vertex in collision.
                // (#)
                if (proj > 0)
                {
                    toi.slipped = true;
                }
                if (proj <= 0 || sep < HALF_LIMIT)
                {
                    break;
                }
            }

            // Lower bound on TOI advancement
            var denom = (angBias - dot) * timeStep;
            if (denom <= 0)
            {
                // fail.
                curTOIAlpha = -1;
                break;
            }

            var delta = (sep / denom);
            // Permit small advancement when objects are already intersecting (#)
            // As well as to avoid failing when a box is rotating with its face
            // parallel to the other collider so that delta is roughly 0.
            //
            // This also helps with performance.
            if (delta < MIN_ADVANCE)
            {
                delta = MIN_ADVANCE;
            }

            curTOIAlpha += delta;
            if (curTOIAlpha >= 1)
            {
                // fail
                curTOIAlpha = -1;
                break;
            }

            curIter += 1;
            if (curIter >= MAX_ITER)
            {
                // If presently intersecting (ignoring slop)
                // Then we mark objects to have their angular
                // velocity set to 0 and permit tunnelling even
                // though we failed to reach tolerance.
                if (sep > negRadius)
                {
                    toi.failed = true;
                }
                break;
            }
        }

        toiData[(/*TOI_TOI_ALPHA*/6)] = curTOIAlpha;
        return curTOIAlpha;
    },

    // =====================================================================

    // Assumption, shapes have been updated by body.
    // need not be IN a body.
    _distance : function distanceFn(shapeA, shapeB, toiData)
    {
        if (shapeA._type === (/*TYPE_CIRCLE*/0))
        {
            if (shapeB._type === (/*TYPE_CIRCLE*/0))
            {
                return this._distanceCircle2Circle(shapeA, shapeB, toiData);
            }
            else
            {
                return this._distanceCircle2Polygon(shapeA, shapeB, toiData);
            }
        }
        else
        {
            if (shapeB._type === (/*TYPE_CIRCLE*/0))
            {
                var ret = this._distanceCircle2Polygon(shapeB, shapeA, toiData);
                // Reverse axis.
                toiData[(/*TOI_AXIS*/0)]     = -toiData[(/*TOI_AXIS*/0)];
                toiData[(/*TOI_AXIS*/0) + 1] = -toiData[(/*TOI_AXIS*/0) + 1];

                // Swap witness points.
                var tmp = toiData[(/*TOI_WITNESS_A*/2)];
                toiData[(/*TOI_WITNESS_A*/2)] = toiData[(/*TOI_WITNESS_B*/4)];
                toiData[(/*TOI_WITNESS_B*/4)] = tmp;

                tmp = toiData[(/*TOI_WITNESS_A*/2) + 1];
                toiData[(/*TOI_WITNESS_A*/2) + 1] = toiData[(/*TOI_WITNESS_B*/4) + 1];
                toiData[(/*TOI_WITNESS_B*/4) + 1] = tmp;
                return ret;
            }
            else
            {
                return this._distancePolygon2Polygon(shapeA, shapeB, toiData);
            }
        }
    },

    _distanceCircle2Circle : function distanceCircle2CircleFn(circleA, circleB, toiData)
    {
        var dataA = circleA._data;
        var dataB = circleB._data;

        var cAX = dataA[(/*CIRCLE_WORLD*/9)];
        var cAY = dataA[(/*CIRCLE_WORLD*/9) + 1];
        var cBX = dataB[(/*CIRCLE_WORLD*/9)];
        var cBY = dataB[(/*CIRCLE_WORLD*/9) + 1];
        var radA = dataA[(/*CIRCLE_RADIUS*/6)];
        var radB = dataB[(/*CIRCLE_RADIUS*/6)];

        var dx = (cBX - cAX);
        var dy = (cBY - cAY);
        var rSum = (radA + radB);

        var len = Math.sqrt((dx * dx) + (dy * dy));
        if (len === 0)
        {
            toiData[(/*TOI_AXIS*/0)]    = dx = 1;
            toiData[(/*TOI_AXIS*/0) + 1] = dy = 0;
        }
        else
        {
            var rec = (1 / len);
            toiData[(/*TOI_AXIS*/0)]     = (dx *= rec);
            toiData[(/*TOI_AXIS*/0) + 1] = (dy *= rec);
        }
        toiData[(/*TOI_WITNESS_A*/2)]     = cAX + (dx * radA);
        toiData[(/*TOI_WITNESS_A*/2) + 1] = cAY + (dy * radA);
        toiData[(/*TOI_WITNESS_B*/4)]     = cBX - (dx * radB);
        toiData[(/*TOI_WITNESS_B*/4) + 1] = cBY - (dy * radB);

        return (len - rSum);
    },

    _distanceCircle2Polygon : function distanceCircle2PolygonFn(circle, polygon, toiData)
    {
        var dataC = circle._data;
        var dataP = polygon._data;

        var cx = dataC[(/*CIRCLE_WORLD*/9)];
        var cy = dataC[(/*CIRCLE_WORLD*/9) + 1];
        var radius = dataC[(/*CIRCLE_RADIUS*/6)];

        var max = Number.NEGATIVE_INFINITY;
        var edge, proj;

        var index = (/*POLY_VERTICES*/6);
        var limit = dataP.length;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            // proj = world-normal dot position
            proj = ((dataP[index + (/*POLY_WNORMAL*/6)]     * cx) +
                    (dataP[index + (/*POLY_WNORMAL*/6) + 1] * cy));
            var dist = proj - (radius + dataP[index + (/*POLY_WPROJ*/9)]);
            if (dist > max)
            {
                max = dist;
                edge = index;
            }
        }

        var nx = dataP[edge + (/*POLY_WNORMAL*/6)];
        var ny = dataP[edge + (/*POLY_WNORMAL*/6) + 1];
        proj = ((nx * cy) - (ny * cx));
        if (proj >= dataP[edge + (/*POLY_CROSS1*/10)])
        {
            if (proj <= dataP[edge + (/*POLY_CROSS2*/11)])
            {
                // circle center is within voronoi region of edge.
                toiData[(/*TOI_AXIS*/0)]     = -nx;
                toiData[(/*TOI_AXIS*/0) + 1] = -ny;
                toiData[(/*TOI_WITNESS_A*/2)]     = (cx -= (nx * radius));
                toiData[(/*TOI_WITNESS_A*/2) + 1] = (cy -= (ny * radius));
                toiData[(/*TOI_WITNESS_B*/4)]     = (cx - (nx * max));
                toiData[(/*TOI_WITNESS_B*/4) + 1] = (cy - (ny * max));
                return max;
            }
            else
            {
                // skip to next edge.
                edge += (/*POLY_STRIDE*/13);
                if (edge === limit)
                {
                    edge = (/*POLY_VERTICES*/6);
                }
            }
        }

        // Perform circle-vertex check.
        var vX = dataP[edge + (/*POLY_WORLD*/2)];
        var vY = dataP[edge + (/*POLY_WORLD*/2) + 1];
        var dx = (vX - cx);
        var dy = (vY - cy);

        var len = Math.sqrt((dx * dx) + (dy * dy));
        if (len === 0)
        {
            toiData[(/*TOI_AXIS*/0)]     = dx = -nx;
            toiData[(/*TOI_AXIS*/0) + 1] = dy = -ny;
        }
        else
        {
            var rec = (1 / len);
            toiData[(/*TOI_AXIS*/0)]     = (dx *= rec);
            toiData[(/*TOI_AXIS*/0) + 1] = (dy *= rec);
        }
        toiData[(/*TOI_WITNESS_A*/2)]     = (cx + (dx * radius));
        toiData[(/*TOI_WITNESS_A*/2) + 1] = (cy + (dy * radius));
        toiData[(/*TOI_WITNESS_B*/4)]     = vX;
        toiData[(/*TOI_WITNESS_B*/4) + 1] = vY;
        return (len - radius);
    },

    _distancePolygon2Polygon : function distancePoly2PolyFn(polyA, polyB, toiData)
    {
        var inf = Number.POSITIVE_INFINITY;
        var dataA = polyA._data;
        var dataB = polyB._data;

        var limitA = dataA.length;
        var limitB = dataB.length;

        var i, j;
        var min, k, nx, ny;

        var max = -inf;
        var first, edge;

        for (i = (/*POLY_VERTICES*/6); i < limitA; i += (/*POLY_STRIDE*/13))
        {
            min = inf;
            nx = dataA[i + (/*POLY_WNORMAL*/6)];
            ny = dataA[i + (/*POLY_WNORMAL*/6) + 1];
            for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
            {
                k = (nx * dataB[j + (/*POLY_WORLD*/2)]) +
                    (ny * dataB[j + (/*POLY_WORLD*/2) + 1]);
                if (k < min)
                {
                    min = k;
                }
            }
            min -= dataA[i + (/*POLY_WPROJ*/9)];

            if (min > max)
            {
                max = min;
                edge = i;
                first = true;
            }
        }

        for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
        {
            min = inf;
            nx = dataB[j + (/*POLY_WNORMAL*/6)];
            ny = dataB[j + (/*POLY_WNORMAL*/6) + 1];
            for (i = (/*POLY_VERTICES*/6); i < limitA; i += (/*POLY_STRIDE*/13))
            {
                k = (nx * dataA[i + (/*POLY_WORLD*/2)]) +
                    (ny * dataA[i + (/*POLY_WORLD*/2) + 1]);
                if (k < min)
                {
                    min = k;
                }
            }
            min -= dataB[j + (/*POLY_WPROJ*/9)];

            if (min > max)
            {
                max = min;
                edge = j;
                first = false;
            }
        }

        // swap data so first polygon owns seperating axis.
        var flip = (first ? 1 : -1);
        var indA, indB;
        if (!first)
        {
            dataA = polyB._data;
            dataB = polyA._data;
            limitA = dataA.length;
            limitB = dataB.length;
            indA = (/*TOI_WITNESS_B*/4);
            indB = (/*TOI_WITNESS_A*/2);
        }
        else
        {
            indA = (/*TOI_WITNESS_A*/2);
            indB = (/*TOI_WITNESS_B*/4);
        }

        nx = dataA[edge + (/*POLY_WNORMAL*/6)];
        ny = dataA[edge + (/*POLY_WNORMAL*/6) + 1];

        // Find witness edge on dataB (not necessarigly polyB)
        min = inf;
        var witness;
        for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
        {
            k = (nx * dataB[j + (/*POLY_WNORMAL*/6)]) +
                (ny * dataB[j + (/*POLY_WNORMAL*/6) + 1]);
            if (k < min)
            {
                min = k;
                witness = j;
            }
        }

        var next = witness + (/*POLY_STRIDE*/13);
        if (next === limitB)
        {
            next = (/*POLY_VERTICES*/6);
        }

        var kX, kY;
        var k1, k2;
        var x3, y3;
        var x4, y4;
        var dL;

        var x1 = dataB[witness + (/*POLY_WORLD*/2)];
        var y1 = dataB[witness + (/*POLY_WORLD*/2) + 1];
        var x2 = dataB[next    + (/*POLY_WORLD*/2)];
        var y2 = dataB[next    + (/*POLY_WORLD*/2) + 1];

        // Special case for parallel, intersecting edges.
        var parallel = (min < (Physics2DConfig.COLLINEAR_EPSILON - 1));
        if (max < 0 && parallel)
        {
            toiData[(/*TOI_AXIS*/0)]     = (nx * flip);
            toiData[(/*TOI_AXIS*/0) + 1] = (ny * flip);

            // Clip (x1,y1), (x2,y2) to edge.
            // Projections relative to edge start.
            kX = dataA[edge + (/*POLY_WORLD*/2)];
            kY = dataA[edge + (/*POLY_WORLD*/2) + 1];
            dL = dataA[edge + (/*POLY_LENGTH*/12)];

            k1 = (nx * (y1 - kY)) - (ny * (x1 - kX));
            if (k1 >= 0 && k1 <= dL)
            {
                toiData[indB]     = kX = x1;
                toiData[indB + 1] = kY = y1;
            }
            else
            {
                k2 = (nx * (y2 - kY)) - (ny * (x1 - kX));
                if (k2 >= 0 && k2 <= dL)
                {
                    toiData[indB]     = kX = x2;
                    toiData[indB + 1] = kY = y2;
                }
                else
                {
                    //clip one of the vertices (x1,y1) to the edge.
                    if (k1 < 0)
                    {
                        k1 = -k1;
                    }
                    else if (k1 > dL)
                    {
                        k1 = (dL - k1);
                    }

                    toiData[indB]     = kX = x1 - (ny * k1);
                    toiData[indB + 1] = kY = y1 + (nx * k1);
                }
            }

            // Witness on toiDataA is the projection.
            toiData[indA]     = kX - (nx * max);
            toiData[indA + 1] = kY - (ny * max);

            return max;
        }
        else
        {
            // Special case for intersection.
            if (max <= 0)
            {
                toiData[(/*TOI_AXIS*/0)]     = (nx * flip);
                toiData[(/*TOI_AXIS*/0) + 1] = (ny * flip);

                // Find vertex on toiDataB that is 'deepest' This is a vertex of witness edge.
                k1 = (nx * x1) + (ny * y1);
                k2 = (nx * x2) + (ny * y2);
                if (k2 < k1)
                {
                    witness = next;
                }

                // Witness on toiDataB is the deep vertex.
                toiData[indB]     = kX = dataB[witness + (/*POLY_WORLD*/2)];
                toiData[indB + 1] = kY = dataB[witness + (/*POLY_WORLD*/2) + 1];

                // Witness on toiDataA is the projection.
                toiData[indA]     = kX - (nx * max);
                toiData[indA + 1] = kY - (ny * max);
                return max;
            }
            else
            {
                // Find closest point on dataA edge to witness edge.
                // Witness on dataB is one of the witness vertices.
                // Witness on dataA is the closest point (projection of witness on dataB)
                dL = dataA[edge + (/*POLY_LENGTH*/12)];

                // !! Special case parallel edges.
                if (parallel)
                {
                    // Need to swap if dataB is 'longer' edge than on dataA.
                    var dL2 = dataB[witness + (/*POLY_LENGTH*/12)];
                    if (dL2 > dL)
                    {
                        dL = dL2;

                        // swap edge/witness
                        next = edge;
                        edge = witness;
                        witness = next;

                        next = (witness + (/*POLY_STRIDE*/13));
                        if (next === limitA)
                        {
                            next = (/*POLY_VERTICES*/6);
                        }

                        x1 = dataA[witness + (/*POLY_WORLD*/2)];
                        y1 = dataA[witness + (/*POLY_WORLD*/2) + 1];
                        x2 = dataA[next    + (/*POLY_WORLD*/2)];
                        y2 = dataA[next    + (/*POLY_WORLD*/2) + 1];

                        // Change to dataB for (kX, kY) below.
                        dataA = dataB;

                        // flip everyyyyything.
                        nx *= -1;
                        ny *= -1;
                        flip *= -1;

                        var tmp = indA;
                        indA = indB;
                        indB = tmp;
                    }
                }

                kX = dataA[edge + (/*POLY_WORLD*/2)];
                kY = dataA[edge + (/*POLY_WORLD*/2) + 1];

                // 'time' of point w1 along edge.
                k1 = -((nx * (kY - y1)) - (ny * (kX - x1)));
                var in1 = true;
                if (k1 < 0)
                {
                    k1 = 0;
                    in1 = false;
                }
                else if (k1 > dL)
                {
                    k1 = dL;
                    in1 = false;
                }

                // 'time' of point w2 along edge.
                k2 = -((nx * (kY - y2)) - (ny * (kX - x2)));
                var in2 = true;
                if (k2 < 0)
                {
                    k2 = 0;
                    in2 = false;
                }
                else if (k2 > dL)
                {
                    k2 = dL;
                    in2 = false;
                }

                // point on edge closest to w1/w2, relative to closest points for axis.
                x3 = x1 - (kX - (ny * k1));
                y3 = y1 - (kY + (nx * k1));
                x4 = x2 - (kX - (ny * k2));
                y4 = y2 - (kY + (nx * k2));

                k1 = ((x3 * x3) + (y3 * y3));
                k2 = ((x4 * x4) + (y4 * y4));
                var rec;
                if (k1 < k2)
                {
                    // point closest to w1 is shorter distance.
                    toiData[indB]     = kX = x1;
                    toiData[indB + 1] = kY = y1;
                    max = Math.sqrt(k1);
                    if (in1 || max < Physics2DConfig.NORMALIZE_EPSILON)
                    {
                        toiData[(/*TOI_AXIS*/0)]     = (nx *= flip);
                        toiData[(/*TOI_AXIS*/0) + 1] = (ny *= flip);
                    }
                    else
                    {
                        rec = flip / max;
                        toiData[(/*TOI_AXIS*/0)]     = nx = (x3 * rec);
                        toiData[(/*TOI_AXIS*/0) + 1] = ny = (y3 * rec);
                    }
                }
                else
                {
                    // point closest to w2 is shorter distance.
                    toiData[indB]     = kX = x2;
                    toiData[indB + 1] = kY = y2;
                    max = Math.sqrt(k2);
                    if (in2 || max < Physics2DConfig.NORMALIZE_EPSILON)
                    {
                        toiData[(/*TOI_AXIS*/0)]     = (nx *= flip);
                        toiData[(/*TOI_AXIS*/0) + 1] = (ny *= flip);
                    }
                    else
                    {
                        rec = flip / max;
                        toiData[(/*TOI_AXIS*/0)]     = nx = (x4 * rec);
                        toiData[(/*TOI_AXIS*/0) + 1] = ny = (y4 * rec);
                    }
                }

                toiData[indA]     = kX - (nx * max * flip);
                toiData[indA + 1] = kY - (ny * max * flip);
                return max;
            }
        }
    },

    // =====================================================================

    // Assumption, shapes have been updated by body.
    //   shapes must also be 'in' a Body for special contact data.
    // This method is not quite modular as test/distance
    // due to the complicated values required for contacts etc.
    // no AABB test performed here.
    _collide : function collideFn(shapeA, shapeB, arb)
    {
        if (shapeA._type === (/*TYPE_CIRCLE*/0))
        {
            if (shapeB._type === (/*TYPE_CIRCLE*/0))
            {
                return this._collideCircle2Circle(shapeA, shapeB, arb);
            }
            else
            {
                return this._collideCircle2Polygon(shapeA, shapeB, arb, false);
            }
        }
        else
        {
            if (shapeB._type === (/*TYPE_CIRCLE*/0))
            {
                return this._collideCircle2Polygon(shapeB, shapeA, arb, true);
            }
            else
            {
                return this._collidePolygon2Polygon(shapeA, shapeB, arb);
            }
        }
    },

    _collideCircle2Polygon : function collideCircle2PolygonFn(circle, polygon, arb, reverse)
    {
        var dataC = circle._data;
        var dataP = polygon._data;

        var cx = dataC[(/*CIRCLE_WORLD*/9)];
        var cy = dataC[(/*CIRCLE_WORLD*/9) + 1];
        var radius = dataC[(/*CIRCLE_RADIUS*/6)];

        var max = Number.NEGATIVE_INFINITY;

        var edge, proj;
        var index = (/*POLY_VERTICES*/6);
        var limit = dataP.length;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            proj = ((dataP[index + (/*POLY_WNORMAL*/6)]     * cx) +
                    (dataP[index + (/*POLY_WNORMAL*/6) + 1] * cy)) -
                   (dataP[index + (/*POLY_WPROJ*/9)] + radius);
            if (proj > 0)
            {
                return false;
            }
            if (proj > max)
            {
                max = proj;
                edge = index;
            }
        }

        var adata = arb._data;
        var con, cdata;

        var nx = dataP[edge + (/*POLY_WNORMAL*/6)];
        var ny = dataP[edge + (/*POLY_WNORMAL*/6) + 1];
        var vX, vY, lvX, lvY;
        var dx, dy;
        proj = ((nx * cy) - (ny * cx));
        if (proj >= dataP[edge + (/*POLY_CROSS1*/10)])
        {
            if (proj <= dataP[edge + (/*POLY_CROSS2*/11)])
            {
                // circle center within voronoi region of edge.

                // Take contact point to be consistently halfway into the overlap.
                proj = (radius + (max * 0.5));
                dx = (nx * proj);
                dy = (ny * proj);

                con = arb._injectContact(cx - dx, cy - dy,
                                         (reverse ? nx : -nx), (reverse ? ny : -ny),
                                         max, (/*HASH_CIRCLE*/0));

                arb._faceType = (reverse ? (/*FACE_1*/1) : (/*FACE_2*/2));
                arb._reverse = !reverse;
                adata[(/*ARB_LNORM*/11)]     = dataP[edge + (/*POLY_LNORMAL*/4)];
                adata[(/*ARB_LNORM*/11) + 1] = dataP[edge + (/*POLY_LNORMAL*/4) + 1];
                adata[(/*ARB_LPROJ*/13)]     = dataP[edge + (/*POLY_LPROJ*/8)];
                adata[(/*ARB_RADIUS*/14)]    = radius;

                cdata = con._data;
                cdata[(/*CON_LREL1*/13)]     = dataC[(/*CIRCLE_LOCAL*/7)];
                cdata[(/*CON_LREL1*/13) + 1] = dataC[(/*CIRCLE_LOCAL*/7) + 1];
                return true;
            }
            else
            {
                var next = edge + (/*POLY_STRIDE*/13);
                if (next === limit)
                {
                    next = (/*POLY_VERTICES*/6);
                }
                vX = dataP[next + (/*POLY_WORLD*/2)];
                vY = dataP[next + (/*POLY_WORLD*/2) + 1];
                lvX = dataP[next + (/*POLY_LOCAL*/0)];
                lvY = dataP[next + (/*POLY_LOCAL*/0) + 1];
            }
        }
        else
        {
            vX = dataP[edge + (/*POLY_WORLD*/2)];
            vY = dataP[edge + (/*POLY_WORLD*/2) + 1];
            lvX = dataP[edge + (/*POLY_LOCAL*/0)];
            lvY = dataP[edge + (/*POLY_LOCAL*/0) + 1];
        }

        // Circle - Vertex
        dx = (cx - vX);
        dy = (cy - vY);
        var dsq = ((dx * dx) + (dy * dy));
        if (dsq > (radius * radius))
        {
            return false;
        }

        if (dsq < Physics2DConfig.NORMALIZE_SQ_EPSILON)
        {
            // Take contact point to be consistently halfway into the overlap.
            con = arb._injectContact(cx, cy,
                                     (reverse ? nx : -nx), (reverse ? ny : -ny),
                                     0, (/*HASH_CIRCLE*/0));
        }
        else
        {
            var dist = Math.sqrt(dsq);
            var invDist = (1 / dist);
            var df = 0.5 + (radius * invDist * 0.5);
            if (!reverse)
            {
                invDist = -invDist;
            }

            // Take contact point to be consistently halfway into the overlap.
            con = arb._injectContact(cx - (dx * df), cy - (dy * df),
                                     dx * invDist, dy * invDist,
                                     dist - radius, (/*HASH_CIRCLE*/0));
        }

        cdata = con._data;
        if (reverse)
        {
            cdata[(/*CON_LREL1*/13)]     = lvX;
            cdata[(/*CON_LREL1*/13) + 1] = lvY;
            cdata[(/*CON_LREL2*/15)]     = dataC[(/*CIRCLE_LOCAL*/7)];
            cdata[(/*CON_LREL2*/15) + 1] = dataC[(/*CIRCLE_LOCAL*/7) + 1];
        }
        else
        {
            cdata[(/*CON_LREL1*/13)]     = dataC[(/*CIRCLE_LOCAL*/7)];
            cdata[(/*CON_LREL1*/13) + 1] = dataC[(/*CIRCLE_LOCAL*/7) + 1];
            cdata[(/*CON_LREL2*/15)]     = lvX;
            cdata[(/*CON_LREL2*/15) + 1] = lvY;
        }

        adata[(/*ARB_RADIUS*/14)] = radius;
        arb._faceType = (/*FACE_CIRCLE*/0);
        arb._reverse = false;

        return true;
    },

    _collidePolygon2Polygon : function collidePolygon2Polygon(polyA, polyB, arb)
    {
        var inf = Number.POSITIVE_INFINITY;
        var dataA = polyA._data;
        var dataB = polyB._data;

        var limitA = dataA.length;
        var limitB = dataB.length;

        var i, j;
        var min, k, nx, ny;

        var max = -inf;
        var first, edge, proj;

        for (i = (/*POLY_VERTICES*/6); i < limitA; i += (/*POLY_STRIDE*/13))
        {
            min = inf;
            nx = dataA[i + (/*POLY_WNORMAL*/6)];
            ny = dataA[i + (/*POLY_WNORMAL*/6) + 1];
            proj = dataA[i + (/*POLY_WPROJ*/9)];
            for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
            {
                k = (nx * dataB[j + (/*POLY_WORLD*/2)]) +
                    (ny * dataB[j + (/*POLY_WORLD*/2) + 1]);
                if (k < min)
                {
                    min = k;
                }
                if ((min - proj) <= max)
                {
                    break;
                }
            }
            min -= proj;
            if (min >= 0)
            {
                return false;
            }
            if (min > max)
            {
                max = min;
                edge = i;
                first = true;
            }
        }

        for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
        {
            min = inf;
            nx = dataB[j + (/*POLY_WNORMAL*/6)];
            ny = dataB[j + (/*POLY_WNORMAL*/6) + 1];
            proj = dataB[j + (/*POLY_WPROJ*/9)];
            for (i = (/*POLY_VERTICES*/6); i < limitA; i += (/*POLY_STRIDE*/13))
            {
                k = (nx * dataA[i + (/*POLY_WORLD*/2)]) +
                    (ny * dataA[i + (/*POLY_WORLD*/2) + 1]);
                if (k < min)
                {
                    min = k;
                }
                if ((min - proj) <= max)
                {
                    break;
                }
            }
            min -= proj;
            if (min >= 0)
            {
                return false;
            }
            if (min > max)
            {
                max = min;
                edge = j;
                first = false;
            }
        }

        // swap data so first polygon owns seperating axis.
        var flip = (first ? 1 : -1);
        var bdata;
        if (!first)
        {
            dataA = polyB._data;
            dataB = polyA._data;
            limitA = dataA.length;
            limitB = dataB.length;
            bdata = polyA.body._data;
        }
        else
        {
            bdata = polyB.body._data;
        }

        nx = dataA[edge + (/*POLY_WNORMAL*/6)];
        ny = dataA[edge + (/*POLY_WNORMAL*/6) + 1];

        // Find witness edge on dataB (not necessarigly polyB)
        min = inf;
        var witness;
        for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
        {
            k = (nx * dataB[j + (/*POLY_WNORMAL*/6)]) +
                (ny * dataB[j + (/*POLY_WNORMAL*/6) + 1]);
            if (k < min)
            {
                min = k;
                witness = j;
            }
        }

        var next = witness + (/*POLY_STRIDE*/13);
        if (next === limitB)
        {
            next = (/*POLY_VERTICES*/6);
        }

        var c1X = dataB[witness + (/*POLY_WORLD*/2)];
        var c1Y = dataB[witness + (/*POLY_WORLD*/2) + 1];
        var c2X = dataB[next    + (/*POLY_WORLD*/2)];
        var c2Y = dataB[next    + (/*POLY_WORLD*/2) + 1];

        var dvX = (c2X - c1X);
        var dvY = (c2Y - c1Y);
        var d1 = (c1X * ny) - (c1Y * nx);
        var d2 = (c2X * ny) - (c2Y * nx);
        var den = (1 / (d2 - d1));

        // clip c1
        var t = (-dataA[edge + (/*POLY_CROSS2*/11)] - d1) * den;
        if (t > Physics2DConfig.CLIP_EPSILON)
        {
            c1X += (dvX * t);
            c1Y += (dvY * t);
        }

        // clip c2
        t = (-dataA[edge + (/*POLY_CROSS1*/10)] - d2) * den;
        if (t < -Physics2DConfig.CLIP_EPSILON)
        {
            c2X += (dvX * t);
            c2Y += (dvY * t);
        }

        var adata = arb._data;
        adata[(/*ARB_LNORM*/11)]     = dataA[edge + (/*POLY_LNORMAL*/4)];
        adata[(/*ARB_LNORM*/11) + 1] = dataA[edge + (/*POLY_LNORMAL*/4) + 1];
        adata[(/*ARB_LPROJ*/13)]     = dataA[edge + (/*POLY_LPROJ*/8)];
        adata[(/*ARB_RADIUS*/14)]    = 0.0;
        arb._faceType = (first ? (/*FACE_1*/1) : (/*FACE_2*/2));

        // Per contact distance
        proj = dataA[edge + (/*POLY_WPROJ*/9)];
        var c1d = ((c1X * nx) + (c1Y * ny)) - proj;
        var c2d = ((c2X * nx) + (c2Y * ny)) - proj;

        var p1x = bdata[(/*BODY_POS*/2)];
        var p1y = bdata[(/*BODY_POS*/2) + 1];
        var cos = bdata[(/*BODY_AXIS*/5)];
        var sin = bdata[(/*BODY_AXIS*/5) + 1];

        if (c1d > 0 && c2d > 0)
        {
            return false;
        }

        var rx = (c1X - p1x);
        var ry = (c1Y - p1y);
        c1X -= (nx * c1d * 0.5);
        c1Y -= (ny * c1d * 0.5);
        var con = arb._injectContact(c1X, c1Y, nx * flip, ny * flip, c1d, (first ? (/*HASH_LEFT*/1) : (/*HASH_RIGHT*/2)), c1d > 0)._data;
        con[(/*CON_LREL1*/13)]     = ((cos * rx) + (sin * ry));
        con[(/*CON_LREL1*/13) + 1] = ((cos * ry) - (sin * rx));

        rx = (c2X - p1x);
        ry = (c2Y - p1y);
        c2X -= (nx * c2d * 0.5);
        c2Y -= (ny * c2d * 0.5);
        con = arb._injectContact(c2X, c2Y, nx * flip, ny * flip, c2d, (first ? (/*HASH_RIGHT*/2) : (/*HASH_LEFT*/1)), c2d > 0)._data;
        con[(/*CON_LREL1*/13)]     = ((cos * rx) + (sin * ry));
        con[(/*CON_LREL1*/13) + 1] = ((cos * ry) - (sin * rx));

        arb._reverse = (!first);

        return true;
    },

    _collideCircle2Circle : function collideCircle2CircleFn(circleA, circleB, arb)
    {
        var dataA = circleA._data;
        var dataB = circleB._data;

        var x1 = dataA[(/*CIRCLE_WORLD*/9)];
        var y1 = dataA[(/*CIRCLE_WORLD*/9) + 1];
        var r1 = dataA[(/*CIRCLE_RADIUS*/6)];

        var dx = (dataB[(/*CIRCLE_WORLD*/9)]     - x1);
        var dy = (dataB[(/*CIRCLE_WORLD*/9) + 1] - y1);
        var rSum = r1 + dataB[(/*CIRCLE_RADIUS*/6)];

        var dsq = ((dx * dx) + (dy * dy));
        if (dsq > (rSum * rSum))
        {
            return false;
        }

        var con;
        if (dsq < Physics2DConfig.NORMALIZE_SQ_EPSILON)
        {
            // Take contact point to be consistently halfway into the overlap.
            con = arb._injectContact(x1 + (dx * 0.5), y1 + (dy * 0.5), 1, 0,
                                    -rSum, (/*HASH_CIRCLE*/0));
        }
        else
        {
            var dist = Math.sqrt(dsq);
            var invDist = (1 / dist);
            var df = (0.5 + ((r1 - (0.5 * rSum)) * invDist));

            // Take contact point to be consistently halfway into the overlap.
            con = arb._injectContact(x1 + (dx * df), y1 + (dy * df),
                                     dx * invDist, dy * invDist,
                                     dist - rSum, (/*HASH_CIRCLE*/0));
        }

        var data = con._data;
        data[(/*CON_LREL1*/13)]     = dataA[(/*CIRCLE_LOCAL*/7)];
        data[(/*CON_LREL1*/13) + 1] = dataA[(/*CIRCLE_LOCAL*/7) + 1];
        data[(/*CON_LREL2*/15)]     = dataB[(/*CIRCLE_LOCAL*/7)];
        data[(/*CON_LREL2*/15) + 1] = dataB[(/*CIRCLE_LOCAL*/7) + 1];

        data = arb._data;
        data[(/*ARB_RADIUS*/14)] = rSum;
        arb._faceType = (/*FACE_CIRCLE*/0);

        return true;
    },

    // =====================================================================

    // Assumption, shapes have been updated by body.
    // need not be 'in' a body.
    // No AABB test performed here.
    _test : function testFn(shapeA, shapeB)
    {
        if (shapeA._type === (/*TYPE_CIRCLE*/0))
        {
            if (shapeB._type === (/*TYPE_CIRCLE*/0))
            {
                return this._testCircle2Circle(shapeA, shapeB);
            }
            else
            {
                return this._testCircle2Polygon(shapeA, shapeB);
            }
        }
        else
        {
            if (shapeB._type === (/*TYPE_CIRCLE*/0))
            {
                return this._testCircle2Polygon(shapeB, shapeA);
            }
            else
            {
                return this._testPolygon2Polygon(shapeA, shapeB);
            }
        }
    },

    _testCircle2Circle : function testCircle2CircleFn(circleA, circleB)
    {
        var dataA = circleA._data;
        var dataB = circleB._data;

        var dx = (dataA[(/*CIRCLE_WORLD*/9)]     - dataB[(/*CIRCLE_WORLD*/9)]);
        var dy = (dataA[(/*CIRCLE_WORLD*/9) + 1] - dataB[(/*CIRCLE_WORLD*/9) + 1]);
        var rSum = dataA[(/*CIRCLE_RADIUS*/6)] + dataB[(/*CIRCLE_RADIUS*/6)];

        return (((dx * dx) + (dy * dy)) <= (rSum * rSum));
    },

    _testCircle2Polygon : function testCircle2PolygonFn(circle, polygon)
    {
        var dataC = circle._data;
        var dataP = polygon._data;

        var cx = dataC[(/*CIRCLE_WORLD*/9)];
        var cy = dataC[(/*CIRCLE_WORLD*/9) + 1];
        var radius = dataC[(/*CIRCLE_RADIUS*/6)];

        var max = Number.NEGATIVE_INFINITY;
        var edge, proj;

        var index = (/*POLY_VERTICES*/6);
        var limit = dataP.length;
        for (; index < limit; index += (/*POLY_STRIDE*/13))
        {
            // proj = world-normal dot position
            proj = ((dataP[index + (/*POLY_WNORMAL*/6)]     * cx) +
                    (dataP[index + (/*POLY_WNORMAL*/6) + 1] * cy));
            var dist = proj - (radius + dataP[index + (/*POLY_WPROJ*/9)]);
            if (dist > 0)
            {
                return false;
            }

            if (dist > max)
            {
                max = dist;
                edge = index;
            }
        }

        // proj = world-normal perpdot position
        proj = ((dataP[edge + (/*POLY_WNORMAL*/6)]     * cy) -
                (dataP[edge + (/*POLY_WNORMAL*/6) + 1] * cx));
        if (proj >= dataP[edge + (/*POLY_CROSS1*/10)])
        {
            if (proj <= dataP[edge + (/*POLY_CROSS2*/11)])
            {
                // circle center is within voronoi region of edge.
                return true;
            }
            else
            {
                // skip to next edge.
                edge += (/*POLY_STRIDE*/13);
                if (edge === limit)
                {
                    edge = (/*POLY_VERTICES*/6);
                }
            }
        }

        // Perform circle-vertex check.
        // delta = position - vertex
        var dx = (cx - dataP[edge + (/*POLY_WORLD*/2)]);
        var dy = (cy - dataP[edge + (/*POLY_WORLD*/2) + 1]);
        return (((dx * dx) + (dy * dy)) <= (radius * radius));
    },

    _testPolygon2Polygon : function testPolygon2PolygonFn(polyA, polyB)
    {
        var inf = Number.POSITIVE_INFINITY;
        var dataA = polyA._data;
        var dataB = polyB._data;

        var limitA = dataA.length;
        var limitB = dataB.length;

        var i, j;
        var min, proj, nx, ny;

        for (i = (/*POLY_VERTICES*/6); i < limitA; i += (/*POLY_STRIDE*/13))
        {
            min = inf;
            nx = dataA[i + (/*POLY_WNORMAL*/6)];
            ny = dataA[i + (/*POLY_WNORMAL*/6) + 1];
            for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
            {
                proj = (nx * dataB[j + (/*POLY_WORLD*/2)]) +
                       (ny * dataB[j + (/*POLY_WORLD*/2) + 1]);
                if (proj < min)
                {
                    min = proj;
                }
            }
            if (min > dataA[i + (/*POLY_WPROJ*/9)])
            {
                return false;
            }
        }

        for (j = (/*POLY_VERTICES*/6); j < limitB; j += (/*POLY_STRIDE*/13))
        {
            min = inf;
            nx = dataB[j + (/*POLY_WNORMAL*/6)];
            ny = dataB[j + (/*POLY_WNORMAL*/6) + 1];
            for (i = (/*POLY_VERTICES*/6); i < limitA; i += (/*POLY_STRIDE*/13))
            {
                proj = (nx * dataA[i + (/*POLY_WORLD*/2)]) +
                       (ny * dataA[i + (/*POLY_WORLD*/2) + 1]);
                if (proj < min)
                {
                    min = proj;
                }
            }
            if (min > dataB[j + (/*POLY_WPROJ*/9)])
            {
                return false;
            }
        }

        return true;
    }

};

Physics2DCollisionUtils.create = function phys2DCollideFn()
{
    var c = new Physics2DCollisionUtils();
    c._toi = Physics2DTOIEvent.allocate();
    return c;
};

// =========================================================================

//
// Physics2D Device
//
function Physics2DDevice() {}
Physics2DDevice.prototype = {

    version : 1,
    vendor : "Turbulenz",

    getDefaultMaterial : function getDefaultMaterialFn()
    {
        return Physics2DMaterial.defaultMaterial;
    },

    createCircleShape : function createCircleShapeFn(params)
    {
        return Physics2DCircle.create(params);
    },

    createPolygonShape : function createPolygonShapeFn(params)
    {
        return Physics2DPolygon.create(params, null);
    },

    createRigidBody : function createRigidBodyFn(params)
    {
        return Physics2DRigidBody.create(params);
    },

    createWorld : function createWorldFn(params)
    {
        return Physics2DWorld.create(params);
    },

    createMaterial : function createMaterialFn(params)
    {
        return Physics2DMaterial.create(params);
    },

    createSweepAndPruneBroadphase : function createSAPBPhaseFn()
    {
        return Physics2DSweepAndPrune.create();
    },

    createBoxTreeBroadphase : function createBoxBPhaseFn()
    {
        return Physics2DBoxTreeBroadphase.create();
    },

    createCollisionUtils : function createCollisionUtilsFn()
    {
        return Physics2DCollisionUtils.create();
    },

    createPointConstraint : function createPointConstraintFn(params)
    {
        return Physics2DPointConstraint.create(params);
    },

    createWeldConstraint : function createWeldConstraintFn(params)
    {
        return Physics2DWeldConstraint.create(params);
    },

    createAngleConstraint : function createAngleConstraintFn(params)
    {
        return Physics2DAngleConstraint.create(params);
    },

    createDistanceConstraint : function createDistanceConstraintFn(params)
    {
        return Physics2DDistanceConstraint.create(params);
    },

    createLineConstraint : function createLineConstraintFn(params)
    {
        return Physics2DLineConstraint.create(params);
    },

    createMotorConstraint : function createMotorConstraintFn(params)
    {
        return Physics2DMotorConstraint.create(params);
    },

    createPulleyConstraint : function createPulleyConstraintFn(params)
    {
        return Physics2DPulleyConstraint.create(params);
    },

    createCustomConstraint : function createCustomConstraintFn(params)
    {
        return Physics2DCustomConstraint.create(params);
    },

    createRectangleVertices : function createRectangleVerticesFn(minX, minY, maxX, maxY)
    {
        var tmp;
        if (maxX < minX)
        {
            tmp = minX;
            minX = maxX;
            maxX = tmp;
        }
        if (maxY < minY)
        {
            tmp = minY;
            minY = maxY;
            maxY = tmp;
        }

        var v0 = new Physics2DDevice.prototype.floatArray(2);
        v0[0] = minX;
        v0[1] = minY;
        var v1 = new Physics2DDevice.prototype.floatArray(2);
        v1[0] = maxX;
        v1[1] = minY;
        var v2 = new Physics2DDevice.prototype.floatArray(2);
        v2[0] = maxX;
        v2[1] = maxY;
        var v3 = new Physics2DDevice.prototype.floatArray(2);
        v3[0] = minX;
        v3[1] = maxY;

        return [v0, v1, v2, v3];
    },

    createBoxVertices : function createBoxVerticesFn(width, height)
    {
        var w = (width * 0.5);
        var h = (height * 0.5);

        var v0 = new Physics2DDevice.prototype.floatArray(2);
        v0[0] = -w;
        v0[1] = -h;
        var v1 = new Physics2DDevice.prototype.floatArray(2);
        v1[0] = w;
        v1[1] = -h;
        var v2 = new Physics2DDevice.prototype.floatArray(2);
        v2[0] = w;
        v2[1] = h;
        var v3 = new Physics2DDevice.prototype.floatArray(2);
        v3[0] = -w;
        v3[1] = h;

        return [v0, v1, v2, v3];
    },

    createRegularPolygonVertices : function createRegulariVerticesFn(diameterX, diameterY, numVertices)
    {
        var rX = (diameterX  * 0.5);
        var rY = (diameterY * 0.5);
        var vertices = [];

        var num = numVertices;
        var angInc = (Math.PI * 2 / num);

        var i;
        for (i = 0; i < num; i += 1)
        {
            var ang = (angInc * i);
            var vec = vertices[vertices.length] = new Physics2DDevice.prototype.floatArray(2);
            vec[0] = (rX * Math.cos(ang));
            vec[1] = (rY * Math.sin(ang));
        }

        return vertices;
    }
};

Physics2DDevice.create = function Physics2DDeviceFn()
{
    var pd = new Physics2DDevice();
    return pd;
};


// =========================================================================

// Detect correct typed arrays
(function () {
    Physics2DDevice.prototype.floatArray = function (arg) {
        if (arguments.length === 0)
        {
            return [];
        }

        var i, ret;
        if (typeof arg === "number")
        {
            ret = new Array(arg);
        }
        else
        {
            ret = [];
            for (i = 0; i < arg.length; i += 1)
            {
                ret[i] = arg[i];
            }
        }
        return ret;
    };

    Physics2DDevice.prototype.uint16Array = Physics2DDevice.prototype.floatArray;

    var testArray, textDescriptor;
    if (typeof Float32Array !== "undefined")
    {
        testArray = new Float32Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            Physics2DDevice.prototype.floatArray = Float32Array;
        }
    }

    if (typeof Uint16Array !== "undefined")
    {
        testArray = new Uint16Array(4);
        textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Uint16Array]')
        {
            Physics2DDevice.prototype.uint16Array = Uint16Array;
        }
    }
}());

// Must defer so that floatArray on Physics2DDevice is defined.
Physics2DMaterial.defaultMaterial = Physics2DMaterial.create();

/*jshint white: true*/

// Complains in various parts about use of (/*NAME*/value) constants.
/*jshint white: false*/

// Copyright (c) 2012 Turbulenz Limited

/*global
Float32Array: false
Uint16Array: false

Physics2DDevice: false
Physics2DConfig: false
Physics2DCustomConstraint: false
Physics2DWeldConstraint: false
Physics2DPointConstraint: false
Physics2DDistanceConstraint: false
Physics2DAngleConstraint: false
Physics2DLineConstraint: false
Physics2DPulleyConstraint: false
*/


//
// Physics2D DebugDraw
//
function Physics2DDebugDraw() {}
Physics2DDebugDraw.prototype = {

    version : 1,

    setPhysics2DViewport : function setPhysics2DViewportFn(viewport)
    {
        if (viewport)
        {
            var port = this._physics2DPort;
            port[0] = viewport[0];
            port[1] = viewport[1];
            port[2] = viewport[2];
            port[3] = viewport[3];
            this._physics2DPortEnabled = true;
        }
        else
        {
            this._physics2DPortEnabled = false;
        }
        this._invalidated = true;
    },

    setScreenViewport : function setScreenViewportFn(viewport)
    {
        if (viewport)
        {
            var port = this._screenPort;
            port[0] = viewport[0];
            port[1] = viewport[1];
            port[2] = viewport[2];
            port[3] = viewport[3];
            this._screenPortEnabled = true;
        }
        else
        {
            this._screenPortEnabled = false;
        }
        this._invalidated = true;
    },

    drawLine : function drawLineFn(x1, y1, x2, y2, color)
    {
        var numVertices = this._numVertices;
        var vindex = (numVertices * 6);
        var iindex = (this._numLines * 2);
        this._prepare(2, 1); // 2 vertices, 1 lines

        var data = this._vertexData;
        data[vindex]     = x1;
        data[vindex + 1] = y1;
        data[vindex + 6] = x2;
        data[vindex + 7] = y2;
        data[vindex + 2] = data[vindex + 8]  = color[0];
        data[vindex + 3] = data[vindex + 9]  = color[1];
        data[vindex + 4] = data[vindex + 10] = color[2];
        data[vindex + 5] = data[vindex + 11] = color[3];

        data = this._indexData;
        data[iindex]     = numVertices;
        data[iindex + 1] = (numVertices + 1);
    },

    drawLinearSpring : function drawLinearSpringFn(x1, y1, x2, y2, numCoils, radius, color)
    {
        if (numCoils <= 0)
        {
            this.drawLine(x1, y1, x2, y2, color);
            return;
        }

        // Draw linear spring as a sequence of curves approximating
        // a sine wave.
        //
        var dx = (x2 - x1);
        var dy = (y2 - y1);

        var lengthSq = ((dx * dx) + (dy * dy));
        var min = (this.minSpringLength * this.screenToPhysics2D);
        if (lengthSq < (min * min))
        {
            // Spring length is below defined epsilon, so we use a line instead.
            this.drawLine(x1, y1, x2, y2, color);
            return;
        }

        // set (nx, ny) to be normal-offset to line between end points of spring
        //   defining twice the amplitude of wave.
        // We use control points which are twice as far from spring line
        //   as the amplitude of wave as the nature of bezier curves means this will
        //   give us a curve that reaches the amplitude perfectly.
        var nx = -dy;
        var ny = dx;
        var nlsq = ((2 * radius) / Math.sqrt((nx * nx) + (ny * ny)));
        nx *= nlsq;
        ny *= nlsq;

        var rec = (1 / (numCoils * 4));
        dx *= rec;
        dy *= rec;

        var i;
        for (i = 0; i < numCoils; i += 1)
        {
            x2 = (x1 + (dx * 2));
            y2 = (y1 + (dy * 2));
            this.drawCurve(x1, y1, (x1 + dx + nx), (y1 + dy + ny), x2, y2, color);
            x1 = x2;
            y1 = y2;

            x2 = (x1 + (dx * 2));
            y2 = (y1 + (dy * 2));
            this.drawCurve(x1, y1, (x1 + dx - nx), (y1 + dy - ny), x2, y2, color);
            x1 = x2;
            y1 = y2;
        }
    },

    _drawAngleIndicator : function _drawAngleIndicatorFn(x, y, ang, rad, size, color)
    {
        var cos = Math.cos(ang);
        var sin = Math.sin(ang);
        this._drawAnchor(x + (rad * cos), y + (rad * sin), size, color);
    },

    _drawAnchor : function _drawAnchorFn(x, y, rad, color)
    {
        // 'emulates' a filled circle.
        this.drawCircle(x, y, rad,        color);
        this.drawCircle(x, y, rad * 0.75, color);
        this.drawCircle(x, y, rad * 0.5,  color);
        this.drawCircle(x, y, rad * 0.25, color);
    },

    drawSpiral : function drawSpiralFn(x, y, ang1, ang2, rad1, rad2, color)
    {
        // Order end points so ang1 < ang2.
        if (ang1 > ang2)
        {
            var tmp = ang1;
            ang1 = ang2;
            ang2 = tmp;

            tmp = rad1;
            rad1 = rad2;
            rad2 = tmp;
        }

        if (ang1 === ang2)
        {
            return;
        }

        var deltaRadius = (rad2 - rad1);
        var deltaAngle = (ang2 - ang1);

        // Render spiral in angular segments.
        var segmentCount = Math.ceil(deltaAngle / this.spiralMaxArc);
        var segmentDeltaRadius = (deltaRadius / segmentCount);
        var segmentDeltaAngle = (deltaAngle / segmentCount);

        var cosDelta = Math.cos(segmentDeltaAngle);
        var sinDelta = Math.sin(segmentDeltaAngle);

        // Generate spiral points by rotating (and scaling)
        // radial vector.
        var radialX = Math.cos(ang1);
        var radialY = Math.sin(ang1);
        var radius = rad1;

        var x1 = (x + (rad1 * radialX));
        var y1 = (y + (rad1 * radialY));

        // Gradient at (x1, y1).
        var ux = (deltaRadius * radialX) - (radius * deltaAngle * radialY);
        var uy = (deltaRadius * radialY) + (radius * deltaAngle * radialX);

        var i;
        for (i = 0; i < segmentCount; i += 1)
        {
            // Compute next point on spiral
            var newRadius = (radius + segmentDeltaRadius);
            var newRadialX = (cosDelta * radialX) - (sinDelta * radialY);
            var newRadialY = (sinDelta * radialX) + (cosDelta * radialY);

            var x2 = (x + (newRadius * newRadialX));
            var y2 = (y + (newRadius * newRadialY));

            // Gradient at (x2, y2)
            var vx = (deltaRadius * newRadialX) - (newRadius * deltaAngle * newRadialY);
            var vy = (deltaRadius * newRadialY) + (newRadius * deltaAngle * newRadialX);

            // Render this spiral segment using a bezier curve (if possible)
            // We find the control point by intersecting the gradients at start and end point.
            var den = ((ux * vy) - (uy * vx));
            if ((den * den) < this.spiralEpsilon)
            {
                // Gradients are nearly parallel, use a line!
                this.drawLine(x1, y1, x2, y2, color);
            }
            else
            {
                // Compute intersection 'time' along gradient (ux, uy).
                var t = (((x2 - x1) * vy) + ((y1 - y2) * vx)) / den;
                if (t <= 0)
                {
                    // Intersection has negative 'time'? Can happen (rare).
                    // Better use a line!
                    this.drawLine(x1, y1, x2, y2, color);
                }
                else
                {
                    this.drawCurve(x1, y1, (x1 + (ux * t)), (y1 + (uy * t)), x2, y2, color);
                }
            }

            radius = newRadius;
            radialX = newRadialX;
            radialY = newRadialY;
            ux = vx;
            uy = vy;
            x1 = x2;
            y1 = y2;
        }
    },

    // We render a spiral 'spring' in the same way we do a spiral.
    // Only that the expressions for point on spring, and gradient at point
    // are more complex than that of a plain spiral.
    drawSpiralSpring : function drawSpiralSpring(x, y, ang1, ang2, rad1, rad2, numCoils, color)
    {
        // Order end points so ang1 < ang2.
        if (ang1 > ang2)
        {
            var tmp = ang1;
            ang1 = ang2;
            ang2 = tmp;

            tmp = rad1;
            rad1 = rad2;
            rad2 = tmp;
        }

        if (ang1 === ang2)
        {
            return;
        }

        var deltaRadius = (rad2 - rad1);
        var deltaAngle = (ang2 - ang1);

        // Render spiral in angular segments.
        var segmentCount = Math.max(Math.ceil(deltaAngle / (this.spiralMaxArc * 3)), (40 * numCoils));
        var segmentDeltaAngle = (deltaAngle / segmentCount);
        var segmentDeltaTime = (1 / segmentCount);

        var cosDelta = Math.cos(segmentDeltaAngle);
        var sinDelta = Math.sin(segmentDeltaAngle);

        var spiralSpringSize = this.spiralSpringSize;
        // Coeffecients in expression for point on spiral spring.
        // and gradient of spiral spring at point.
        var Delta = Math.abs(2 * Math.PI * deltaRadius / deltaAngle);
        var spiralA = (spiralSpringSize * Delta);
        var spiralB = (2 * numCoils * Math.PI);
        var spiralAt = (spiralA * spiralB);

        // Generate spiral points by rotating (and scaling)
        // radial vector.
        var radialX = Math.cos(ang1);
        var radialY = Math.sin(ang1);
        var radius = rad1;

        var x1 = (x + (radius * radialX));
        var y1 = (y + (radius * radialY));

        // Gradient at (x1, y1).
        var gradient = (deltaRadius + spiralAt);
        var ux = (gradient * radialX) - (radius * deltaAngle * radialY);
        var uy = (gradient * radialY) + (radius * deltaAngle * radialX);

        var i;
        for (i = 0; i < segmentCount; i += 1)
        {
            // Compute next point on spiral.
            var t = ((i + 1) * segmentDeltaTime);
            var newRadialX = (cosDelta * radialX) - (sinDelta * radialY);
            var newRadialY = (sinDelta * radialX) + (cosDelta * radialY);

            radius = ((rad1 + (deltaRadius * t)) + (spiralA * Math.sin(spiralB * t)));
            var x2 = (x + (radius * newRadialX));
            var y2 = (y + (radius * newRadialY));

            // Gradient at (x2, y2)
            gradient = (deltaRadius + (spiralAt * Math.cos(spiralB * t)));
            var vx = (gradient * newRadialX) - (radius * deltaAngle * newRadialY);
            var vy = (gradient * newRadialY) + (radius * deltaAngle * newRadialX);

            // Render spiral segment using a bezier curve (if possible).
            // We find the control point by intersecting the gradients at start and end point.
            var den = ((ux * vy) - (uy * vx));
            // Additional constraint that gradient directions in same general direction
            // but not completely equal.
            var dot = ((ux * vx) + (uy * vy));
            if ((den * den) < this.spiralEpsilon || dot < 0 || dot > (1 - this.spiralEpsilon))
            {
                // better use a line!
                this.drawLine(x1, y1, x2, y2, color);
            }
            else
            {
                // Compute intersection 'time' along gradient (ux, uy).
                t = (((x2 - x1) * vy) + ((y1 - y2) * vx)) / den;
                if (t <= 0)
                {
                    // better use a line!
                    this.drawLine(x1, y1, x2, y2, color);
                }
                else
                {
                    this.drawCurve(x1, y1, (x1 + (ux * t)), (y1 + (uy * t)), x2, y2, color);
                }
            }

            radialX = newRadialX;
            radialY = newRadialY;
            ux = vx;
            uy = vy;
            x1 = x2;
            y1 = y2;
        }
    },

    drawCurve : function drawCurveFn(x1, y1, cx, cy, x2, y2, color)
    {
        var r = color[0];
        var g = color[1];
        var b = color[2];
        var a = color[3];

        var stack = this._curveStack;
        var verts = this._curveVerts;
        stack.push(x1, y1, cx, cy, x2, y2);
        while (stack.length > 0)
        {
            y2 = stack.pop();
            x2 = stack.pop();
            cy = stack.pop();
            cx = stack.pop();
            y1 = stack.pop();
            x1 = stack.pop();

            // (qx, qy) = mid-point of quadratic bezier segment.
            var qx = 0.25 * (x1 + (2 * cx) + x2);
            var qy = 0.25 * (y1 + (2 * cy) + y2);
            // (lx, ly) = mid-point of line from (x1, y1) -> (x2, y2)
            var lx = 0.5 * (x1 + x2);
            var ly = 0.5 * (y1 + y2);

            // If distance between q, l is minimal (by configured epsilon)
            // Then we approximate segment with a straight line.
            var dx = (qx - lx);
            var dy = (qy - ly);
            var err = (this.curveMaxError * this.screenToPhysics2D);
            if (((dx * dx) + (dy * dy)) < (err * err))
            {
                verts.push(x1, y1);
            }
            else
            {
                // Otherwise we decompose segment in two halves
                // And 'recurse'
                var m1x = 0.5 * (x1 + cx);
                var m1y = 0.5 * (y1 + cy);
                var m2x = 0.5 * (x2 + cx);
                var m2y = 0.5 * (y2 + cy);
                var mmx = 0.5 * (m1x + m2x);
                var mmy = 0.5 * (m1y + m2y);
                stack.push(mmx, mmy, m2x, m2y, x2, y2);
                stack.push(x1, y1, m1x, m1y, mmx, mmy);
            }
        }
        verts.push(x2, y2);
        /*jshint white: false*/
        var vCount = (verts.length >> 1);
        /*jshint white: true*/

        var numVertices = this._numVertices;
        var vindex = (numVertices * 6);
        var iindex = (this._numLines * 2);
        this._prepare(vCount, (vCount - 1)); // N vertices, (N - 1) lines

        var vdata = this._vertexData;
        var idata = this._indexData;

        var i, j = 0;
        for (i = 0; i < vCount; i += 1)
        {
            vdata[vindex]     = verts[j];
            vdata[vindex + 1] = verts[j + 1];
            vdata[vindex + 2] = r;
            vdata[vindex + 3] = g;
            vdata[vindex + 4] = b;
            vdata[vindex + 5] = a;
            j += 2;
            vindex += 6;

            if (i > 0)
            {
                idata[iindex]     = (numVertices + i - 1);
                idata[iindex + 1] = (numVertices + i);
                iindex += 2;
            }
        }

        verts.length = 0;
    },

    drawRectangle : function drawRectangleFn(x1, y1, x2, y2, color)
    {
        var numVertices = this._numVertices;
        var vindex = (numVertices * 6);
        var iindex = (this._numLines * 2);
        this._prepare(4, 4); // vCount verts, vCount lines

        var vdata = this._vertexData;
        var idata = this._indexData;
        vdata[vindex]      = vdata[vindex + 18] = x1;
        vdata[vindex + 1]  = vdata[vindex + 7]  = y1;
        vdata[vindex + 6]  = vdata[vindex + 12] = x2;
        vdata[vindex + 13] = vdata[vindex + 19] = y2;
        vdata[vindex + 2]  = vdata[vindex + 8]  = vdata[vindex + 14] = vdata[vindex + 20] = color[0];
        vdata[vindex + 3]  = vdata[vindex + 9]  = vdata[vindex + 15] = vdata[vindex + 21] = color[1];
        vdata[vindex + 4]  = vdata[vindex + 10] = vdata[vindex + 16] = vdata[vindex + 22] = color[2];
        vdata[vindex + 5]  = vdata[vindex + 11] = vdata[vindex + 17] = vdata[vindex + 23] = color[3];

        idata[iindex]     = idata[iindex + 7] = numVertices;
        idata[iindex + 1] = idata[iindex + 2] = (numVertices + 1);
        idata[iindex + 3] = idata[iindex + 4] = (numVertices + 2);
        idata[iindex + 5] = idata[iindex + 6] = (numVertices + 3);
    },

    drawCircle : function drawCircleFn(x, y, radius, color)
    {
        var r = color[0];
        var g = color[1];
        var b = color[2];
        var a = color[3];

        // Compute number of vertices needed to keep error low.
        var maxError = this.circleMaxError; //px
        var rad = (radius * this.physics2DToScreen);

        var vCount;
        if (rad < maxError / 2)
        {
            vCount = 3;
        }
        else
        {
            // Error for given theta angle between vertices
            // is radius * (1 - cos (theta / 2))
            //
            // to keep error below maxError
            // need theta > (2 * acos(1 - maxError / radius))
            //
            // requiring pi / (acos(1 - maxError / radius)) vertices.
            vCount = Math.ceil(Math.PI / Math.acos(1 - maxError / rad));
            if (vCount < 3)
            {
                vCount = 3;
            }
        }

        var numVertices = this._numVertices;
        var vindex = (numVertices * 6);
        var iindex = (this._numLines * 2);
        this._prepare(vCount, vCount); // vCount verts, vCount lines

        // We generate vertices by taking radial vector (radius, 0) of circle
        // and rotating it through angular increments.
        var dx = radius;
        var dy = 0;

        var angInc = (Math.PI * 2 / vCount);
        var cos = Math.cos(angInc);
        var sin = Math.sin(angInc);

        var vdata = this._vertexData;
        var idata = this._indexData;
        var i;
        for (i = 0; i < vCount; i += 1)
        {
            // rotate radial vector by angInc.
            var nx = (dx * cos) - (dy * sin);
            dy = (dx * sin) + (dy * cos);
            dx = nx;

            vdata[vindex]     = x + dx;
            vdata[vindex + 1] = y + dy;
            vdata[vindex + 2] = r;
            vdata[vindex + 3] = g;
            vdata[vindex + 4] = b;
            vdata[vindex + 5] = a;
            vindex += 6;

            idata[iindex]     = (numVertices + i);
            idata[iindex + 1] = (numVertices + ((i + 1) % vCount));
            iindex += 2;
        }
    },

    drawRigidBody : function drawRigidBodyFn(body)
    {
        body._update();
        var shapes = body.shapes;
        var limit = shapes.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            this._drawShape(shapes[i]);
        }

        if (this.showBodyDetail)
        {
            var data = body._data;
            this.drawCircle(data[(/*BODY_POS*/2)], data[(/*BODY_POS*/2) + 1],
                            this.screenToPhysics2D * this.bodyPositionRadius,
                            this.bodyDetailColor);
            this.drawLine(data[(/*BODY_PRE_POS*/15)], data[(/*BODY_PRE_POS*/15) + 1],
                          data[(/*BODY_POS*/2)], data[(/*BODY_POS*/2) + 1],
                          this.bodyDetailColor);
        }
    },

    drawConstraint : function drawConstraintFn(con)
    {
        if (con._draw)
        {
            con._draw(this, con._stiff);
        }
    },

    drawWorld : function drawWorldFn(world)
    {
        var i, limit;
        if (this.showRigidBodies)
        {
            var bodies = world.rigidBodies;
            limit = bodies.length;
            for (i = 0; i < limit; i += 1)
            {
                var body = bodies[i];
                this.drawRigidBody(body);
            }
        }

        if (this.showContacts)
        {
            this._drawArbiters(world.dynamicArbiters);
            this._drawArbiters(world.staticArbiters);
        }

        if (this.showConstraints)
        {
            var constraints = world.constraints;
            limit = constraints.length;
            for (i = 0; i < limit; i += 1)
            {
                var con = constraints[i];
                if (con._active)
                {
                    this.drawConstraint(con);
                }
            }
        }
    },

    _drawArbiters : function _drawArbitersFn(arbiters)
    {
        var rad = (this.screenToPhysics2D * this.contactRadius);
        var imp = (this.screenToPhysics2D * this.contactImpulseScale);

        var limit = arbiters.length;
        var i;
        for (i = 0; i < limit; i += 1)
        {
            var arb = arbiters[i];
            if (!arb.active)
            {
                continue;
            }

            var color = (arb._static ? this.staticContactColor : this.dynamicContactColor);

            var nx, ny;
            if (arb.sensor)
            {
                nx = 0;
                ny = 0;
            }
            else
            {
                var adata = arb._data;
                nx = adata[(/*ARB_NORMAL*/4)];
                ny = adata[(/*ARB_NORMAL*/4) + 1];
            }

            var c1 = arb._contact1._data;
            var x1 = c1[(/*CON_POS*/0)];
            var y1 = c1[(/*CON_POS*/0) + 1];
            this.drawCircle(x1, y1, rad, color);

            var jn, jt;
            if (this.showContactImpulses && !arb._contact1.virtual)
            {
                jn = (c1[(/*CON_JNACC*/11)]) * imp;
                jt = (c1[(/*CON_JTACC*/12)]) * imp;
                this.drawLine(x1, y1, x1 + (nx * jn), y1 + (ny * jn), this.normalImpulseColor);
                this.drawLine(x1, y1, x1 - (ny * jt), y1 + (nx * jt), this.frictionImpulseColor);
            }

            if (arb._position2Contact)
            {
                var c2 = arb._contact2._data;
                var x2 = c2[(/*CON_POS*/0)];
                var y2 = c2[(/*CON_POS*/0) + 1];
                if (this.showContactImpulses && !arb._contact2.virtual)
                {
                    jn = (c2[(/*CON_JNACC*/11)]) * imp;
                    jt = (c2[(/*CON_JTACC*/12)]) * imp;
                    this.drawLine(x2, y2, x2 + (nx * jn), y2 + (ny * jn), this.normalImpulseColor);
                    this.drawLine(x2, y2, x2 - (ny * jt), y2 + (nx * jt), this.frictionImpulseColor);
                }

                nx *= rad;
                ny *= rad;
                this.drawCircle(x2, y2, rad, color);
                this.drawLine(x1 + nx, y1 + ny, x2 + nx, y2 + ny, color);
                this.drawLine(x1 - nx, y1 - ny, x2 - nx, y2 - ny, color);
            }
        }
    },

    // Assumption that shape was updated by a body before call.
    _drawShape : function drawShapeFn(shape)
    {
        var body = shape.body;
        if ((shape.sensor && !this.showSensorsShapes) ||
            (!shape.sensor && !this.showColliderShapes))
        {
            return;
        }

        /*jshint bitwise: false*/
        var color = this._colors[shape.body._type |
                                (body.sleeping ? 4 : 0) |
                                (shape.sensor ? 8 : 0) |
                                (body._bullet ? 16 : 0)];
        /*jshint bitwise: true*/

        if (shape._type === (/*TYPE_CIRCLE*/0))
        {
            this._drawCircleShape(shape, color);
        }
        else
        {
            this._drawPolygonShape(shape, color);
        }

        if (this.showShapeDetail)
        {
            var data = shape._data;
            this.drawRectangle(
                data[(/*SHAPE_AABB*/0)],     data[(/*SHAPE_AABB*/0) + 1],
                data[(/*SHAPE_AABB*/0) + 2], data[(/*SHAPE_AABB*/0) + 3],
                this.shapeDetailColor
            );
        }
    },

    _drawCircleShape : function drawCircleShapeFn(circle, color)
    {
        var body = circle.body._data;
        var data = circle._data;
        var cx = data[(/*CIRCLE_WORLD*/9)];
        var cy = data[(/*CIRCLE_WORLD*/9) + 1];
        var rad = data[(/*CIRCLE_RADIUS*/6)];
        this.drawCircle(cx, cy, rad, color);

        if (circle.body._type !== (/*TYPE_STATIC*/2))
        {
            var cos = body[(/*BODY_AXIS*/5)];
            var sin = body[(/*BODY_AXIS*/5) + 1];
            this.drawLine(cx + (rad * 0.333 * cos), cy + (rad * 0.333 * sin),
                          cx + (rad * cos),         cy + (rad * sin),
                          color);
        }

        if (this.showShapeDetail)
        {
            this.drawCircle(data[(/*CIRCLE_WORLD*/9)], data[(/*CIRCLE_WORLD*/9) + 1],
                            this.screenToPhysics2D * this.circleOriginRadius,
                            this.shapeDetailColor);
        }
    },

    _drawPolygonShape : function drawPolyShapeFn(polygon, color)
    {
        var r = color[0];
        var g = color[1];
        var b = color[2];
        var a = color[3];

        var numVertices = this._numVertices;
        var vindex = (numVertices * 6);
        var iindex = (this._numLines * 2);

        var pdata = polygon._data;
        var pindex = (/*POLY_VERTICES*/6);
        var limit = pdata.length;

        var vCount = ((limit - pindex) / (/*POLY_STRIDE*/13));
        this._prepare(vCount, vCount); // vCount verts and lines.

        var vdata = this._vertexData;
        var idata = this._indexData;
        var i;
        for (i = 0; pindex < limit; pindex += (/*POLY_STRIDE*/13), i += 1)
        {
            vdata[vindex]     = pdata[pindex + (/*POLY_WORLD*/2)];
            vdata[vindex + 1] = pdata[pindex + (/*POLY_WORLD*/2) + 1];
            vdata[vindex + 2] = r;
            vdata[vindex + 3] = g;
            vdata[vindex + 4] = b;
            vdata[vindex + 5] = a;
            vindex += 6;

            idata[iindex]     = (numVertices + i);
            idata[iindex + 1] = (numVertices + ((i + 1) % vCount));
            iindex += 2;
        }
    },

    // =========================================================================

    begin : function beginFn()
    {
        var gd = this._graphicsDevice;
        var width = gd.width;
        var height = gd.height;

        var screenX, screenY, screenW, screenH;
        var port;
        if (this._screenPortEnabled)
        {
            port = this._screenPort;
            screenX = port[0];
            screenY = port[1];
            screenW = port[2] - screenX;
            screenH = port[3] - screenY;
        }
        else
        {
            screenX = 0;
            screenY = 0;
            screenW = width;
            screenH = height;
        }

        if (width !== this._width || height !== this._height || this._invalidated)
        {
            this._width = width;
            this._height = height;
            this._invalidated = false;

            var physX, physY, physW, physH;
            if (this._physics2DPortEnabled)
            {
                port = this._physics2DPort;
                physX = port[0];
                physY = port[1];
                physW = port[2] - physX;
                physH = port[3] - physY;
            }
            else
            {
                physX = 0;
                physY = 0;
                physW = width / 60;
                physH = height / 60;
            }

            var clip = this._techniqueParams.clipSpace;
            clip[0] =  (2 * screenW) / (width * physW);
            clip[1] = -(2 * screenH) / (height * physH);
            clip[2] = -(2 * physX * screenW) / (width * physW) + (2 * screenX / width) - 1;
            clip[3] =  (2 * physY * screenH) / (height * physH) - (2 * screenY / height) + 1;

            var rx =  (clip[0] * 0.5 * width);
            var ry = -(clip[1] * 0.5 * height);
            this.physics2DToScreen = 0.5 * (rx + ry);
            this.screenToPhysics2D = 1 / this.physics2DToScreen;
        }

        gd.setScissor(screenX, height - screenY - screenH, screenW, screenH);
        gd.setTechnique(this._technique);
        gd.setTechniqueParameters(this._techniqueParams);
    },

    end : function endFn()
    {
        this._dispatch();
    },

    // =========================================================================

    _prepare : function prepareFn(numVerts, numLines)
    {
        var size, newData, i;

        var index = (this._numVertices * 6);
        var total = index + (numVerts * 6);
        var data = this._vertexData;
        if (total > data.length)
        {
            // allocate new vertex buffer data array.
            size = this._bufferSizeAlgorithm(total);
            newData = this._vertexData = new Physics2DDevice.prototype.floatArray(size);

            // copy data from existing buffer.
            for (i = 0; i < index; i += 1)
            {
                newData[i] = data[i];
            }
        }
        this._numVertices += numVerts;

        index = (this._numLines * 2);
        total = index + (numLines * 2);
        data = this._indexData;
        if (total > data.length)
        {
            // allocate new index buffer data array
            size = this._bufferSizeAlgorithm(total);
            newData = this._indexData = new Physics2DDevice.prototype.uint16Array(size);

            // copy data from existing buffer.
            for (i = 0; i < index; i += 1)
            {
                newData[i] = data[i];
            }
        }
        this._numLines += numLines;
    },

    _bufferSizeAlgorithm : function bufferSizeAlgorithmFn(target)
    {
        // scale factor of 2 is asymtopically optimal in terms of number of resizes
        // performed and copies performed, but we want to try and conserve memory
        // and so choose a less optimal 1.25 so that buffer will never be too much
        // larger than necessary.
        var factor = 1.25;

        // We size buffer to the next power of the factor which is >= target
        var logf = Math.ceil(Math.log(target) / Math.log(factor));
        var size = Math.floor(Math.pow(factor, logf));

        // Additionally ensure that we always take a multiple of of the stride
        // to avoid wasted bytes that could never be used.
        return (6 * Math.ceil(size / 6));
    },

    _dispatch : function dispatchFn()
    {
        var graphicsDevice = this._graphicsDevice;
        var vertexBuffer = this._vertexBuffer;
        var vertexBufferParameters = this._vertexBufferParameters;
        var vertexData = this._vertexData;
        var indexBuffer = this._indexBuffer;
        var indexBufferParameters = this._indexBufferParameters;
        var indexData = this._indexData;

        var count = this._numVertices;
        if (count === 0)
        {
            return;
        }

        var newSize;
        // Resize buffer.
        if (count > vertexBufferParameters.numVertices)
        {
            newSize = this._bufferSizeAlgorithm(count);
            vertexBufferParameters.numVertices = newSize;
            this._vertexBuffer.destroy();
            this._vertexBuffer = vertexBuffer = graphicsDevice.createVertexBuffer(vertexBufferParameters);
        }

        vertexBuffer.setData(vertexData, 0, count);

        count = (this._numLines * 2);
        // Resize buffer.
        if (count > indexBufferParameters.numIndices)
        {
            newSize = this._bufferSizeAlgorithm(count);
            indexBufferParameters.numIndices = newSize;
            this._indexBuffer.destroy();
            this._indexBuffer = indexBuffer = graphicsDevice.createIndexBuffer(indexBufferParameters);
        }

        indexBuffer.setData(indexData, 0, count);
        graphicsDevice.setStream(vertexBuffer, this._semantics);
        graphicsDevice.setIndexBuffer(indexBuffer);
        graphicsDevice.drawIndexed(graphicsDevice.PRIMITIVE_LINES, count);

        this._numVertices = 0;
        this._numLines = 0;
    },

    destroy : function debugDrawDestroyFn()
    {
        this._graphicsDevice = null;
        this._curveStack.length = 0;
        this._curveVerts.length = 0;
        this._colors.length = 0;

        this._vertexBuffer.destroy();
        this._indexBuffer.destroy();
    }

};

Physics2DDebugDraw.create = function physics2DDebugDrawFn(params)
{
    var o = new Physics2DDebugDraw();
    var gd = o._graphicsDevice = params.graphicsDevice;

    o._screenPort = new Physics2DDevice.prototype.floatArray(4);
    o._screenPortEnabled = false;
    o._physics2DPort = new Physics2DDevice.prototype.floatArray(4);
    o._physics2DPortEnabled = false;
    o._invalidated = true;

    o.physics2DToScreen = 0;
    o.screenToPhysics2D = 0;

    o.circleMaxError = 0.4; //px
    o.curveMaxError = 0.6; //px
    o.spiralMaxArc = Math.PI / 4; // rad
    o.spiralEpsilon = 1e-5;
    o.spiralSpringSize = 0.75; // percentage of gap between spiral arms for spring.
    o._curveStack = [];
    o._curveVerts = [];

    o.minSpringLength = 0.5; // px

    function v4Build(r, g, b, a)
    {
        var ret = new Physics2DDevice.prototype.floatArray(4);
        ret[0] = r;
        ret[1] = g;
        ret[2] = b;
        ret[3] = a;
        return ret;
    }

    var bulletColor                  = v4Build(1.0, 1.0, 1.0, 1.0);
    var staticColor                  = v4Build(1.0, 0.5, 0.5, 1.0);
    var staticSensorColor            = v4Build(0.9, 0.7, 0.7, 0.6);
    var kinematicColor               = v4Build(0.8, 0.3, 0.8, 1.0);
    var kinematicSensorColor         = v4Build(0.8, 0.4, 0.8, 0.6);
    var dynamicColor                 = v4Build(0.5, 1.0, 0.5, 1.0);
    var dynamicSensorColor           = v4Build(0.7, 0.9, 0.7, 0.6);
    var sleepingDynamicColor         = v4Build(0.5, 1.0, 0.5, 0.5);
    var sleepingDynamicSensorColor   = v4Build(0.7, 0.9, 0.7, 0.4);
    var sleepingKinematicColor       = v4Build(0.8, 0.4, 0.8, 0.5);
    var sleepingKinematicSensorColor = v4Build(0.8, 0.5, 0.8, 0.4);

    o.showConstraints               = true;
    o.constraintAnchorRadius        = 3.0;
    o.constraintSpringRadius        = 3.0;
    o.constraintSpringNumCoils      = 3;
    o.constraintSpiralMinRadius     = 10.0;
    o.constraintSpiralDeltaRadius   = (2.5 / Math.PI);
    o.constraintSpiralNumCoils      = 4;
    o.constraintColorA              = v4Build(1.0, 0.0, 0.0, 0.8);
    o.constraintSleepingColorA      = v4Build(0.7, 0.2, 0.2, 0.6);
    o.constraintColorB              = v4Build(0.0, 0.0, 1.0, 0.8);
    o.constraintSleepingColorB      = v4Build(0.2, 0.2, 0.7, 0.6);
    o.constraintColorC              = v4Build(0.0, 1.0, 0.0, 0.8);
    o.constraintSleepingColorC      = v4Build(0.2, 0.7, 0.2, 0.6);
    o.constraintColorD              = v4Build(1.0, 0.0, 1.0, 0.8);
    o.constraintSleepingColorD      = v4Build(0.7, 0.2, 0.7, 0.6);
    o.constraintErrorColorA         = v4Build(1.0, 1.0, 0.5, 0.8);
    o.constraintErrorSleepingColorA = v4Build(0.7, 0.7, 0.5, 0.6);
    o.constraintErrorColorB         = v4Build(0.5, 1.0, 1.0, 0.8);
    o.constraintErrorSleepingColorB = v4Build(0.5, 0.7, 0.7, 0.6);
    o.constraintErrorColorC         = v4Build(0.4, 1.0, 0.4, 0.8);
    o.constraintErrorSleepingColorC = v4Build(0.4, 0.7, 0.4, 0.6);
    o.constraintErrorColorD         = v4Build(1.0, 0.4, 1.0, 0.8);
    o.constraintErrorSleepingColorD = v4Build(0.7, 0.4, 0.7, 0.6);

    o.showContacts         = false;
    o.showContactImpulses  = false;
    o.contactRadius        = 3.0;
    o.contactImpulseScale  = 30.0;
    o.dynamicContactColor  = v4Build(1.0, 0.0, 0.5, 0.7);
    o.staticContactColor   = v4Build(0.5, 0.0, 1.0, 0.7);
    o.normalImpulseColor   = v4Build(1.0, 0.0, 0.0, 1.0);
    o.frictionImpulseColor = v4Build(0.0, 0.0, 1.0, 1.0);

    o.showRigidBodies    = true;
    o.showColliderShapes = true;
    o.showSensorsShapes   = true;
    o.showBodyDetail     = false;
    o.showShapeDetail    = false;
    o.bodyPositionRadius = 0.5;
    o.circleOriginRadius = 0.5;
    o.bodyDetailColor    = v4Build(0.0, 1.0, 1.0, 0.5);
    o.shapeDetailColor   = v4Build(1.0, 1.0, 0.0, 0.5);

    // (type | (sleeping << 2) | (sensor << 3) | (bullet << 4))
    var colors = o._colors = [];
    colors[(/*TYPE_STATIC*/2)    + 4]  = staticColor;
    colors[(/*TYPE_STATIC*/2)    + 12] = staticSensorColor;
    colors[(/*TYPE_DYNAMIC*/0)]        = dynamicColor;
    colors[(/*TYPE_DYNAMIC*/0)   + 8]  = dynamicSensorColor;
    colors[(/*TYPE_DYNAMIC*/0)   + 4]  = sleepingDynamicColor;
    colors[(/*TYPE_DYNAMIC*/0)   + 12] = sleepingDynamicSensorColor;
    colors[(/*TYPE_DYNAMIC*/0)   + 16] = bulletColor;
    colors[(/*TYPE_KINEMATIC*/1)]      = kinematicColor;
    colors[(/*TYPE_KINEMATIC*/1) + 8]  = kinematicSensorColor;
    colors[(/*TYPE_KINEMATIC*/1) + 4]  = sleepingKinematicColor;
    colors[(/*TYPE_KINEMATIC*/1) + 12] = sleepingKinematicSensorColor;

    // Load embedded default shader and techniques
    /*jshint white: false*/
    var shader = gd.createShader(
{
 "version": 1,
 "name": "lines.cgfx",
 "parameters":
 {
  "clipSpace":
  {
   "type": "float",
   "columns": 4
  }
 },
 "techniques":
 {
  "alpha":
  [
   {
    "parameters": ["clipSpace"],
    "semantics": ["POSITION","COLOR"],
    "states":
    {
     "DepthTestEnable": false,
     "DepthMask": false,
     "CullFaceEnable": false,
     "BlendEnable": true,
     "BlendFunc": [770,771]
    },
    "programs": ["vp_draw2dlines","fp_draw2dlines"]
   }
  ]
 },
 "programs":
 {
  "fp_draw2dlines":
  {
   "type": "fragment",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;\nvoid main()\n{gl_FragColor=tz_Color;}"
  },
  "vp_draw2dlines":
  {
   "type": "vertex",
   "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;attribute vec4 ATTR3;attribute vec4 ATTR0;\nvec4 _outpos1;vec4 _outcol1;uniform vec4 clipSpace;void main()\n{vec2 _TMP1;_TMP1=ATTR0.xy*clipSpace.xy+clipSpace.zw;_outpos1=vec4(_TMP1.x,_TMP1.y,0.0,1.0);_outcol1=ATTR3;tz_Color=ATTR3;gl_Position=_outpos1;}"
  }
 }
}
    );
    /*jshint white: true*/

    o._techniqueParams = gd.createTechniqueParameters({
        clipSpace : new Physics2DDevice.prototype.floatArray(4)
    });
    o._technique = shader.getTechnique("alpha");

    var initialVertices = 4;
    var initialIndices = 4;

    o._vertexBufferParameters = {
        numVertices : initialVertices,
        attributes : [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT4],
        'transient': true
    };
    o._vertexBuffer = gd.createVertexBuffer(o._vertexBufferParameters);

    o._semantics = gd.createSemantics([gd.SEMANTIC_POSITION, gd.SEMANTIC_COLOR]);

    o._indexBufferParameters = {
        numIndices : initialIndices,
        format : gd.INDEXFORMAT_USHORT,
        'transient' : true
    };
    o._indexBuffer = gd.createIndexBuffer(o._indexBufferParameters);

    o._vertexData = new Physics2DDevice.prototype.floatArray(60);
    o._indexData = new Physics2DDevice.prototype.uint16Array(60);
    o._numVertices = 0;
    o._numLines = 0;

    return o;
};


// =========================================================================
// PULLEY CONSTRAINT

Physics2DPulleyConstraint.prototype._draw = function _pulleyDrawFn(debug)
{
    var colA  = (this.sleeping ? debug.constraintSleepingColorA      : debug.constraintColorA);
    var colB  = (this.sleeping ? debug.constraintSleepingColorB      : debug.constraintColorB);
    var colC  = (this.sleeping ? debug.constraintSleepingColorC      : debug.constraintColorC);
    var colD  = (this.sleeping ? debug.constraintSleepingColorD      : debug.constraintColorD);
    var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
    var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);
    var colSC = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);
    var colSD = (this.sleeping ? debug.constraintErrorSleepingColorD : debug.constraintErrorColorD);

    var data = this._data;
    var b1 = this.bodyA._data;
    var b2 = this.bodyB._data;
    var b3 = this.bodyC._data;
    var b4 = this.bodyD._data;

    var x1 = (b1[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR1*/19)]);
    var y1 = (b1[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR1*/19) + 1]);
    var x2 = (b2[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR2*/21)]);
    var y2 = (b2[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR2*/21) + 1]);
    var x3 = (b3[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR3*/23)]);
    var y3 = (b3[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR3*/23) + 1]);
    var x4 = (b4[(/*BODY_POS*/2)]     + data[(/*PULLEY_RANCHOR4*/25)]);
    var y4 = (b4[(/*BODY_POS*/2) + 1] + data[(/*PULLEY_RANCHOR4*/25) + 1]);

    var n12x = (x2 - x1);
    var n12y = (y2 - y1);
    var n34x = (x4 - x3);
    var n34y = (y4 - y3);
    var nL12 = Math.sqrt((n12x * n12x) + (n12y * n12y));
    var nL34 = Math.sqrt((n34x * n34x) + (n34y * n34y));
    var ratio = data[(/*PULLEY_RATIO*/7)];
    this._drawLink(debug, x1, y1, x2, y2, n12x, n12y, nL12, (nL34 * ratio), 1.0, colSA, colSB);
    this._drawLink(debug, x3, y3, x4, y4, n34x, n34y, nL34, nL12, (1 / ratio),   colSC, colSD);

    var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
    debug._drawAnchor(x1, y1, rad, colA);
    debug._drawAnchor(x2, y2, rad, colB);
    debug._drawAnchor(x3, y3, rad, colC);
    debug._drawAnchor(x4, y4, rad, colD);
};

Physics2DPulleyConstraint.prototype._drawLink = function _drawLinkFn(debug, x1, y1, x2, y2, nx, ny, nl, bias, scale, colSA, colSB)
{
    if (nl > Physics2DConfig.NORMALIZE_EPSILON)
    {
        var rec = (1 / nl);
        nx *= rec;
        ny *= rec;

        var midX = (0.5 * (x1 + x2));
        var midY = (0.5 * (y1 + y2));

        var data = this._data;
        var jointMin = (data[(/*PULLEY_JOINTMIN*/5)] - bias) * scale;
        if (jointMin < 0)
        {
            jointMin = 0;
        }
        var jointMax = (data[(/*PULLEY_JOINTMAX*/6)] - bias) * scale;
        if (jointMax < 0)
        {
            jointMax = 0;
        }

        var minX1 = (midX - (nx * (jointMin * 0.5)));
        var minY1 = (midY - (ny * (jointMin * 0.5)));
        var minX2 = (midX + (nx * (jointMin * 0.5)));
        var minY2 = (midY + (ny * (jointMin * 0.5)));
        var maxX1 = (midX - (nx * (jointMax * 0.5)));
        var maxY1 = (midY - (ny * (jointMax * 0.5)));
        var maxX2 = (midX + (nx * (jointMax * 0.5)));
        var maxY2 = (midY + (ny * (jointMax * 0.5)));

        debug.drawLine(minX1, minY1, minX2, minY2, colSA);
        debug.drawLine(maxX1, maxY1, minX1, minY1, colSB);
        debug.drawLine(maxX2, maxY2, minX2, minY2, colSB);

        if (!this._stiff)
        {
            var numCoils = debug.constraintSpringNumCoils;
            var radius   = (debug.constraintSpringRadius * debug.screenToPhysics2D);
            if (nl > jointMax)
            {
                debug.drawLinearSpring(maxX1, maxY1, x1, y1, numCoils, radius, colSB);
                debug.drawLinearSpring(maxX2, maxY2, x2, y2, numCoils, radius, colSB);
            }
            else if (nl < jointMin)
            {
                debug.drawLinearSpring(minX1, minY1, x1, y1, numCoils, radius, colSA);
                debug.drawLinearSpring(minX2, minY2, x2, y2, numCoils, radius, colSA);
            }
        }
    }
};

// =========================================================================
// LINE CONSTRAINT

Physics2DLineConstraint.prototype._draw = function lineDrawFn(debug)
{
    var colA  = (this.sleeping ? debug.constraintSleepingColorA      : debug.constraintColorA);
    var colB  = (this.sleeping ? debug.constraintSleepingColorB      : debug.constraintColorB);
    var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
    var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);
    var colSC = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);

    var data = this._data;
    var b1 = this.bodyA._data;
    var b2 = this.bodyB._data;

    var x1 = (b1[(/*BODY_POS*/2)]     + data[(/*LINE_RANCHOR1*/13)]);
    var y1 = (b1[(/*BODY_POS*/2) + 1] + data[(/*LINE_RANCHOR1*/13) + 1]);
    var x2 = (b2[(/*BODY_POS*/2)]     + data[(/*LINE_RANCHOR2*/15)]);
    var y2 = (b2[(/*BODY_POS*/2) + 1] + data[(/*LINE_RANCHOR2*/15) + 1]);
    var dx = data[(/*LINE_RAXIS*/17)];
    var dy = data[(/*LINE_RAXIS*/17) + 1];

    var jointMin = data[(/*LINE_JOINTMIN*/5)];
    var jointMax = data[(/*LINE_JOINTMAX*/6)];
    if (jointMin === Number.NEGATIVE_INFINITY)
    {
        jointMin = -1e20;
    }
    if (jointMax === Number.POSITIVE_INFINITY)
    {
        jointMax = 1e20;
    }

    var delX = (x2 - x1);
    var delY = (y2 - y1);
    var pn = (delX * dx) + (delY * dy);

    var ex1 = (x1 + (dx * jointMin));
    var ey1 = (y1 + (dy * jointMin));
    var ex2 = (x1 + (dx * jointMax));
    var ey2 = (y1 + (dy * jointMax));

    var t;
    if (pn > jointMin)
    {
        t = Math.min(pn, jointMax);
        debug.drawLine(ex1, ey1, x1 + (dx * t), y1 + (dy * t), colSA);
    }
    if (pn < jointMax)
    {
        t = Math.max(pn, jointMin);
        debug.drawLine(ex2, ey2, x1 + (dx * t), y1 + (dy * t), colSB);
    }

    if (!this._stiff)
    {
        var anchX = (pn < jointMin ? ex1 : (pn > jointMax ? ex2 : (x1 + (dx * pn))));
        var anchY = (pn < jointMin ? ey1 : (pn > jointMax ? ey2 : (y1 + (dy * pn))));

        var numCoils = debug.constraintSpringNumCoils;
        var radius   = (debug.constraintSpringRadius * debug.screenToPhysics2D);
        debug.drawLinearSpring(anchX, anchY, x2, y2, numCoils, radius, colSC);
    }

    var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
    debug._drawAnchor(x1, y1, rad, colA);
    debug._drawAnchor(x2, y2, rad, colB);
};

// =========================================================================
// DISTANCE CONSTRAINT

Physics2DDistanceConstraint.prototype._draw = function distanceDrawFn(debug)
{
    var colA  = (this.sleeping ? debug.constraintSleepingColorA      : debug.constraintColorA);
    var colB  = (this.sleeping ? debug.constraintSleepingColorB      : debug.constraintColorB);
    var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
    var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);

    var data = this._data;
    var b1 = this.bodyA._data;
    var b2 = this.bodyB._data;

    var x1 = (b1[(/*BODY_POS*/2)]     + data[(/*DIST_RANCHOR1*/11)]);
    var y1 = (b1[(/*BODY_POS*/2) + 1] + data[(/*DIST_RANCHOR1*/11) + 1]);
    var x2 = (b2[(/*BODY_POS*/2)]     + data[(/*DIST_RANCHOR2*/13)]);
    var y2 = (b2[(/*BODY_POS*/2) + 1] + data[(/*DIST_RANCHOR2*/13) + 1]);

    var nx = (x2 - x1);
    var ny = (y2 - y1);
    var nlsq = ((nx * nx) + (ny * ny));
    if (nlsq > Physics2DConfig.NORMALIZE_SQ_EPSILON)
    {
        var nl = Math.sqrt(nlsq);
        var rec = (1 / nl);
        nx *= rec;
        ny *= rec;

        var midX = (0.5 * (x1 + x2));
        var midY = (0.5 * (y1 + y2));

        var jointMin = data[(/*DIST_JOINTMIN*/5)];
        var jointMax = data[(/*DIST_JOINTMAX*/6)];
        var minX1 = (midX - (nx * (jointMin * 0.5)));
        var minY1 = (midY - (ny * (jointMin * 0.5)));
        var minX2 = (midX + (nx * (jointMin * 0.5)));
        var minY2 = (midY + (ny * (jointMin * 0.5)));
        var maxX1 = (midX - (nx * (jointMax * 0.5)));
        var maxY1 = (midY - (ny * (jointMax * 0.5)));
        var maxX2 = (midX + (nx * (jointMax * 0.5)));
        var maxY2 = (midY + (ny * (jointMax * 0.5)));

        debug.drawLine(minX1, minY1, minX2, minY2, colSA);
        debug.drawLine(maxX1, maxY1, minX1, minY1, colSB);
        debug.drawLine(maxX2, maxY2, minX2, minY2, colSB);

        if (!this._stiff)
        {
            var numCoils = debug.constraintSpringNumCoils;
            var radius   = (debug.constraintSpringRadius * debug.screenToPhysics2D);
            if (nl > jointMax)
            {
                debug.drawLinearSpring(maxX1, maxY1, x1, y1, numCoils, radius, colSB);
                debug.drawLinearSpring(maxX2, maxY2, x2, y2, numCoils, radius, colSB);
            }
            else if (nl < jointMin)
            {
                debug.drawLinearSpring(minX1, minY1, x1, y1, numCoils, radius, colSA);
                debug.drawLinearSpring(minX2, minY2, x2, y2, numCoils, radius, colSA);
            }
        }
    }

    var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
    debug._drawAnchor(x1, y1, rad, colA);
    debug._drawAnchor(x2, y2, rad, colB);
};

// =========================================================================
// ANGLE CONSTRAINT

Physics2DAngleConstraint.prototype._draw = function angleDrawFn(debug)
{
    var colA  = (this.sleeping ? debug.constraintSleepingColorA      : debug.constraintColorA);
    var colB  = (this.sleeping ? debug.constraintSleepingColorB      : debug.constraintColorB);
    var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
    var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);

    var data = this._data;
    var b1 = this.bodyA._data;
    var b2 = this.bodyB._data;

    var ratio = data[(/*ANGLE_RATIO*/7)];
    this._drawForBody(debug, b1, b2, ratio, -1, colSA, colSB, colA);
    this._drawForBody(debug, b2, b1, (1 / ratio), (1 / ratio), colSA, colSB, colB);
};

Physics2DAngleConstraint.prototype._drawForBody = function _drawForBodyFn(debug, b1, b2, bodyScale, limitScale, colA, colB, col)
{
    var data = this._data;
    var jointMin = data[(/*ANGLE_JOINTMIN*/5)];
    var jointMax = data[(/*ANGLE_JOINTMAX*/6)];

    var min = (b2[(/*BODY_POS*/2) + 2] * bodyScale) + (jointMin * limitScale);
    var max = (b2[(/*BODY_POS*/2) + 2] * bodyScale) + (jointMax * limitScale);
    if (min > max)
    {
        var tmp = min;
        min = max;
        max = tmp;
    }

    var minRadius     = (debug.constraintSpiralMinRadius   * debug.screenToPhysics2D);
    var deltaRadius   = (debug.constraintSpiralDeltaRadius * debug.screenToPhysics2D);
    var indicatorSize = (debug.constraintAnchorRadius      * debug.screenToPhysics2D);
    var numCoils      = debug.constraintSpiralNumCoils;

    var x   = b1[(/*BODY_POS*/2)];
    var y   = b1[(/*BODY_POS*/2) + 1];
    var rot = b1[(/*BODY_POS*/2) + 2];

    var dr;
    if (rot > min)
    {
        dr = Math.min(rot, max);
        debug.drawSpiral(x, y, min, dr, minRadius, minRadius + ((dr - min) * deltaRadius), colA);
    }
    else if (!this._stiff && rot < min)
    {
        debug.drawSpiralSpring(x, y, rot, min, minRadius + ((rot - min) * deltaRadius), minRadius, numCoils, colA);
    }

    if (rot < max)
    {
        dr = Math.max(rot, min);
        debug.drawSpiral(x, y, dr, max, minRadius + ((dr - min) * deltaRadius), minRadius + ((max - min) * deltaRadius), colB);
    }
    else if (!this._stiff && rot > max)
    {
        debug.drawSpiralSpring(x, y, rot, max, minRadius + ((rot - min) * deltaRadius), minRadius + ((max - min) * deltaRadius), numCoils, colB);
    }

    debug._drawAngleIndicator(x, y, rot, minRadius + ((rot - min) * deltaRadius), indicatorSize, col);
};

// =========================================================================
// WELD CONSTRAINT

Physics2DWeldConstraint.prototype._draw = function weldDrawFn(debug)
{
    var colA = (this.sleeping ? debug.constraintSleepingColorA      : debug.constraintColorA);
    var colB = (this.sleeping ? debug.constraintSleepingColorB      : debug.constraintColorB);
    var colE = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);

    var data = this._data;
    var b1 = this.bodyA._data;
    var b2 = this.bodyB._data;

    var x1 = (b1[(/*BODY_POS*/2)]     + data[(/*WELD_RANCHOR1*/9)]);
    var y1 = (b1[(/*BODY_POS*/2) + 1] + data[(/*WELD_RANCHOR1*/9) + 1]);
    var x2 = (b2[(/*BODY_POS*/2)]     + data[(/*WELD_RANCHOR2*/11)]);
    var y2 = (b2[(/*BODY_POS*/2) + 1] + data[(/*WELD_RANCHOR2*/11) + 1]);

    var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
    debug._drawAnchor(x1, y1, rad, colA);
    debug._drawAnchor(x2, y2, rad, colB);

    if (this._stiff)
    {
        debug.drawLine(x1, y1, x2, y2, colE);
    }
    else
    {
        var numCoils = debug.constraintSpringNumCoils;
        var radius   = (debug.constraintSpringRadius * debug.screenToPhysics2D);
        debug.drawLinearSpring(x1, y1, x2, y2, numCoils, radius, colE);

        var minRadius     = (debug.constraintSpiralMinRadius  * debug.screenToPhysics2D);
        var deltaRadius   = (debug.constraintSpiralDeltaRadius * debug.screenToPhysics2D);
        var indicatorSize = (debug.constraintAnchorRadius     * debug.screenToPhysics2D);
        numCoils          = debug.constraintSpiralNumCoils;

        var target, min;
        // angle indication on bodyA
        min = b1[(/*BODY_POS*/2) + 2];
        target = (b2[(/*BODY_POS*/2) + 2] - data[(/*WELD_PHASE*/13)]);

        var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
        var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);

        debug.drawSpiralSpring(b1[(/*BODY_POS*/2)], b1[(/*BODY_POS*/2) + 1],
                               min, target, minRadius, minRadius + ((target - min) * deltaRadius),
                               numCoils, colSB);
        debug._drawAngleIndicator(b1[(/*BODY_POS*/2)], b1[(/*BODY_POS*/2) + 1], min, minRadius, indicatorSize, colSA);

        min = b2[(/*BODY_POS*/2) + 2];
        target = (data[(/*WELD_PHASE*/13)] + b1[(/*BODY_POS*/2) + 2]);

        debug.drawSpiralSpring(b2[(/*BODY_POS*/2)], b2[(/*BODY_POS*/2) + 1],
                               min, target, minRadius, minRadius + ((target - min) * deltaRadius),
                               numCoils, colSA);
        debug._drawAngleIndicator(b2[(/*BODY_POS*/2)], b2[(/*BODY_POS*/2) + 1], min, minRadius, indicatorSize, colSB);
    }
};

// =========================================================================
// POINT CONSTRAINT

Physics2DPointConstraint.prototype._draw = function pointDrawFn(debug)
{
    var colA = (this.sleeping ? debug.constraintSleepingColorA      : debug.constraintColorA);
    var colB = (this.sleeping ? debug.constraintSleepingColorB      : debug.constraintColorB);
    var colE = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);

    var data = this._data;
    var b1 = this.bodyA._data;
    var b2 = this.bodyB._data;

    var x1 = (b1[(/*BODY_POS*/2)]     + data[(/*POINT_RANCHOR1*/9)]);
    var y1 = (b1[(/*BODY_POS*/2) + 1] + data[(/*POINT_RANCHOR1*/9) + 1]);
    var x2 = (b2[(/*BODY_POS*/2)]     + data[(/*POINT_RANCHOR2*/11)]);
    var y2 = (b2[(/*BODY_POS*/2) + 1] + data[(/*POINT_RANCHOR2*/11) + 1]);

    var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
    debug._drawAnchor(x1, y1, rad, colA);
    debug._drawAnchor(x2, y2, rad, colB);

    if (this._stiff)
    {
        debug.drawLine(x1, y1, x2, y2, colE);
    }
    else
    {
        var numCoils = debug.constraintSpringNumCoils;
        var radius   = (debug.constraintSpringRadius * debug.screenToPhysics2D);
        debug.drawLinearSpring(x1, y1, x2, y2, numCoils, radius, colE);
    }
};

// Copyright (c) 2012 Turbulenz Limited
/*global Float32Array: false*/

//
// BoxTreeNode
//
function BoxTreeNode() {}
BoxTreeNode.prototype =
{
    version : 1,

    isLeaf : function boxtreeNodeIsLeafFn()
    {
        return !!this.externalNode;
    },

    reset : function boxtreeNodeResetFn(minX, minY, maxX, maxY,
                                         escapeNodeOffset,
                                         externalNode)
    {
        this.escapeNodeOffset = escapeNodeOffset;
        this.externalNode = externalNode;
        var oldExtents = this.extents;
        oldExtents[0] = minX;
        oldExtents[1] = minY;
        oldExtents[2] = maxX;
        oldExtents[3] = maxY;
    },

    clear : function boxtreeNodeClearFn()
    {
        this.escapeNodeOffset = 1;
        this.externalNode = undefined;
        var oldExtents = this.extents;
        var maxNumber = Number.MAX_VALUE;
        oldExtents[0] = maxNumber;
        oldExtents[1] = maxNumber;
        oldExtents[2] = -maxNumber;
        oldExtents[3] = -maxNumber;
    }
};

// Constructor function
BoxTreeNode.create = function boxtreeNodeCreateFn(extents, escapeNodeOffset, externalNode)
{
    var n = new BoxTreeNode();
    n.escapeNodeOffset = escapeNodeOffset;
    n.externalNode = externalNode;
    n.extents = extents;
    return n;
};


//
// BoxTree
//
function BoxTree() {}
BoxTree.prototype =
{
    version : 1,
    numNodesLeaf : 4,

    add : function addFn(externalNode, extents)
    {
        var endNode = this.endNode;
        externalNode.boxTreeIndex = endNode;
        var copyExtents = new this.arrayConstructor(4);
        copyExtents[0] = extents[0];
        copyExtents[1] = extents[1];
        copyExtents[2] = extents[2];
        copyExtents[3] = extents[3];
        this.nodes[endNode] = BoxTreeNode.create(copyExtents, 1, externalNode);
        this.endNode = (endNode + 1);
        this.needsRebuild = true;
        this.numAdds += 1;
        this.numExternalNodes += 1;
    },

    remove : function removeFn(externalNode)
    {
        var index = externalNode.boxTreeIndex;
        if (index !== undefined)
        {
            if (this.numExternalNodes > 1)
            {
                var nodes = this.nodes;

                nodes[index].clear();

                var endNode = this.endNode;
                if ((index + 1) >= endNode)
                {
                    while (!nodes[endNode - 1].externalNode) // No leaf
                    {
                        endNode -= 1;
                    }
                    this.endNode = endNode;
                }
                else
                {
                    this.needsRebuild = true;
                }
                this.numExternalNodes -= 1;
            }
            else
            {
                this.clear();
            }

            delete externalNode.boxTreeIndex;
        }
    },

    findParent : function findParentFn(nodeIndex)
    {
        var nodes = this.nodes;
        var parentIndex = nodeIndex;
        var nodeDist = 0;
        var parent;
        do
        {
            parentIndex -= 1;
            nodeDist += 1;
            parent = nodes[parentIndex];
        }
        while (parent.escapeNodeOffset <= nodeDist);
        return parent;
    },

    update : function boxTreeUpdateFn(externalNode, extents)
    {
        var index = externalNode.boxTreeIndex;
        if (index !== undefined)
        {
            var min0 = extents[0];
            var min1 = extents[1];
            var max0 = extents[2];
            var max1 = extents[3];

            var needsRebuild = this.needsRebuild;
            var needsRebound = this.needsRebound;
            var nodes = this.nodes;
            var node = nodes[index];
            var nodeExtents = node.extents;

            var doUpdate = (needsRebuild ||
                            needsRebound ||
                            nodeExtents[0] > min0 ||
                            nodeExtents[1] > min1 ||
                            nodeExtents[2] < max0 ||
                            nodeExtents[3] < max1);

            nodeExtents[0] = min0;
            nodeExtents[1] = min1;
            nodeExtents[2] = max0;
            nodeExtents[3] = max1;

            if (doUpdate)
            {
                if (!needsRebuild && 1 < nodes.length)
                {
                    this.numUpdates += 1;
                    if (this.startUpdate > index)
                    {
                        this.startUpdate = index;
                    }
                    if (this.endUpdate < index)
                    {
                        this.endUpdate = index;
                    }
                    if (!needsRebound)
                    {
                        // force a rebound when things change too much
                        if ((2 * this.numUpdates) > this.numExternalNodes)
                        {
                            this.needsRebound = true;
                        }
                        else
                        {
                            var parent = this.findParent(index);
                            var parentExtents = parent.extents;
                            if (parentExtents[0] > min0 ||
                                parentExtents[1] > min1 ||
                                parentExtents[2] < max0 ||
                                parentExtents[3] < max1)
                            {
                                this.needsRebound = true;
                            }
                        }
                    }
                    else
                    {
                        // force a rebuild when things change too much
                        if (this.numUpdates > (3 * this.numExternalNodes))
                        {
                            this.needsRebuild = true;
                            this.numAdds = this.numUpdates;
                        }
                    }
                }
            }
        }
        else
        {
            this.add(externalNode, extents);
        }
    },

    needsFinalize : function needsFinalizeFn()
    {
        return (this.needsRebuild || this.needsRebound);
    },

    finalize : function finalizeFn()
    {
        if (this.needsRebuild)
        {
            this.rebuild();
        }
        else if (this.needsRebound)
        {
            this.rebound();
        }
    },

    rebound : function reboundFn()
    {
        var nodes = this.nodes;
        if (nodes.length > 1)
        {
            var startUpdateNodeIndex = this.startUpdate;
            var endUpdateNodeIndex   = this.endUpdate;

            var nodesStack = [];
            var numNodesStack = 0;
            var topNodeIndex = 0;
            for (;;)
            {
                var topNode = nodes[topNodeIndex];
                var currentNodeIndex = topNodeIndex;
                var currentEscapeNodeIndex = (topNodeIndex + topNode.escapeNodeOffset);
                var nodeIndex = (topNodeIndex + 1); // First child
                var node;
                do
                {
                    node = nodes[nodeIndex];
                    var escapeNodeIndex = (nodeIndex + node.escapeNodeOffset);
                    if (nodeIndex < endUpdateNodeIndex)
                    {
                        if (!node.externalNode) // No leaf
                        {
                            if (escapeNodeIndex > startUpdateNodeIndex)
                            {
                                nodesStack[numNodesStack] = topNodeIndex;
                                numNodesStack += 1;
                                topNodeIndex = nodeIndex;
                            }
                        }
                    }
                    else
                    {
                        break;
                    }
                    nodeIndex = escapeNodeIndex;
                }
                while (nodeIndex < currentEscapeNodeIndex);

                if (topNodeIndex === currentNodeIndex)
                {
                    nodeIndex = (topNodeIndex + 1); // First child
                    node = nodes[nodeIndex];

                    var extents = node.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var maxX = extents[2];
                    var maxY = extents[3];

                    nodeIndex = (nodeIndex + node.escapeNodeOffset);
                    while (nodeIndex < currentEscapeNodeIndex)
                    {
                        node = nodes[nodeIndex];
                        extents = node.extents;
                        /*jshint white: false*/
                        if (minX > extents[0]) { minX = extents[0]; }
                        if (minY > extents[1]) { minY = extents[1]; }
                        if (maxX < extents[2]) { maxX = extents[2]; }
                        if (maxY < extents[3]) { maxY = extents[3]; }
                        /*jshint white: true*/
                        nodeIndex = (nodeIndex + node.escapeNodeOffset);
                    }

                    extents = topNode.extents;
                    extents[0] = minX;
                    extents[1] = minY;
                    extents[2] = maxX;
                    extents[3] = maxY;

                    endUpdateNodeIndex = topNodeIndex;

                    if (0 < numNodesStack)
                    {
                        numNodesStack -= 1;
                        topNodeIndex = nodesStack[numNodesStack];
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        //this.numUpdates = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    },

    rebuild : function rebuildFn()
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;

            var buildNodes, numBuildNodes, endNodeIndex;

            if (this.numExternalNodes === nodes.length)
            {
                buildNodes = nodes;
                numBuildNodes = nodes.length;
                nodes = [];
                this.nodes = nodes;
            }
            else
            {
                buildNodes = [];
                buildNodes.length = this.numExternalNodes;
                numBuildNodes = 0;
                endNodeIndex = this.endNode;
                for (var n = 0; n < endNodeIndex; n += 1)
                {
                    var currentNode = nodes[n];
                    if (currentNode.externalNode) // Is leaf
                    {
                        nodes[n] = undefined;
                        buildNodes[numBuildNodes] = currentNode;
                        numBuildNodes += 1;
                    }
                }
                if (buildNodes.length > numBuildNodes)
                {
                    buildNodes.length = numBuildNodes;
                }
            }

            if (numBuildNodes > 1)
            {
                if (numBuildNodes > this.numNodesLeaf &&
                    this.numAdds > 0)
                {
                    if (this.highQuality)
                    {
                        this.sortNodesHighQuality(buildNodes);
                    }
                    else
                    {
                        this.sortNodes(buildNodes);
                    }
                }

                this.recursiveBuild(buildNodes, 0, numBuildNodes, 0);

                endNodeIndex = nodes[0].escapeNodeOffset;
                if (nodes.length > endNodeIndex)
                {
                    nodes.length = endNodeIndex;
                }
                this.endNode = endNodeIndex;
            }
            else
            {
                var rootNode = buildNodes[0];
                rootNode.externalNode.boxTreeIndex = 0;
                nodes.length = 1;
                nodes[0] = rootNode;
                this.endNode = 1;
            }
            buildNodes = null;
        }

        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        this.numUpdates = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    },

    sortNodes : function sortNodesFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[2]);
        }

        function getkeyYfn(node)
        {
            var extents = node.extents;
            return (extents[1] + extents[3]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[2]);
        }

        function getreversekeyYfn(node)
        {
            var extents = node.extents;
            return -(extents[1] + extents[3]);
        }

        var nthElement = this.nthElement;
        var reverse = false;
        var axis = 0;

        function sortNodesRecursive(nodes, startIndex, endIndex)
        {
            /*jshint bitwise: false*/
            var splitNodeIndex = ((startIndex + endIndex) >> 1);
            /*jshint bitwise: true*/

            if (axis === 0)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
                }
            }
            else //if (axis === 1)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
                }
            }

            if (axis === 0)
            {
                axis = 2;
            }
            else if (axis === 2)
            {
                axis = 1;
            }
            else //if (axis === 1)
            {
                axis = 0;
            }

            reverse = !reverse;

            if ((startIndex + numNodesLeaf) < splitNodeIndex)
            {
                sortNodesRecursive(nodes, startIndex, splitNodeIndex);
            }

            if ((splitNodeIndex + numNodesLeaf) < endIndex)
            {
                sortNodesRecursive(nodes, splitNodeIndex, endIndex);
            }
        }

        sortNodesRecursive(nodes, 0, numNodes);
    },

    sortNodesHighQuality : function sortNodesHighQualityFn(nodes)
    {
        var numNodesLeaf = this.numNodesLeaf;
        var numNodes = nodes.length;

        function getkeyXfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[2]);
        }

        function getkeyYfn(node)
        {
            var extents = node.extents;
            return (extents[1] + extents[3]);
        }

        function getkeyXYfn(node)
        {
            var extents = node.extents;
            return (extents[0] + extents[1] + extents[2] + extents[3]);
        }

        function getkeyYXfn(node)
        {
            var extents = node.extents;
            return (extents[0] - extents[1] + extents[2] - extents[3]);
        }

        function getreversekeyXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[2]);
        }

        function getreversekeyYfn(node)
        {
            var extents = node.extents;
            return -(extents[1] + extents[3]);
        }

        function getreversekeyXYfn(node)
        {
            var extents = node.extents;
            return -(extents[0] + extents[1] + extents[2] + extents[3]);
        }

        function getreversekeyYXfn(node)
        {
            var extents = node.extents;
            return -(extents[0] - extents[1] + extents[2] - extents[3]);
        }

        var nthElement = this.nthElement;
        var calculateSAH = this.calculateSAH;
        var reverse = false;

        function sortNodesHighQualityRecursive(nodes, startIndex, endIndex)
        {
            /*jshint bitwise: false*/
            var splitNodeIndex = ((startIndex + endIndex) >> 1);
            /*jshint bitwise: true*/

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
            var sahX = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
            var sahY = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXYfn);
            var sahXY = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYXfn);
            var sahYX = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

            if (sahX <= sahY &&
                sahX <= sahXY &&
                sahX <= sahYX)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
                }
            }
            else if (sahY <= sahXY &&
                     sahY <= sahYX)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
                }
            }
            else if (sahXY <= sahYX)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXYfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXYfn);
                }
            }
            else //if (sahYX <= sahXY)
            {
                if (reverse)
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYXfn);
                }
                else
                {
                    nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYXfn);
                }
            }

            reverse = !reverse;

            if ((startIndex + numNodesLeaf) < splitNodeIndex)
            {
                sortNodesHighQualityRecursive(nodes, startIndex, splitNodeIndex);
            }

            if ((splitNodeIndex + numNodesLeaf) < endIndex)
            {
                sortNodesHighQualityRecursive(nodes, splitNodeIndex, endIndex);
            }
        }

        sortNodesHighQualityRecursive(nodes, 0, numNodes);
    },

    calculateSAH : function calculateSAHFn(buildNodes, startIndex, endIndex)
    {
        var buildNode, extents, minX, minY, maxX, maxY;

        buildNode = buildNodes[startIndex];
        extents = buildNode.extents;
        minX = extents[0];
        minY = extents[1];
        maxX = extents[2];
        maxY = extents[3];

        for (var n = (startIndex + 1); n < endIndex; n += 1)
        {
            buildNode = buildNodes[n];
            extents = buildNode.extents;
            /*jshint white: false*/
            if (minX > extents[0]) { minX = extents[0]; }
            if (minY > extents[1]) { minY = extents[1]; }
            if (maxX < extents[2]) { maxX = extents[2]; }
            if (maxY < extents[3]) { maxY = extents[3]; }
            /*jshint white: true*/
        }

        return ((maxX - minX) + (maxY - minY));
    },

    nthElement : function nthElementFn(nodes, first, nth, last, getkey)
    {
        function medianFn(a, b, c)
        {
            if (a < b)
            {
                if (b < c)
                {
                    return b;
                }
                else if (a < c)
                {
                    return c;
                }
                else
                {
                    return a;
                }
            }
            else if (a < c)
            {
                return a;
            }
            else if (b < c)
            {
                return c;
            }
            return b;
        }

        function insertionSortFn(nodes, first, last, getkey)
        {
            var sorted = (first + 1);
            while (sorted !== last)
            {
                var tempNode = nodes[sorted];
                var tempKey = getkey(tempNode);

                var next = sorted;
                var current = (sorted - 1);

                while (next !== first && tempKey < getkey(nodes[current]))
                {
                    nodes[next] = nodes[current];
                    next -= 1;
                    current -= 1;
                }

                if (next !== sorted)
                {
                    nodes[next] = tempNode;
                }

                sorted += 1;
            }
        }

        while ((last - first) > 8)
        {
            /*jshint bitwise: false*/
            var midValue = medianFn(getkey(nodes[first]),
                                    getkey(nodes[first + ((last - first) >> 1)]),
                                    getkey(nodes[last - 1]));
            /*jshint bitwise: true*/

            var firstPos = first;
            var lastPos  = last;
            var midPos;
            for (; ; firstPos += 1)
            {
                while (getkey(nodes[firstPos]) < midValue)
                {
                    firstPos += 1;
                }

                do
                {
                    lastPos -= 1;
                }
                while (midValue < getkey(nodes[lastPos]));

                if (firstPos >= lastPos)
                {
                    midPos = firstPos;
                    break;
                }
                else
                {
                    var temp = nodes[firstPos];
                    nodes[firstPos] = nodes[lastPos];
                    nodes[lastPos]  = temp;
                }
            }

            if (midPos <= nth)
            {
                first = midPos;
            }
            else
            {
                last = midPos;
            }
        }

        insertionSortFn(nodes, first, last, getkey);
    },

    recursiveBuild : function recursiveBuildFn(buildNodes, startIndex, endIndex, lastNodeIndex)
    {
        var nodes = this.nodes;
        var nodeIndex = lastNodeIndex;
        lastNodeIndex += 1;

        var minX, minY, maxX, maxY, extents;
        var buildNode, lastNode;

        if ((startIndex + this.numNodesLeaf) >= endIndex)
        {
            buildNode = buildNodes[startIndex];
            extents = buildNode.extents;
            minX = extents[0];
            minY = extents[1];
            maxX = extents[2];
            maxY = extents[3];

            buildNode.externalNode.boxTreeIndex = lastNodeIndex;
            nodes[lastNodeIndex] = buildNode;

            for (var n = (startIndex + 1); n < endIndex; n += 1)
            {
                buildNode = buildNodes[n];
                extents = buildNode.extents;
                /*jshint white: false*/
                if (minX > extents[0]) { minX = extents[0]; }
                if (minY > extents[1]) { minY = extents[1]; }
                if (maxX < extents[2]) { maxX = extents[2]; }
                if (maxY < extents[3]) { maxY = extents[3]; }
                /*jshint white: true*/
                lastNodeIndex += 1;
                buildNode.externalNode.boxTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }

            lastNode = nodes[lastNodeIndex];
        }
        else
        {
            /*jshint bitwise: false*/
            var splitPosIndex = ((startIndex + endIndex) >> 1);
            /*jshint bitwise: true*/

            if ((startIndex + 1) >= splitPosIndex)
            {
                buildNode = buildNodes[startIndex];
                buildNode.externalNode.boxTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }
            else
            {
                this.recursiveBuild(buildNodes, startIndex, splitPosIndex, lastNodeIndex);
            }

            lastNode = nodes[lastNodeIndex];
            extents = lastNode.extents;
            minX = extents[0];
            minY = extents[1];
            maxX = extents[2];
            maxY = extents[3];

            lastNodeIndex = (lastNodeIndex + lastNode.escapeNodeOffset);

            if ((splitPosIndex + 1) >= endIndex)
            {
                buildNode = buildNodes[splitPosIndex];
                buildNode.externalNode.boxTreeIndex = lastNodeIndex;
                nodes[lastNodeIndex] = buildNode;
            }
            else
            {
                this.recursiveBuild(buildNodes, splitPosIndex, endIndex, lastNodeIndex);
            }

            lastNode = nodes[lastNodeIndex];
            extents = lastNode.extents;
            /*jshint white: false*/
            if (minX > extents[0]) { minX = extents[0]; }
            if (minY > extents[1]) { minY = extents[1]; }
            if (maxX < extents[2]) { maxX = extents[2]; }
            if (maxY < extents[3]) { maxY = extents[3]; }
            /*jshint white: true*/
        }

        var node = nodes[nodeIndex];
        if (node !== undefined)
        {
            node.reset(minX, minY, maxX, maxY,
                       (lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex));
        }
        else
        {
            var parentExtents = new this.arrayConstructor(4);
            parentExtents[0] = minX;
            parentExtents[1] = minY;
            parentExtents[2] = maxX;
            parentExtents[3] = maxY;

            nodes[nodeIndex] = BoxTreeNode.create(parentExtents,
                                                  (lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex));
        }
    },

    getVisibleNodes : function getVisibleNodesFn(planes, visibleNodes)
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var numPlanes = planes.length;
            var numVisibleNodes = visibleNodes.length;
            var node, extents, endChildren;
            var n0, n1, p0, p1;
            var isInside, n, plane, d0, d1;
            var nodeIndex = 0;

            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                n0 = extents[0];
                n1 = extents[1];
                p0 = extents[2];
                p1 = extents[3];
                //isInsidePlanesBox
                isInside = true;
                n = 0;
                do
                {
                    plane = planes[n];
                    d0 = plane[0];
                    d1 = plane[1];
                    if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1)) < plane[2])
                    {
                        isInside = false;
                        break;
                    }
                    n += 1;
                }
                while (n < numPlanes);
                if (isInside)
                {
                    if (node.externalNode) // Is leaf
                    {
                        visibleNodes[numVisibleNodes] = node.externalNode;
                        numVisibleNodes += 1;
                        nodeIndex += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                    else
                    {
                        //isFullyInsidePlanesBox
                        isInside = true;
                        n = 0;
                        do
                        {
                            plane = planes[n];
                            d0 = plane[0];
                            d1 = plane[1];
                            if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1)) < plane[2])
                            {
                                isInside = false;
                                break;
                            }
                            n += 1;
                        }
                        while (n < numPlanes);
                        if (isInside)
                        {
                            endChildren = (nodeIndex + node.escapeNodeOffset);
                            nodeIndex += 1;
                            do
                            {
                                node = nodes[nodeIndex];
                                if (node.externalNode) // Is leaf
                                {
                                    visibleNodes[numVisibleNodes] = node.externalNode;
                                    numVisibleNodes += 1;
                                }
                                nodeIndex += 1;
                            }
                            while (nodeIndex < endChildren);
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                        else
                        {
                            nodeIndex += 1;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
        }
    },

    getOverlappingNodes : function getOverlappingNodesFn(queryExtents, overlappingNodes, startIndex)
    {
        if (this.numExternalNodes > 0)
        {
            var queryMinX = queryExtents[0];
            var queryMinY = queryExtents[1];
            var queryMaxX = queryExtents[2];
            var queryMaxY = queryExtents[3];
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var node, extents, endChildren;
            var numOverlappingNodes = 0;
            var storageIndex = (startIndex === undefined) ? overlappingNodes.length : startIndex;
            var nodeIndex = 0;
            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                var minX = extents[0];
                var minY = extents[1];
                var maxX = extents[2];
                var maxY = extents[3];
                if (queryMinX <= maxX &&
                    queryMinY <= maxY &&
                    queryMaxX >= minX &&
                    queryMaxY >= minY)
                {
                    if (node.externalNode) // Is leaf
                    {
                        overlappingNodes[storageIndex] = node.externalNode;
                        storageIndex += 1;
                        numOverlappingNodes += 1;
                        nodeIndex += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (queryMaxX >= maxX &&
                            queryMaxY >= maxY &&
                            queryMinX <= minX &&
                            queryMinY <= minY)
                        {
                            endChildren = (nodeIndex + node.escapeNodeOffset);
                            nodeIndex += 1;
                            do
                            {
                                node = nodes[nodeIndex];
                                if (node.externalNode) // Is leaf
                                {
                                    overlappingNodes[storageIndex] = node.externalNode;
                                    storageIndex += 1;
                                    numOverlappingNodes += 1;
                                }
                                nodeIndex += 1;
                            }
                            while (nodeIndex < endChildren);
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                        else
                        {
                            nodeIndex += 1;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
            return numOverlappingNodes;
        }
        else
        {
            return 0;
        }
    },

    getCircleOverlappingNodes : function getCircleOverlappingNodesFn(center, radius, overlappingNodes)
    {
        if (this.numExternalNodes > 0)
        {
            var radiusSquared = (radius * radius);
            var centerX = center[0];
            var centerY = center[1];
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var node, extents;
            var numOverlappingNodes = overlappingNodes.length;
            var nodeIndex = 0;
            for (;;)
            {
                node = nodes[nodeIndex];
                extents = node.extents;
                var minX = extents[0];
                var minY = extents[1];
                var maxX = extents[2];
                var maxY = extents[3];
                var totalDistance = 0, sideDistance;
                if (centerX < minX)
                {
                    sideDistance = (minX - centerX);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerX > maxX)
                {
                    sideDistance = (centerX - maxX);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (centerY < minY)
                {
                    sideDistance = (minY - centerY);
                    totalDistance += (sideDistance * sideDistance);
                }
                else if (centerY > maxY)
                {
                    sideDistance = (centerY - maxY);
                    totalDistance += (sideDistance * sideDistance);
                }
                if (totalDistance <= radiusSquared)
                {
                    nodeIndex += 1;
                    if (node.externalNode) // Is leaf
                    {
                        overlappingNodes[numOverlappingNodes] = node.externalNode;
                        numOverlappingNodes += 1;
                        if (nodeIndex >= endNodeIndex)
                        {
                            break;
                        }
                    }
                }
                else
                {
                    nodeIndex += node.escapeNodeOffset;
                    if (nodeIndex >= endNodeIndex)
                    {
                        break;
                    }
                }
            }
        }
    },

    getOverlappingPairs : function getOverlappingPairsFn(overlappingPairs, startIndex)
    {
        if (this.numExternalNodes > 0)
        {
            var nodes = this.nodes;
            var endNodeIndex = this.endNode;
            var currentNode, currentExternalNode, node, extents;
            var numInsertions = 0;
            var storageIndex = (startIndex === undefined) ? overlappingPairs.length : startIndex;
            var currentNodeIndex = 0, nodeIndex;
            for (;;)
            {
                currentNode = nodes[currentNodeIndex];
                while (!currentNode.externalNode) // No leaf
                {
                    currentNodeIndex += 1;
                    currentNode = nodes[currentNodeIndex];
                }

                currentNodeIndex += 1;
                if (currentNodeIndex < endNodeIndex)
                {
                    currentExternalNode = currentNode.externalNode;
                    extents = currentNode.extents;
                    var minX = extents[0];
                    var minY = extents[1];
                    var maxX = extents[2];
                    var maxY = extents[3];

                    nodeIndex = currentNodeIndex;
                    for (;;)
                    {
                        node = nodes[nodeIndex];
                        extents = node.extents;
                        if (minX <= extents[2] &&
                            minY <= extents[3] &&
                            maxX >= extents[0] &&
                            maxY >= extents[1])
                        {
                            nodeIndex += 1;
                            if (node.externalNode) // Is leaf
                            {
                                overlappingPairs[storageIndex] = currentExternalNode;
                                overlappingPairs[storageIndex + 1] = node.externalNode;
                                storageIndex += 2;
                                numInsertions += 2;
                                if (nodeIndex >= endNodeIndex)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            nodeIndex += node.escapeNodeOffset;
                            if (nodeIndex >= endNodeIndex)
                            {
                                break;
                            }
                        }
                    }
                }
                else
                {
                    break;
                }
            }
            return numInsertions;
        }
        else
        {
            return 0;
        }
    },

    getRootNode : function getRootNodeFn()
    {
        return this.nodes[0];
    },

    getNodes : function getNodesFn()
    {
        return this.nodes;
    },

    getEndNodeIndex : function getEndNodeIndexFn()
    {
        return this.endNode;
    },

    clear : function clearFn()
    {
        this.nodes = [];
        this.endNode = 0;
        this.needsRebuild = false;
        this.needsRebound = false;
        this.numAdds = 0;
        this.numUpdates = 0;
        this.numExternalNodes = 0;
        this.startUpdate = Number.MAX_VALUE;
        this.endUpdate = -Number.MAX_VALUE;
    }
};

BoxTree.rayTest = function boxtreeRayTestFn(trees, ray, callback)
{
    // convert ray to parametric form
    var origin = ray.origin;
    var direction = ray.direction;

    // values used throughout calculations.
    var o0 = origin[0];
    var o1 = origin[1];
    var d0 = direction[0];
    var d1 = direction[1];
    var id0 = 1 / d0;
    var id1 = 1 / d1;

    // evaluate distance factor to a node's extents from ray origin, along direction
    // use this to induce an ordering on which nodes to check.
    function distanceExtents(extents, upperBound)
    {
        var min0 = extents[0];
        var min1 = extents[1];
        var max0 = extents[2];
        var max1 = extents[3];

        // treat origin internal to extents as 0 distance.
        if (min0 <= o0 && o0 <= max0 &&
            min1 <= o1 && o1 <= max1)
        {
            return 0.0;
        }

        var tmin, tmax;
        var tymin, tymax;
        var del;
        if (d0 >= 0)
        {
            // Deal with cases where d0 == 0
            del = (min0 - o0);
            tmin = ((del === 0) ? 0 : (del * id0));
            del = (max0 - o0);
            tmax = ((del === 0) ? 0 : (del * id0));
        }
        else
        {
            tmin = ((max0 - o0) * id0);
            tmax = ((min0 - o0) * id0);
        }

        if (d1 >= 0)
        {
            // Deal with cases where d1 == 0
            del = (min1 - o1);
            tymin = ((del === 0) ? 0 : (del * id1));
            del = (max1 - o1);
            tymax = ((del === 0) ? 0 : (del * id1));
        }
        else
        {
            tymin = ((max1 - o1) * id1);
            tymax = ((min1 - o1) * id1);
        }

        if ((tmin > tymax) || (tymin > tmax))
        {
            return undefined;
        }

        if (tymin > tmin)
        {
            tmin = tymin;
        }

        if (tymax < tmax)
        {
            tmax = tymax;
        }

        if (tmin < 0)
        {
            tmin = tmax;
        }

        return (0 <= tmin && tmin < upperBound) ? tmin : undefined;
    }

    // we traverse both trees at once
    // keeping a priority list of nodes to check next.

    // TODO: possibly implement priority list more effeciently?
    //       binary heap probably too much overhead in typical case.
    var priorityList = [];
    //current upperBound on distance to first intersection
    //and current closest object properties
    var minimumResult = null;

    //if node is a leaf, intersect ray with shape
    // otherwise insert node into priority list.
    function processNode(tree, nodeIndex, upperBound)
    {
        var nodes = tree.getNodes();
        var node = nodes[nodeIndex];
        var distance = distanceExtents(node.extents, upperBound);
        if (distance === undefined)
        {
            return upperBound;
        }

        if (node.externalNode)
        {
            var result = callback(tree, node.externalNode, ray, distance, upperBound);
            if (result)
            {
                minimumResult = result;
                upperBound = result.factor;
            }
        }
        else
        {
            // TODO: change to binary search?
            var length = priorityList.length;
            var i;
            for (i = 0; i < length; i += 1)
            {
                var curObj = priorityList[i];
                if (distance > curObj.distance)
                {
                    break;
                }
            }

            //insert node at index i
            priorityList.splice(i - 1, 0, {
                    tree: tree,
                    nodeIndex: nodeIndex,
                    distance: distance
                });
        }

        return upperBound;
    }

    var upperBound = ray.maxFactor;

    var tree;
    var i;
    for (i = 0; i < trees.length; i += 1)
    {
        tree = trees[i];
        if (tree.endNode !== 0)
        {
            upperBound = processNode(tree, 0, upperBound);
        }
    }

    while (priorityList.length !== 0)
    {
        var nodeObj = priorityList.pop();
        // A node inserted into priority list after this one may have
        // moved the upper bound.
        if (nodeObj.distance >= upperBound)
        {
            continue;
        }

        var nodeIndex = nodeObj.nodeIndex;
        tree = nodeObj.tree;
        var nodes = tree.getNodes();

        var node = nodes[nodeIndex];
        var maxIndex = nodeIndex + node.escapeNodeOffset;

        var childIndex = nodeIndex + 1;
        do
        {
            upperBound = processNode(tree, childIndex, upperBound);
            childIndex += nodes[childIndex].escapeNodeOffset;
        }
        while (childIndex < maxIndex);
    }

    return minimumResult;
};

// Constructor function
BoxTree.create = function boxtreeCreateFn(highQuality)
{
    var t = new BoxTree();
    t.clear();
    if (highQuality)
    {
        t.highQuality = true;
    }
    return t;
};

// Detect correct typed arrays
(function () {
    BoxTree.prototype.arrayConstructor = Array;
    if (typeof Float32Array !== "undefined")
    {
        var testArray = new Float32Array(4);
        var textDescriptor = Object.prototype.toString.call(testArray);
        if (textDescriptor === '[object Float32Array]')
        {
            BoxTree.prototype.arrayConstructor = Float32Array;
        }
    }
}());


function Game(renderer) {
		
	var backgroundColour = [0.3,0.3,0.3,1];

	function update() {
		renderer.draw(backgroundColour, null);
	}	

	return { update : update };
}
function Rendering(drawing2d, graphicsDevice, spriteRendering) {
	

	function render(clearColour) {
		if (graphicsDevice.beginFrame()) {			
			drawing2d.setBackBuffer();
			drawing2d.clear(clearColour);
			drawing2d.begin('alpha');
			spriteRendering.render();
			drawing2d.end();
			graphicsDevice.endFrame();
		}
	}

	return { render : render };
}
function SpriteRendering(drawing2d) {
	
	var spriteCollection = [];

	function render() {
		for (var spriteCount = 0, arrayLength = spriteCollection.length; spriteCount < arrayLength; spriteCount++) {
			drawing2d.drawSprite(spriteCollection[spriteCount]);
		}

		spriteCollection = [];
	}

	function addSprite(sprite) {
		if(!!sprite) {
			spriteCollection.push(sprite);
		}
	}

	return { render : render,
		addSprite : addSprite };
}
/*jslint browser: true*/
/*global TurbulenzEngine,TurbulenzServices,Canvas,Draw2D*/
(function() {
	TurbulenzEngine.onload = function onload() {
	    
	    var graphicsDevice = TurbulenzEngine.createGraphicsDevice({}),
	    	drawing2d = Draw2D.create({ graphicsDevice : graphicsDevice }),
	    	spriteRendering = new SpriteRendering(drawing2d, graphicsDevice),
	    	rendering = new Rendering(drawing2d, graphicsDevice, spriteRendering),
			requestHandler = RequestHandler.create({}),
			game = new Game(spriteRendering),
			backgroundColour = [0.3,0.3,0.3,1],
			background,
			taxi,
			pysicsDebug = Physics2DDebugDraw.create({
 				graphicsDevice : graphicsDevice
 			});

	    function update() {
	    	if(!!background && !!taxi) {
		    	spriteRendering.addSprite(background);
		    	spriteRendering.addSprite(taxi);
	    	}

	    	rendering.render(backgroundColour);	    	
	    }

	    TurbulenzEngine.onunload = function gameOnunload() {
			spriteDrawing = null;		
			requestHandler = null;
			sprite = null;	
			graphicsDevice = null;
			game = null;
		};

		function sessionCreated(gameSession) {
			TurbulenzServices.createMappingTable(requestHandler,
				gameSession,
				function (table) {
					graphicsDevice.createTexture({ src : table.getURL("textures/Sky512.jpg"),
						mipmaps : true,
						onload : function (texture) {
							background = Draw2DSprite.create({
							x : 512,
							y : 256,
							texture : texture						
							});							
						}
					});

					graphicsDevice.createTexture({ src : table.getURL("textures/taxi.png"),
						mipmaps : true,
						onload : function (texture) {
							taxi = Draw2DSprite.create({
							x : 50,
							y : 50,
							texture : texture						
							});
						}
					});
				});
		}

		TurbulenzServices.createGameSession(requestHandler, sessionCreated);
		TurbulenzEngine.setInterval(update, 1000 / 60);
	};
}());

    if (!TurbulenzEngine.onload)
    {
        window.alert("Entry point 'TurbulenzEngine.onload' must be defined for Engine 0.19.0 onwards.");
        return;
    }
    TurbulenzEngine.onload.call(this);
}());